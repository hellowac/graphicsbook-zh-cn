
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="计算机图形学概论(graphicsbook)">
      
      
      
        <link rel="canonical" href="https://hellowac.github.io/graphicsbook-zh-cn/cn/c6/s1/">
      
      
        <link rel="prev" href="../">
      
      
        <link rel="next" href="../s2/">
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.5.18">
    
    
      
        <title>6.1 可编程流水线 - 计算机图形学概论</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.66ac8b77.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.06af60db.min.css">
      
      

  
  
  
  
  <style>:root{--md-annotation-icon:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M22 12a10 10 0 0 1-10 10A10 10 0 0 1 2 12 10 10 0 0 1 12 2a10 10 0 0 1 10 10M6 13h8l-3.5 3.5 1.42 1.42L17.84 12l-5.92-5.92L10.5 7.5 14 11H6v2Z"/></svg>');}</style>


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
   <link href="../../../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
        html.glightbox-open { overflow: initial; height: 100%; }
        .gslide-title { margin-top: 0px; user-select: text; }
        .gslide-desc { color: #666; user-select: text; }
        .gslide-image img { background: white; }
        
            .gscrollbar-fixer { padding-right: 15px; }
            .gdesc-inner { font-size: 0.75rem; }
            body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
            body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
            body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}
            </style> <script src="../../../assets/javascripts/glightbox.min.js"></script></head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="default" data-md-color-accent="red">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#61-可编程流水线" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="计算机图形学概论" class="md-header__button md-logo" aria-label="计算机图形学概论" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            计算机图形学概论
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              6.1 可编程流水线
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
      <div class="md-header__option">
  <div class="md-select">
    
    <button class="md-header__button md-icon" aria-label="选择当前语言">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m12.87 15.07-2.54-2.51.03-.03A17.52 17.52 0 0 0 14.07 6H17V4h-7V2H8v2H1v2h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04M18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12m-2.62 7 1.62-4.33L19.12 17h-3.24Z"/></svg>
    </button>
    <div class="md-select__inner">
      <ul class="md-select__list">
        
          <li class="md-select__item">
            <a href="/graphicsbook-zh-cn/en/" hreflang="en" class="md-select__link">
              English
            </a>
          </li>
        
          <li class="md-select__item">
            <a href="/graphicsbook-zh-cn/cn/" hreflang="cn" class="md-select__link">
              中文
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</div>
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/hellowac/graphicsbook-zh-cn" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    graphicsbook
  </div>
</a>
      </div>
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../" class="md-tabs__link">
        
  
    
  
  首页

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../preface/" class="md-tabs__link">
        
  
    
  
  前言

      </a>
    </li>
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c1/" class="md-tabs__link">
          
  
    
  
  1.简介

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c2/" class="md-tabs__link">
          
  
    
  
  2.二维图形

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c3/" class="md-tabs__link">
          
  
    
  
  3.几何

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c4/" class="md-tabs__link">
          
  
    
  
  4.灯光和材质

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c5/" class="md-tabs__link">
          
  
    
  
  5.three.js

        </a>
      </li>
    
  

      
        
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../" class="md-tabs__link">
          
  
    
  
  6.WebGL

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c7/" class="md-tabs__link">
          
  
    
  
  7.WebGL 3D

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c8/" class="md-tabs__link">
          
  
    
  
  8.高阶3D

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c9/" class="md-tabs__link">
          
  
    
  
  9.WEBGPU

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../a1/" class="md-tabs__link">
          
  
    
  
  附录

        </a>
      </li>
    
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../.." class="md-tabs__link">
        
  
    
  
  关于

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="计算机图形学概论" class="md-nav__button md-logo" aria-label="计算机图形学概论" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    计算机图形学概论
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/hellowac/graphicsbook-zh-cn" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    graphicsbook
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    首页
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../preface/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    前言
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c1/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    1.简介
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_3" id="__nav_3_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            1.简介
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 1 节 绘画与绘图
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 2 节：三维(3D)图形的要素
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 3 节：硬件与软件
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c2/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    2.二维图形
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_4" id="__nav_4_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            2.二维图形
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第1节: 像素、坐标和颜色
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第2节: 形状
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第3节: 变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第4节: 分层建模
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第5节: Java 绘制2D
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第6节: HTML Canvas图形
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第7节: SVG：一种场景描述语言
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c3/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    3.几何
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_5" id="__nav_5_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            3.几何
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.1 OpenGL 1.1 中的形状和颜色
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.2 3D 坐标和变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.3 投影与观看
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.4 多边形网格和 glDrawArrays
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.5 部分线性代数基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.6 使用 GLUT 和 JOGL
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c4/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    4.灯光和材质
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_6" id="__nav_6_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6">
            <span class="md-nav__icon md-icon"></span>
            4.灯光和材质
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.1 照明简介
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.2 OpenGL 1.1 中的光和材质
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.3 图像纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.4 灯光、相机、动作
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c5/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    5.three.js
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_7" id="__nav_7_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7">
            <span class="md-nav__icon md-icon"></span>
            5.three.js
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.1 Three.js 基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.2 构建对象
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.3 其他功能
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" checked>
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    6.WebGL
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_8" id="__nav_8_label" tabindex="">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_8">
            <span class="md-nav__icon md-icon"></span>
            6.WebGL
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    6.1 可编程流水线
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    6.1 可编程流水线
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#611-webgl-图形上下文" class="md-nav__link">
    <span class="md-ellipsis">
      6.1.1 WebGL 图形上下文
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#612-着色器程序" class="md-nav__link">
    <span class="md-ellipsis">
      6.1.2 着色器程序
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#613-管道中的数据流" class="md-nav__link">
    <span class="md-ellipsis">
      6.1.3 管道中的数据流
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#614-统一变量的值" class="md-nav__link">
    <span class="md-ellipsis">
      6.1.4 统一变量的值
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#615-属性值" class="md-nav__link">
    <span class="md-ellipsis">
      6.1.5 属性值
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#616-绘制基元" class="md-nav__link">
    <span class="md-ellipsis">
      6.1.6 绘制基元
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#617-webgl-20顶点数组对象" class="md-nav__link">
    <span class="md-ellipsis">
      6.1.7 WebGL 2.0：顶点数组对象
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#618-webgl-20实例化绘图" class="md-nav__link">
    <span class="md-ellipsis">
      6.1.8 WebGL 2.0：实例化绘图
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.2 第一个例子
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.3 GLSL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.4 图像纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.5 实现 2D 变换
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c7/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    7.WebGL 3D
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_9" id="__nav_9_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9">
            <span class="md-nav__icon md-icon"></span>
            7.WebGL 3D
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.1 3D变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.2 照明和材质
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.3 纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.4 帧缓冲区
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.5 WebGL 扩展
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c8/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    8.高阶3D
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_10" id="__nav_10_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_10_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10">
            <span class="md-nav__icon md-icon"></span>
            8.高阶3D
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c8/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8.1 光线追踪
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c8/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8.2 路径追踪
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_11" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c9/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    9.WEBGPU
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_11" id="__nav_11_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_11_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_11">
            <span class="md-nav__icon md-icon"></span>
            9.WEBGPU
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.1 WebGPU 基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.2 实例和索引
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.3 WGSL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.4 WebGPU 中的 3D 图形
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.5 纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.6 计算着色器
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.7 细节
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_12" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../a1/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    附录
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_12" id="__nav_12_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_12_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_12">
            <span class="md-nav__icon md-icon"></span>
            附录
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a2/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Blender 3D建模
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a3/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Gimp和Inkscape
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../source/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    示例程序源代码
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../glossary/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    术语表
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    关于
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#611-webgl-图形上下文" class="md-nav__link">
    <span class="md-ellipsis">
      6.1.1 WebGL 图形上下文
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#612-着色器程序" class="md-nav__link">
    <span class="md-ellipsis">
      6.1.2 着色器程序
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#613-管道中的数据流" class="md-nav__link">
    <span class="md-ellipsis">
      6.1.3 管道中的数据流
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#614-统一变量的值" class="md-nav__link">
    <span class="md-ellipsis">
      6.1.4 统一变量的值
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#615-属性值" class="md-nav__link">
    <span class="md-ellipsis">
      6.1.5 属性值
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#616-绘制基元" class="md-nav__link">
    <span class="md-ellipsis">
      6.1.6 绘制基元
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#617-webgl-20顶点数组对象" class="md-nav__link">
    <span class="md-ellipsis">
      6.1.7 WebGL 2.0：顶点数组对象
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#618-webgl-20实例化绘图" class="md-nav__link">
    <span class="md-ellipsis">
      6.1.8 WebGL 2.0：实例化绘图
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="61-可编程流水线">6.1 可编程流水线<a class="headerlink" href="#61-可编程流水线" title="Permanent link">&para;</a></h1>
<p><strong>The Programmable Pipeline</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="1:2"><input checked="checked" id="__tabbed_1_1" name="__tabbed_1" type="radio" /><input id="__tabbed_1_2" name="__tabbed_1" type="radio" /><div class="tabbed-labels"><label for="__tabbed_1_1">中文</label><label for="__tabbed_1_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p><abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1 使用 <strong><abbr title="一个具有固定处理阶段集的图形处理管线，程序员无法修改。图像数据通过一系列处理阶段传递，最终产品是图像。这个序列被称为“管线”。在固定功能管线中，程序员可以启用和禁用阶段，并设置控制处理的选项，但无法增加功能。">固定功能管线</abbr></strong> 进行图形处理。数据由程序提供，并通过一系列处理阶段，最终产生最终图像中看到的像素颜色。程序可以启用和禁用过程中的一些步骤，例如深度测试和光照计算。但是，它无法改变每个阶段发生的事情。功能是固定的。</p>
<p><abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 2.0 引入了 <strong><abbr title="一个图形处理管线，其中一些处理阶段可以或必须由程序实现。图像数据通过一系列处理阶段传递，最终产品是图像。这个序列被称为“管线”。可编程管线在现代GPU中使用，为程序员提供更多的灵活性和控制。可编程管线的程序称为着色器，并使用GLSL等着色器编程语言编写。">可编程管线</abbr></strong>。程序员可以替换管线中的某些阶段为自己的程序。这为程序员提供了对发生该阶段的完全控制。在 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 2.0 中，可编程性是可选的；对于不需要可编程灵活性的程序，仍然可以使用完整的固定功能管线。<abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 使用可编程管线，并且是 <strong>强制性的</strong>。没有办法在不编写程序来实现图形处理管线的一部分的情况下使用 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>。</p>
<p>作为管线一部分编写的程序称为 <strong><abbr title="在渲染管线的某个阶段执行的程序。OpenGL着色器使用GLSL编程语言编写。对于WebGL，仅支持顶点着色器和片段着色器。WebGPU还有计算着色器，用于计算管线。">着色器</abbr></strong>。对于 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>，你需要编写一个 <strong><abbr title="一个着色器程序，将为原语中的每个顶点执行一次。顶点着色器必须计算裁剪坐标系中的顶点坐标。它还可以计算其他属性，如颜色。">顶点着色器</abbr></strong>，它将为原语中的每个顶点调用一次，以及一个 <strong><abbr title="一个着色器程序，将为原语中的每个像素执行一次。片段着色器必须为像素计算颜色，或者丢弃它。片段着色器也称为像素着色器。">片段着色器</abbr></strong>，它将为原语中的每个像素调用一次。除了这两个可编程阶段外，<abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 管线还包含原始固定功能管线的几个阶段。例如，深度测试仍然是固定功能的一部分，并且可以在 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 中以与 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1 中相同的方式启用或禁用。</p>
<p>在本节中，我们将介绍 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 程序的基本结构以及数据如何从程序的 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 部分流入图形管线，并通过顶点和片段着色器。</p>
<p>我应该注意，<abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 的后续版本引入了新的可编程阶段，除了顶点和片段着色器之外，但它们不是 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 或 2.0 的一部分，本书中也没有涵盖。</p>
</div>
<div class="tabbed-block">
<p><abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1 uses a <strong><abbr title="A graphics processing pipeline with a fixed set of processing stages that cannot be modified by a programmer. Data for an image passes through a sequence of processing stages, with the image as the end product. The sequence is called a &quot;pipeline.&quot; With a fixed-function pipeline, the programmer can enable and disable stages and set options that control the processing but cannot add to the functionality.">fixed-function pipeline</abbr></strong> for graphics processing. Data is provided by a program and passes through a series of processing stages that ultimately produce the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> colors seen in the final image. The program can enable and disable some of the steps in the process, such as the <abbr title="A solution to the hidden surface problem that involves keeping track of the depth, or distance from the viewer, of the object currently visible at each pixel in the image. When a new object is drawn at a pixel, the depth of the new object is compared to the depth of the current object to decide which one is closer to the viewer. The advantage of the depth test is that objects can be rendered in any order. A disadvantage is that only a limited range of depths can be represented in the image.">depth test</abbr> and <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> calculations. But there is no way for it to change what happens at each stage. The functionality is fixed.</p>
<p><abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 2.0 introduced a <strong>programmable <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr></strong>. It became possible for the programmer to replace certain stages in the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> with their own programs. This gives the programmer complete control over what happens at that stage. In <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 2.0, the programmability was optional; the complete <abbr title="A graphics processing pipeline with a fixed set of processing stages that cannot be modified by a programmer. Data for an image passes through a sequence of processing stages, with the image as the end product. The sequence is called a &quot;pipeline.&quot; With a fixed-function pipeline, the programmer can enable and disable stages and set options that control the processing but cannot add to the functionality.">fixed-function pipeline</abbr> was still available for programs that didn't need the flexibility of programmability. <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> uses a programmable <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>, and it is <strong>mandatory</strong>. There is no way to use <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> without writing programs to implement part of the graphics processing <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>.</p>
<p>The programs that are written as part of the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> are called <strong>shaders</strong>. For <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>, you need to write a <strong><abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr></strong>, which is called once for each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> in a primitive, and a <strong><abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr></strong>, which is called once for each <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> in the primitive. Aside from these two programmable stages, the <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> also contains several stages from the original <abbr title="A graphics processing pipeline with a fixed set of processing stages that cannot be modified by a programmer. Data for an image passes through a sequence of processing stages, with the image as the end product. The sequence is called a &quot;pipeline.&quot; With a fixed-function pipeline, the programmer can enable and disable stages and set options that control the processing but cannot add to the functionality.">fixed-function pipeline</abbr>. For example, the <abbr title="A solution to the hidden surface problem that involves keeping track of the depth, or distance from the viewer, of the object currently visible at each pixel in the image. When a new object is drawn at a pixel, the depth of the new object is compared to the depth of the current object to decide which one is closer to the viewer. The advantage of the depth test is that objects can be rendered in any order. A disadvantage is that only a limited range of depths can be represented in the image.">depth test</abbr> is still part of the fixed functionality, and it can be enabled or disabled in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> in the same way as in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1.</p>
<p>In this section, we will cover the basic structure of a <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> program and how data flows from the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side of the program into the graphics <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> and through the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> and fragment shaders.</p>
<p>I should note that later versions of <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> have introduced new programmable stages, in addition to the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> and fragment shaders, but they are not part of <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 or 2.0, and they are not covered in this book.</p>
</div>
</div>
</div>
<h2 id="611-webgl-图形上下文">6.1.1 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 图形上下文<a class="headerlink" href="#611-webgl-图形上下文" title="Permanent link">&para;</a></h2>
<p><strong>The <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> Graphics Context</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="2:2"><input checked="checked" id="__tabbed_2_1" name="__tabbed_2" type="radio" /><input id="__tabbed_2_2" name="__tabbed_2" type="radio" /><div class="tabbed-labels"><label for="__tabbed_2_1">中文</label><label for="__tabbed_2_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>要使用WebGL，你需要一个WebGL图形上下文。图形上下文是一个JavaScript对象，其方法实现了WebGL API的JavaScript部分。WebGL在HTML画布中绘制图像，这是与<a href="../../c2/s6/">第2.6节</a>中介绍的2D API相同的<code>&lt;canvas&gt;</code>元素。图形上下文与特定画布相关联。<abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0的图形上下文可以通过调用函数<em>canvas.getContext("webgl")</em>获得，其中<em>canvas</em>是表示画布的DOM对象。对于WebGL 2.0，你只需简单地使用<em>canvas.getContext("webgl2")</em>。如果无法创建上下文，<em>getContext()</em>的返回值将为<em>null</em>。因此，获取WebGL图形上下文通常看起来像这样：</p>
<div class="highlight"><pre><span></span><code><span class="nx">canvas</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;webglcanvas&quot;</span><span class="p">);</span>
<span class="nx">gl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">canvas</span><span class="p">.</span><span class="nx">getContext</span><span class="p">(</span><span class="s2">&quot;webgl&quot;</span><span class="p">);</span><span class="w">  </span><span class="c1">// 或许是 canvas.getContext(&quot;webgl2&quot;)</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="nx">gl</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="ne">Error</span><span class="p">(</span><span class="s2">&quot;WebGL not supported; can&#39;t create graphics context.&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>在这里，第一行获取HTML画布的引用，WebGL将在整个程序中用于绘图。变量名<em>gl</em>由你决定，但在我的讨论中，我将始终使用gl来表示WebGL图形上下文。此代码假定网页的HTML源包含一个id="webglcanvas"的画布元素，例如：</p>
<div class="highlight"><pre><span></span><code><span class="p">&lt;</span><span class="nt">canvas</span> <span class="na">width</span><span class="o">=</span><span class="s">&quot;800&quot;</span> <span class="na">height</span><span class="o">=</span><span class="s">&quot;600&quot;</span> <span class="na">id</span><span class="o">=</span><span class="s">&quot;webglcanvas&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">canvas</span><span class="p">&gt;</span>
</code></pre></div>
<p>在上面的代码第二行中，如果网络浏览器不支持<em>getContext</em>的"webgl"参数，<em>canvas.getContext("webgl")</em>将返回<em>null</em>。由于在JavaScript中，<em>null</em>在布尔上下文中被视为<em>false</em>，第三行测试返回值是否为<em>null</em>。在这种情况下，代码抛出一个错误，这可以在其他地方处理，可能是通过向用户显示错误消息。此外，如果浏览器根本没有对<code>&lt;canvas&gt;</code>的支持，代码将抛出异常。我的程序通常使用以下形式的初始化函数：</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span><span class="w"> </span><span class="nx">init</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">canvas</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;webglcanvas&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="nx">gl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">canvas</span><span class="p">.</span><span class="nx">getContext</span><span class="p">(</span><span class="s2">&quot;webgl&quot;</span><span class="p">);</span><span class="w">  </span><span class="c1">// 或 &quot;webgl2&quot;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="nx">gl</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="ne">Error</span><span class="p">(</span><span class="s2">&quot;WebGL not supported.&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="nx">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span>
<span class="w">        </span><span class="p">.</span><span class="w">  </span><span class="c1">// 报告错误</span>
<span class="w">        </span><span class="p">.</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">initGL</span><span class="p">();</span><span class="w">  </span><span class="c1">// 一个初始化WebGL图形上下文的函数</span>
<span class="w">    </span><span class="p">.</span>
<span class="w">    </span><span class="p">.</span><span class="w">  </span><span class="c1">// 其他JavaScript初始化</span>
<span class="w">    </span><span class="p">.</span>
<span class="p">}</span>
</code></pre></div>
<p>在这个函数中，<em>canvas</em>和<em>gl</em>是全局变量。<em>initGL()</em>是在脚本中其他地方定义的函数，用于初始化图形上下文，包括创建和安装着色器程序。<em>init()</em>函数应在页面加载时调用。例如，你可以通过在脚本中分配"window.onload = init;"来安排。</p>
<p>一旦创建了图形上下文<em>gl</em>，就可以使用它来调用WebGL API中的函数。例如，启用深度测试的命令，在OpenGL中写为<em>glEnable(GL_DEPTH_TEST)</em>，变成了：</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">enable</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">DEPTH_TEST</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>请注意，API中的函数和常量都是通过图形上下文引用的。图形上下文的名称"gl"是约定俗成的，但请记住，它只是一个普通的JavaScript变量，其名称由程序员决定。</p>
<p>（一些非常旧的浏览器需要<em>canvas.getContext("experimental-webgl")</em>来创建WebGL 1.0上下文。这包括Internet Explorer 11，但到现在为止，没有人应该使用Internet Explorer。）</p>
</div>
<div class="tabbed-block">
<p>To use <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>, you need a <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> graphics context. The graphics context is a <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> object whose methods implement the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side of the <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> <abbr title="Application Programming Interface. A collection of related classes, functions, constants, etc., for performing some task. An API is an &quot;interface&quot; in the sense that it can be used without understanding how its functionality is actually implemented.">API</abbr>. <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> draws its images in an <abbr title="HyperText Markup Language. A language that is used for specifying the content of web pages. An HTML document is made up of text, along with &quot;elements&quot; for adding other content, such as images, and for defining the structure of the document. Because of nesting of elements, the document can be represented by a tree-like data structure.">HTML</abbr> canvas, the same kind of <code>&lt;canvas&gt;</code> element that is used for the 2D <abbr title="Application Programming Interface. A collection of related classes, functions, constants, etc., for performing some task. An API is an &quot;interface&quot; in the sense that it can be used without understanding how its functionality is actually implemented.">API</abbr> that was covered in <a href="../../c2/s6/">Section 2.6</a>. A graphics context is associated with a particular canvas. A graphics context for <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 can be obtained by calling the function <em>canvas.getContext("webgl")</em>, where <em>canvas</em> is a <abbr title="Document Object Model. A specification for representing a web page (and other kinds of structured document) as a tree-like data structure. Can also refer to the data structure itself, as in &quot;the DOM for this web page.&quot; A web page can be modified dynamically by manipulating its DOM, using the JavaScript programming language.">DOM</abbr> object representing the canvas. For <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0, you would simply use <em>canvas.getContext("webgl2")</em> instead. The return value of <em>getContext()</em> will be <em>null</em> if the context cannot be created. So, getting a <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> graphics context often looks something like this:</p>
<div class="highlight"><pre><span></span><code><span class="nx">canvas</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;webglcanvas&quot;</span><span class="p">);</span>
<span class="nx">gl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">canvas</span><span class="p">.</span><span class="nx">getContext</span><span class="p">(</span><span class="s2">&quot;webgl&quot;</span><span class="p">);</span><span class="w">  </span><span class="c1">// or maybe canvas.getContext(&quot;webgl2&quot;)</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="nx">gl</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="ne">Error</span><span class="p">(</span><span class="s2">&quot;WebGL not supported; can&#39;t create graphics context.&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Here, the first line gets a reference to the <abbr title="HyperText Markup Language. A language that is used for specifying the content of web pages. An HTML document is made up of text, along with &quot;elements&quot; for adding other content, such as images, and for defining the structure of the document. Because of nesting of elements, the document can be represented by a tree-like data structure.">HTML</abbr> canvas that <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> will used throughout the program for drawing. The name <em>gl</em> for the variable is up to you, but I will always use gl for the <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> graphics context in my discussion. This code assumes that the <abbr title="HyperText Markup Language. A language that is used for specifying the content of web pages. An HTML document is made up of text, along with &quot;elements&quot; for adding other content, such as images, and for defining the structure of the document. Because of nesting of elements, the document can be represented by a tree-like data structure.">HTML</abbr> source for the web page includes a canvas element with id="webglcanvas", such as</p>
<div class="highlight"><pre><span></span><code><span class="p">&lt;</span><span class="nt">canvas</span> <span class="na">width</span><span class="o">=</span><span class="s">&quot;800&quot;</span> <span class="na">height</span><span class="o">=</span><span class="s">&quot;600&quot;</span> <span class="na">id</span><span class="o">=</span><span class="s">&quot;webglcanvas&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">canvas</span><span class="p">&gt;</span>
</code></pre></div>
<p>In the second line of the above code, <em>canvas.getContext("webgl")</em> will return <em>null</em> if the web browser does not support "webgl" as a parameter to <em>getContext</em>. Since <em>null</em> is considered to be <em>false</em> in <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> when used in a <em>boolean</em> context, the third line tests whether the return value is <em>null</em>. In that case, the code throws an error, which can be handled elsewhere, probably by showing an error message to the user. Furthermore, the code will throw an exception if the browser has no support at all for <code>&lt;canvas&gt;</code>. My programs often use an initialization function of the form</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span><span class="w"> </span><span class="nx">init</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">canvas</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;webglcanvas&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="nx">gl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">canvas</span><span class="p">.</span><span class="nx">getContext</span><span class="p">(</span><span class="s2">&quot;webgl&quot;</span><span class="p">);</span><span class="w">  </span><span class="c1">// or &quot;webgl2&quot;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="nx">gl</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="ne">Error</span><span class="p">(</span><span class="s2">&quot;WebGL not supported.&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="nx">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span>
<span class="w">        </span><span class="p">.</span><span class="w">  </span><span class="c1">// report the error</span>
<span class="w">        </span><span class="p">.</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">initGL</span><span class="p">();</span><span class="w">  </span><span class="c1">// a function that initializes the WebGL graphics context</span>
<span class="w">    </span><span class="p">.</span>
<span class="w">    </span><span class="p">.</span><span class="w">  </span><span class="c1">// other JavaScript initialization</span>
<span class="w">    </span><span class="p">.</span>
<span class="p">}</span>
</code></pre></div>
<p>In this function, <em>canvas</em> and <em>gl</em> are global variables. And <em>initGL()</em> is a function defined elsewhere in the script that initializes the graphics context, including creating and installing the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> programs. The <em>init()</em> function should be called when the page is loaded. This can be arranged, for example, by assigning "window.onload = init;" in the script.</p>
<p>Once the graphics context, <em>gl</em>, has been created, it can be used to call functions in the <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> <abbr title="Application Programming Interface. A collection of related classes, functions, constants, etc., for performing some task. An API is an &quot;interface&quot; in the sense that it can be used without understanding how its functionality is actually implemented.">API</abbr>. For example, the command for enabling the <abbr title="A solution to the hidden surface problem that involves keeping track of the depth, or distance from the viewer, of the object currently visible at each pixel in the image. When a new object is drawn at a pixel, the depth of the new object is compared to the depth of the current object to decide which one is closer to the viewer. The advantage of the depth test is that objects can be rendered in any order. A disadvantage is that only a limited range of depths can be represented in the image.">depth test</abbr>, which was written as <em>glEnable(GL_DEPTH_TEST)</em> in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr>, becomes</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">enable</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">DEPTH_TEST</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>Note that both functions and constants in the <abbr title="Application Programming Interface. A collection of related classes, functions, constants, etc., for performing some task. An API is an &quot;interface&quot; in the sense that it can be used without understanding how its functionality is actually implemented.">API</abbr> are referenced through the graphics context. The name "gl" for the graphics context is conventional, but remember that it is just an ordinary <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> variable whose name is up to the programmer.</p>
<p>(Some very old browsers required <em>canvas.getContext("experimental-webgl")</em> to create a <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 context. This includes Internet Explorer 11, but at this point, no one should be using Internet Explorer.)</p>
</div>
</div>
</div>
<h2 id="612-着色器程序">6.1.2 着色器程序<a class="headerlink" href="#612-着色器程序" title="Permanent link">&para;</a></h2>
<p><strong>The Shader Program</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="3:2"><input checked="checked" id="__tabbed_3_1" name="__tabbed_3" type="radio" /><input id="__tabbed_3_2" name="__tabbed_3" type="radio" /><div class="tabbed-labels"><label for="__tabbed_3_1">中文</label><label for="__tabbed_3_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>使用WebGL绘图需要一个着色器程序，它由顶点着色器和片段着色器组成。着色器是用GLSL编程语言的某个版本编写的。<abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0使用GLSL ES 1.00，而WebGL 2.0可以使用GLSL ES 1.00或GLSL ES 3.00。这里的讨论是关于GLSL ES 1.00的；我稍后会解释3.00版本中的一些变化。</p>
<p>GLSL基于C编程语言。顶点着色器和片段着色器是分开的程序，每个程序都有自己的<em>main()</em>函数。这两个着色器分别编译，然后“链接”以产生完整的着色器程序。WebGL的JavaScript API包括用于编译着色器然后链接它们的函数。要使用这些函数，着色器的源代码必须是JavaScript字符串。让我们看看它是如何工作的。创建顶点着色器需要三个步骤。</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">vertexShader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createShader</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">VERTEX_SHADER</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">shaderSource</span><span class="p">(</span><span class="w"> </span><span class="nx">vertexShader</span><span class="p">,</span><span class="w"> </span><span class="nx">vertexShaderSource</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">compileShader</span><span class="p">(</span><span class="w"> </span><span class="nx">vertexShader</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>这里使用的函数是WebGL图形上下文gl的一部分，参数<em>vertexShaderSource</em>是包含着色器源代码的字符串。源代码中的错误会导致编译失败，但不会产生任何提示。你需要通过调用函数</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">getShaderParameter</span><span class="p">(</span><span class="w"> </span><span class="nx">vertexShader</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">COMPILE_STATUS</span><span class="w"> </span><span class="p">)</span>
</code></pre></div>
<p>来检查编译是否成功，该函数返回一个布尔值，表示编译是否成功。如果发生错误，你可以使用</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">getShaderInfoLog</span><span class="p">(</span><span class="w"> </span><span class="nx">vertexShader</span><span class="w"> </span><span class="p">)</span>
</code></pre></div>
<p>来检索错误消息，该函数返回一个字符串，包含编译结果。（字符串的确切格式没有被WebGL标准指定。该字符串旨在易于人类阅读。）</p>
<p>可以以类似的方式创建片段着色器。有了这两个着色器，你可以创建并链接程序。在链接之前，需要将着色器“附加”到程序对象上。代码形式如下：</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">prog</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createProgram</span><span class="p">();</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">attachShader</span><span class="p">(</span><span class="w"> </span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="nx">vertexShader</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">attachShader</span><span class="p">(</span><span class="w"> </span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="nx">fragmentShader</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">linkProgram</span><span class="p">(</span><span class="w"> </span><span class="nx">prog</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>即使着色器已成功编译，当它们链接到一个完整的程序时也可能发生错误。例如，顶点和片段着色器可以共享某些类型的变量。如果两个程序声明了同名但类型不同的变量，链接时就会发生错误。检查链接错误与检查着色器编译错误类似。</p>
<p>创建着色器程序的代码总是非常相似的，因此将其打包到一个可重用的函数中非常方便。以下是我在此章节示例中使用的函数：</p>
<div class="highlight"><pre><span></span><code><span class="cm">/**</span>
<span class="cm"> * Creates a program for use in the WebGL context gl, and returns the</span>
<span class="cm"> * identifier for that program.  If an error occurs while compiling or</span>
<span class="cm"> * linking the program, an exception of type Error is thrown.  The error</span>
<span class="cm"> * string contains the compilation or linking error. </span>
<span class="cm"> */</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">createProgram</span><span class="p">(</span><span class="nx">gl</span><span class="p">,</span><span class="w"> </span><span class="nx">vertexShaderSource</span><span class="p">,</span><span class="w"> </span><span class="nx">fragmentShaderSource</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">vsh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createShader</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">VERTEX_SHADER</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">shaderSource</span><span class="p">(</span><span class="w"> </span><span class="nx">vsh</span><span class="p">,</span><span class="w"> </span><span class="nx">vertexShaderSource</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">compileShader</span><span class="p">(</span><span class="w"> </span><span class="nx">vsh</span><span class="w"> </span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getShaderParameter</span><span class="p">(</span><span class="nx">vsh</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">COMPILE_STATUS</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="ne">Error</span><span class="p">(</span><span class="s2">&quot;Error in vertex shader:  &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getShaderInfoLog</span><span class="p">(</span><span class="nx">vsh</span><span class="p">));</span>
<span class="p">}</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">fsh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createShader</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAGMENT_SHADER</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">shaderSource</span><span class="p">(</span><span class="w"> </span><span class="nx">fsh</span><span class="p">,</span><span class="w"> </span><span class="nx">fragmentShaderSource</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">compileShader</span><span class="p">(</span><span class="w"> </span><span class="nx">fsh</span><span class="w"> </span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getShaderParameter</span><span class="p">(</span><span class="nx">fsh</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">COMPILE_STATUS</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="ne">Error</span><span class="p">(</span><span class="s2">&quot;Error in fragment shader:  &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getShaderInfoLog</span><span class="p">(</span><span class="nx">fsh</span><span class="p">));</span>
<span class="p">}</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">prog</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createProgram</span><span class="p">();</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">attachShader</span><span class="p">(</span><span class="w"> </span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="nx">vsh</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">attachShader</span><span class="p">(</span><span class="w"> </span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="nx">fsh</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">linkProgram</span><span class="p">(</span><span class="w"> </span><span class="nx">prog</span><span class="w"> </span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getProgramParameter</span><span class="p">(</span><span class="w"> </span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">LINK_STATUS</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="ne">Error</span><span class="p">(</span><span class="s2">&quot;Link error in program:  &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getProgramInfoLog</span><span class="p">(</span><span class="nx">prog</span><span class="p">));</span>
<span class="p">}</span>
<span class="k">return</span><span class="w"> </span><span class="nx">prog</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>还有一个步骤：你必须告诉WebGL上下文使用程序。如果<em>prog</em>是由上述函数返回的程序标识符，这是通过调用</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">useProgram</span><span class="p">(</span><span class="w"> </span><span class="nx">prog</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>完成的。</p>
<p>可以创建多个着色器程序。然后，你可以随时通过调用<em>gl.useProgram</em>在不同程序之间切换，甚至在渲染图像的过程中。（例如，<em>Three.js</em>为每种类型的<strong><em>Material</em></strong>使用不同的程序。）</p>
<p>建议在初始化过程中创建所需的任何着色器程序。虽然<em>gl.useProgram</em>是一个快速操作，但编译和链接相当慢，所以最好避免在绘制图像的过程中创建新程序。</p>
<p>不再需要的着色器和程序可以被删除以释放它们消耗的资源。使用函数<em>gl.deleteShader(<abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>)</em>和<em>gl.deleteProgram(program)</em>。</p>
</div>
<div class="tabbed-block">
<p>Drawing with <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> requires a <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program, which consists of a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> and a <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr>. Shaders are written in some version of the <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> programming language. <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 used <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 1.00, while <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 can use either <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 1.00 or <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 3.00. The discussion here is about <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 1.00; I will explain some of the changes in the 3.00 version later.</p>
<p><abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> is based on the C programming language. The <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> and <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> are separate programs, each with its own <em>main()</em> function. The two shaders are compiled separately and then "linked" to produce a complete <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program. The <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> <abbr title="Application Programming Interface. A collection of related classes, functions, constants, etc., for performing some task. An API is an &quot;interface&quot; in the sense that it can be used without understanding how its functionality is actually implemented.">API</abbr> for <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> includes functions for compiling the shaders and then linking them. To use the functions, the source code for the shaders must be <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> strings. Let's see how it works. It takes three steps to create the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>.</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">vertexShader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createShader</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">VERTEX_SHADER</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">shaderSource</span><span class="p">(</span><span class="w"> </span><span class="nx">vertexShader</span><span class="p">,</span><span class="w"> </span><span class="nx">vertexShaderSource</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">compileShader</span><span class="p">(</span><span class="w"> </span><span class="nx">vertexShader</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>The functions that are used here are part of the <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> graphics context, gl, and the parameter <em>vertexShaderSource</em> is the string that contains the source code for the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>. Errors in the source code will cause the compilation to fail silently. You need to check for compilation errors by calling the function</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">getShaderParameter</span><span class="p">(</span><span class="w"> </span><span class="nx">vertexShader</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">COMPILE_STATUS</span><span class="w"> </span><span class="p">)</span>
</code></pre></div>
<p>which returns a boolean value to indicate whether the compilation succeeded. In the event that an error occurred, you can retrieve an error message with</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">getShaderInfoLog</span><span class="p">(</span><span class="w"> </span><span class="nx">vertexShader</span><span class="w"> </span><span class="p">)</span>
</code></pre></div>
<p>which returns a string containing the result of the compilation. (The exact format of the string is not specified by the <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> standard. The string is meant to be human-readable.)</p>
<p>The <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> can be created in a similar way. With both shaders in hand, you can create and link the program. The shaders need to be "attached" to the program object before linking. The code takes the form:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">prog</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createProgram</span><span class="p">();</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">attachShader</span><span class="p">(</span><span class="w"> </span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="nx">vertexShader</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">attachShader</span><span class="p">(</span><span class="w"> </span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="nx">fragmentShader</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">linkProgram</span><span class="p">(</span><span class="w"> </span><span class="nx">prog</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>Even if the shaders have been successfully compiled, errors can occur when they are linked into a complete program. For example, the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> and <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> can share certain kinds of variable. If the two programs declare such variables with the same name but with different types, an error will occur at link time. Checking for link errors is similar to checking for compilation errors in the shaders.</p>
<p>The code for creating a <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program is always pretty much the same, so it is convenient to pack it into a reusable function. Here is the function that I use for the examples in this chapter:</p>
<div class="highlight"><pre><span></span><code><span class="cm">/**</span>
<span class="cm"> * Creates a program for use in the WebGL context gl, and returns the</span>
<span class="cm"> * identifier for that program.  If an error occurs while compiling or</span>
<span class="cm"> * linking the program, an exception of type Error is thrown.  The error</span>
<span class="cm"> * string contains the compilation or linking error. </span>
<span class="cm"> */</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">createProgram</span><span class="p">(</span><span class="nx">gl</span><span class="p">,</span><span class="w"> </span><span class="nx">vertexShaderSource</span><span class="p">,</span><span class="w"> </span><span class="nx">fragmentShaderSource</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">vsh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createShader</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">VERTEX_SHADER</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">shaderSource</span><span class="p">(</span><span class="w"> </span><span class="nx">vsh</span><span class="p">,</span><span class="w"> </span><span class="nx">vertexShaderSource</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">compileShader</span><span class="p">(</span><span class="w"> </span><span class="nx">vsh</span><span class="w"> </span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getShaderParameter</span><span class="p">(</span><span class="nx">vsh</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">COMPILE_STATUS</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="ne">Error</span><span class="p">(</span><span class="s2">&quot;Error in vertex shader:  &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getShaderInfoLog</span><span class="p">(</span><span class="nx">vsh</span><span class="p">));</span>
<span class="p">}</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">fsh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createShader</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAGMENT_SHADER</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">shaderSource</span><span class="p">(</span><span class="w"> </span><span class="nx">fsh</span><span class="p">,</span><span class="w"> </span><span class="nx">fragmentShaderSource</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">compileShader</span><span class="p">(</span><span class="w"> </span><span class="nx">fsh</span><span class="w"> </span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getShaderParameter</span><span class="p">(</span><span class="nx">fsh</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">COMPILE_STATUS</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="ne">Error</span><span class="p">(</span><span class="s2">&quot;Error in fragment shader:  &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getShaderInfoLog</span><span class="p">(</span><span class="nx">fsh</span><span class="p">));</span>
<span class="p">}</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">prog</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createProgram</span><span class="p">();</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">attachShader</span><span class="p">(</span><span class="w"> </span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="nx">vsh</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">attachShader</span><span class="p">(</span><span class="w"> </span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="nx">fsh</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">linkProgram</span><span class="p">(</span><span class="w"> </span><span class="nx">prog</span><span class="w"> </span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getProgramParameter</span><span class="p">(</span><span class="w"> </span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">LINK_STATUS</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="ne">Error</span><span class="p">(</span><span class="s2">&quot;Link error in program:  &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getProgramInfoLog</span><span class="p">(</span><span class="nx">prog</span><span class="p">));</span>
<span class="p">}</span>
<span class="k">return</span><span class="w"> </span><span class="nx">prog</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>There is one more step: You have to tell the <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> context to use the program. If <em>prog</em> is a program identifier returned by the above function, this is done by calling</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">useProgram</span><span class="p">(</span><span class="w"> </span><span class="nx">prog</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>It is possible to create several <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> programs. You can then switch from one program to another at any time by calling <em>gl.useProgram</em>, even in the middle of <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> an image. (<em>Three.js</em>, for example, uses a different program for each type of <strong><em>Material</em></strong>.)</p>
<p>It is advisable to create any <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> programs that you need as part of initialization. Although <em>gl.useProgram</em> is a fast operation, compiling and linking are rather slow, so it's better to avoid creating new programs while in the process of drawing an image.</p>
<p>Shaders and programs that are no longer needed can be deleted to free up the resources they consume. Use the functions <em>gl.deleteShader(<abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>)</em> and <em>gl.deleteProgram(program)</em>.</p>
</div>
</div>
</div>
<h2 id="613-管道中的数据流">6.1.3 管道中的数据流<a class="headerlink" href="#613-管道中的数据流" title="Permanent link">&para;</a></h2>
<p><strong>Data Flow in the Pipeline</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="4:2"><input checked="checked" id="__tabbed_4_1" name="__tabbed_4" type="radio" /><input id="__tabbed_4_2" name="__tabbed_4" type="radio" /><div class="tabbed-labels"><label for="__tabbed_4_1">中文</label><label for="__tabbed_4_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>WebGL图形管线渲染图像。定义图像的数据来自JavaScript。当它通过管线时，它会被当前的顶点着色器和片段着色器以及管线的固定功能阶段处理。你需要了解如何将数据通过JavaScript放置到管线中，以及数据在通过管线时是如何被处理的。</p>
<p>WebGL中的基本操作是绘制一个几何原语。WebGL只使用在<a href="../../c3/s1/#311--opengl基元">3.1.1小节</a>中介绍的OpenGL原语中的七个。用于绘制四边形和多边形的原语已被移除。剩余的原语绘制点、线段和三角形。在WebGL中，七种类型的原语由常量<em>gl.POINTS</em>、<em>gl.LINES</em>、<em>gl.LINE_STRIP</em>、<em>gl.LINE_LOOP</em>、<em>gl.TRIANGLES</em>、<em>gl.TRIANGLE_STRIP</em>和<em>gl.TRIANGLE_FAN</em>标识，其中<em>gl</em>是WebGL图形上下文。</p>
<p>当WebGL用于绘制一个原语时，可以为原语提供两类数据。这两种数据分别称为<strong><abbr title="表示可编程图形管线中顶点着色器的输入的变量。属性变量在原语中的每个顶点上可以有不同的值。">属性变量</abbr></strong>（或简称“<abbr title="图形对象的属性，例如颜色。图像可以通过其包含的几何形状以及它们的属性来指定。">属性</abbr>”）和<strong><abbr title="表示可编程图形管线中着色器程序的输入的变量。统一变量在每个顶点和每个像素上都有相同的值。">统一变量</abbr></strong>（或简称“统一”）。一个原语由其类型和顶点列表定义。属性和统一的区别在于，统一变量有一个单一的值，对整个原语都是相同的，而属性变量的值可以对不同的顶点不同。</p>
<p>应该始终指定的一个属性是顶点的坐标。顶点坐标必须是属性，因为原语中的每个顶点都有自己的坐标集。另一个可能的属性是颜色。我们已经看到，OpenGL允许你为原语的每个顶点指定不同的颜色。在WebGL中，你也可以这样做，这种情况下颜色将是一个属性。另一方面，如果你希望整个原语具有相同的“统一”颜色，在这种情况下，颜色可以是统一变量。其他可能根据需要是属性或统一的数量包括法向量和材质属性。如果使用，纹理坐标几乎肯定是属性，因为让原语中的所有顶点具有相同的纹理坐标没有多大意义。如果对原语应用几何变换，它很自然地被表示为统一变量。</p>
<p>然而，重要的是要理解，WebGL没有任何预定义的属性，甚至没有顶点坐标的属性。在可编程管线中，使用哪些属性和统一完全取决于程序员。就WebGL而言，属性只是传递到顶点着色器的值。统一可以传递到顶点着色器、片段着色器或两者。WebGL不赋予值任何意义。意义完全由着色器对值的处理决定。在绘制原语时使用的属性和统一的集合由绘制原语时使用的着色器的源代码确定。</p>
<p>为了理解这一点，我们需要更详细地看看管线中发生了什么。在绘制原语时，JavaScript程序会为着色器程序中的任何属性和统一指定值。对于每个属性，它将指定一个值数组，每个顶点一个。对于每个统一，它将指定一个单一的值。它必须在绘制原语之前将这些值发送到GPU。然后，可以通过调用单个JavaScript函数来绘制原语。在这一点上，GPU接管并执行着色器程序。在绘制原语时，GPU会为每个顶点调用一次顶点着色器。要处理的顶点的属性值被作为输入传递到顶点着色器。统一变量的值也会传递到顶点着色器。这是通过将属性和统一表示为顶点着色器程序中的全局变量来实现的。在调用给定顶点的着色器之前，GPU会适当地设置这些变量的值。</p>
<p>作为其输出之一，顶点着色器必须指定顶点在裁剪坐标系中的坐标（见<a href="../../c3/s3/#331-多种坐标系">3.3.1小节</a>）。它通过给一个名为<em>gl_Position</em>的特殊变量赋值来实现。位置通常通过对表示对象坐标系中坐标的属性应用变换来计算，但位置的计算方式完全取决于程序员。</p>
<p>在计算了原语中所有顶点的位置之后，管线中的一个固定功能阶段会裁剪掉坐标超出有效裁剪坐标范围（每个坐标轴上的-1到1）的原语部分。然后，原语被光栅化；也就是说，确定哪些像素位于原语内部。然后，GPU会为原语中的每个像素调用一次片段着色器。片段着色器可以访问统一变量（但不能访问属性）。它还可以使用一个名为<em>gl_FragCoord</em>的特殊变量，其中包含像素的裁剪坐标。像素坐标是通过插值顶点着色器指定的<em>gl_Position</em>值来计算的。插值是由位于顶点着色器和片段着色器之间的另一个固定功能阶段完成的。</p>
<p>除了坐标之外，其他数量也可以以类似的方式工作。也就是说，顶点着色器为原语的每个顶点计算数量的值。插值器采用在顶点着色器中为原语的每个顶点生成的值，并计算原语中每个像素的值。当片段着色器被调用以处理给定像素时，变化变量的值就是该像素的插值值。片段着色器可以在自己的计算中使用该值。</p>
<p>变化变量存在于顶点着色器和片段着色器中。顶点着色器负责给变化变量赋值。原语的每个顶点可以给变量分配不同的值。插值器采用执行顶点着色器为原语的每个顶点产生的所有值，并插值这些值以产生每个像素的值。当片段着色器被执行以处理给定像素时，变化变量的值就是该像素的插值值。片段着色器可以在自己的计算中使用该值。</p>
<p>变化变量的存在是为了从顶点着色器向片段着色器通信数据。它们在着色器源代码中定义。它们不在使用API的JavaScript方面使用或引用。请注意，决定定义哪些变化变量以及如何处理它们完全取决于程序员。</p>
<p>我们几乎已经到了管线的末尾。在所有这些之后，片段着色器的工作仅仅是为像素指定一种颜色。它通过给一个名为<em>gl_FragColor</em>的特殊变量赋值来实现。然后，该值将被用在管线的剩余固定功能阶段中。</p>
<p>总结：程序的JavaScript方面将属性和统一变量的值发送到GPU，然后发出绘制原语的命令。GPU为每个顶点执行一次顶点着色器。顶点着色器可以使用属性和统一的值。它给<em>gl_Position</em>和着色器中的任何变化变量赋值。在裁剪、光栅化和插值之后，GPU为原语中的每个像素执行一次片段着色器。片段着色器可以使用变化变量、统一和<em>gl_FragCoord</em>的值。它计算<em>gl_FragColor</em>的值。这张图总结了数据的流向：</p>
<p><a class="glightbox" href="../../../en/c6/webgl-dataflow.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c6/webgl-dataflow.png" /></a></p>
<p>这张图不完整。还有一些特殊的变量我还没有提到。以及如何使用纹理的重要问题。但是如果你理解了这张图，你就对理解WebGL有了一个良好的开端。</p>
<hr />
<p><strong>对于GLSL ES 3.00</strong>，相同的图适用，只是没有特殊的变量<em>gl_FragColor</em>。相反，片段着色器必须定义自己的输出变量来表示颜色。在GLSL ES 1.00中，声明实际着色器程序源代码中的变量时使用“<abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>”和“varying”。在3.00版本的源代码中，属性变量变为“in”变量，因为它们是顶点着色器的输入，而变化变量在顶点着色器中变为“out”变量，在片段着色器中变为“in”变量。变量<em>gl_FragColor</em>被片段着色器中的“out”变量替换。实际上，“in”和“out”的使用更适合具有附加管线阶段的系统，其中一个阶段的“out”变量可以成为下一个阶段的“in”变量。无论如何，在讨论WebGL时，即使使用GLSL ES 3.00，人们仍然使用属性和变化这些术语。</p>
</div>
<div class="tabbed-block">
<p>The <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> graphics <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> renders an image. The data that defines the image comes from <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr>. As it passes through the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>, it is processed by the current <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> and <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> as well as by the fixed-function stages of the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>. You need to understand how data is placed by <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> into the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> and how the data is processed as it passes through the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>.</p>
<p>The basic operation in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> is to draw a <abbr title="Geometric objects in a graphics system, such as OpenGL, that are not made up of simpler objects. Examples in OpenGL include points, lines, and triangles, but the set of available primitives depends on the graphics system. (Note that as the term is used in OpenGL, a single primitive can be made up of many points, line segments, or triangles.)">geometric primitive</abbr>. <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> uses just seven of the <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> primitives that were introduced in <a href="../../c3/s1/#311--opengl基元">Subsection 3.1.1</a>. The primitives for drawing quads and polygons have been removed. The remaining primitives draw points, line segments, and triangles. In WegGL, the seven types of primitive are identified by the constants <em>gl.POINTS</em>, <em>gl.LINES</em>, <em>gl.LINE_STRIP</em>, <em>gl.LINE_LOOP</em>, <em>gl.TRIANGLES</em>, <em>gl.TRIANGLE_STRIP</em>, and <em>gl.TRIANGLE_FAN</em>, where <em>gl</em> is a <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> graphics context.</p>
<p>When <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> is used to draw a primitive, there are two general categories of data that can be provided for the primitive. The two kinds of data are referred to as <strong><abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> variables</strong> (or just "<abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr>") and <strong>uniform variables</strong> (or just "uniforms"). A primitive is defined by its type and by a list of vertices. The difference between <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr> and uniforms is that a <abbr title="Variables that represent input to a shader program in a programmable graphics pipeline. A uniform variable has the same value at every vertex and at every pixel of a primitive.">uniform variable</abbr> has a single value that is the same for the entire primitive, while the value of an <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> variable can be different for different vertices.</p>
<p>One <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> that should always be specified is the coordinates of the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>. The <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> coordinates must be an <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> since each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> in a primitive will have its own set of coordinates. Another possible <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> is color. We have seen that <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> allows you to specify a different color for each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> of a primitive. You can do the same thing in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>, and in that case the color will be an <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>. On the other hand, maybe you want the entire primitive to have the same, "uniform" color; in that case, color can be a <abbr title="Variables that represent input to a shader program in a programmable graphics pipeline. A uniform variable has the same value at every vertex and at every pixel of a primitive.">uniform variable</abbr>. Other quantities that could be either <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr> or uniforms, depending on your needs, include normal vectors and <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> properties. Texture coordinates, if they are used, are almost certain to be an <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>, since it doesn't really make sense for all the vertices in a primitive to have the same <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates. If a <abbr title="A coordinate transformation; that is, a function that can be applied to each of the points in a geometric object to produce a new object. Common transforms include scaling, rotation, and translation.">geometric transform</abbr> is to be applied to the primitive, it would naturally be represented as a <abbr title="Variables that represent input to a shader program in a programmable graphics pipeline. A uniform variable has the same value at every vertex and at every pixel of a primitive.">uniform variable</abbr>.</p>
<p>It is important to understand, however, that <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> does not come with <strong>any</strong> predefined <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr>, not even one for <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> coordinates. In the programmable <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>, the <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr> and uniforms that are used are entirely up to the programmer. As far as <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> is concerned, <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr> are just values that are passed into the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>. Uniforms can be passed into the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>, the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr>, or both. <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> does not assign a meaning to the values. The meaning is entirely determined by what the shaders do with the values. The set of <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr> and uniforms that are used in drawing a primitive is determined by the source code of the shaders that are in use when the primitive is drawn.</p>
<p>To understand this, we need to look at what happens in the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> in a more detail. When drawing a primitive, the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> program specifies values for any <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr> and uniforms in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program. For each <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>, it will specify an array of values, one for each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>. For each uniform, it will specify a single value. It must send these values to the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> before drawing the primitive. The primitive can then be drawn by calling a single <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> function. At that point, the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> takes over, and executes the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> programs. When drawing the primitive, the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> calls the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> once for each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>. The <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> values for the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> that is to be processed are passed as input into the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>. Values of uniform variables are also passed to the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>. The way this works is that both <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr> and uniforms are represented as global variables in the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program. Before calling the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> for a given <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>, the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> sets the values of those variables appropriately for that specific <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>.</p>
<p>As one of its outputs, the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> must specify the coordinates of the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> in the clip <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr> (see <a href="../../c3/s3/#331-多种坐标系">Subsection 3.3.1</a>). It does that by assigning a value to a special variable named <em>gl_Position</em>. The position is often computed by applying a transformation to the <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> that represents the coordinates in the object <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr>, but exactly how the position is computed is up to the programmer.</p>
<p>After the positions of all the vertices in the primitive have been computed, a fixed-function stage in the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> clips away the parts of the primitive whose coordinates are outside the range of valid <abbr title="The default coordinate system in OpenGL. The projection transform maps the 3D scene to clip coordinates. The rendered image will show the contents of the cube in the clip coordinate system that contains x, y, and z values in the range from -1 to 1; anything outside that range is &quot;clipped&quot; away.">clip coordinates</abbr> (−1 to 1 along each coordinate axis). The primitive is then rasterized; that is, it is determined which <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr> lie inside the primitive. The <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> then calls the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> once for each <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> that lies in the primitive. The <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> has access to uniform variables (but not <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr>). It can also use a special variable named <em>gl_FragCoord</em> that contains the <abbr title="The default coordinate system in OpenGL. The projection transform maps the 3D scene to clip coordinates. The rendered image will show the contents of the cube in the clip coordinate system that contains x, y, and z values in the range from -1 to 1; anything outside that range is &quot;clipped&quot; away.">clip coordinates</abbr> of the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>. Pixel coordinates are computed by interpolating the values of <em>gl_Position</em> that were specified by the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>. The <abbr title="Given values for some quantity at certain reference points, computing a value for that quantity at other points by some kind of averaging applied to the values at the reference points.">interpolation</abbr> is done by another fixed-function stage that comes between the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> and the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr>.</p>
<p>Other quantities besides coordinates can work in much that same way. That is, the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> computes a value for the quantity at each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> of a primitive. An interpolator takes the values at the vertices and computes a value for each <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> in the primitive. The value for a given <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> is then input into the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> when the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> is called to process that <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>. For example, color in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> follows this pattern: The color of an interior <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> of a primitive is computed by interpolating the color at the vertices. In <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr>, this pattern is implemented using <strong>varying variables</strong>.</p>
<p>A <abbr title="A variable that is used to communicate values from the vertex shader to the fragment shader in the WebGL or OpenGL ES 2.0 graphics pipeline. A varying variable is assigned a value in the vertex shader. The value of the variable in the fragment shader for a pixel in the primitive is obtained by interpolating the values from the vertices of the primitive. (In newer versions of GLSL, which support additional shader stages, the term &quot;varying variable&quot; is replaced by the more general terms &quot;in variable&quot; and &quot;out variable,&quot; which refer to variables that are used for input to or output from a shader.)">varying variable</abbr> is declared both in the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> and in the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr>. The <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> is responsible for assigning a value to the <abbr title="A variable that is used to communicate values from the vertex shader to the fragment shader in the WebGL or OpenGL ES 2.0 graphics pipeline. A varying variable is assigned a value in the vertex shader. The value of the variable in the fragment shader for a pixel in the primitive is obtained by interpolating the values from the vertices of the primitive. (In newer versions of GLSL, which support additional shader stages, the term &quot;varying variable&quot; is replaced by the more general terms &quot;in variable&quot; and &quot;out variable,&quot; which refer to variables that are used for input to or output from a shader.)">varying variable</abbr>. Each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> of a primitive can assign a different value to the variable. The interpolator takes all the values produced by executing the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> for each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> of the primitive, and it interpolates those values to produce a value for each <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>. When the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> is executed for a given <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>, the value of the <abbr title="A variable that is used to communicate values from the vertex shader to the fragment shader in the WebGL or OpenGL ES 2.0 graphics pipeline. A varying variable is assigned a value in the vertex shader. The value of the variable in the fragment shader for a pixel in the primitive is obtained by interpolating the values from the vertices of the primitive. (In newer versions of GLSL, which support additional shader stages, the term &quot;varying variable&quot; is replaced by the more general terms &quot;in variable&quot; and &quot;out variable,&quot; which refer to variables that are used for input to or output from a shader.)">varying variable</abbr> is the interpolated value for that <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>. The <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> can use the value in its own computations.</p>
<p>Varying variables exist to communicate data from the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> to the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr>. They are defined in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> source code. They are not used or referred to in the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side of the <abbr title="Application Programming Interface. A collection of related classes, functions, constants, etc., for performing some task. An API is an &quot;interface&quot; in the sense that it can be used without understanding how its functionality is actually implemented.">API</abbr>. Note that it is entirely up to the programmer to decide what varying variables to define and what to do with them.</p>
<p>We have almost gotten to the end of the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>. After all that, the job of the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> is simply to specify a color for the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>. It does that by assigning a value to a special variable named <em>gl_FragColor</em>. That value will then be used in the remaining fixed-function stages of the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>.</p>
<p>To summarize: The <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side of the program sends values for <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr> and uniform variables to the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> and then issues a command to draw a primitive. The <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> executes the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> once for each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>. The <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> can use the values of <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr> and uniforms. It assigns values to <em>gl_Position</em> and to any varying variables that exist in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>. After clipping, <abbr title="The process of creating a raster image, that is one made of pixels, from other data that specifies the content of the image. For example, a vector graphics image must be rasterized in order to be displayed on a computer screen.">rasterization</abbr>, and <abbr title="Given values for some quantity at certain reference points, computing a value for that quantity at other points by some kind of averaging applied to the values at the reference points.">interpolation</abbr>, the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> executes the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> once for each <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> in the primitive. The <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> can use the values of varying variables, uniform variables, and <em>gl_FragCoord</em>. It computes a value for <em>gl_FragColor</em>. This diagram summarizes the flow of data:</p>
<p><a class="glightbox" href="../../../en/c6/webgl-dataflow.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c6/webgl-dataflow.png" /></a></p>
<p>The diagram is not complete. There are a few more special variables that I haven't mentioned. And there is the important question of how textures are used. But if you understand the diagram, you have a good start on understanding <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>.</p>
<hr />
<p><strong>For <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 3.00</strong>, the same diagram applies, except that there is no special variable <em>gl_FragColor</em>. Instead, the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> must define its own output variable to represent the color. In <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 1.00, the words "<abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>" and "varying" are used when declaring variables in the actual <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program source code. In source code for the 3.00 version, <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> variables become "in" variables, since they are inputs to the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>, and varying variables become "out" variables in the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> and "in" variables in the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr>. And the variable <em>gl_FragColor</em> is replaced by an "out" variable in the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr>. The use of the terms "in" and "out" are actually more appropriate to systems with additional <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> stages, where "out" variables from one stage can become "in" variables to the next stage. In any case, people still use the terms <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> and varying when discussing <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>, even if it is using <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 3.00.</p>
</div>
</div>
</div>
<h2 id="614-统一变量的值">6.1.4 统一变量的值<a class="headerlink" href="#614-统一变量的值" title="Permanent link">&para;</a></h2>
<p><strong>Values for Uniform Variables</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="5:2"><input checked="checked" id="__tabbed_5_1" name="__tabbed_5" type="radio" /><input id="__tabbed_5_2" name="__tabbed_5" type="radio" /><div class="tabbed-labels"><label for="__tabbed_5_1">中文</label><label for="__tabbed_5_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>是时候开始看一些实际的WebGL代码了。我们将首先关注JavaScript方面，但你还需要了解一些GLSL的基本知识。GLSL有一些熟悉的基本数据类型：<strong><em>float</em></strong>、<strong><em>int</em></strong>和<strong><em>bool</em></strong>。但它也有一些新的预定义数据类型来表示向量和矩阵。例如，数据类型<em>vec3</em>表示3D中的向量。<em>vec3</em>变量的值是三个浮点数的列表。类似地，还有数据类型<em>vec2</em>和<em>vec4</em>来表示2D和4D向量。</p>
<p>在顶点着色器中的全局变量声明可以标记为<em><abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr></em>、<em>varying</em>或<em>uniform</em>（或者在GLSL ES 3.00中作为<em>in</em>、<em>out</em>或<em>uniform</em>，但再说一次，我们将暂时坚持使用1.00版本）。没有任何这些修饰符的变量声明定义了一个局部于顶点着色器的变量。片段着色器中的全局变量可以是<em>uniform</em>或<em>varying</em>，也可以不加修饰符声明。应在两个着色器中声明变化变量，使用相同的名称和类型。这允许GLSL编译器确定在着色器程序中使用了哪些属性、统一和变化变量。</p>
<p>程序的JavaScript方面需要一种方法来引用特定的属性和统一变量。函数<em>gl.getUniformLocation</em>可以用来获取着色器程序中统一变量的引用，其中<em>gl</em>指的是WebGL图形上下文。它接受两个参数：由<em>gl.createProgram</em>返回的编译程序的标识符，以及着色器源代码中统一变量的名称。例如，如果prog标识了一个具有名为<em>color</em>的统一变量的着色器程序，那么可以使用以下JavaScript语句获取<em>color</em>变量的位置：</p>
<div class="highlight"><pre><span></span><code><span class="nx">colorUniformLoc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getUniformLocation</span><span class="p">(</span><span class="w"> </span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;color&quot;</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>然后可以使用位置<em>colorUniformLoc</em>来设置统一变量的值。例如：</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">uniform3f</span><span class="p">(</span><span class="w"> </span><span class="nx">colorUniformLoc</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>函数<em>gl.uniform3f</em>是一系列可以作为<em>gl.uniform</em><em>组的函数之一。这类似于OpenGL 1.1中的</em>glVertex<em><em>系列。</em>代表一个后缀，表示为变量提供的值的数量和类型。在这种情况下，</em>gl.uniform3f<em>接受三个浮点值，适用于设置类型为vec3的统一变量的值。值的数量可以是1、2、3或4。类型可以是“f”表示浮点数或“i”表示整数。（对于布尔统一变量，应使用</em>gl.uniform1i<em>并将0传递以表示</em>false<em>或1以表示</em>true*。）如果在后缀中添加“v”，则值以数组的形式传递。例如，</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">uniform3fv</span><span class="p">(</span><span class="w"> </span><span class="nx">colorUniformLoc</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>还有另一组函数用于设置统一矩阵变量的值。我们稍后会讲到。</p>
<p>统一变量的值可以在着色器程序编译后的任何时间设置，并且该值一直有效，直到通过另一次调用<em>gl.uniform</em>*来更改。</p>
<p>如果传递给<em>gl.getUniformLocation</em>作为第二个参数的字符串不是着色器程序中的统一变量名称，那么返回值将是<em>null</em>。如果统一变量在着色器源代码中声明但不在程序中“活跃”，则返回值也可能是<em>null</em>。一个声明但没有实际使用的变量不是活跃的，它在编译程序中不会获得位置。这偶尔给我带来了问题，当我为了调试目的注释掉着色器程序的一部分时，并不小心通过这样做使一个变量变为非活跃状态。</p>
</div>
<div class="tabbed-block">
<p>It's time to start looking at some actual <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> code. We will concentrate on the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side first, but you need to know a little about <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr>. <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> has some familiar basic data types: <strong><em>float</em></strong>, <strong><em>int</em></strong>, and <strong><em>bool</em></strong>. But it also has some new predefined data types to represent vectors and matrices. For example, the data type <em>vec3</em> represents a <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> in 3D. The value of a <em>vec3</em> variable is a list of three floating-point numbers. Similarly, there are data types <em>vec2</em> and <em>vec4</em> to represent 2D and 4D vectors.</p>
<p>Global variable declarations in a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> can be marked as <em><abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr></em>, <em>varying</em>, or <em>uniform</em> (or as <em>in</em>, out, or <em>uniform</em> in <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 3.00, but again, we will stick to the 1.00 version for the time being). A variable declaration with none of these modifiers defines a variable that is local to the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>. Global variables in a fragment can optionally be <em>uniform</em> or <em>varying</em>, or they can be declared without a modifier. A <abbr title="A variable that is used to communicate values from the vertex shader to the fragment shader in the WebGL or OpenGL ES 2.0 graphics pipeline. A varying variable is assigned a value in the vertex shader. The value of the variable in the fragment shader for a pixel in the primitive is obtained by interpolating the values from the vertices of the primitive. (In newer versions of GLSL, which support additional shader stages, the term &quot;varying variable&quot; is replaced by the more general terms &quot;in variable&quot; and &quot;out variable,&quot; which refer to variables that are used for input to or output from a shader.)">varying variable</abbr> should be declared in both shaders, with the same name and type. This allows the <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> compiler to determine what <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>, uniform, and varying variables are used in a <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program.</p>
<p>The <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side of the program needs a way to refer to particular <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr> and uniform variables. The function <em>gl.getUniformLocation</em> can be used to get a reference to a <abbr title="Variables that represent input to a shader program in a programmable graphics pipeline. A uniform variable has the same value at every vertex and at every pixel of a primitive.">uniform variable</abbr> in a <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program, where <em>gl</em> refers to the <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> graphics context. It takes as parameters the identifier for the compiled program, which was returned by <em>gl.createProgram</em>, and the name of the <abbr title="Variables that represent input to a shader program in a programmable graphics pipeline. A uniform variable has the same value at every vertex and at every pixel of a primitive.">uniform variable</abbr> in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> source code. For example, if prog identifies a <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program that has a <abbr title="Variables that represent input to a shader program in a programmable graphics pipeline. A uniform variable has the same value at every vertex and at every pixel of a primitive.">uniform variable</abbr> named <em>color</em>, then the location of the <em>color</em> variable can be obtained with the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> statement</p>
<div class="highlight"><pre><span></span><code><span class="nx">colorUniformLoc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getUniformLocation</span><span class="p">(</span><span class="w"> </span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;color&quot;</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>The location <em>colorUniformLoc</em> can then be used to set the value of the <abbr title="Variables that represent input to a shader program in a programmable graphics pipeline. A uniform variable has the same value at every vertex and at every pixel of a primitive.">uniform variable</abbr>. For example:</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">uniform3f</span><span class="p">(</span><span class="w"> </span><span class="nx">colorUniformLoc</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>The function <em>gl.uniform3f</em> is one of a family of functions that can be referred to as a group as <em>gl.uniform*</em>. This is similar to the family <em>glVertex*</em> in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1. The * represents a suffix that tells the number and type of values that are provided for the variable. In this case, <em>gl.uniform3f</em> takes three floating point values, and it is appropriate for setting the value of a <abbr title="Variables that represent input to a shader program in a programmable graphics pipeline. A uniform variable has the same value at every vertex and at every pixel of a primitive.">uniform variable</abbr> of type vec3. The number of values can be 1, 2, 3, or 4. The type can be "f" for floating point or "i" for integer. (For a boolean uniform, you should use <em>gl.uniform1i</em> and pass 0 to represent <em>false</em> or 1 to represent <em>true</em>.) If a "v" is added to the suffix, then the values are passed in an array. For example,</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">uniform3fv</span><span class="p">(</span><span class="w"> </span><span class="nx">colorUniformLoc</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>There is another family of functions for setting the value of uniform <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> variables. We will get to that later.</p>
<p>The value of a <abbr title="Variables that represent input to a shader program in a programmable graphics pipeline. A uniform variable has the same value at every vertex and at every pixel of a primitive.">uniform variable</abbr> can be set any time after the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program has been compiled, and the value remains in effect until it is changed by another call to <em>gl.uniform*</em>.</p>
<p>If the string that is passed as the second parameter <em>gl.getUniformLocation</em> is not the name of a <abbr title="Variables that represent input to a shader program in a programmable graphics pipeline. A uniform variable has the same value at every vertex and at every pixel of a primitive.">uniform variable</abbr> in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> programs, then the return value is <em>null</em>. The return value can also be <em>null</em> if the <abbr title="Variables that represent input to a shader program in a programmable graphics pipeline. A uniform variable has the same value at every vertex and at every pixel of a primitive.">uniform variable</abbr> is declared in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> source code but is not "active" in the program. A variable that is declared but not actually used is not active, and it does not get a location in the compiled program. This has occasionally caused problems for me, when I commented out part of a <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program for debugging purposes, and accidentally made a variable inactive by doing so.</p>
</div>
</div>
</div>
<h2 id="615-属性值">6.1.5 属性值<a class="headerlink" href="#615-属性值" title="Permanent link">&para;</a></h2>
<p><strong>Values for Attributes</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="6:2"><input checked="checked" id="__tabbed_6_1" name="__tabbed_6" type="radio" /><input id="__tabbed_6_2" name="__tabbed_6" type="radio" /><div class="tabbed-labels"><label for="__tabbed_6_1">中文</label><label for="__tabbed_6_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>现在让我们来看看一些实际的WebGL代码。我们将首先关注JavaScript方面，但你还需要了解一些GLSL的基本知识。GLSL有一些熟悉的基本数据类型：<strong><em>float</em></strong>、<strong><em>int</em></strong>和<strong><em>bool</em></strong>。但它也有一些新的预定义数据类型来表示向量和矩阵。例如，数据类型<em>vec3</em>表示3D中的向量。<em>vec3</em>变量的值是三个浮点数的列表。类似地，还有数据类型<em>vec2</em>和<em>vec4</em>来表示2D和4D向量。</p>
<p>在顶点着色器中的全局变量声明可以标记为<em><abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr></em>、<em>varying</em>或<em>uniform</em>（或者在GLSL ES 3.00中作为<em>in</em>、<em>out</em>或<em>uniform</em>，但再说一次，我们将暂时坚持使用1.00版本）。没有任何这些修饰符的变量声明定义了一个局部于顶点着色器的变量。片段着色器中的全局变量可以是<em>uniform</em>或<em>varying</em>，也可以不加修饰符声明。应在两个着色器中声明变化变量，使用相同的名称和类型。这允许GLSL编译器确定在着色器程序中使用了哪些属性、统一和变化变量。</p>
<p>程序的JavaScript方面需要一种方法来引用特定的属性和统一变量。函数<em>gl.getUniformLocation</em>可以用来获取着色器程序中统一变量的引用，其中<em>gl</em>指的是WebGL图形上下文。它接受两个参数：由<em>gl.createProgram</em>返回的编译程序的标识符，以及着色器源代码中统一变量的名称。例如，如果prog标识了一个具有名为<em>color</em>的统一变量的着色器程序，那么可以使用以下JavaScript语句获取<em>color</em>变量的位置：</p>
<div class="highlight"><pre><span></span><code><span class="nx">colorUniformLoc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getUniformLocation</span><span class="p">(</span><span class="w"> </span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;color&quot;</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>然后可以使用位置<em>colorUniformLoc</em>来设置统一变量的值。例如：</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">uniform3f</span><span class="p">(</span><span class="w"> </span><span class="nx">colorUniformLoc</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>函数<em>gl.uniform3f</em>是一系列可以作为<em>gl.uniform</em><em>组的函数之一。这类似于OpenGL 1.1中的</em>glVertex<em><em>系列。</em>代表一个后缀，表示为变量提供的值的数量和类型。在这种情况下，</em>gl.uniform3f<em>接受三个浮点值，适用于设置类型为vec3的统一变量的值。值的数量可以是1、2、3或4。类型可以是“f”表示浮点数或“i”表示整数。（对于布尔统一变量，应使用</em>gl.uniform1i<em>并将0传递以表示</em>false<em>或1以表示</em>true*。）如果在后缀中添加“v”，则值以数组的形式传递。例如，</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">uniform3fv</span><span class="p">(</span><span class="w"> </span><span class="nx">colorUniformLoc</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>还有另一组函数用于设置统一矩阵变量的值。我们稍后会讲到。</p>
<p>统一变量的值可以在着色器程序编译后的任何时间设置，并且该值一直有效，直到通过另一次调用<em>gl.uniform</em>*来更改。</p>
<p>如果传递给<em>gl.getUniformLocation</em>作为第二个参数的字符串不是着色器程序中的统一变量名称，那么返回值将是<em>null</em>。如果统一变量在着色器源代码中声明但不在程序中“活跃”，则返回值也可能是<em>null</em>。一个声明但没有实际使用的变量不是活跃的，它在编译程序中不会获得位置。这偶尔给我带来了问题，当我为了调试目的注释掉着色器程序的一部分时，并不小心通过这样做使一个变量变为非活跃状态。</p>
<p>现在让我们来看看属性，情况就更加复杂了，因为属性在原语中的每个顶点可以取不同的值。基本思想是在单个操作中将属性的完整数据集从JavaScript数组复制到GPU可以访问的内存中。不幸的是，设置使该操作成为可能的过程并不简单。</p>
<p>首先，普通的JavaScript数组不适合这个目的。为了效率，我们需要数据存储在连续内存位置的数值块中，而常规的JavaScript数组没有这种形式。为了解决这个问题，JavaScript引入了一种新型数组，称为类型化数组。我们在<a href="../../c5/">第5章</a>中使用three.js时遇到了类型化数组。在<a href="../../c5/s1/#514-物体几何形状材料">5.1.4小节</a>中有类型化数组的简短介绍。类型化数组有固定长度，在创建时分配，并且只能保存指定类型的数字。不同类型的类型化数组用于不同类型的数值数据。现在我们将使用<strong><em>Float32Array</em></strong>，它保存32位浮点数。一旦你有了类型化数组，你可以像使用常规数组一样使用它，但是当你给<strong><em>Float32Array</em></strong>的元素分配任何值时，该值会被转换为32位浮点数。如果值不能被解释为数字，它将被转换为NaN，即“不是一个数字”的值。</p>
<p>在数据可以从JavaScript传输到属性变量之前，它必须被放置到类型化数组中。如果可能的话，为了效率，你应该直接使用类型化数组，而不是使用常规的JavaScript数组，然后复制数据到类型化数组中。</p>
<hr />
<p>在WebGL中使用属性数据，必须将其传输到VBO（<abbr title="顶点缓冲对象。可以容纳一组顶点的坐标或其他属性的内存块。VBO 可以存储在 GPU 上。VBO 使得可以将此类数据发送到 GPU 一次，然后多次重用。在 OpenGL 中，VBO 与函数 glDrawArrays 和 glDrawElements 一起使用。">顶点缓冲对象</abbr>）。VBO在OpenGL 1.5中引入，并在<a href="../../c3/s4/#344-显示列表和vbo">3.4.4小节</a>中简要讨论过。VBO是GPU可以访问的内存块。要使用VBO，你必须首先调用函数<em>gl.createBuffer()</em>来创建它。例如，</p>
<div class="highlight"><pre><span></span><code><span class="nx">colorBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">();</span>
</code></pre></div>
<p>在将数据传输到VBO之前，你必须“绑定”<abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr>：</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">bindBuffer</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">colorBuffer</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p><em>gl.bindBuffer</em>的第一个参数称为“目标”。它指定了VBO的用途。目标<em>gl.ARRAY_BUFFER</em>用于存储属性的值。一次只能将一个VBO绑定到给定目标。</p>
<p>传输数据到VBO的函数没有提到VBO——而是使用当前绑定的VBO。要将数据复制到该缓冲区，使用<em>gl.bufferData()</em>。例如：</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">bufferData</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">colorArray</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">STATIC_DRAW</span><span class="p">);</span>
</code></pre></div>
<p>第一个参数再次是目标。数据被传输到绑定到该目标的VBO。第二个参数是在JavaScript方面持有数据的类型化数组。数组中的所有元素都被复制到缓冲区，数组的大小决定了缓冲区的大小。注意，这是原始数据字节的直接传输；WebGL不记得数据是否表示浮点数或整数或其他类型的数据。</p>
<p><em>gl.bufferData</em>的第三个参数是常量<em>gl.STATIC_DRAW</em>、<em>gl.STREAM_DRAW</em>或<em>gl.DYNAMIC_DRAW</em>之一。它是对WebGL的提示，说明数据将如何使用，它帮助WebGL以最有效的方式管理数据。值<em>gl.STATIC_DRAW</em>意味着您打算多次使用数据而不更改它。例如，如果您将在整个程序中使用相同的数据，您可以在初始化期间使用<em>gl.STATIC_DRAW</em>将其加载到缓冲区一次。WebGL可能会将数据存储在图形卡本身上，以便图形硬件可以最快速地访问。第二个值gl.STEAM_DRAW用于仅使用一次或最多几次的数据。（当需要时，它可以“流式传输”到卡上。）值<em>gl.DYNAMIC_DRAW</em>介于其他两个值之间；它适用于将多次使用但会修改的数据。</p>
<hr />
<p>将属性数据放入VBO只是故事的一部分。您还必须告诉WebGL将VBO用作属性的值源。首先，您需要知道属性在着色器程序中的位置。您可以使用<em>gl.getAttribLocation</em>来确定。例如，</p>
<div class="highlight"><pre><span></span><code><span class="nx">colorAttribLoc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getAttribLocation</span><span class="p">(</span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;a_color&quot;</span><span class="p">);</span>
</code></pre></div>
<p>这假设<em>prog</em>是着色器程序，“a_color”是顶点着色器中的属性变量的名称。这与<em>gl.getUniformLocation</em>完全类似（除了返回值是整数，如果请求的属性不存在或不活跃，则为-1）。</p>
<p>尽管属性通常在不同顶点处取不同的值，但有可能在每个顶点处使用相同的值。事实上，这是默认行为。可以通过<em>gl.vertexAttrib</em><em>系列函数为所有顶点设置单一属性值，它们的工作方式类似于</em>gl.uniform**。在更常见的情况下，您想要从VBO中获取属性的值，您必须启用该属性的VBO使用。这可以通过调用</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">enableVertexAttribArray</span><span class="p">(</span><span class="w"> </span><span class="nx">colorAttribLoc</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>来完成，参数是属性在着色器程序中的位置，由<em>gl.getAttribLocation()</em>调用返回。此命令与任何特定的VBO无关。它只是打开了指定属性的缓冲区使用。通常，在初始化期间只调用这个方法一次是合理的。可以通过调用</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">disableVertexAttribArray</span><span class="p">(</span><span class="w"> </span><span class="nx">colorAttribLoc</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>来关闭VBO数据的使用。最后，在您绘制使用VBO属性数据的原语之前，您必须告诉WebGL哪个缓冲区包含数据以及如何解释该缓冲区中的位。这可以通过<em>gl.vertexAttribPointer()</em>来完成。调用此函数时，VBO必须绑定到<em>ARRAY_BUFFER</em>目标。例如，</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">bindBuffer</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">colorBuffer</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">vertexAttribPointer</span><span class="p">(</span><span class="w"> </span><span class="nx">colorAttribLoc</span><span class="p">,</span><span class="w"> </span><span class="mf">3</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">FLOAT</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>假设<em>colorBuffer</em>指代VBO，而<em>colorAttribLoc</em>是属性的位置，这告诉WebGL从该缓冲区获取属性的值。通常，你会在调用<em>gl.vertexAttribPointer()</em>之前调用<em>gl.bindBuffer()</em>，但如果所需的缓冲区已经被绑定，那就不必了。</p>
<p><em>gl.vertexAttribPointer</em>的第一个参数是属性位置。第二个是每个顶点的值的数量。例如，如果你为<em>vec2</em>提供值，第二个参数将是2，你将为每个顶点提供两个数字；对于<em>vec3</em>，第二个参数将是3；对于<em>float</em>，它将是1。第三个参数指定了每个值的类型。在这里，<em>gl.FLOAT</em>表示每个值是一个32位浮点数。其他值包括<em>gl.BYTE</em>、<em>gl.UNSIGNED_BYTE</em>、<em>gl.UNSIGNED_SHORT</em>和<em>gl.SHORT</em>，用于整数值。请注意，在WebGL 1.0中，所有属性都是浮点值；如果你为属性提供整数值，它们将被转换为浮点数。参数值应与缓冲区中的数据类型相匹配。例如，如果数据来自<strong><em>Float32Array</em></strong>，那么参数应该是<em>gl.FLOAT</em>。在调用<em>gl.vertexAttribPointer</em>时，我总是会使用<em>false</em>、0和0作为最后三个参数。这些参数增加了我不需要的灵活性；如果你感兴趣，可以在文档中查找它们。（<em>false</em>参数与整数值如何转换为浮点值有关。）</p>
<p><strong>在WebGL 2.0</strong>中，属性变量可以是整型。当使用<em>gl.vertexAttribPointer()</em>配置属性时，为属性提供的值总是被转换为浮点数，所以它不适合整型属性。对于整型属性的使用，<abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0引入了一个新函数<em>gl.vertexAttribIPointer()</em>，它正确地处理整型数据。</p>
<p>这里有很多东西需要理解。使用VBO为属性提供值需要六个单独的命令，这是在生成数据并将其放入类型化数组之外的。这里是全部的命令集：</p>
<div class="highlight"><pre><span></span><code><span class="nx">colorAttribLoc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getAttribLocation</span><span class="p">(</span><span class="w"> </span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;a_color&quot;</span><span class="w"> </span><span class="p">);</span>
<span class="nx">colorBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">();</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">enableVertexAttribArray</span><span class="p">(</span><span class="w"> </span><span class="nx">colorAttribLoc</span><span class="w"> </span><span class="p">);</span>

<span class="nx">gl</span><span class="p">.</span><span class="nx">bindBuffer</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">colorBuffer</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">vertexAttribPointer</span><span class="p">(</span><span class="w"> </span><span class="nx">colorAttribLoc</span><span class="p">,</span><span class="w"> </span><span class="mf">3</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">FLOAT</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bufferData</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">colorArray</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">STATIC_DRAW</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>然而，这六个命令并不总是在JavaScript代码的同一点出现。前三个命令通常作为初始化的一部分完成。<em>gl.bufferData</em>将在需要更改属性数据时调用；它可能只在初始化期间使用一次，或者在需要修改数据时使用。<em>gl.bindBuffer</em>必须在调用<em>gl.vertexAttribPointer</em>或<em>gl.bufferData</em>之前调用，因为它建立了这两个命令使用的VBO。记住，所有这些都必须为着色器程序中使用的每个属性完成。</p>
</div>
<div class="tabbed-block">
<p>Turning now to <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr>, the situation is more complicated, because an <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> can take a different value for each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> in a primitive. The basic idea is that the complete set of data for the <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> is copied in a single operation from a <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> array into memory that is accessible to the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>. Unfortunately, setting things up to make that operation possible is nontrivial.</p>
<p>First of all, a regular <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> array is not suitable for this purpose. For efficiency, we need the data to be in a block of memory holding numerical values in successive memory locations, and regular <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> arrays don't have that form. To fix this problem, a new kind of array, called typed arrays, was introduced into <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr>. We encountered typed arrays when working with <abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr> in the <a href="../../c5/">Chapter 5</a>. There is a short introduction to typed arrays in <a href="../../c5/s1/#514-物体几何形状材料">Subsection 5.1.4</a>. A <abbr title="In JavaScript, an array type that is limited to holding numerical values of a single type. For example, the type Float32Array represents arrays that can hold 32-bit floating point values, and Uint8Array arrays can hold only 8-bit integer values. Such arrays are more efficient than general JavaScript arrays for numerical calculations. The were introduced into JavaScript along with HTML canvas graphics and WebGL.">typed array</abbr> has a fixed length, which is assigned when it is created, and it can only hold numbers of a specified type. There are different kinds of <abbr title="In JavaScript, an array type that is limited to holding numerical values of a single type. For example, the type Float32Array represents arrays that can hold 32-bit floating point values, and Uint8Array arrays can hold only 8-bit integer values. Such arrays are more efficient than general JavaScript arrays for numerical calculations. The were introduced into JavaScript along with HTML canvas graphics and WebGL.">typed array</abbr> for different kinds of numerical data. For now we will use <strong><em>Float32Array</em></strong>, which holds 32-bit floating point numbers. Once you have a <abbr title="In JavaScript, an array type that is limited to holding numerical values of a single type. For example, the type Float32Array represents arrays that can hold 32-bit floating point values, and Uint8Array arrays can hold only 8-bit integer values. Such arrays are more efficient than general JavaScript arrays for numerical calculations. The were introduced into JavaScript along with HTML canvas graphics and WebGL.">typed array</abbr>, you can use it much like a regular array, but when you assign any value to an element of a <strong><em>Float32Array</em></strong>, the value is converted into a 32-bit floating point number. If the value cannot be interpreted as a number, it will be converted to NaN, the "not-a-number" value.</p>
<p>Before data can be transferred from <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> into an <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> variable, it must be placed into a <abbr title="In JavaScript, an array type that is limited to holding numerical values of a single type. For example, the type Float32Array represents arrays that can hold 32-bit floating point values, and Uint8Array arrays can hold only 8-bit integer values. Such arrays are more efficient than general JavaScript arrays for numerical calculations. The were introduced into JavaScript along with HTML canvas graphics and WebGL.">typed array</abbr>. When possible, for efficiency, you should work with typed arrays directly, rather than working with regular <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> arrays and then copying the data into typed arrays.</p>
<hr />
<p>For use in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>, the <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> data must be transferred into a <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr> (<abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffer object). VBOs were introduced in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.5 and were discussed briefly in <a href="../../c3/s4/#344-显示列表和vbo">Subsection 3.4.4</a>. A <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr> is a block of memory that is accessible to the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>. To use a <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr>, you must first call the function <em>gl.createBuffer()</em> to create it. For example,</p>
<div class="highlight"><pre><span></span><code><span class="nx">colorBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">();</span>
</code></pre></div>
<p>Before transferring data into the <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr>, you must "bind" the <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr>:</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">bindBuffer</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">colorBuffer</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>The first parameter to <em>gl.bindBuffer</em> is called the "target." It specifies how the <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr> will be used. The target <em>gl.ARRAY_BUFFER</em> is used when the buffer is being used to store values for an <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>. Only one <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr> at a time can be bound to a given target.</p>
<p>The function that transfers data into a <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr> doesn't mention the <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr>—instead, it uses the <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr> that is currently bound. To copy data into that buffer, use <em>gl.bufferData()</em>. For example:</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">bufferData</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">colorArray</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">STATIC_DRAW</span><span class="p">);</span>
</code></pre></div>
<p>The first parameter is, again, the target. The data is transferred into the <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr> that is bound to that target. The second parameter is the <abbr title="In JavaScript, an array type that is limited to holding numerical values of a single type. For example, the type Float32Array represents arrays that can hold 32-bit floating point values, and Uint8Array arrays can hold only 8-bit integer values. Such arrays are more efficient than general JavaScript arrays for numerical calculations. The were introduced into JavaScript along with HTML canvas graphics and WebGL.">typed array</abbr> that holds the data on the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side. All the elements of the array are copied into the buffer, and the size of the array determines the size of the buffer. Note that this is a straightforward transfer of raw data bytes; <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> does not remember whether the data represents floats or ints or some other kind of data.</p>
<p>The third parameter to <em>gl.bufferData</em> is one of the constants <em>gl.STATIC_DRAW</em>, <em>gl.STREAM_DRAW</em>, or <em>gl.DYNAMIC_DRAW</em>. It is a hint to <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> about how the data will be used, and it helps <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> to manage the data in the most efficient way. The value <em>gl.STATIC_DRAW</em> means that you intend to use the data many times without changing it. For example, if you will use the same data throughout the program, you can load it into a buffer once, during initialization, using <em>gl.STATIC_DRAW</em>. <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> will probably store the data on the graphics card itself where it can be accessed most quickly by the graphics hardware. The second value, gl.STEAM_DRAW, is for data that will be used only once, or at most a few times. (It can be "streamed" to the card when it is needed.) The value <em>gl.DYNAMIC_DRAW</em> is somewhere between the other two values; it is meant for data that will be used multiple times, but with modifications.</p>
<hr />
<p>Getting <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> data into VBOs is only part of the story. You also have to tell <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> to use the <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr> as the source of values for the <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>. To do so, first of all, you need to know the location of the <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program. You can determine that using <em>gl.getAttribLocation</em>. For example,</p>
<div class="highlight"><pre><span></span><code><span class="nx">colorAttribLoc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getAttribLocation</span><span class="p">(</span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;a_color&quot;</span><span class="p">);</span>
</code></pre></div>
<p>This assumes that <em>prog</em> is the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program and "a_color" is the name of the <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> variable in the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>. This is entirely analogous to <em>gl.getUniformLocation</em> (except that the return value is an integer, and is -1 if the requested <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> does not exist or is not active).</p>
<p>Although an <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> usually takes different values at different vertices, it is possible to use the same value at every <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>. In fact, that is the default behavior. The single <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> value for all vertices can be set using the family of functions <em>gl.vertexAttrib*</em>, which work similarly to <em>gl.uniform*</em>. In the more usual case, where you want to take the values of an <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> from a <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr>, you must enable the use of a <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr> for that <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>. This is done by calling</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">enableVertexAttribArray</span><span class="p">(</span><span class="w"> </span><span class="nx">colorAttribLoc</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>where the parameter is the location of the <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program, as returned by a call to <em>gl.getAttribLocation()</em>. This command has nothing to do with any particular <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr>. It just turns on the use of buffers for the specified <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>. Often, it is reasonable to call this method just once, during initialization. Use of data from the <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr> can be turned off by calling</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">disableVertexAttribArray</span><span class="p">(</span><span class="w"> </span><span class="nx">colorAttribLoc</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>Finally, before you draw a primitive that uses the <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> data from a <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr>, you have to tell <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> which buffer contains the data and how the bits in that buffer are to be interpreted. This is done with <em>gl.vertexAttribPointer()</em>. The <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr> must be bound to the <em>ARRAY_BUFFER</em> target when this function is called. For example,</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">bindBuffer</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">colorBuffer</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">vertexAttribPointer</span><span class="p">(</span><span class="w"> </span><span class="nx">colorAttribLoc</span><span class="p">,</span><span class="w"> </span><span class="mf">3</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">FLOAT</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>Assuming that <em>colorBuffer</em> refers to the <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr> and <em>colorAttribLoc</em> is the location of the <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>, this tells <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> to take values for the <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> from that buffer. Often, you will call <em>gl.bindBuffer()</em> just before calling <em>gl.vertexAttribPointer()</em>, but that is not necessary if the desired buffer is already bound.</p>
<p>The first parameter to <em>gl.vertexAttribPointer</em> is the <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> location. The second is the number of values per <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>. For example, if you are providing values for a <em>vec2</em>, the second parameter will be 2 and you will provide two numbers per <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>; for a <em>vec3</em>, the second parameter would be 3; for a <em>float</em>, it would be 1. The third parameter specifies the type of each value. Here, <em>gl.FLOAT</em> indicates that each value is a 32-bit floating point number. Other values include <em>gl.BYTE</em>, <em>gl.UNSIGNED_BYTE</em>, <em>gl.UNSIGNED_SHORT</em>, and <em>gl.SHORT</em> for integer values. Note that in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0, all <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr> are floating point values; if you provide integer values for an <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>, they will be converted to floating point. The parameter value should match the data type in the buffer. For example, if the data came from a <strong><em>Float32Array</em></strong>, then the parameter should be <em>gl.FLOAT</em>. For the last three parameters in a call to <em>gl.vertexAttribPointer</em>, I will always use <em>false</em>, 0, and 0. These parameters add flexibility that I won't need; you can look them up in the documentation if you are interested. (The <em>false</em> parameter has to do with how integer values are converted into floating point values.)</p>
<p><strong>In <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0</strong>, <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> variables can have integer type. When <em>gl.vertexAttribPointer()</em> is used to configure an <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>, the values provided for the <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> will always be converted to floating point, so it is inappropriate for integer-valued <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr>. For use with integer-valued <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr>, <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 introduces a new function, <em>gl.vertexAttribIPointer()</em> that works correctly with integer data.</p>
<p>There is a lot to take in here. Using a <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr> to provide values for an <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> requires six separate commands, and that is in addition to generating the data and placing it in a <abbr title="In JavaScript, an array type that is limited to holding numerical values of a single type. For example, the type Float32Array represents arrays that can hold 32-bit floating point values, and Uint8Array arrays can hold only 8-bit integer values. Such arrays are more efficient than general JavaScript arrays for numerical calculations. The were introduced into JavaScript along with HTML canvas graphics and WebGL.">typed array</abbr>. Here is the full set of commands:</p>
<div class="highlight"><pre><span></span><code><span class="nx">colorAttribLoc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getAttribLocation</span><span class="p">(</span><span class="w"> </span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;a_color&quot;</span><span class="w"> </span><span class="p">);</span>
<span class="nx">colorBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">();</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">enableVertexAttribArray</span><span class="p">(</span><span class="w"> </span><span class="nx">colorAttribLoc</span><span class="w"> </span><span class="p">);</span>

<span class="nx">gl</span><span class="p">.</span><span class="nx">bindBuffer</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">colorBuffer</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">vertexAttribPointer</span><span class="p">(</span><span class="w"> </span><span class="nx">colorAttribLoc</span><span class="p">,</span><span class="w"> </span><span class="mf">3</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">FLOAT</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bufferData</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">colorArray</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">STATIC_DRAW</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>However, the six commands will not always occur at the same point in the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> code. The first three commands are often done as part of initialization. <em>gl.bufferData</em> would be called whenever the data for the <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> needs to be changed; it might be used just once during initialization, or it might be used whenever the data needs to be modified. <em>gl.bindBuffer</em> must be called before <em>gl.vertexAttribPointer</em> or <em>gl.bufferData</em>, since it establishes the <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr> that is used by those two commands. Remember that all of this must be done for every <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> that is used in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program.</p>
</div>
</div>
</div>
<h2 id="616-绘制基元">6.1.6 绘制基元<a class="headerlink" href="#616-绘制基元" title="Permanent link">&para;</a></h2>
<p><strong>Drawing a Primitive</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="7:2"><input checked="checked" id="__tabbed_7_1" name="__tabbed_7" type="radio" /><input id="__tabbed_7_2" name="__tabbed_7" type="radio" /><div class="tabbed-labels"><label for="__tabbed_7_1">中文</label><label for="__tabbed_7_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>在着色器程序被创建并且为统一变量和属性设置了值之后，绘制一个原语只需要再一个命令。一种方法是使用函数<em>gl.drawArrays</em>：</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">drawArrays</span><span class="p">(</span><span class="nx">primitiveType</span><span class="p">,</span><span class="w"> </span><span class="nx">startVertex</span><span class="p">,</span><span class="w"> </span><span class="nx">vertexCount</span><span class="p">);</span>
</code></pre></div>
<p>第一个参数是七个常量之一，用于标识WebGL原语类型，例如<em>gl.TRIANGLES</em>、<em>gl.LINE_LOOP</em>和<em>gl_POINTS</em>。第二个和第三个参数是整数，用于确定用于原语的顶点的子集。在调用<em>gl.drawArrays</em>之前，你会将一些顶点的属性值放入一个或多个VBO中。当原语被渲染时，启用的属性的属性值会从VBO中获取。<em>startVertex</em>是在VBO中数据的起始顶点号，<em>vertexCount</em>是原语中的顶点数。通常，<em>startVertex</em>是零，<em>vertexCount</em>是可用数据的顶点总数。例如，绘制一个单独三角形的命令可能是：</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">drawArrays</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TRIANGLES</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">3</span><span class="p">);</span>
</code></pre></div>
<p><em>gl.drawArrays</em>和<em>gl.ARRAY_BUFFER</em>中“array”这个词可能有点令人困惑，因为数据存储在顶点缓冲对象中，而不是JavaScript数组中。当<em>glDrawArrays</em>最初在OpenGL 1.1中引入时，它使用的是普通数组，而不是VBO。从OpenGL 1.5开始，<em>glDrawArrays</em>可以与普通数组或VBO一起使用。在WebGL中，放弃了对普通数组的支持，<em>gl.drawArrays</em>只能与VBO一起工作，即使名称仍然提到数组。</p>
<p>我们在<a href="../../c3/s4/#342-gldrawarrays和gldrawelements">3.4.2小节</a>中遇到了<em>glDrawArrays</em>的原始版本。该部分还介绍了用于绘制原语的另一种函数<em>glDrawElements</em>，它可以用于绘制索引面集。在WebGL中也可用<em>gl.drawElements</em>函数。使用<em>gl.drawElements</em>时，属性数据不是按照在VBO中的顺序使用的。相反，有一个单独的索引列表，确定访问数据的顺序。</p>
<p>要使用<em>gl.drawElements</em>，需要一个额外的VBO来保存索引列表。当用于此目的时，VBO必须绑定到目标<em>gl.ELEMENT_ARRAY_BUFFER</em>而不是<em>gl.ARRAY_BUFFER</em>。VBO将保存整数值，可以是<em>gl.UNSIGNED_BYTE</em>或<em>gl.UNSIGNED_SHORT</em>类型（或者对于WebGL 2.0，是<em>gl.UNSIGNED_INT</em>）。值可以从JavaScript类型化数组加载，对于<em>gl.UNSIGNED_BYTE</em>使用<strong><em>Uint8Array</em></strong>，对于<em>gl.UNSIGNED_SHORT</em>使用<strong><em>Uint16Array</em></strong>。创建VBO并用数据填充它是一个多步骤过程。例如：</p>
<div class="highlight"><pre><span></span><code><span class="nx">elementBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">();</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bindBuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ELEMENT_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">elementBuffer</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Uint8Array</span><span class="p">([</span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">3</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">3</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">4</span><span class="p">,</span><span class="w"> </span><span class="mf">3</span><span class="p">]);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bufferData</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ELEMENT_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">STREAM_DRAW</span><span class="p">);</span>
</code></pre></div>
<p>假设属性数据也已经加载到VBO中，然后可以使用<em>gl.drawElements</em>来绘制原语。调用<em>gl.drawElements</em>的形式是</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">drawElements</span><span class="p">(</span><span class="nx">primitiveType</span><span class="p">,</span><span class="w"> </span><span class="nx">count</span><span class="p">,</span><span class="w"> </span><span class="nx">dataType</span><span class="p">,</span><span class="w"> </span><span class="nx">startByte</span><span class="p">);</span>
</code></pre></div>
<p>当调用这个函数时，包含顶点索引的VBO必须绑定到<em>ELEMENT_ARRAY_BUFFER</em>目标。<em>gl.drawElements</em>的第一个参数是原语类型，如<em>gl.TRIANGLE_FAN</em>。计数是原语中的顶点数。<em>dataType</em>指定了加载到VBO中的数据类型；它将是<em>gl.UNSIGNED_SHORT</em>或<em>gl.UNSIGNED_BYTE</em>。<em>startByte</em>是VBO中原语数据的起始点；它通常是零。（注意，起始点以字节为单位给出，而不是顶点号。）一个典型的例子是</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">drawElements</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TRIANGLES</span><span class="p">,</span><span class="w"> </span><span class="mf">9</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">UNSIGNED_BYTE</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">);</span>
</code></pre></div>
<p>我们将在后面的场合使用这个函数。如果你发现它令人困惑，你应该回顾<a href="../../c3/s4/#342-gldrawarrays和gldrawelements">3.4.2小节</a>。WebGL中的情况与OpenGL 1.1中的情况非常相似。</p>
</div>
<div class="tabbed-block">
<p>After the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program has been created and values have been set up for the uniform variables and <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr>, it takes just one more command to draw a primitive. One way to do that is with the function <em>gl.drawArrays</em>:</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">drawArrays</span><span class="p">(</span><span class="w"> </span><span class="nx">primitiveType</span><span class="p">,</span><span class="w"> </span><span class="nx">startVertex</span><span class="p">,</span><span class="w"> </span><span class="nx">vertexCount</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>The first parameter is one of the seven constants that identify <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> primitive types, such as <em>gl.TRIANGLES</em>, <em>gl.LINE_LOOP</em>, and <em>gl_POINTS</em>. The second and third parameters are integers that determine which subset of available vertices is used for the primitive. Before calling <em>gl.drawArrays</em>, you will have placed <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> values for some number of vertices into one or more VBOs. When the primitive is rendered, the <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> values for enabled <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr> are pulled from the VBOs. The <em>startVertex</em> is the starting <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> number of the data within the VBOs, and <em>vertexCount</em> is the number of vertices in the primitive. Often, <em>startVertex</em> is zero, and <em>vertexCount</em> is the total number of vertices for which data is available. For example, the command for drawing a single triangle might be</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">drawArrays</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TRIANGLES</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">3</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>The use of the word "array" in <em>gl.drawArrays</em> and <em>gl.ARRAY_BUFFER</em> might be a little confusing, since the data is stored in <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffer objects rather than in <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> arrays. When <em>glDrawArrays</em> was first introduced in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1, it used ordinary arrays rather than VBOs. Starting with <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.5, <em>glDrawArrays</em> could be used either with ordinary arrays or VBOs. In <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>, support for ordinary arrays was dropped, and <em>gl.drawArrays</em> can only work with VBOs, even though the name still refers to arrays.</p>
<p>We encountered the original version of <em>glDrawArrays</em> in <a href="../../c3/s4/#342-gldrawarrays和gldrawelements">Subsection 3.4.2</a>. That section also introduced an alternative function for drawing primitives, <em>glDrawElements</em>, which can be used for drawing indexed face sets. A <em>gl.drawElements</em> function is also available in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>. With <em>gl.drawElements</em>, <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> data is not used in the order in which it occurs in the VBOs. Instead, there is a separate list of indices that determines the order in which the data is accessed.</p>
<p>To use <em>gl.drawElements</em>, an extra <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr> is required to hold the list of indices. When used for this purpose, the <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr> must be bound to the target <em>gl.ELEMENT_ARRAY_BUFFER</em> rather than <em>gl.ARRAY_BUFFER</em>. The <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr> will hold integer values, which can be of type <em>gl.UNSIGNED_BYTE</em> or <em>gl.UNSIGNED_SHORT</em> (or, for <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0, <em>gl.UNSIGNED_INT</em>). The values can be loaded from a <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> <abbr title="In JavaScript, an array type that is limited to holding numerical values of a single type. For example, the type Float32Array represents arrays that can hold 32-bit floating point values, and Uint8Array arrays can hold only 8-bit integer values. Such arrays are more efficient than general JavaScript arrays for numerical calculations. The were introduced into JavaScript along with HTML canvas graphics and WebGL.">typed array</abbr> of type <strong><em>Uint8Array</em></strong>, for <em>gl.UNSIGNED_BYTE</em>, or <strong><em>Uint16Array</em></strong>, for <em>gl.UNSIGNED_SHORT</em>. Creating the <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr> and filling it with data is again a multistep process. For example,</p>
<div class="highlight"><pre><span></span><code><span class="nx">elementBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">();</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bindBuffer</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">ELEMENT_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">elementBuffer</span><span class="w"> </span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Uint8Array</span><span class="p">(</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="mf">2</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">3</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">3</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="mf">4</span><span class="p">,</span><span class="mf">3</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bufferData</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">ELEMENT_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">STREAM_DRAW</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>Assuming that the <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> data has also been loaded into VBOs, <em>gl.drawElements</em> can then be used to draw the primitive. A call to <em>gl.drawElements</em> takes the form</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">drawElements</span><span class="p">(</span><span class="w"> </span><span class="nx">primitiveType</span><span class="p">,</span><span class="w"> </span><span class="nx">count</span><span class="p">,</span><span class="w"> </span><span class="nx">dataType</span><span class="p">,</span><span class="w"> </span><span class="nx">startByte</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>The <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr> that contains the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> indices must be bound to the <em>ELEMENT_ARRAY_BUFFER</em> target when this function is called. The first parameter to <em>gl.drawElements</em> is a primitive type such as <em>gl.TRIANGLE_FAN</em>. The count is the number of vertices in the primitive. The <em>dataType</em> specifies the type of data that was loaded into the <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr>; it will be either <em>gl.UNSIGNED_SHORT</em> or <em>gl.UNSIGNED_BYTE</em>. The <em>startByte</em> is the starting point in the <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr> of the data for the primitive; it is usually zero. (Note that the starting point is given in terms of bytes, not <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> numbers.) A typical example would be</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">drawElements</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TRIANGLES</span><span class="p">,</span><span class="w"> </span><span class="mf">9</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">UNSIGNED_BYTE</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>We will have occasion to use this function later. If you find it confusing, you should review <a href="../../c3/s4/#342-gldrawarrays和gldrawelements">Subsection 3.4.2</a>. The situation is much the same in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> as it was in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1.</p>
</div>
</div>
</div>
<h2 id="617-webgl-20顶点数组对象">6.1.7 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0：<abbr title="在WebGL 2.0中，顶点数组对象（VAO）是通常位于显卡上的一块内存区域，它保存了一系列属性设置，如启用状态和顶点属性指针的值。然后，所有设置都可以通过绑定VAO来选择。">顶点数组对象</abbr><a class="headerlink" href="#617-webgl-20顶点数组对象" title="Permanent link">&para;</a></h2>
<p><strong><abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0: Vertex Array Objects</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="8:2"><input checked="checked" id="__tabbed_8_1" name="__tabbed_8" type="radio" /><input id="__tabbed_8_2" name="__tabbed_8" type="radio" /><div class="tabbed-labels"><label for="__tabbed_8_1">中文</label><label for="__tabbed_8_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>与属性一起工作的大量函数可能看起来有些过分。在绘制几个不同对象的程序中，情况更糟。每个对象可能需要自己的缓冲区和自己的属性指针设置。在绘制每个对象之前，都需要为每个属性调用<em>gl.bindBuffer()</em>和<em>gl.vertexAttribPointer()</em>。一个典型的3D图形程序会使用属性来表示顶点坐标、<abbr title="表面上某点的法向量是与该点表面垂直的向量。曲线的法向量定义类似。法向量对照明计算很重要。">法向量</abbr>、材质属性和纹理坐标。所以，每个对象都会有大量的函数调用。</p>
<p>为了解决这个问题，<abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0引入了<strong><abbr title="在WebGL 2.0中，顶点数组对象（VAO）是通常位于显卡上的一块内存区域，它保存了一系列属性设置，如启用状态和顶点属性指针的值。然后，所有设置都可以通过绑定VAO来选择。">顶点数组对象</abbr></strong>（VAOs）。VAO是一块内存区域，通常存储在显卡上。它保存了由渲染函数（如<em>gl.drawArrays()</em>）使用的设置。这包括每个属性的启用状态、用于属性数据的缓冲区引用，以及通过调用<em>gl.vertexAttribPointer()</em>设置的所有属性的值。它还包括设置和对由<em>gl.drawElements()</em>使用的缓冲区的引用，以及下一节中讨论的属性除数。</p>
<p><abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0有一个默认的VAO，当没有选择其他VAO时，它将使用这个默认VAO。要使用替代VAO，首先需要通过调用<em>gl.createVertexArray()</em>来创建它：</p>
<div class="highlight"><pre><span></span><code><span class="nx">vao</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createVertexArray</span><span class="p">();</span>
</code></pre></div>
<p>返回值<em>vao</em>是已创建VAO的标识符。在新的VAO中，所有属性都具有默认值。特别是，所有顶点属性都被禁用，并且没有关联的缓冲区。要实际使用VAO，需要绑定它：</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">bindVertexArray</span><span class="p">(</span><span class="nx">vao</span><span class="p">);</span>
</code></pre></div>
<p>影响或使用属性的函数适用于当前绑定的VAO。例如，在调用<em>gl.vertexAttribPointer()</em>时的设置存储在当前VAO中。调用<em>gl.drawArrays()</em>时，它需要绘制原语的所有数据都来自当前VAO。程序可以随时通过调用<em>gl.bindVertexArray</em>从一个VAO切换到另一个VAO。要回到使用默认VAO，程序可以调用<em>gl.bindVertexArray(0)</em>。</p>
<p>这个想法是，绘制几个对象的程序可以使用每个对象的不同VAO。对象的VAO必须在配置对象的设置时绑定。但在绘制对象之前，程序只需要绑定该对象的VAO。这个单一的函数调用可以替代可能需要恢复每个属性的适当设置的大量函数调用。优势不仅仅是更整洁的程序组织——也更有效率，因为只需要发送一个命令到GPU来配置所有属性。</p>
<p>示例WebGL 2.0程序<a href="../../../en/source/webgl/VAO-test-webgl2.html">webgl/<abbr title="Vertex Array Object. In WebGL 2.0, a region of memory, typically on the graphics card, that holds a collection of attribute settings such as enabled state and values of vertex attribute pointers. All of the settings can then be selected simply by binding the VAO.">VAO</abbr>-test-webgl2.html</a>为六个不同的对象使用不同的VAO。该程序使用了许多我们尚未涵盖的技术，但你可以查看<em>drawModel()</em>函数，看看它如何使用VAOs和VBOs。</p>
</div>
<div class="tabbed-block">
<p>The large number of functions needed to work with <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr> can seem excessive. The situation is worse in a program that draws several different objects. Each object can require its own buffers and its own settings for <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> pointers. Before drawing each object, it would be necessary to call <em>gl.bindBuffer()</em> and <em>gl.vertexAttribPointer()</em> for each <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>. A typical 3D graphics program would use <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr> for <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> coordinates, normal vectors, <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> properties, and <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates. So, there would be a lot of function calls for each object.</p>
<p>To help with this situation, <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 introduced <strong>Vertex Array Objects</strong> (VAOs). A <abbr title="Vertex Array Object. In WebGL 2.0, a region of memory, typically on the graphics card, that holds a collection of attribute settings such as enabled state and values of vertex attribute pointers. All of the settings can then be selected simply by binding the VAO.">VAO</abbr> is a section of memory, typically stored on the graphics card. It holds settings that are used by <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> functions such as <em>gl.drawArrays()</em>. This includes the enabled state of each <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>, references to the buffers used for the <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> data, and the values of all properties that are set by calling <em>gl.vertexAttribPointer()</em>. It also includes the settings and a reference to the buffer used by <em>gl.drawElements()</em>, as well as the <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> divisors that are discussed in the next subsection.</p>
<p><abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 has a default <abbr title="Vertex Array Object. In WebGL 2.0, a region of memory, typically on the graphics card, that holds a collection of attribute settings such as enabled state and values of vertex attribute pointers. All of the settings can then be selected simply by binding the VAO.">VAO</abbr>, which it uses when no other <abbr title="Vertex Array Object. In WebGL 2.0, a region of memory, typically on the graphics card, that holds a collection of attribute settings such as enabled state and values of vertex attribute pointers. All of the settings can then be selected simply by binding the VAO.">VAO</abbr> has been selected. To use an alternative <abbr title="Vertex Array Object. In WebGL 2.0, a region of memory, typically on the graphics card, that holds a collection of attribute settings such as enabled state and values of vertex attribute pointers. All of the settings can then be selected simply by binding the VAO.">VAO</abbr>, you first have to create it, by calling <em>gl.createVertexArray()</em>:</p>
<div class="highlight"><pre><span></span><code><span class="nx">vao</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createVertexArray</span><span class="p">();</span>
</code></pre></div>
<p>The return value, <em>vao</em>, is an identifier for the <abbr title="Vertex Array Object. In WebGL 2.0, a region of memory, typically on the graphics card, that holds a collection of attribute settings such as enabled state and values of vertex attribute pointers. All of the settings can then be selected simply by binding the VAO.">VAO</abbr> that has been created. In the new <abbr title="Vertex Array Object. In WebGL 2.0, a region of memory, typically on the graphics card, that holds a collection of attribute settings such as enabled state and values of vertex attribute pointers. All of the settings can then be selected simply by binding the VAO.">VAO</abbr>, all properties have their default values. In particular, all <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr> are disabled and have no associated buffers. To actually use a <abbr title="Vertex Array Object. In WebGL 2.0, a region of memory, typically on the graphics card, that holds a collection of attribute settings such as enabled state and values of vertex attribute pointers. All of the settings can then be selected simply by binding the VAO.">VAO</abbr>, you need to bind it:</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">bindVertexArray</span><span class="p">(</span><span class="nx">vao</span><span class="p">);</span>
</code></pre></div>
<p>Functions that affect or use <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr> apply to the <abbr title="Vertex Array Object. In WebGL 2.0, a region of memory, typically on the graphics card, that holds a collection of attribute settings such as enabled state and values of vertex attribute pointers. All of the settings can then be selected simply by binding the VAO.">VAO</abbr> that is currently bound. For example, the settings in a call to <em>gl.vertexAttribPointer()</em> are stored in the current <abbr title="Vertex Array Object. In WebGL 2.0, a region of memory, typically on the graphics card, that holds a collection of attribute settings such as enabled state and values of vertex attribute pointers. All of the settings can then be selected simply by binding the VAO.">VAO</abbr>. And a call to <em>gl.drawArrays()</em> gets all the data that it needs to draw a primitive from the current <abbr title="Vertex Array Object. In WebGL 2.0, a region of memory, typically on the graphics card, that holds a collection of attribute settings such as enabled state and values of vertex attribute pointers. All of the settings can then be selected simply by binding the VAO.">VAO</abbr>. A program can switch from one <abbr title="Vertex Array Object. In WebGL 2.0, a region of memory, typically on the graphics card, that holds a collection of attribute settings such as enabled state and values of vertex attribute pointers. All of the settings can then be selected simply by binding the VAO.">VAO</abbr> to another at any time simply by calling <em>gl.bindVertexArray</em>. To go back to using the default <abbr title="Vertex Array Object. In WebGL 2.0, a region of memory, typically on the graphics card, that holds a collection of attribute settings such as enabled state and values of vertex attribute pointers. All of the settings can then be selected simply by binding the VAO.">VAO</abbr>, a program can call <em>gl.bindVertexArray(0)</em>.</p>
<p>The idea is that a program that draws several objects can use a different <abbr title="Vertex Array Object. In WebGL 2.0, a region of memory, typically on the graphics card, that holds a collection of attribute settings such as enabled state and values of vertex attribute pointers. All of the settings can then be selected simply by binding the VAO.">VAO</abbr> for each object. The <abbr title="Vertex Array Object. In WebGL 2.0, a region of memory, typically on the graphics card, that holds a collection of attribute settings such as enabled state and values of vertex attribute pointers. All of the settings can then be selected simply by binding the VAO.">VAO</abbr> for an object must be bound when the settings for the object are configured. But before drawing the object, the program simply needs to bind the <abbr title="Vertex Array Object. In WebGL 2.0, a region of memory, typically on the graphics card, that holds a collection of attribute settings such as enabled state and values of vertex attribute pointers. All of the settings can then be selected simply by binding the VAO.">VAO</abbr> for that object. That single function call replaces a potentially a large number of function calls that would be needed to restore the appropriate settings for each <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> individually. The advantage is more than just a more nicely organized program—it is also much more efficient, since only one command needs to be sent to the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> to configure all of the <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr>.</p>
<p>The sample <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 program <a href="../../../en/source/webgl/VAO-test-webgl2.html">webgl/<abbr title="Vertex Array Object. In WebGL 2.0, a region of memory, typically on the graphics card, that holds a collection of attribute settings such as enabled state and values of vertex attribute pointers. All of the settings can then be selected simply by binding the VAO.">VAO</abbr>-test-webgl2.html</a> uses a different <abbr title="Vertex Array Object. In WebGL 2.0, a region of memory, typically on the graphics card, that holds a collection of attribute settings such as enabled state and values of vertex attribute pointers. All of the settings can then be selected simply by binding the VAO.">VAO</abbr> for each of six different objects. That program uses many techniques that we have not yet covered, but you can look at the <em>drawModel()</em> function to see how it uses VAOs and VBOs.</p>
</div>
</div>
</div>
<h2 id="618-webgl-20实例化绘图">6.1.8 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0：实例化绘图<a class="headerlink" href="#618-webgl-20实例化绘图" title="Permanent link">&para;</a></h2>
<p><strong><abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0: Instanced Drawing</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="9:2"><input checked="checked" id="__tabbed_9_1" name="__tabbed_9" type="radio" /><input id="__tabbed_9_2" name="__tabbed_9" type="radio" /><div class="tabbed-labels"><label for="__tabbed_9_1">中文</label><label for="__tabbed_9_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>在一个场景中，通常包含使用相同顶点坐标的同一原语的多个副本，但每个副本具有不同的变换、颜色或其他属性。<abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0使得只需一个函数调用即可绘制所有这些副本。这称为<strong><abbr title="用单个函数调用来渲染多个版本的原语的能力。每个副本可以有自己的某些属性值，如颜色或变换。">实例化绘制</abbr></strong>或实例化，原语的个别副本称为实例。使用实例化绘制的函数是<em>gl.drawArraysInstanced()</em>和<em>gl.drawElementsInstanced()</em>。</p>
<p>实例化属性——从一个实例到另一个实例变化的属性——当分别绘制每个实例时，很可能是统一变量。也就是说，每个实例都有一个适用于实例中所有顶点的属性值。尽管如此，属性在着色器程序中由属性变量表示，而不是统一变量，并且它们被配置为属性。</p>
<p>要指定一个属性是实例化属性，只需要为该属性指定一个“除数”。这是通过调用<em>gl.vertexAttribDivisor</em>完成的：</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">vertexAttribDivisor</span><span class="p">(</span><span class="nx">attribID</span><span class="p">,</span><span class="w"> </span><span class="nx">divisor</span><span class="p">);</span>
</code></pre></div>
<p>这里，<em>attribID</em>是由<em>gl.getAttribLocation()</em>返回的属性标识符。除数是一个非负整数。将除数传递为零将关闭该属性的实例化。如果<em>divisor</em>是正数，那么属性的每个值将适用于那么多实例。例如，如果<em>divisor</em>是3，那么属性值数组中的第一个条目适用于第一、第二和第三个实例；数组中的第二个值适用于第四、第五和第六个实例；以此类推。实际上，除数的值通常是1，这意味着每个实例在属性值数组中都有自己的条目。</p>
<p>对于实例化属性，除了设置除数之外，还需要启用属性，将数据加载到VBO中，并使用gl.vertexAttribPointer进行配置。当然，还需要使用<em>gl.drawArraysInstanced()</em>或<em>gl.drawElementsInstanced()</em>绘制原语，而不是使用<em>gl.drawArrays()</em>或<em>gl.drawElements()</em>。</p>
<p>示例WebGL 2.0程序<a href="../../../en/source/webgl/instancing-test-webgl2.html">webgl/instancing-test-webgl2.html</a>是实例化绘制的一个例子。（再说一次，程序中有很多内容在我们覆盖更多WebGL之前你是不会理解的）。该程序绘制了30个彩色圆盘，其中圆盘由<em>gl.TRIANGLE_FAN</em>类型的原语近似。使用了三个属性：一个属性保存顶点的坐标，一个实例化属性保存圆盘的颜色，另一个实例化属性保存每个圆盘的不同平移。</p>
<p>程序中另一个有趣的点是它对顶点缓冲对象的使用。圆盘可以被动画化。圆盘在移动，但它们的颜色不会改变。由于颜色不会改变，圆盘的颜色值在程序初始化期间一次性加载到VBO中。<em>gl.bufferData</em>中的使用参数设置为<em>gl.STATIC_DRAW</em>，因为数据不会被修改。然而，由于圆盘在移动，圆盘的平移值必须在每一帧中更改。所以，每一帧都会将新数据加载到相应的VBO中，使用<em>gl.STREAM_DRAW</em>，因为正在加载的数据只会使用一次。</p>
<p>最后，我应该注意，VAO和实例化需要WebGL 2.0，但许多WebGL 1.0的实现中也提供了相同的功能作为可选扩展。WebGL扩展将在<a href="../../c7/s5/">第7.5节</a>中讨论。</p>
</div>
<div class="tabbed-block">
<p>It's common for a scene to contain multiple copies of the same primitive (that is, using the same <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> coordinates), but with different transformations, colors, or other properties for each copy. <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 makes it possible to draw all those copies with a single function call. This is called <strong><abbr title="The ability to render multiple versions of a primitive with a single function call. Each copy can have its own values for certain attributes, such as color or transformation.">instanced drawing</abbr></strong> or instancing, and the individual copies of the primitive are called instances. The functions that use <abbr title="The ability to render multiple versions of a primitive with a single function call. Each copy can have its own values for certain attributes, such as color or transformation.">instanced drawing</abbr> are <em>gl.drawArraysInstanced()</em> and <em>gl.drawElementsInstanced()</em>.</p>
<p>Instanced properties—the properties that vary from one instance to another—are things that would likely be uniform variables when drawing each instance separately. That is, each instance gets just one value of the property that applies to all the vertices of the instance. Nevertheless, the properties are represented by <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> variables in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program, not uniform variables, and they are configured as <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr>.</p>
<p>To specify that an <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> is an instanced property, you just need to specify a "divisor" for that <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>. This is done by calling <em>gl.vertexAttribDivisor</em>:</p>
<div class="highlight"><pre><span></span><code><span class="nx">g</span><span class="p">.</span><span class="nx">vertexAttribDivisor</span><span class="p">(</span><span class="w"> </span><span class="nx">attribID</span><span class="p">,</span><span class="w"> </span><span class="nx">divisor</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>Here, <em>attribID</em> is the identifier for the <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>, as returned by <em>gl.getAttribLocation()</em>. The divisor is a non-negative integer. Passing zero as the divisor will turn off instancing for the <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>. If <em>divisor</em> is positive, then each value of the <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> will apply to that many instances. For example, if <em>divisor</em> is 3, then the first entry in the <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> value array applies to the first, second, and third instances; the second value in the array applies to the fourth, fifth, and sixth instances; and so on. In practice, the value of <em>divisor</em> is usually one, meaning that each instance has its own entry in the <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> value array.</p>
<p>For an instanced property, in addition to setting the divisor, it is still necessary to enable the <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>, load data for it into a <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr>, and configure it with gl.vertexAttribPointer. And, of course, it is necessary to draw the primitive using <em>gl.drawArraysInstanced()</em> or <em>gl.drawElementsInstanced()</em>, and not with <em>gl.drawArrays()</em> or <em>gl.drawElements()</em>.</p>
<p>The sample <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 program <a href="../../../en/source/webgl/instancing-test-webgl2.html">webgl/instancing-test-webgl2.html</a> is an example of <abbr title="The ability to render multiple versions of a primitive with a single function call. Each copy can have its own values for certain attributes, such as color or transformation.">instanced drawing</abbr>. (Again, there is a lot in the program that you won't understand until we have covered more of <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>). The program draws 30 colored disks, where a disk is approximated by a primitive of type <em>gl.TRIANGLE_FAN</em>. Three <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr> are used: an <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> that holds the coordinates of the vertices, an instanced <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> that holds the colors for the disks, and an instanced <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> that holds a different <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr> for each disk.</p>
<p>Another point of interest in the program is its used of <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffer objects. The disks can be animated. The disks move, but their colors don't change. Since the colors don't change, the color values for the disks are loaded into a <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr> once, during program initialization. The usage parameter in <em>gl.bufferData</em> is set to <em>gl.STATIC_DRAW</em> because the data will not be modified. However, because the disks are moving, the values for the translations of the disks have to change in each frame. So, new data is loaded into the corresponding <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr> for each frame, with usage <em>gl.STREAM_DRAW</em> because the data that is being loaded will only be used once.</p>
<p>Finally, I should note that VAOs and instancing require <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0, but the same functionality is available in many implementations of <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 as optional extensions. Webgl extensions will be discussed in <a href="../../c7/s5/">Section 7.5</a>.</p>
</div>
</div>
</div>
<p>*[纹理单元]：GPU中的一个硬件组件，用于进行纹理查找。（也可以指代这样一个组件的抽象，无论它是否实际在硬件中实现。）也就是说，它将纹理坐标映射到图像纹理的颜色上。这个操作被称为“采样”，纹理单元与GLSL着色器程序中的采样器变量相关联。</p>
<p>*[<abbr title="Texture Mapping Unit, another name for texture unit (perhaps with a stronger implication of actual hardware support). Also called a TPU (Texture Processing Unit).">TMU</abbr>]：纹理映射单元，纹理单元的另一个名称（可能更强调实际的硬件支持）。也称为TPU（纹理处理单元）。</p>
<p>*[采样]：将纹理坐标映射到纹理的颜色上的操作，包括如果可用则使用mipmap，并且在必要时应用缩放或放大滤波器。</p>
<p>*[采样器变量]：在GLSL中，着色器程序中的一个变量，可以用来在图像纹理中进行查找。采样器变量的值指定了将用于进行查找的纹理单元。在WebGL中，采样器变量的类型为“sampler2D”或“samplerCube”。</p>
<p>*[<abbr title="A new JavaScript graphics API, similar to WebGL, but designed to let web programs access modern GPU capabilities such as compute shaders.">WebGPU</abbr>]：一种新的JavaScript图形API，类似于WebGL，但设计上允许Web程序访问现代GPU功能，如计算着色器。</p>







  
    
  
  
    
  


  <aside class="md-source-file">
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="最后更新">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1-2.1-2M12.5 7v5.2l4 2.4-1 1L11 13V7h1.5M11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2v1.8Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">2024年6月13日</span>
  </span>

    
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="创建日期">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.47 15.08 11 13V7h1.5v5.25l3.08 1.83c-.41.28-.79.62-1.11 1m-1.39 4.84c-.36.05-.71.08-1.08.08-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8c0 .37-.03.72-.08 1.08.69.1 1.33.32 1.92.64.1-.56.16-1.13.16-1.72 0-5.5-4.5-10-10-10S2 6.5 2 12s4.47 10 10 10c.59 0 1.16-.06 1.72-.16-.32-.59-.54-1.23-.64-1.92M18 15v3h-3v2h3v3h2v-3h3v-2h-3v-3h-2Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">2024年5月26日</span>
  </span>

    
    
    
  </aside>





                
              </article>
            </div>
          
          
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var tab,labels=set.querySelector(".tabbed-labels");for(tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script>

<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../../..", "features": ["content.code.copy", "content.tabs.link", "navigation.tabs", "navigation.tabs.sticky", "navigation.indexes", "navigation.top", "toc.follow", "content.tooltips"], "search": "../../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.3220b9d7.min.js"></script>
      
        <script src="../../../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="https://unpkg.com/mermaid@9.4.0/dist/mermaid.min.js"></script>
      
    
  <script>document$.subscribe(() => {const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});})</script></body>
</html>