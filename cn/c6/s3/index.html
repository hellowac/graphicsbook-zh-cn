
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="计算机图形学概论(graphicsbook)">
      
      
      
        <link rel="canonical" href="https://hellowac.github.io/graphicsbook-zh-cn/cn/c6/s3/">
      
      
        <link rel="prev" href="../s2/">
      
      
        <link rel="next" href="../s4/">
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.5.18">
    
    
      
        <title>6.3 GLSL - 计算机图形学概论</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.66ac8b77.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.06af60db.min.css">
      
      

  
  
  
  
  <style>:root{--md-annotation-icon:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M22 12a10 10 0 0 1-10 10A10 10 0 0 1 2 12 10 10 0 0 1 12 2a10 10 0 0 1 10 10M6 13h8l-3.5 3.5 1.42 1.42L17.84 12l-5.92-5.92L10.5 7.5 14 11H6v2Z"/></svg>');}</style>


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
   <link href="../../../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
        html.glightbox-open { overflow: initial; height: 100%; }
        .gslide-title { margin-top: 0px; user-select: text; }
        .gslide-desc { color: #666; user-select: text; }
        .gslide-image img { background: white; }
        
            .gscrollbar-fixer { padding-right: 15px; }
            .gdesc-inner { font-size: 0.75rem; }
            body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
            body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
            body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}
            </style> <script src="../../../assets/javascripts/glightbox.min.js"></script></head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="default" data-md-color-accent="red">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#63-glsl" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="计算机图形学概论" class="md-header__button md-logo" aria-label="计算机图形学概论" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            计算机图形学概论
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              6.3 GLSL
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
      <div class="md-header__option">
  <div class="md-select">
    
    <button class="md-header__button md-icon" aria-label="选择当前语言">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m12.87 15.07-2.54-2.51.03-.03A17.52 17.52 0 0 0 14.07 6H17V4h-7V2H8v2H1v2h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04M18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12m-2.62 7 1.62-4.33L19.12 17h-3.24Z"/></svg>
    </button>
    <div class="md-select__inner">
      <ul class="md-select__list">
        
          <li class="md-select__item">
            <a href="/graphicsbook-zh-cn/en/" hreflang="en" class="md-select__link">
              English
            </a>
          </li>
        
          <li class="md-select__item">
            <a href="/graphicsbook-zh-cn/cn/" hreflang="cn" class="md-select__link">
              中文
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</div>
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/hellowac/graphicsbook-zh-cn" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    graphicsbook
  </div>
</a>
      </div>
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../" class="md-tabs__link">
        
  
    
  
  首页

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../preface/" class="md-tabs__link">
        
  
    
  
  前言

      </a>
    </li>
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c1/" class="md-tabs__link">
          
  
    
  
  1.简介

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c2/" class="md-tabs__link">
          
  
    
  
  2.二维图形

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c3/" class="md-tabs__link">
          
  
    
  
  3.几何

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c4/" class="md-tabs__link">
          
  
    
  
  4.灯光和材质

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c5/" class="md-tabs__link">
          
  
    
  
  5.three.js

        </a>
      </li>
    
  

      
        
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../" class="md-tabs__link">
          
  
    
  
  6.WebGL

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c7/" class="md-tabs__link">
          
  
    
  
  7.WebGL 3D

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c8/" class="md-tabs__link">
          
  
    
  
  8.高阶3D

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c9/" class="md-tabs__link">
          
  
    
  
  9.WEBGPU

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../a1/" class="md-tabs__link">
          
  
    
  
  附录

        </a>
      </li>
    
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../.." class="md-tabs__link">
        
  
    
  
  关于

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="计算机图形学概论" class="md-nav__button md-logo" aria-label="计算机图形学概论" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    计算机图形学概论
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/hellowac/graphicsbook-zh-cn" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    graphicsbook
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    首页
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../preface/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    前言
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c1/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    1.简介
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_3" id="__nav_3_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            1.简介
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 1 节 绘画与绘图
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 2 节：三维(3D)图形的要素
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 3 节：硬件与软件
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c2/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    2.二维图形
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_4" id="__nav_4_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            2.二维图形
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第1节: 像素、坐标和颜色
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第2节: 形状
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第3节: 变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第4节: 分层建模
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第5节: Java 绘制2D
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第6节: HTML Canvas图形
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第7节: SVG：一种场景描述语言
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c3/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    3.几何
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_5" id="__nav_5_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            3.几何
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.1 OpenGL 1.1 中的形状和颜色
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.2 3D 坐标和变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.3 投影与观看
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.4 多边形网格和 glDrawArrays
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.5 部分线性代数基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.6 使用 GLUT 和 JOGL
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c4/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    4.灯光和材质
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_6" id="__nav_6_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6">
            <span class="md-nav__icon md-icon"></span>
            4.灯光和材质
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.1 照明简介
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.2 OpenGL 1.1 中的光和材质
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.3 图像纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.4 灯光、相机、动作
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c5/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    5.three.js
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_7" id="__nav_7_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7">
            <span class="md-nav__icon md-icon"></span>
            5.three.js
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.1 Three.js 基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.2 构建对象
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.3 其他功能
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" checked>
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    6.WebGL
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_8" id="__nav_8_label" tabindex="">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_8">
            <span class="md-nav__icon md-icon"></span>
            6.WebGL
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.1 可编程流水线
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.2 第一个例子
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    6.3 GLSL
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    6.3 GLSL
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#631-基本类型" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.1 基本类型
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#632-数据结构" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.2 数据结构
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#633-预选赛" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.3 预选赛
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#634-表达式" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.4 表达式
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#635-函数定义" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.5 函数定义
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#636-控制结构" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.6 控制结构
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#637-限制" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.7 限制
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.4 图像纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.5 实现 2D 变换
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c7/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    7.WebGL 3D
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_9" id="__nav_9_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9">
            <span class="md-nav__icon md-icon"></span>
            7.WebGL 3D
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.1 3D变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.2 照明和材质
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.3 纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.4 帧缓冲区
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.5 WebGL 扩展
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c8/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    8.高阶3D
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_10" id="__nav_10_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_10_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10">
            <span class="md-nav__icon md-icon"></span>
            8.高阶3D
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c8/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8.1 光线追踪
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c8/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8.2 路径追踪
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_11" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c9/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    9.WEBGPU
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_11" id="__nav_11_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_11_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_11">
            <span class="md-nav__icon md-icon"></span>
            9.WEBGPU
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.1 WebGPU 基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.2 实例和索引
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.3 WGSL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.4 WebGPU 中的 3D 图形
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.5 纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.6 计算着色器
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.7 细节
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_12" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../a1/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    附录
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_12" id="__nav_12_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_12_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_12">
            <span class="md-nav__icon md-icon"></span>
            附录
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a2/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Blender 3D建模
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a3/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Gimp和Inkscape
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../source/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    示例程序源代码
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../glossary/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    术语表
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    关于
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#631-基本类型" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.1 基本类型
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#632-数据结构" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.2 数据结构
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#633-预选赛" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.3 预选赛
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#634-表达式" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.4 表达式
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#635-函数定义" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.5 函数定义
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#636-控制结构" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.6 控制结构
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#637-限制" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.7 限制
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="63-glsl">6.3 <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr><a class="headerlink" href="#63-glsl" title="Permanent link">&para;</a></h1>
<p><strong><abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr></strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="1:2"><input checked="checked" id="__tabbed_1_1" name="__tabbed_1" type="radio" /><input id="__tabbed_1_2" name="__tabbed_1" type="radio" /><div class="tabbed-labels"><label for="__tabbed_1_1">中文</label><label for="__tabbed_1_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>你已经看到了一些用GLSL编写的简短简单的着色器程序示例。实际上，着色器程序通常相当简短，但并不总是那么简单。为了理解我们将在本书的其余部分中使用的更复杂的着色器，你需要更多地了解GLSL。本节旨在简要介绍该语言的主要特点。这是一个相当技术性的章节。你应该阅读它以熟悉GLSL，并在需要时将其作为参考。</p>
<p>对于WebGL 1.0，着色器必须用GLSL ES 1.00版本编写。<abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0可以使用1.00版本或3.00版本，但某些WebGL 2.0的功能只有在用GLSL ES 3.00编写着色器时才可用。尽管两个版本的GLSL非常相似，但存在重大差异和不兼容性。除非另有说明，这里的讨论适用于两个版本。</p>
<p>着色器程序中的顶点着色器和片段着色器必须使用相同版本的GLSL编写。<abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 3.00着色器程序必须以以下行开始：</p>
<div class="highlight"><pre><span></span><code><span class="cp">#version 300 es</span>
</code></pre></div>
<p>这必须是着色器源代码的非常第一行。它甚至不能由空行或注释先行。不以这行开始的着色器是1.00版本的着色器。1.00版本的着色器不包括版本号的声明。</p>
</div>
<div class="tabbed-block">
<p>You have seen a few short, simple examples of <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> programs written in <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr>. In fact, <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> programs are often fairly short, but they are not always so simple. To understand the more complex shaders that we will be using in the rest of this book, you will need to know more about <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr>. This section aims to give a short introduction to the major features of the language. This is a rather technical section. You should read it to get some familiarity with <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr>, and then use it as a reference when needed.</p>
<p>For <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0, shaders must be written in version 1.00 of <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES. <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 can use either version 1.00 or version 3.00, but some features of <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 are only available when shaders are written in <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 3.00. Although the two versions of <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> are very similar, there are major differences and incompatibilities. Unless otherwise noted, the discussion here applies to both versions.</p>
<p>The <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> and the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> in a <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program must be written using the same version of <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr>. A <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 3.00 <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program must begin with the line</p>
<div class="highlight"><pre><span></span><code><span class="err">#</span><span class="nx">version</span><span class="w"> </span><span class="mf">300</span><span class="w"> </span><span class="nx">es</span>
</code></pre></div>
<p>This must be the very first line of the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> source code. It cannot even be preceded by blank lines or comments. A <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program that does not start with this line is a version 1.00 <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>. A version 1.00 <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> does not include a declaration of the version number.</p>
</div>
</div>
</div>
<h2 id="631-基本类型">6.3.1 基本类型<a class="headerlink" href="#631-基本类型" title="Permanent link">&para;</a></h2>
<p><strong>Basic Types</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="2:2"><input checked="checked" id="__tabbed_2_1" name="__tabbed_2" type="radio" /><input id="__tabbed_2_2" name="__tabbed_2" type="radio" /><div class="tabbed-labels"><label for="__tabbed_2_1">中文</label><label for="__tabbed_2_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>在GLSL中，变量在使用前必须声明。GLSL是一种严格类型化的语言，每个变量在声明时都会被赋予一个类型。</p>
<p>GLSL有内置类型来表示标量（即单个值）、向量和矩阵。标量类型有<strong><em>float</em></strong>、<strong><em>int</em></strong>和<strong><em>bool</em></strong>。3.00版本增加了无符号整型，<strong><em>uint</em></strong>。GPU可能不会在硬件层面支持整数或布尔值，因此<strong><em>int</em></strong>和<strong><em>bool</em></strong>类型实际上是用浮点值表示的。</p>
<p><em>vec2</em>、<em>vec3</em>和<em>vec4</em>类型分别表示两个、三个和四个<strong><em>floats</em></strong>的向量。还有表示<strong><em>ints</em></strong>的向量类型（<em>ivec2</em>、<em>ivec3</em>和<em>ivec4</em>）和布尔值的向量类型（bvec2、bvec3和bvec4）——以及在3.00版本中，表示无符号整数的向量类型（uvec2、uvec3和uvec4）。GLSL对于引用向量分量的符号非常灵活。访问它们的一种是使用数组符号。例如，如果v是一个四分量向量，那么它的分量可以作为<em>v[0]</em>、<em>v[1]</em>、<em>v[2]</em>和<em>v[3]</em>访问。但它们也可以使用点符号作为<em>v.x</em>、<em>v.y</em>、<em>v.z</em>和<em>v.w</em>访问。分量名称x、y、z和w适用于保存坐标的向量。然而，向量也可以用于表示颜色，v的分量也可以称为<em>v.r</em>、<em>v.g</em>、<em>v.b</em>和<em>v.a</em>。最后，它们可以称为<em>v.s</em>、<em>v.t</em>、<em>v.p</em>和<em>v.q</em>——适用于纹理坐标的名称。</p>
<p>此外，GLSL允许你在点后面使用多个分量名称，如v.rgb或v.zx甚至<em>v.yyy</em>。名称可以按任何顺序排列，允许重复。这称为<strong><em>swizzling</em></strong>，<em>v.zx</em>是swizzler的一个例子。<em>v.zx</em>符号可以在表达式中作为一个两分量向量使用。例如，如果<em>v</em>是<em>vec4(1.0,2.0,3.0,4.0)</em>，那么<em>v.zx</em>等同于<em>vec2(3.0,1.0)</em>，而<em>v.yyy</em>就像<em>vec3(2.0,2.0,2.0)</em>。只要它们不包含重复的分量，swizzlers甚至可以用在赋值的左侧。例如，</p>
<div class="highlight"><pre><span></span><code><span class="nx">vec4</span><span class="w"> </span><span class="nx">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="p">,</span><span class="w"> </span><span class="mf">3.0</span><span class="p">,</span><span class="w"> </span><span class="mf">4.0</span><span class="p">);</span>
<span class="nx">vec3</span><span class="w"> </span><span class="nx">point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec3</span><span class="p">(</span><span class="mf">5.0</span><span class="p">,</span><span class="w"> </span><span class="mf">6.0</span><span class="p">,</span><span class="w"> </span><span class="mf">7.0</span><span class="p">);</span>
<span class="nx">coords</span><span class="p">.</span><span class="nx">yzw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">coords</span><span class="p">.</span><span class="nx">wyz</span><span class="p">;</span><span class="w">  </span><span class="c1">// 现在，coords是(1.0, 4.0, 2.0, 3.0)</span>
<span class="nx">point</span><span class="p">.</span><span class="nx">xy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">coords</span><span class="p">.</span><span class="nx">xx</span><span class="p">;</span><span class="w">     </span><span class="c1">// 现在，point是(1.0, 1.0, 7.0)</span>
</code></pre></div>
<p>像<em>vec2(1.0, 2.0)</em>这样的符号被称为“构造函数”，尽管它不是Java或C++中的意义上的构造函数，因为GLSL不是面向对象的，也没有<em>new</em>运算符。GLSL中的构造函数由类型名称后跟括号中的表达式列表组成，它表示由类型名称指定的类型的值。可以使用任何类型名称，包括标量类型。该值由括号中的表达式的值构建。一个表达式可以为构建的值贡献多个值；我们已经在像</p>
<div class="highlight"><pre><span></span><code><span class="nx">vec2</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec2</span><span class="p">(</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="p">);</span>
<span class="nx">vec4</span><span class="w"> </span><span class="nx">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="w"> </span><span class="nx">v</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="p">);</span><span class="w">  </span><span class="c1">// w是( 1.0, 2.0, 1.0, 2.0 )</span>
</code></pre></div>
<p>注意，表达式可以是swizzlers：</p>
<div class="highlight"><pre><span></span><code><span class="nx">vec3</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec3</span><span class="p">(</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="p">,</span><span class="w"> </span><span class="mf">3.0</span><span class="w"> </span><span class="p">);</span>
<span class="nx">vec3</span><span class="w"> </span><span class="nx">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec3</span><span class="p">(</span><span class="w"> </span><span class="nx">v</span><span class="p">.</span><span class="nx">zx</span><span class="p">,</span><span class="w"> </span><span class="mf">4.0</span><span class="w"> </span><span class="p">);</span><span class="w">  </span><span class="c1">// w是( 3.0, 1.0, 4.0 )</span>
</code></pre></div>
<p>最后一个参数的额外值将被丢弃。这使得可以使用构造函数来缩短向量。然而，拥有一些根本没有为结果贡献值的额外参数是不合法的：</p>
<div class="highlight"><pre><span></span><code><span class="nx">vec4</span><span class="w"> </span><span class="nx">rgba</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="w"> </span><span class="mf">0.1</span><span class="p">,</span><span class="w"> </span><span class="mf">0.2</span><span class="p">,</span><span class="w"> </span><span class="mf">0.3</span><span class="p">,</span><span class="w"> </span><span class="mf">0.4</span><span class="w"> </span><span class="p">);</span>
<span class="nx">vec3</span><span class="w"> </span><span class="nx">rgb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec3</span><span class="p">(</span><span class="w"> </span><span class="nx">rgba</span><span class="w"> </span><span class="p">);</span><span class="w">  </span><span class="c1">// 从rgba中取3个项目；rgb是(0.1, 0.2, 0.3)</span>
<span class="kr">float</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kr">float</span><span class="p">(</span><span class="w"> </span><span class="nx">rgba</span><span class="w"> </span><span class="p">);</span><span class="w">  </span><span class="c1">// r是0.1</span>
<span class="nx">vec2</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec2</span><span class="p">(</span><span class="w"> </span><span class="nx">rgb</span><span class="p">,</span><span class="w"> </span><span class="nx">rgba</span><span class="w"> </span><span class="p">);</span><span class="w">    </span><span class="c1">// 错误：没有使用rgba中的值。</span>
</code></pre></div>
<p>作为一种特殊情况，当从一个单一的标量值构造向量时，向量的所有分量都将被设置为该值：</p>
<div class="highlight"><pre><span></span><code><span class="nx">vec4</span><span class="w"> </span><span class="nx">black</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">);</span><span class="w">  </span><span class="c1">// black是( 1.0, 1.0, 1.0, 1.0 )</span>
</code></pre></div>
<p>当构造内置类型时，如果需要，将应用类型转换。就转换而言，布尔值<em>true/false</em>转换为数值零和一；反过来，零转换为<em>false</em>，任何其他数值转换为<em>true</em>。据我所知，构造函数是GLSL中<strong>唯一</strong>的自动类型转换的上下文。例如，你需要使用构造函数将<strong><em>int</em></strong>值赋给<strong><em>float</em></strong>变量，直接将<strong><em>int</em></strong>加到<strong><em>float</em></strong>是非法的：</p>
<div class="highlight"><pre><span></span><code><span class="kr">int</span><span class="w"> </span><span class="nx">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1</span><span class="p">;</span>
<span class="kr">float</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kr">float</span><span class="p">(</span><span class="nx">k</span><span class="p">);</span><span class="w">  </span><span class="c1">// 好的；&quot;x = k&quot;将是类型不匹配错误</span>
<span class="nx">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span><span class="w">         </span><span class="c1">// 好的</span>
<span class="nx">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1</span><span class="p">;</span><span class="w">           </span><span class="c1">// 错误：不能添加不同类型的值。</span>
</code></pre></div>
<hr />
<p>内置的矩阵类型是<em>mat2</em>、<em>mat3</em>和<em>mat4</em>。它们分别表示二乘二、三乘三和四乘四的浮点数矩阵。（没有整数或布尔值的矩阵，但有一些额外的矩阵类型用于表示非方阵。）矩阵的元素可以使用数组符号访问，如<em>M[2][1]</em>。如果使用单一索引，如<em>M[2]</em>，结果是向量。例如，如果<em>M</em>是<em>mat4</em>类型，那么<em>M[2]</em>是<em>vec4</em>。GLSL中的数组，像OpenGL中的一样，使用<strong><abbr title="二维矩阵元素的列主序排列；即，从第一列的元素开始，然后是第二列的元素，依此类推。OpenGL和GLSL中的矩阵使用列主序。">列主序</abbr></strong>。这意味着<em>M[2]</em>是M中的第二列，而不是第二行（就像在Java中一样），<em>M[2][1]</em>是第二列和第一行的元素。</p>
<p>矩阵可以从适当数量的值构造，这些值可以作为标量、向量或矩阵提供。例如，<em>mat3</em>可以从九个<strong><em>float</em></strong>或三个<em>vec3</em>参数构造：</p>
<div class="highlight"><pre><span></span><code><span class="nx">mat3</span><span class="w"> </span><span class="nx">m1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">mat3</span><span class="p">(</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="p">,</span><span class="w"> </span><span class="mf">3.0</span><span class="p">,</span><span class="w"> </span><span class="mf">4.0</span><span class="p">,</span><span class="w"> </span><span class="mf">5.0</span><span class="p">,</span><span class="w"> </span><span class="mf">6.0</span><span class="p">,</span><span class="w"> </span><span class="mf">7.0</span><span class="p">,</span><span class="w"> </span><span class="mf">8.0</span><span class="p">,</span><span class="w"> </span><span class="mf">9.0</span><span class="w"> </span><span class="p">);</span>
<span class="nx">vec3</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec3</span><span class="p">(</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">3</span><span class="w"> </span><span class="p">);</span>
<span class="nx">mat3</span><span class="w"> </span><span class="nx">m2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">mat3</span><span class="p">(</span><span class="w"> </span><span class="nx">v</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>请记住，矩阵是以列主序填充的；也就是说，前三个数字进入第0列，接下来的三个进入第1列，最后三个进入第2列。</p>
<p>作为一种特殊情况，如果矩阵<em>M</em>从一个单一的标量值构造，那么该值将放入<em>M</em>的所有对角元素中（<em>M[0][0]</em>、<em>M[1][1]</em>等）。非对角元素都设置为零。例如，<em>mat4(1.0)</em>构造了四乘四的单位矩阵。</p>
<p>唯一其他内置类型是所谓的“采样器类型”，用于访问纹理。采样器类型只能以有限的方式使用。它们不是数值类型，也不能转换为数值类型。它们将在<a href="../s4/">下一部分</a>中介绍。</p>
</div>
<div class="tabbed-block">
<p>Variables in <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> must be declared before they are used. <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> is a strictly typed language, and every variable is given a type when it is declared.</p>
<p><abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> has built-in types to represent scalars (that is, single values), vectors, and matrices. The scalar types are <strong><em>float</em></strong>, <strong><em>int</em></strong>, and <strong><em>bool</em></strong>. Version 3.00 adds an unsigned integer type, <strong><em>uint</em></strong>. A <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> might not support integers or booleans on the hardware level, so it is possible that the <strong><em>int</em></strong> and <strong><em>bool</em></strong> types are actually represented as floating point values.</p>
<p>The types <em>vec2</em>, <em>vec3</em>, and <em>vec4</em> represent vectors of two, three, and four <strong><em>floats</em></strong>. There are also types to represent vectors of <strong><em>ints</em></strong> (<em>ivec2</em>, <em>ivec3</em>, and <em>ivec4</em>) and bools (bvec2, bvec3, and bvec4) — and, in version 3.00, of unsigned integers (uvec2, uvec3, and uvec4). <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> has very flexible notation for referring to the components of a <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr>. One way to access them is with array notation. For example, if v is a four-component <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr>, then its components can be accessed as <em>v[0]</em>, <em>v[1]</em>, <em>v[2]</em>, and <em>v[3]</em>. But they can also be accessed using the dot notation as <em>v.x</em>, <em>v.y</em>, <em>v.z</em>, andv.w. The component names x, y, z, and w are appropriate for a <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> that holds coordinates. However, vectors can also be used to represent colors, and the components of v can alternatively be referred to as <em>v.r</em>, <em>v.g</em>, <em>v.b</em>, and <em>v.a</em>. Finally, they can be referred to as <em>v.s</em>, <em>v.t</em>, <em>v.p</em>, and <em>v.q</em> — names appropriate for <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates.</p>
<p>Furthermore, <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> allows you to use multiple component names after the dot, as in v.rgb or v.zx or even <em>v.yyy</em>. The names can be in any order, and repetition is allowed. This is called <strong><em>swizzling</em></strong>, and <em>v.zx</em> is an example of a <abbr title="In GLSL and WGSL, a notation such as v.yzx, where v is a vector and v.yzx represents the three-component vector made up of the y, z, and x components of v. Technically, any use of the dot notation with vectors is considered to be a swizzler.">swizzler</abbr>. The notation <em>v.zx</em> can be used in an expression as a two-component <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr>. For example, if <em>v</em> is <em>vec4(1.0,2.0,3.0,4.0)</em>, then <em>v.zx</em> is equivalent to <em>vec2(3.0,1.0)</em>, and <em>v.yyy</em> is like <em>vec3(2.0,2.0,2.0)</em>. Swizzlers can even be used on the left-hand side of an assignment, as long as they don't contain repeated components. For example,</p>
<div class="highlight"><pre><span></span><code><span class="nx">vec4</span><span class="w"> </span><span class="nx">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="p">,</span><span class="w"> </span><span class="mf">3.0</span><span class="p">,</span><span class="w"> </span><span class="mf">4.0</span><span class="p">);</span>
<span class="nx">vec3</span><span class="w"> </span><span class="nx">point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec3</span><span class="p">(</span><span class="mf">5.0</span><span class="p">,</span><span class="w"> </span><span class="mf">6.0</span><span class="p">,</span><span class="w"> </span><span class="mf">7.0</span><span class="p">);</span>
<span class="nx">coords</span><span class="p">.</span><span class="nx">yzw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">coords</span><span class="p">.</span><span class="nx">wyz</span><span class="p">;</span><span class="w">  </span><span class="c1">// Now, coords is (1.0, 4.0, 2.0, 3.0)</span>
<span class="nx">point</span><span class="p">.</span><span class="nx">xy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">coords</span><span class="p">.</span><span class="nx">xx</span><span class="p">;</span><span class="w">     </span><span class="c1">// Now, point is (1.0, 1.0, 7.0)</span>
</code></pre></div>
<p>A notation such as <em>vec2(1.0, 2.0)</em> is referred to as a "<abbr title="In object-oriented programming, a subroutine that is used to create objects. A constructor for a class creates and initializes objects belonging to that class.">constructor</abbr>," although it is not a <abbr title="In object-oriented programming, a subroutine that is used to create objects. A constructor for a class creates and initializes objects belonging to that class.">constructor</abbr> in the sense of Java or C++, since <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> is not object-oriented, and there is no <em>new</em> operator. A <abbr title="In object-oriented programming, a subroutine that is used to create objects. A constructor for a class creates and initializes objects belonging to that class.">constructor</abbr> in <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> consists of a type name followed by a list of expressions in parentheses, and it represents a value of the type specified by the type name. Any type name can be used, including the scalar types. The value is constructed from the values of the expressions in parentheses. An expression can contribute more than one value to the constructed value; we have already seen this in examples such as</p>
<div class="highlight"><pre><span></span><code><span class="nx">vec2</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec2</span><span class="p">(</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="p">);</span>
<span class="nx">vec4</span><span class="w"> </span><span class="nx">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="w"> </span><span class="nx">v</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="p">);</span><span class="w">  </span><span class="c1">// w is ( 1.0, 2.0, 1.0, 2.0 )</span>
</code></pre></div>
<p>Note that the expressions can be swizzlers:</p>
<div class="highlight"><pre><span></span><code><span class="nx">vec3</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec3</span><span class="p">(</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="p">,</span><span class="w"> </span><span class="mf">3.0</span><span class="w"> </span><span class="p">);</span>
<span class="nx">vec3</span><span class="w"> </span><span class="nx">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec3</span><span class="p">(</span><span class="w"> </span><span class="nx">v</span><span class="p">.</span><span class="nx">zx</span><span class="p">,</span><span class="w"> </span><span class="mf">4.0</span><span class="w"> </span><span class="p">);</span><span class="w">  </span><span class="c1">// w is ( 3.0, 1.0, 4.0 )</span>
</code></pre></div>
<p>Extra values from the last parameter will be dropped. This makes is possible to use a <abbr title="In object-oriented programming, a subroutine that is used to create objects. A constructor for a class creates and initializes objects belonging to that class.">constructor</abbr> to shorten a <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr>. However, it is not legal to have extra parameters that contribute no values at all to the result:</p>
<div class="highlight"><pre><span></span><code><span class="nx">vec4</span><span class="w"> </span><span class="nx">rgba</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="w"> </span><span class="mf">0.1</span><span class="p">,</span><span class="w"> </span><span class="mf">0.2</span><span class="p">,</span><span class="w"> </span><span class="mf">0.3</span><span class="p">,</span><span class="w"> </span><span class="mf">0.4</span><span class="w"> </span><span class="p">);</span>
<span class="nx">vec3</span><span class="w"> </span><span class="nx">rgb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec3</span><span class="p">(</span><span class="w"> </span><span class="nx">rgba</span><span class="w"> </span><span class="p">);</span><span class="w">  </span><span class="c1">// takes 3 items from rgba; rgb is (0.1, 0.2, 0.3)</span>
<span class="kr">float</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kr">float</span><span class="p">(</span><span class="w"> </span><span class="nx">rgba</span><span class="w"> </span><span class="p">);</span><span class="w">  </span><span class="c1">// r is 0.1</span>
<span class="nx">vec2</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec2</span><span class="p">(</span><span class="w"> </span><span class="nx">rgb</span><span class="p">,</span><span class="w"> </span><span class="nx">rgba</span><span class="w"> </span><span class="p">);</span><span class="w">    </span><span class="c1">// ERROR: No values from rgba are used.</span>
</code></pre></div>
<p>As a special case, when a <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> is constructed from a single scalar value, all components of the <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> will be set equal to that value:</p>
<div class="highlight"><pre><span></span><code><span class="nx">vec4</span><span class="w"> </span><span class="nx">black</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">);</span><span class="w">  </span><span class="c1">// black is ( 1.0, 1.0, 1.0, 1.0 )</span>
</code></pre></div>
<p>When constructing one of the built-in types, type conversion will be applied if necessary. For purposes of conversion, the boolean values <em>true/false</em> convert to the numeric values zero and one; in the other direction, zero converts to <em>false</em> and any other numeric value converts to <em>true</em>. As far as I know, constructors are the <strong>only</strong> context in which <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> does automatic type conversion. For example, you need to use a <abbr title="In object-oriented programming, a subroutine that is used to create objects. A constructor for a class creates and initializes objects belonging to that class.">constructor</abbr> to assign an <strong><em>int</em></strong> value to a <strong><em>float</em></strong> variable, and it is illegal to add an <strong><em>int</em></strong> to a <strong><em>float</em></strong>:</p>
<div class="highlight"><pre><span></span><code><span class="kr">int</span><span class="w"> </span><span class="nx">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1</span><span class="p">;</span>
<span class="kr">float</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kr">float</span><span class="p">(</span><span class="nx">k</span><span class="p">);</span><span class="w">  </span><span class="c1">// OK; &quot;x = k&quot; would be a type mismatch error</span>
<span class="nx">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span><span class="w">         </span><span class="c1">// OK</span>
<span class="nx">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1</span><span class="p">;</span><span class="w">           </span><span class="c1">// ERROR: Can&#39;t add values of different types.</span>
</code></pre></div>
<hr />
<p>The built-in <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> types are <em>mat2</em>, <em>mat3</em>, and <em>mat4</em>. They represent, respectively, two-by-two, three-by-three, and four-by-four matrices of floating point numbers. (There are no matrices of integers or booleans, but there are some additional <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> types for representing non-square matrices.) The elements of a <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> can be accessed using array notation, such as <em>M[2][1]</em>. If a single index is used, as in <em>M[2]</em>, the result is a <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr>. For example, if <em>M</em> is of type <em>mat4</em>, then <em>M[2]</em> is a <em>vec4</em>. Arrays in <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr>, as in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr>, use <strong><abbr title="Column-by-column ordering of the elements of a two-dimensional matrix; that is, an ordering that starts with the elements in the first column, followed by the elements in the second column, and so on. Column-major order is used for matrices in OpenGL and GLSL.">column-major order</abbr></strong>. This means that <em>M[2]</em> is column number 2 in M rather than row number 2 (as it would be in Java), and <em>M[2][1]</em> is the element in column 2 and row 1.</p>
<p>A <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> can be constructed from the appropriate number of values, which can be provided as scalars, vectors or matrices. For example, a <em>mat3</em> can be constructed from nine <strong><em>float</em></strong> or from three <em>vec3</em> parameters:</p>
<div class="highlight"><pre><span></span><code><span class="nx">mat3</span><span class="w"> </span><span class="nx">m1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">mat3</span><span class="p">(</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="p">,</span><span class="w"> </span><span class="mf">3.0</span><span class="p">,</span><span class="w"> </span><span class="mf">4.0</span><span class="p">,</span><span class="w"> </span><span class="mf">5.0</span><span class="p">,</span><span class="w"> </span><span class="mf">6.0</span><span class="p">,</span><span class="w"> </span><span class="mf">7.0</span><span class="p">,</span><span class="w"> </span><span class="mf">8.0</span><span class="p">,</span><span class="w"> </span><span class="mf">9.0</span><span class="w"> </span><span class="p">);</span>
<span class="nx">vec3</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec3</span><span class="p">(</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">3</span><span class="w"> </span><span class="p">);</span>
<span class="nx">mat3</span><span class="w"> </span><span class="nx">m2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">mat3</span><span class="p">(</span><span class="w"> </span><span class="nx">v</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>Keep in mind that the <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> is filled in <abbr title="Column-by-column ordering of the elements of a two-dimensional matrix; that is, an ordering that starts with the elements in the first column, followed by the elements in the second column, and so on. Column-major order is used for matrices in OpenGL and GLSL.">column-major order</abbr>; that is, the first three numbers go into column 0, the next three into column 1, and the last three into column 2.</p>
<p>As a special case, if a <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> <em>M</em> is constructed from a single scalar value, then that value is put into all the diagonal elements of <em>M</em> (<em>M[0][0]</em>, <em>M[1][1]</em>, and so on). The non-diagonal elements are all set equal to zero. For example, <em>mat4(1.0)</em> constructs the four-by-four <abbr title="The n-by-n identity matrix is an n-by-n matrix which has ones on the diagonal and zeros elsewhere. Multiplication of any matrix B by the identity matrix, in either order, leaves B unchanged. Multiplication of an n-dimensional vector by the n-by-n identity matrix leaves the vector unchanged; that is, the identity matrix is the matrix for the identity transformation.">identity matrix</abbr>.</p>
<p>The only other built-in types are the so-called "sampler types", which are used for accessing textures. The sampler types can be used only in limited ways. They are not numeric types and cannot be converted to or from numeric types. The will be covered in the <a href="../s4/">next section</a>.</p>
</div>
</div>
</div>
<h2 id="632-数据结构">6.3.2 数据结构<a class="headerlink" href="#632-数据结构" title="Permanent link">&para;</a></h2>
<p><strong>Data Structures</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="3:2"><input checked="checked" id="__tabbed_3_1" name="__tabbed_3" type="radio" /><input id="__tabbed_3_2" name="__tabbed_3" type="radio" /><div class="tabbed-labels"><label for="__tabbed_3_1">中文</label><label for="__tabbed_3_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>GLSL程序可以使用<em>struct</em>关键字定义新类型。语法与C语言相同，但有一些限制。一个结构由一系列命名成员组成，这些成员可以是不同类型的。成员的类型可以是任何内置类型、数组类型或之前定义的结构类型。例如：</p>
<div class="highlight"><pre><span></span><code><span class="nx">struct</span><span class="w"> </span><span class="nx">LightProperties</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">position</span><span class="p">;</span>
<span class="w">    </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">color</span><span class="p">;</span>
<span class="w">    </span><span class="kr">float</span><span class="w"> </span><span class="nx">intensity</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>这定义了一个名为<em>LightProperties</em>的类型。这个类型可以用来声明变量：</p>
<div class="highlight"><pre><span></span><code><span class="nx">LightProperties</span><span class="w"> </span><span class="nx">light</span><span class="p">;</span>
</code></pre></div>
<p>然后，变量<em>light</em>的成员被称为<em>light.position</em>、<em>light.color</em>和<em>light.intensity</em>。结构类型有构造函数，但它们的构造函数不支持类型转换：构造函数必须包含一个值列表，其类型与结构中相应成员的类型完全匹配。例如：</p>
<div class="highlight"><pre><span></span><code><span class="nx">light</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">LightProperties</span><span class="p">(</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">),</span><span class="w"> </span><span class="nx">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>GLSL还支持数组。只允许一维数组。数组的基础类型可以是任何基本类型，也可以是结构类型。数组的大小必须在变量声明中指定为整型常量。例如：</p>
<div class="highlight"><pre><span></span><code><span class="kr">int</span><span class="w"> </span><span class="nx">A</span><span class="p">[</span><span class="mf">10</span><span class="p">];</span>
<span class="nx">vec3</span><span class="w"> </span><span class="nx">palette</span><span class="p">[</span><span class="mf">8</span><span class="p">];</span>
<span class="nx">LightProperties</span><span class="w"> </span><span class="nx">lights</span><span class="p">[</span><span class="mf">3</span><span class="p">];</span>
</code></pre></div>
<p>在1.00版本中，没有数组构造函数，也不能在声明时初始化数组。3.00版本确实有数组构造函数，并允许使用类型名称，如“int[10]”，表示一个包含10个整数的数组：</p>
<div class="highlight"><pre><span></span><code><span class="kr">int</span><span class="p">[</span><span class="mf">4</span><span class="p">]</span><span class="w"> </span><span class="nx">B</span><span class="p">;</span><span class="w"> </span><span class="c1">// B是一个包含4个int的数组；仅限GLSL ES 3.00！</span>
<span class="nx">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kr">int</span><span class="p">[</span><span class="mf">4</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">3</span><span class="p">,</span><span class="w"> </span><span class="mf">5</span><span class="p">,</span><span class="w"> </span><span class="mf">7</span><span class="p">);</span><span class="w">  </span><span class="c1">// 数组构造函数；仅限GLSL ES 3.00！</span>
</code></pre></div>
<p>数组索引使用通常的语法，如<em>A[0]</em>或<em>palette[i+1]</em>或<em>lights[3].color</em>。在GLSL ES 1.00中，对于可以用作数组索引的表达式有一些严格的限制。除了一个例外，用作数组索引的表达式只能包含整型常量和for循环变量（即在for循环中用作循环控制变量的变量）。例如，表达式<em>palette[i+1]</em>只有在形式为<em>for (int i = ....</em>的for循环中才是合法的。唯一的例外是，在顶点着色器中的<em>uniforms</em>数组（且仅当数组不包含采样器时）可以使用任意索引表达式。请注意，这些限制在GLSL ES 3.00中不适用。</p>
<p>就像在C语言中一样，没有对数组索引越界错误进行检查。程序员需要确保数组索引是有效的。</p>
</div>
<div class="tabbed-block">
<p>A <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> program can define new types using the <em>struct</em> keyword. The syntax is the same as in C, with some limitations. A struct is made up of a sequence of named members, which can be of different types. The type of a member can be any of the built-in types, an array type, or a previously defined struct type. For example,</p>
<div class="highlight"><pre><span></span><code><span class="nx">struct</span><span class="w"> </span><span class="nx">LightProperties</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">position</span><span class="p">;</span>
<span class="w">    </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">color</span><span class="p">;</span>
<span class="w">    </span><span class="kr">float</span><span class="w"> </span><span class="nx">intensity</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>This defines a type named <em>LightProperties</em>. The type can be used to declare variables:</p>
<div class="highlight"><pre><span></span><code><span class="nx">LightProperties</span><span class="w"> </span><span class="nx">light</span><span class="p">;</span>
</code></pre></div>
<p>The members of the variable <em>light</em> are then referred to as <em>light.position</em>, <em>light.color</em>, and <em>light.intensity</em>. Struct types have constructors, but their constructors do not support type conversion: The <abbr title="In object-oriented programming, a subroutine that is used to create objects. A constructor for a class creates and initializes objects belonging to that class.">constructor</abbr> must contain a list of values whose types exactly match the types of the corresponding members in the struct. For example,</p>
<div class="highlight"><pre><span></span><code><span class="nx">light</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">LightProperties</span><span class="p">(</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">),</span><span class="w"> </span><span class="nx">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p><abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> also supports arrays. Only one-dimensional arrays are allowed. The base type of an array can be any of the basic types or it can be a struct type. The size of the array must be specified in the variable declaration as an integer constant. For example</p>
<div class="highlight"><pre><span></span><code><span class="kr">int</span><span class="w"> </span><span class="nx">A</span><span class="p">[</span><span class="mf">10</span><span class="p">];</span>
<span class="nx">vec3</span><span class="w"> </span><span class="nx">palette</span><span class="p">[</span><span class="mf">8</span><span class="p">];</span>
<span class="nx">LightProperties</span><span class="w"> </span><span class="nx">lights</span><span class="p">[</span><span class="mf">3</span><span class="p">];</span>
</code></pre></div>
<p>In version 1.00, there are no array constructors, and it is not possible to initialize an array as part of its declaration. Version 3.00 does have array constructors, and it allows type names such as "int[10], representing an array of 10 integers:</p>
<div class="highlight"><pre><span></span><code><span class="kr">int</span><span class="p">[</span><span class="mf">4</span><span class="p">]</span><span class="w"> </span><span class="nx">B</span><span class="p">;</span><span class="w"> </span><span class="c1">// B is an array of 4 ints; GLSL ES 3.00 only!</span>
<span class="nx">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kr">int</span><span class="p">[</span><span class="mf">4</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">3</span><span class="p">,</span><span class="w"> </span><span class="mf">5</span><span class="p">,</span><span class="w"> </span><span class="mf">7</span><span class="p">);</span><span class="w">  </span><span class="c1">// Array constructor; GLSL ES 3.00 only!</span>
</code></pre></div>
<p>Array indexing uses the usual syntax, such as <em>A[0]</em> or <em>palette[i+1]</em> or <em>lights[3].color</em>. In <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 1.00, there are some strong limitations on the expressions that can be used as array indices. With one exception, an expression that is used as the index for an array can contain only integer constants and for loop variables (that is, variables that are used as loop control variables in for loops). For example, the expression <em>palette[i+1]</em> would only be legal inside a for of the form <em>for (int i = ....</em> The single exception is that arbitrary index expressions can be used for arrays of <em>uniforms</em> in a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> (and then only if the array does not contain samplers). Note that these restrictions do not apply in <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 3.00.</p>
<p>Just as in C, there is no check for array index out of bounds errors. It is up to the programmer to make sure that array indices are valid.</p>
</div>
</div>
</div>
<h2 id="633-预选赛">6.3.3 预选赛<a class="headerlink" href="#633-预选赛" title="Permanent link">&para;</a></h2>
<p><strong>Qualifiers</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="4:2"><input checked="checked" id="__tabbed_4_1" name="__tabbed_4" type="radio" /><input id="__tabbed_4_2" name="__tabbed_4" type="radio" /><div class="tabbed-labels"><label for="__tabbed_4_1">中文</label><label for="__tabbed_4_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>变量声明可以通过各种限定符进行修改。你已经看到了限定符<em><abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr></em>、<em>uniform</em>和<em>varying</em>的例子。这些被称为<strong><abbr title="在GLSL中，变量声明的以下修饰符之一：uniform（统一）、attribute（属性）、varying（变化）或const（常量）。">存储限定符</abbr></strong>。在3.00版本中，没有<em><abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr></em>和<em>varying</em>限定符；相反，在顶点着色器中使用存储限定符<em>in</em>声明属性，在顶点着色器中使用<em>out</em>声明变化变量，在片段着色器中使用<em>in</em>。<em>uniform</em>限定符在两个版本中都使用。只有全局变量，而不是函数定义中的局部变量，才能是属性、统一或变化变量。</p>
<p><em><abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr></em>限定符只能在GLSL ES 1.00顶点着色器中使用，并且它只适用于内置浮点类型<strong><em>float</em></strong>、<em>vec2</em>、<em>vec3</em>、<em>vec4</em>、<em>mat2</em>、<em>mat3</em>和<em>mat4</em>。（矩阵属性在JavaScript方面没有直接支持。矩阵属性必须被视为一组向量属性，每个矩阵列一个。列的属性位置是连续的整数，WebGL函数<em>gl.getAttribLocation</em>将返回第一列的位置。矩阵属性可能很少见，但对于实例化绘制可能很有用，我不会在这里详细介绍它们。）</p>
<p>在GLSL ES 3.00中，顶点着色器变量上的<em>in</em>限定符将其定义为属性变量，并且它可以应用于整数和无符号整数标量和向量，以及浮点类型。</p>
<p>同样在GLSL ES 3.00中，<em>out</em>限定符可以在片段着色器中的整数和浮点标量和向量上使用。在1.00版本中，片段着色器有预定义变量<em>gl_FragColor</em>，类型为<strong><em>vec4</em></strong>，用于指定像素的颜色。在3.00版本中，片段着色器可以有多个输出，输出不一定是颜色。因为输出类型不一定是<strong><em>vec4</em></strong>，所以不可能有一个预定义的输出变量。目前，我们只会使用一个代表颜色的片段着色器输出。所以，3.00版本的片段着色器将有一个类型为<strong><em>vec4</em></strong>的输出变量。（当我们在<a href="../../c7/s4/">第7.4节</a>讨论帧缓冲区时，我们将看到如何使用多个输出。）</p>
<p>顶点着色器和片段着色器都可以使用<em>uniform</em>变量。只要两个着色器中的类型相同，同一个变量就可以出现在两个着色器中。统一变量可以是任何类型，包括数组和结构类型。现在，JavaScript只有用于设置标量变量、向量或矩阵的统一值的函数。没有用于设置结构或数组值的函数。解决这个问题的方法是将结构或数组的每个组件视为单独的统一值。例如，考虑声明：</p>
<div class="highlight"><pre><span></span><code><span class="nx">struct</span><span class="w"> </span><span class="nx">LightProperties</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">position</span><span class="p">;</span>
<span class="w">    </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">color</span><span class="p">;</span>
<span class="w">    </span><span class="kr">float</span><span class="w"> </span><span class="nx">intensity</span><span class="p">;</span>
<span class="p">};</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">LightProperties</span><span class="w"> </span><span class="nx">light</span><span class="p">[</span><span class="mf">4</span><span class="p">];</span>
</code></pre></div>
<p>变量<em>light</em>包含十二个基本值，类型为<em>vec4</em>、<em>vec3</em>或<em>float</em>。要在JavaScript中使用<em>light</em><abbr title="表示可编程图形管线中着色器程序的输入的变量。统一变量在每个顶点和每个像素上都有相同的值。">统一变量</abbr>，我们需要十二个变量来表示统一变量的12个组件的位置。当使用<em>gl.getUniformLocation</em>获取12个组件之一的位置时，你需要在GLSL程序中给出组件的完整名称。例如：<em>gl.getUniformLocation(prog, "light[2].color")</em>。很自然地将12个位置存储在与GLSL端的结构数组平行的JavaScript对象数组中。以下是创建结构并使用它初始化统一变量的典型JavaScript代码：</p>
<div class="highlight"><pre><span></span><code><span class="nx">lightLocations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Array</span><span class="p">(</span><span class="mf">4</span><span class="p">);</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">light</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">lightLocations</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">position</span><span class="o">:</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getUniformLocation</span><span class="p">(</span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;light[&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">&quot;].position&quot;</span><span class="w"> </span><span class="p">),</span>
<span class="w">        </span><span class="nx">color</span><span class="o">:</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getUniformLocation</span><span class="p">(</span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;light[&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">&quot;].color&quot;</span><span class="w"> </span><span class="p">),</span>
<span class="w">        </span><span class="nx">intensity</span><span class="o">:</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getUniformLocation</span><span class="p">(</span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;light[&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">&quot;].intensity&quot;</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">};</span>
<span class="p">}</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">light</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">uniform4f</span><span class="p">(</span><span class="w"> </span><span class="nx">lightLocations</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">position</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">uniform3f</span><span class="p">(</span><span class="w"> </span><span class="nx">lightLocations</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">color</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">uniform1f</span><span class="p">(</span><span class="w"> </span><span class="nx">lightLocations</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">intensity</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">);</span><span class="w">    </span>
<span class="p">}</span>
</code></pre></div>
<p>对于矩阵统一着色器变量，用于设置统一值的JavaScript函数是<em>gl.uniformMatrix2fv</em>用于<em>mat2</em>，<em>gl.uniformMatrix3fv</em>用于<em>mat3</em>，或<em>gl.uniformMatrix4fv</em>用于<em>mat4</em>。即使矩阵是二维的，值也存储在一维数组中。值以列主序的方式加载到数组中。例如，如果<em>transform</em>是着色器中的统一<em>mat3</em>，则JavaScript可以将其值设置为单位矩阵：</p>
<div class="highlight"><pre><span></span><code><span class="nx">transformLoc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getUniformLocation</span><span class="p">(</span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;transform&quot;</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">uniformMatrix3fv</span><span class="p">(</span><span class="w"> </span><span class="nx">transformLoc</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>在1.00版本中，第二个参数<strong>必须</strong>是false。在3.00版本中，第二个参数可以是<em>true</em>，表示矩阵的条目以行主序而不是列主序提供。注意，<em>uniformMatrix3fv</em>中的3指的是矩阵的行数和列数，而不是数组的长度，数组的长度必须是9。（顺便说一下，对于统一变量的值，使用类型化数组而不是普通的JavaScript数组是可以的。）</p>
<p>变化变量应在顶点着色器和片段着色器中以相同的名称和类型声明。在1.00版本中，声明变化变量的存储限定符是varying，它只能用于内置浮点类型（<em>float</em>、<em>vec2</em>、<em>vec3</em>、<em>vec4</em>、<em>mat2</em>、<em>mat3</em>和<em>mat4</em>）和这些类型的数组。</p>
<p>在3.00版本中，变化变量也可以是整数或无符号整数标量或向量。但有一个复杂情况，因为对整数值应用插值是没有意义的。所以，整型变化变量必须用额外的限定符<em>flat</em>声明，这意味着它不会被插值。相反，三角形或线段的第一个顶点的值将用于每个像素。（浮点变化变量也可以选择性地声明为<em>flat</em>。）例如：</p>
<div class="highlight"><pre><span></span><code><span class="nx">flat</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nx">ivec3</span><span class="w"> </span><span class="nx">A</span><span class="p">;</span><span class="w">  </span><span class="c1">// 仅限GLSL ES 3.00片段着色器！</span>
</code></pre></div>
<p>另一种可能的存储限定符是<em>const</em>，这意味着变量的值在初始化后不能更改。<em>const</em>变量的声明必须包括初始化。</p>
<hr />
<p>变量声明也可以通过<strong><abbr title="在GLSL中，数值变量声明的以下修饰符之一：lowp（低精度）、mediump（中等精度）或highp（高精度）。精度修饰符指定变量的最小位数或值的范围。">精度限定符</abbr></strong>进行修改。可能的精度限定符是<em>highp</em>、<em>mediump</em>和<em>lowp</em>。精度限定符为整型变量设置了最小值范围，或为浮点变量设置了最小值范围和最小小数位数。GLSL没有为精度限定符分配确切的含义，但规定了一些最低要求。例如，在1.00版本中，<em>lowp</em>整数必须能够表示至少在-2<sup>8到2</sup>8范围内的值；<em>mediump</em>整数，在-2<sup>10到2</sup>10范围内；<em>highp</em>整数，在-2<sup>16到2</sup>16范围内。对于3.00版本，<em>highp</em>变量始终使用32位，<em>mediump</em>和<em>lowp</em>的要求更高。甚至可能所有值都是32位值，精度限定符没有实际效果。但是，嵌入式系统的GPU可能更有限。</p>
<p>精度限定符可用于任何变量声明，包括局部变量和函数参数。如果变量还有存储限定符，则存储限定符放在第一位。例如</p>
<div class="highlight"><pre><span></span><code><span class="nx">lowp</span><span class="w"> </span><span class="kr">int</span><span class="w"> </span><span class="nx">n</span><span class="p">;</span>
<span class="nx">varying</span><span class="w"> </span><span class="nx">highp</span><span class="w"> </span><span class="kr">float</span><span class="w"> </span><span class="nx">v</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">mediump</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">colors</span><span class="p">[</span><span class="mf">3</span><span class="p">];</span>
</code></pre></div>
<p>变化变量在顶点着色器和片段着色器中可以有不同的精度。顶点着色器中整数和浮点数的默认精度是<em>highp</em>。片段着色器不一定支持<em>highp</em>，尽管它们很可能会这样做，除非可能是在旧的移动硬件上。在片段着色器中，整数的默认精度是<em>mediump</em>，但浮点数没有默认精度。这意味着片段着色器中的每个浮点变量都必须显式分配精度。或者，可以使用语句为浮点数设置默认精度</p>
<div class="highlight"><pre><span></span><code><span class="nx">precision</span><span class="w"> </span><span class="nx">mediump</span><span class="w"> </span><span class="kr">float</span><span class="p">;</span>
</code></pre></div>
<p>这在<a href="../s2/">上一节</a>的每个片段着色器开头都使用了。当然，如果片段着色器确实支持highp，这会不必要地限制精度。你可以通过在片段着色器开头使用以下代码来避免这种情况：</p>
<div class="highlight"><pre><span></span><code><span class="cp">#ifdef GL_FRAGMENT_PRECISION_HIGH</span>
<span class="w">    </span><span class="n">precision</span><span class="w"> </span><span class="n">highp</span><span class="w"> </span><span class="kt">float</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="w">    </span><span class="n">precision</span><span class="w"> </span><span class="n">mediump</span><span class="w"> </span><span class="kt">float</span><span class="p">;</span>
<span class="cp">#endif</span>
</code></pre></div>
<p>如果可用，则将默认精度设置为<em>highp</em>，如果不可用，则设置为<em>mediump</em>。以"#"开头的行是预处理器指令——GLSL的一个方面，我不想深入。</p>
<hr />
<p>下一个限定符，<strong>invariant</strong>，更难以解释，它的用途也有限。不变性指的是当相同的表达式用于计算同一个变量的值（可能在不同的着色器中）时，分配给变量的值在两种情况下应该完全相同。这并不自动成立。例如，如果编译器在两个表达式中使用不同的优化或以不同的顺序评估操作数，得到的值可能会不同。变量上的不变性限定符将强制编译器对两个赋值语句使用完全相同的计算。这个限定符只能用在变化变量的声明上。它必须是声明中的第一个限定符。例如：</p>
<div class="highlight"><pre><span></span><code><span class="nx">invariant</span><span class="w"> </span><span class="nx">varying</span><span class="w"> </span><span class="nx">mediump</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">color</span><span class="p">;</span>
</code></pre></div>
<p>不变性限定符也可以用于使内置变量（如 <code>gl_Position</code> 和 <code>gl_FragCoord</code>）不变，使用如下语句：</p>
<div class="highlight"><pre><span></span><code><span class="nx">invariant</span><span class="w"> </span><span class="nx">gl_Position</span><span class="p">;</span>
</code></pre></div>
<p>在多阶段算法中，不变性可能很重要，该算法连续应用两个或更多的着色器程序来计算图像。例如，当两个着色器使用相同的表达式计算同一个顶点的 <code>gl_Position</code> 时，确保它们得到相同的结果是很重要的。在着色器中使 <code>gl_Position</code> 不变将确保这一点。</p>
<p>最后，"布局"（layout）限定符仅在3.00版本中可用。它可以用来指定属性变量的整型ID，作为使用 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 函数 <code>gl.getAttribLocation()</code> 查询ID的替代。例如：</p>
<div class="highlight"><pre><span></span><code><span class="nx">layout</span><span class="p">(</span><span class="nx">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">a_coords</span><span class="p">;</span><span class="w"> </span><span class="c1">// 仅限 GLSL ES 3.00 顶点着色器！</span>
</code></pre></div>
<p>在 <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 3.00 片段着色器中，如果有多个输出，也可以使用相同类型的布局限定符。在这种情况下，它指定了该变量应该使用的几个输出目标中的哪一个。</p>
<p>希望这些信息对你有所帮助。如果你有更多关于 <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> 或其他编程语言的问题，请随时提问。</p>
</div>
<div class="tabbed-block">
<p>Variable declarations can be modified by various qualifiers. You have seen examples of the qualifiers <em><abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr></em>, <em>uniform</em>, and <em>varying</em>. These are called <strong>storage qualifiers</strong>. The qualifiers <em><abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr></em> and <em>varying</em> do not exist in version 3.00; instead, an <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> is declared in the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> using the <abbr title="In GLSL, one of the following modifiers on a variable declaration: uniform, attribute, varying, or const.">storage qualifier</abbr> <em>in</em>, and a <abbr title="A variable that is used to communicate values from the vertex shader to the fragment shader in the WebGL or OpenGL ES 2.0 graphics pipeline. A varying variable is assigned a value in the vertex shader. The value of the variable in the fragment shader for a pixel in the primitive is obtained by interpolating the values from the vertices of the primitive. (In newer versions of GLSL, which support additional shader stages, the term &quot;varying variable&quot; is replaced by the more general terms &quot;in variable&quot; and &quot;out variable,&quot; which refer to variables that are used for input to or output from a shader.)">varying variable</abbr> is declared using <em>out</em> in the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> and in <em>in</em> the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr>. The <em>uniform</em> qualifier is used in both versions. Only global variables, not local variables in function definition, can be <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>, uniform, or varying variables.</p>
<p>The <em><abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr></em> qualifier can only be used in a <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 1.00 <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>, and it only applies to the built-in floating point types <strong><em>float</em></strong>, <em>vec2</em>, <em>vec3</em>, <em>vec4</em>, <em>mat2</em>, <em>mat3</em>, and <em>mat4</em>. (Matrix <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr> are not supported directly on the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side. A <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> has to be treated as a set of <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr>, one for each column. The <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> locations for the columns are successive integers, and the <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> function <em>gl.getAttribLocation</em> will return the location for the first column. Matrix <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr> would be rare, though perhaps useful for <abbr title="The ability to render multiple versions of a primitive with a single function call. Each copy can have its own values for certain attributes, such as color or transformation.">instanced drawing</abbr>, and I won't go into further detail about them here.)</p>
<p>In <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 3.00, the <em>in</em> qualifier on a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> variable defines it to be an <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> variable, and it can be applied to integer and unsigned integer scalars and vectors, as well as to the floating point types.</p>
<p>Also in <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 3.00, the <em>out</em> qualifier can be used on integer and floating point scalars and vectors in the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr>. In version 1.00, a <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> has the predefined variable <em>gl_FragColor</em> of type <strong><em>vec4</em></strong> to specify the color of the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>. In version 3.00, a <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> can have multiple outputs, and the outputs are not necessarily colors. Because the output type does not have to be <strong><em>vec4</em></strong>, it is not possible to have a predefined output variable. For now, we will only use one <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> output representing a color. So, a version 3.00 <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> will have one out variable of type <strong><em>vec4</em></strong>. (When we discuss framebuffers in <a href="../../c7/s4/">Section 7.4</a>, we will see how multiple outputs can be used.)</p>
<p>Both the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> and the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> can use <em>uniform</em> variables. The same variable can occur in both shaders, as long as the types in the two shaders are the same. Uniform variables can be of any type, including array and structure types. Now, <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> only has functions for setting uniform values that are scalar variables, vectors, or matrices. There are no functions for setting the values of structs or arrays. The solution to this problem requires treating every component of a struct or array as a separate uniform value. For example, consider the declarations</p>
<div class="highlight"><pre><span></span><code><span class="nx">struct</span><span class="w"> </span><span class="nx">LightProperties</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">position</span><span class="p">;</span>
<span class="w">    </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">color</span><span class="p">;</span>
<span class="w">    </span><span class="kr">float</span><span class="w"> </span><span class="nx">intensity</span><span class="p">;</span>
<span class="p">};</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">LightProperties</span><span class="w"> </span><span class="nx">light</span><span class="p">[</span><span class="mf">4</span><span class="p">];</span>
</code></pre></div>
<p>The variable <em>light</em> contains twelve basic values, which are of type <em>vec4</em>, <em>vec3</em>, or <em>float</em>. To work with the <em>light</em> uniform in <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr>, we need twelve variables to represent the locations of the 12 components of the <abbr title="Variables that represent input to a shader program in a programmable graphics pipeline. A uniform variable has the same value at every vertex and at every pixel of a primitive.">uniform variable</abbr>. When using <em>gl.getUniformLocation</em> to get the location of one of the 12 components, you need to give the full name of the component in the <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> program. For example: <em>gl.getUniformLocation(prog, "light[2].color")</em>. It is natural to store the 12 locations in an array of <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> objects that parallels the structure of the array of structs on the <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> side. Here is typical <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> code to create the structure and use it to initialize the uniform variables:</p>
<div class="highlight"><pre><span></span><code><span class="nx">lightLocations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Array</span><span class="p">(</span><span class="mf">4</span><span class="p">);</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">light</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">lightLocations</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">position</span><span class="o">:</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getUniformLocation</span><span class="p">(</span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;light[&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">&quot;].position&quot;</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="nx">color</span><span class="o">:</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getUniformLocation</span><span class="p">(</span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;light[&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">&quot;].color&quot;</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="nx">intensity</span><span class="o">:</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getUniformLocation</span><span class="p">(</span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;light[&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">&quot;].intensity&quot;</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">};</span>
<span class="p">}</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">light</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">uniform4f</span><span class="p">(</span><span class="w"> </span><span class="nx">lightLocations</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">position</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">uniform3f</span><span class="p">(</span><span class="w"> </span><span class="nx">lightLocations</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">color</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">uniform1f</span><span class="p">(</span><span class="w"> </span><span class="nx">lightLocations</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">intensity</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">);</span><span class="w">    </span>
<span class="p">}</span>
</code></pre></div>
<p>For uniform <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> variables that are matrices, the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> function that is used to set the value of the uniform is <em>gl.uniformMatrix2fv</em> for a <em>mat2</em>, <em>gl.uniformMatrix3fv</em> for a <em>mat3</em>, or <em>gl.uniformMatrix4fv</em> for a <em>mat4</em>. Even though the <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> is two-dimensional, the values are stored in a one dimensional array. The values are loaded into the array in <abbr title="Column-by-column ordering of the elements of a two-dimensional matrix; that is, an ordering that starts with the elements in the first column, followed by the elements in the second column, and so on. Column-major order is used for matrices in OpenGL and GLSL.">column-major order</abbr>. For example, if <em>transform</em> is a uniform <em>mat3</em> in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>, then <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> can set its value to be the <abbr title="The n-by-n identity matrix is an n-by-n matrix which has ones on the diagonal and zeros elsewhere. Multiplication of any matrix B by the identity matrix, in either order, leaves B unchanged. Multiplication of an n-dimensional vector by the n-by-n identity matrix leaves the vector unchanged; that is, the identity matrix is the matrix for the identity transformation.">identity matrix</abbr> with</p>
<div class="highlight"><pre><span></span><code><span class="nx">transformLoc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getUniformLocation</span><span class="p">(</span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;transform&quot;</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">uniformMatrix3fv</span><span class="p">(</span><span class="w"> </span><span class="nx">transformLoc</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>In Version 1.00, the second parameter <strong>must</strong> be false. In Version 3.00, the second parameter can be <em>true</em> to indicate that the entries of the <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> are provided in row-major rather than <abbr title="Column-by-column ordering of the elements of a two-dimensional matrix; that is, an ordering that starts with the elements in the first column, followed by the elements in the second column, and so on. Column-major order is used for matrices in OpenGL and GLSL.">column-major order</abbr>. Note that the 3 in <em>uniformMatrix3fv</em> refers to the number of rows and columns in the <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>, not to the length of the array, which must be 9. (By the way, it is OK to use a <abbr title="In JavaScript, an array type that is limited to holding numerical values of a single type. For example, the type Float32Array represents arrays that can hold 32-bit floating point values, and Uint8Array arrays can hold only 8-bit integer values. Such arrays are more efficient than general JavaScript arrays for numerical calculations. The were introduced into JavaScript along with HTML canvas graphics and WebGL.">typed array</abbr> rather than a normal <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> array for the value of a uniform.)</p>
<p>A <abbr title="A variable that is used to communicate values from the vertex shader to the fragment shader in the WebGL or OpenGL ES 2.0 graphics pipeline. A varying variable is assigned a value in the vertex shader. The value of the variable in the fragment shader for a pixel in the primitive is obtained by interpolating the values from the vertices of the primitive. (In newer versions of GLSL, which support additional shader stages, the term &quot;varying variable&quot; is replaced by the more general terms &quot;in variable&quot; and &quot;out variable,&quot; which refer to variables that are used for input to or output from a shader.)">varying variable</abbr> should be declared with the same name and type in both the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> and <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr>. In version 1.00, the <abbr title="In GLSL, one of the following modifiers on a variable declaration: uniform, attribute, varying, or const.">storage qualifier</abbr> for declaring varying variables is varying, and it can only be used for the built-in floating point types (<em>float</em>, <em>vec2</em>, <em>vec3</em>, <em>vec4</em>, <em>mat2</em>, <em>mat3</em>, and <em>mat4</em>) and for arrays of those types.</p>
<p>In version 3.00, a <abbr title="A variable that is used to communicate values from the vertex shader to the fragment shader in the WebGL or OpenGL ES 2.0 graphics pipeline. A varying variable is assigned a value in the vertex shader. The value of the variable in the fragment shader for a pixel in the primitive is obtained by interpolating the values from the vertices of the primitive. (In newer versions of GLSL, which support additional shader stages, the term &quot;varying variable&quot; is replaced by the more general terms &quot;in variable&quot; and &quot;out variable,&quot; which refer to variables that are used for input to or output from a shader.)">varying variable</abbr> can also be an integer or unsigned integer scalar or <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr>. But there is a complication because it doesn't make sense to apply <abbr title="Given values for some quantity at certain reference points, computing a value for that quantity at other points by some kind of averaging applied to the values at the reference points.">interpolation</abbr> to integer values. So, a <abbr title="A variable that is used to communicate values from the vertex shader to the fragment shader in the WebGL or OpenGL ES 2.0 graphics pipeline. A varying variable is assigned a value in the vertex shader. The value of the variable in the fragment shader for a pixel in the primitive is obtained by interpolating the values from the vertices of the primitive. (In newer versions of GLSL, which support additional shader stages, the term &quot;varying variable&quot; is replaced by the more general terms &quot;in variable&quot; and &quot;out variable,&quot; which refer to variables that are used for input to or output from a shader.)">varying variable</abbr> of integer type must be declared with the additional qualifier <em>flat</em>, which means it will not be interpolated. Instead, the value from the first <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> of a triangle or line segment will be used for every <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>. (Floating point varying variables can also, optionally, be declared as <em>flat</em>.) For example:</p>
<div class="highlight"><pre><span></span><code><span class="nx">flat</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nx">ivec3</span><span class="w"> </span><span class="nx">A</span><span class="p">;</span><span class="w">  </span><span class="c1">// GLSL ES 3.00 fragment shader only!</span>
</code></pre></div>
<p>Another possible <abbr title="In GLSL, one of the following modifiers on a variable declaration: uniform, attribute, varying, or const.">storage qualifier</abbr> is <em>const</em>, which means that the value of the variable cannot be changed after it has been initialized. The declaration of a <em>const</em> variable must include initialization.</p>
<hr />
<p>A variable declaration can also be modified by <strong>precision qualifiers</strong>. The possible precision qualifiers are <em>highp</em>, <em>mediump</em>, and <em>lowp</em>. A <abbr title="In GLSL, one of the following modifiers on a numeric variable declaration: lowp, mediump, or highp. A precision modifier specifies the minimum number of bits or range of values for the variable.">precision qualifier</abbr> sets the minimum range of possible values for an integer variable or the minimum range of values and number of decimal places for a floating point variable. <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> doesn't assign a definite meaning to the precision qualifiers, but mandates some minimum requirements. For example, in version 1.00, <em>lowp</em> integers must be able to represent values in at least the range −2<sup>8</sup> to 2<sup>8</sup>; mediump integers, in the range −2<sup>10</sup> to 2<sup>10</sup>; and <em>highp</em> integers, in the range −2<sup>16</sup> to 2<sup>16</sup>. For version 3.00, <em>highp</em> variables always use 32 bits, and the requirements for <em>mediump</em> and <em>lowp</em> are higher. It is even possible that all values are 32-bit values and the precision qualifiers have no real effect. But GPUs in embedded systems can be more limited.</p>
<p>A <abbr title="In GLSL, one of the following modifiers on a numeric variable declaration: lowp, mediump, or highp. A precision modifier specifies the minimum number of bits or range of values for the variable.">precision qualifier</abbr> can be used on any variable declaration, including local variables and function parameters. If the variable also has a <abbr title="In GLSL, one of the following modifiers on a variable declaration: uniform, attribute, varying, or const.">storage qualifier</abbr>, the <abbr title="In GLSL, one of the following modifiers on a variable declaration: uniform, attribute, varying, or const.">storage qualifier</abbr> comes first. For example</p>
<div class="highlight"><pre><span></span><code><span class="nx">lowp</span><span class="w"> </span><span class="kr">int</span><span class="w"> </span><span class="nx">n</span><span class="p">;</span>
<span class="nx">varying</span><span class="w"> </span><span class="nx">highp</span><span class="w"> </span><span class="kr">float</span><span class="w"> </span><span class="nx">v</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">mediump</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">colors</span><span class="p">[</span><span class="mf">3</span><span class="p">];</span>
</code></pre></div>
<p>A <abbr title="A variable that is used to communicate values from the vertex shader to the fragment shader in the WebGL or OpenGL ES 2.0 graphics pipeline. A varying variable is assigned a value in the vertex shader. The value of the variable in the fragment shader for a pixel in the primitive is obtained by interpolating the values from the vertices of the primitive. (In newer versions of GLSL, which support additional shader stages, the term &quot;varying variable&quot; is replaced by the more general terms &quot;in variable&quot; and &quot;out variable,&quot; which refer to variables that are used for input to or output from a shader.)">varying variable</abbr> can have different precisions in the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> and in the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr>. The default precision for integers and floats in the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> is <em>highp</em>. Fragment shaders are not required to support <em>highp</em>, although it is likely that they do so, except perhaps on older mobile hardware. In the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr>, the default precision for integers is <em>mediump</em>, but floats do not have a default precision. This means that every floating point variable in the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> has to be explicitly assigned a precision. Alternatively, it is possible to set a default precision for floats with the statement</p>
<div class="highlight"><pre><span></span><code><span class="nx">precision</span><span class="w"> </span><span class="nx">mediump</span><span class="w"> </span><span class="kr">float</span><span class="p">;</span>
</code></pre></div>
<p>This statement was used at the start of each of the fragment shaders in the <a href="../s2/">previous section</a>. Of course, if the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> does support highp, this restricts the precision unnecessarily. You can avoid that by using this code at the start of the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr>:</p>
<div class="highlight"><pre><span></span><code><span class="cp">#ifdef GL_FRAGMENT_PRECISION_HIGH</span>
<span class="w">    </span><span class="n">precision</span><span class="w"> </span><span class="n">highp</span><span class="w"> </span><span class="kt">float</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="w">    </span><span class="n">precision</span><span class="w"> </span><span class="n">mediump</span><span class="w"> </span><span class="kt">float</span><span class="p">;</span>
<span class="cp">#endif</span>
</code></pre></div>
<p>This sets the default precision to <em>highp</em> if it is available and to <em>mediump</em> if not. The lines starting with "#" are preprocessor directives—an aspect of <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> that I don't want to get into.</p>
<hr />
<p>The next qualifier, <strong>invariant</strong>, is even more difficult to explain, and it has only a limited use. Invariance refers to the requirement that when the same expression is used to compute the value of the same variable (possibly in different shaders), then the value that is assigned to the variable should be exactly the same in both cases. This is not automatically the case. For example, the values can be different if a compiler uses different optimizations or evaluates the operands in a different order in the two expressions. The <abbr title="In GLSL, a modifier that ensures that when the same expression is used to compute the value of a variable in two different shaders, the value will be the same in both shaders. This can be important for multi-pass algorithms, where several shader programs are applied in succession to render one image.">invariant qualifier</abbr> on the variable will force the compiler to use exactly the same calculations for the two assignment statements. The qualifier can only be used on declarations of varying variables. It must be the first qualifier in the declaration. For example,</p>
<div class="highlight"><pre><span></span><code><span class="nx">invariant</span><span class="w"> </span><span class="nx">varying</span><span class="w"> </span><span class="nx">mediump</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">color</span><span class="p">;</span>
</code></pre></div>
<p>It can also be used to make the predefined variables such as gl_Position and gl_FragCoord invariant, using a statement such as</p>
<div class="highlight"><pre><span></span><code><span class="nx">invariant</span><span class="w"> </span><span class="nx">gl_Position</span><span class="p">;</span>
</code></pre></div>
<p>Invariance can be important in a <strong><abbr title="A rendering algorithm that draws a scene several times and combines the results somehow to compute the final image. A simple example is anaglyph stereo, in which a left-eye and right-eye image of the scene are rendered separately and combined.">multi-pass algorithm</abbr></strong> that applies two or more <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> programs in succession to compute an image. It is important, for example, that both shaders get the same answer when they compute gl_Position for the same <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>, using the same expression in both <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> shaders. Making <em>gl_Position</em> invariant in the shaders will ensure that.</p>
<hr />
<p>The last type of qualifier, a "layout" qualifier, is only available in version 3.00. It can be used to specify the integer ID of an <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> variable, as an alternative to using the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> function <em>gl.getAttribLocation()</em> to query the ID. An example would be</p>
<div class="highlight"><pre><span></span><code><span class="nx">layout</span><span class="p">(</span><span class="nx">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">a_coords</span><span class="p">;</span><span class="w"> </span><span class="c1">// GLSL ES 3.00 vertex shader only!</span>
</code></pre></div>
<p>The same kind of layout qualifier can be used on an <em>out</em> variable in a <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 3.00 <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> that has multiple outputs. In that case, it specifies which of several output destinations should be used for that variable.</p>
</div>
</div>
</div>
<h2 id="634-表达式">6.3.4 表达式<a class="headerlink" href="#634-表达式" title="Permanent link">&para;</a></h2>
<p><strong>Expressions</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="5:2"><input checked="checked" id="__tabbed_5_1" name="__tabbed_5" type="radio" /><input id="__tabbed_5_2" name="__tabbed_5" type="radio" /><div class="tabbed-labels"><label for="__tabbed_5_1">中文</label><label for="__tabbed_5_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>在GLSL中，表达式可以使用算术运算符+、-、<em>、/、++和--，用于整数和浮点数值。在3.00版本中，还为整数类型提供了余数运算符%，以及左移和右移位运算符和位逻辑运算符。表达式中没有自动类型转换。如果</em>x<em>是</em><strong>float</strong><em>类型，表达式x+1是非法的。你必须说</em>x+1.0<em>或</em>x+float(1)*。</p>
<p>算术运算符已经以各种方式扩展，以适应向量和矩阵运算。如果你使用<em>来乘以一个矩阵和一个向量，无论是哪种顺序，它都会以线性代数的方式进行乘法，得到一个向量作为结果。操作数的类型必须以显而易见的方式匹配；例如，</em>vec3<em>只能与</em>mat3<em>相乘，结果是</em>vec3<em>。当用于两个相同大小的矩阵时，</em>执行矩阵乘法。</p>
<p>如果对具有相同基本类型的向量和标量使用+、-、<em>或/，则对向量的每个元素执行操作。例如，</em>vec2(3.0,3.0) / 2.0<em>是向量</em>vec2(1.5,1.5)<em>，</em>2<em>ivec3(1,2,3)</em>是向量<em>ivec3(2,4,6)</em>。当这些运算符应用于两个相同类型的向量时，对每对分量执行操作，结果是向量。例如，表达式的值</p>
<div class="highlight"><pre><span></span><code><span class="nx">vec3</span><span class="p">(</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="p">,</span><span class="w"> </span><span class="mf">3.0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">vec3</span><span class="p">(</span><span class="w"> </span><span class="mf">4.2</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mf">7.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.7</span><span class="w"> </span><span class="p">)</span>
</code></pre></div>
<p>是向量<em>vec3(5.2,-5.0,4.7)</em>。特别注意，通常的向量运算操作——向量的加法和减法、向量乘以标量、向量乘以矩阵——在GLSL中以自然的方式书写。</p>
<p>关系运算符&lt;、&gt;、&lt;=和&gt;=只能应用于整数和浮点标量，两个操作数的类型必须完全匹配。然而，等式运算符==和!=已扩展到适用于除采样器类型之外的所有内置类型。两个向量只有在相应的分量对都相等时才相等。矩阵也是如此。等式运算符不能用于数组，但它们适用于结构体，只要结构体不包含任何数组或采样器；同样，两个结构体中的每对成员必须相等，结构体才被视为相等。</p>
<p>GLSL有逻辑运算符!、&amp;&amp;、||和^^（最后一个是异或操作）。操作数必须是<strong><em>bool</em></strong>类型。</p>
<p>最后，还有赋值运算符=、+=、-=、*=和/=，具有通常的含义。</p>
<hr />
<p>GLSL还有大量的预定义函数，我在这里无法全部讨论。我将在这里提到的所有函数都需要浮点值作为参数，即使该函数对整数值也有意义。</p>
<p>也许最有趣的是向量代数函数。见<a href="../../c3/s5/">第3.5节</a>了解这些运算的定义。这些函数有简单的公式，但它们作为函数提供是为了方便，并且因为它们可能在GPU中有高效的硬件实现。函数<em>dot(x,y)</em>计算两个长度相同的向量的点积<em>x·y</em>。返回值是<em>float</em>；<em>cross(x,y)</em>计算叉积<em>x×y</em>，参数和返回值类型为<em>vec3</em>；<em>length(x)</em>是向量<em>x</em>的长度，<em>distance(x,y)</em>给出两个向量之间的距离；<em><abbr title="将非零向量除以其长度得到的单位向量的结果，即长度为一的向量。注意，“归一化向量”和“法向量”是两个无关的术语！">normalize</abbr>(x)</em>返回指向与x相同方向的单位向量。还有名为<em>reflect</em>和<em>refract</em>的函数，可以用来计算反射和折射光线的方向；我将在需要使用它们时介绍。</p>
<p>函数<em>mix(x,y,t)</em>计算<em>x</em>(1−t) + y<em>t。如果t是一个在0.0到1.0范围内的float，那么返回值是x和y的线性混合或加权平均。这个函数可能用于例如两种颜色的alpha混合。函数</em>clamp(x,low,high)<em>将</em>x<em>限制在</em>low<em>到</em>high<em>的范围内；返回值可以计算为</em>min(max(x,low),high)<em>。如果</em>rgb*是一个表示颜色的向量，我们可以通过命令</p>
<div class="highlight"><pre><span></span><code><span class="nx">rgb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">clamp</span><span class="p">(</span><span class="w"> </span><span class="nx">rgb</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>确保向量的所有分量都在0到1的范围内。</p>
<p>如果<em>s</em>和<em>t</em>是float，且<em>s &lt; t</em>，那么<em>smoothstep(s,t,x)</em>在<em>x</em>小于s时返回0.0，在<em>x</em>大于t时返回1.0。对于<em>x</em>在<em>s</em>和<em>t</em>之间的值，返回值从0.0到1.0平滑插值。以下是一个示例，可能在片段着色器中用于渲染启用透明度的<em>gl.POINTS</em>原语：</p>
<div class="highlight"><pre><span></span><code><span class="kr">float</span><span class="w"> </span><span class="nx">dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">distance</span><span class="p">(</span><span class="w"> </span><span class="nx">gl_PointCoord</span><span class="p">,</span><span class="w"> </span><span class="nx">vec2</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="kr">float</span><span class="w"> </span><span class="nx">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">smoothstep</span><span class="p">(</span><span class="w"> </span><span class="mf">0.45</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="nx">dist</span><span class="w"> </span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">alpha</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">discard</span><span class="p">;</span><span class="w"> </span><span class="c1">// 丢弃完全透明的像素</span>
<span class="p">}</span>
<span class="nx">gl_FragColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="nx">alpha</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>这将把点渲染成一个红色的圆盘，颜色从圆盘边缘的不透明到透明平滑过渡，随着<em>dist</em>从0.45增加到0.5。注意，对于函数<em>mix</em>、<em>clamp</em>和<em>smoothstep</em>，<em>x</em>和<em>y</em>参数可以是向量，也可以是float。在这种情况下，它们分别对向量的每个分量进行操作。</p>
<p>GLSL提供了通常的数学函数，包括<em>sin</em>、<em>cos</em>、<em>tan</em>、<em>asin</em>、<em>acos</em>、<em>atan</em>、<em>log</em>、<em>exp</em>、<em>pow</em>、<em>sqrt</em>、<em>abs</em>、<em>floor</em>、<em>ceil</em>、<em>min</em>和<em>max</em>。（在3.00版本中，abs、min和max也适用于整数类型。）对于这些函数，参数可以是任何<strong><em>float</em></strong>、<em>vec2</em>、<em>vec3</em>或<em>vec4</em>类型。返回值是相同类型，并且分别对每个分量应用函数。例如，<em>sqrt(vec3(16.0,9.0,4.0))</em>的值是向量<em>vec3(4.0,3.0,2.0)</em>。对于<em>min</em>和<em>max</em>，还有一个第二个版本的函数，其中第一个参数是向量，第二个参数是<strong><em>float</em></strong>。对于这些版本，向量的每个分量都与float进行比较；例如，<em>max(vec3(1.0,2.0,3.0),2.5)</em>是<em>vec3(2.5,2.5,3.0)</em>。</p>
<p>函数<em>mod(x,y)</em>计算余数，当<em>x</em>除以<em>y</em>时。返回值计算为<em>x − y</em>floor(x/y)<em>。与</em>min<em>和</em>max<em>一样，</em>y<em>可以是向量或float。</em>mod*函数可以用作%运算符的替代品，后者在GLSL ES 1.00中不受支持。</p>
<p>还有用于处理采样器变量的函数。我将在下一部分中讨论其中的一些。</p>
</div>
<div class="tabbed-block">
<p>Expressions in <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> can use the arithmetic operators +, −, *, /, ++ and −− for integer and floating point values. In version 3.00, the remainder operator, %, as well as left and right shift and bitwise logical operators, are also available for integer types. There is no automatic type conversion in expressions. If <em>x</em> is of type <strong><em>float</em></strong>, the expression x+1 is illegal. You have to say <em>x+1.0</em> or <em>x+float(1)</em>.</p>
<p>The arithmetic operators have been extended in various ways to work with vectors and matrices. If you use * to multiply a <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> and a <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr>, in either order, it multiplies them in the <abbr title="The field of mathematics that studies vector spaces and linear transformations between them. Linear algebra is part of the essential mathematical foundation of computer graphics.">linear algebra</abbr> sense, giving a <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> as the result. The types of the operands must match in the obvious way; for example, a <em>vec3</em> can only be multiplied by a <em>mat3</em>, and the result is a <em>vec3</em>. When used with two matrices of the same size, * does <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> multiplication.</p>
<p>If +, −, *, or \/ is used on a <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> and a scalar of the same basic type, then the operation is performed on each element of the <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr>. For example, <em>vec2(3.0,3.0) / 2.0</em> is the <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> <em>vec2(1.5,1.5)</em>, and <em>2</em>ivec3(1,2,3)<em> is the <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> </em>ivec3(2,4,6)*. When one of these operators is applied to two vectors of the same type, the operation is applied to each pair of components, and the result is a <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr>. For example, the value of</p>
<div class="highlight"><pre><span></span><code><span class="nx">vec3</span><span class="p">(</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="p">,</span><span class="w"> </span><span class="mf">3.0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">vec3</span><span class="p">(</span><span class="w"> </span><span class="mf">4.2</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mf">7.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.7</span><span class="w"> </span><span class="p">)</span>
</code></pre></div>
<p>is the <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> <em>vec3(5.2,-5.0,4.7)</em>. Note in particular that the usual <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> arithmetic operations—addition and subtraction of vectors, multiplication of a <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> by a scalar, and multiplication of a <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> by a <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>—are written in the natural way is <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr>.</p>
<p>The relational operators &lt;, &gt;, &lt;=, and &gt;= can only be applied to integer and floating point scalars, and the types of the two operands must match exactly. However, the equality operators == and != have been extended to work on all of the built-in types except sampler types. Two vectors are equal only if the corresponding pairs of components are all equal. The same is true for matrices. The equality operators cannot be used with arrays, but they do work for structs, as long as the structs don't contain any arrays or samplers; again, every pair of members in two structs must be equal for the structs to be considered equal.</p>
<p><abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> has logical operators !, &amp;&amp;, ||, and ^^ (the last one being an exclusive or operation). The operands must be of type <strong><em>bool</em></strong>.</p>
<p>Finally, there are the assignment operators =, +=, −=, *=, and /=, with the usual meanings.</p>
<hr />
<p><abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> also has a large number of predefined functions, more than I can discuss here. All of the functions that I will mention here require floating-point values as parameters, even if the function would also make sense for integer values.</p>
<p>Most interesting, perhaps, are functions for <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> algebra. See <a href="../../c3/s5/">Section 3.5</a> for the definitions of these operations. These functions have simple formulas, but they are provided as functions for convenience and because they might have efficient hardware implementations in a <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>. The function <em>dot(x,y)</em> computes the <abbr title="The dot product of two vectors is the sum of the products of corresponding coordinates. For 3D vectors `v=(x,y,z)` and `w=(a,b,c)`, the dot product of v and w is `x*a+y*b+z*c`. The dot product is equal to the cosine of the angle between the vectors, divided by the product of their lengths.">dot product</abbr> <em>x·y</em> of two vectors of the same length. The return value is a <em>float</em>; <em>cross(x,y)</em> computes the <abbr title="A vector product of two 3D vectors. The cross product of v and w is a vector that is perpendicular to both v and w and whose length is equal to the absolute value of the sine of the angle between v and w. If v=(x,y,z) and w=(a,b,c), then their cross product is the vector (yc-zb,za-xc,xb-ya).">cross product</abbr> <em>x×y</em>, where the parameters and return value are of type <em>vec3</em>; <em>length(x)</em> is the length of the <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> <em>x</em> and <em>distance(x,y)</em> gives the distance between two vectors; <em><abbr title="将非零向量除以其长度得到的单位向量的结果，即长度为一的向量。注意，“归一化向量”和“法向量”是两个无关的术语！">normalize</abbr>(x)</em> returns a <abbr title="A vector of length one.">unit vector</abbr> that points in the same direction as x. There are also functions named <em>reflect</em> and <em>refract</em> that can be used to compute the direction of reflected and refracted light rays; I will cover them when I need to use them.</p>
<p>The function <em>mix(x,y,t)</em> computes <em>x*(1−t) + y*t</em>. If t is a float in the range 0.0 to 1.0, then the return value is a linear mixture, or weighted average, of x and y. This function might be used, for example, to do <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr>-blending of two colors. The function <em>clamp(x,low,high)</em> clamps <em>x</em> to the range <em>low</em> to <em>high</em>; the return value could be computed as <em>min(max(x,low),high)</em>. If <em>rgb</em> is a <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> representing a color, we could ensure that all of the components of the <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> lie in the range 0 to 1 with the command</p>
<div class="highlight"><pre><span></span><code><span class="nx">rgb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">clamp</span><span class="p">(</span><span class="w"> </span><span class="nx">rgb</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>If <em>s</em> and <em>t</em> are floats, with <em>s &lt; t</em>, then <em>smoothstep(s,t,x)</em> returns 0.0 for <em>x</em> less than s and returns 1.0 for <em>x</em> greater than <em>t</em>. For values of <em>x</em> between <em>s</em> and <em>t</em>, the return value is smoothly interpolated from 0.0 to 1.0. Here is an example that might be used in a <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> for <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> a <em>gl.POINTS</em> primitive, with transparency enabled:</p>
<div class="highlight"><pre><span></span><code><span class="kr">float</span><span class="w"> </span><span class="nx">dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">distance</span><span class="p">(</span><span class="w"> </span><span class="nx">gl_PointCoord</span><span class="p">,</span><span class="w"> </span><span class="nx">vec2</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="kr">float</span><span class="w"> </span><span class="nx">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">smoothstep</span><span class="p">(</span><span class="w"> </span><span class="mf">0.45</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="nx">dist</span><span class="w"> </span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">alpha</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">discard</span><span class="p">;</span><span class="w"> </span><span class="c1">// discard fully transparent pixels</span>
<span class="p">}</span>
<span class="nx">gl_FragColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="nx">alpha</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>This would render the point as a red disk, with the color fading smoothly from opaque to transparent around the edge of the disk, as <em>dist</em> increases from 0.45 to 0.5. Note that for the functions <em>mix</em>, <em>clamp</em>, and <em>smoothstep</em>, the <em>x</em> and <em>y</em> parameters can be vectors as well as floats. In that case, they operate on each component of the <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> individually.</p>
<p>The usual mathematical functions are available in <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr>, including <em>sin</em>, <em>cos</em>, <em>tan</em>, <em>asin</em>, <em>acos</em>, <em>atan</em>, <em>log</em>, <em>exp</em>, <em>pow</em>, <em>sqrt</em>, <em>abs</em>, <em>floor</em>, <em>ceil</em>, <em>min</em>, and <em>max</em>. (In version 3.00, abs, min, and max also apply to integer types.) For these functions, the parameters can be any of the types <strong><em>float</em></strong>, <em>vec2</em>, <em>vec3</em>, or <em>vec4</em>. The return value is of the same type, and the function is applied to each component separately. For example, the value of <em>sqrt(vec3(16.0,9.0,4.0))</em> is the <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> <em>vec3(4.0,3.0,2.0)</em>. For <em>min</em> and <em>max</em>, there is also a second version of the function in which the first parameter is a <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> and the second parameter is a <strong><em>float</em></strong>. For those versions, each component of the <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> is compared to the float; for example, <em>max(vec3(1.0,2.0,3.0),2.5)</em> is <em>vec3(2.5,2.5,3.0)</em>.</p>
<p>The function <em>mod(x,y)</em> computes the modulus, or remainder, when <em>x</em> is divided by <em>y</em>. The return value is computed as <em>x − y</em>floor(x/y)<em>. As with </em>min<em> and </em>max<em>, </em>y<em> can be either a <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> or a float. The </em>mod* function can be used as a substitute for the % operator, which is not supported in <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 1.00.</p>
<p>There are also functions for working with <abbr title="In GLSL, a variable in a shader program that can be used to do lookup in an image texture. The value of a sampler variable specifies the texture unit that will be used to do the lookup. In WebGL, sampler variables are of type &quot;sampler2D&quot; or &quot;samplerCube.&quot;">sampler variables</abbr>. I will discuss some of them in the next section.</p>
</div>
</div>
</div>
<h2 id="635-函数定义">6.3.5 函数定义<a class="headerlink" href="#635-函数定义" title="Permanent link">&para;</a></h2>
<p><strong>Function Definitions</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="6:2"><input checked="checked" id="__tabbed_6_1" name="__tabbed_6" type="radio" /><input id="__tabbed_6_2" name="__tabbed_6" type="radio" /><div class="tabbed-labels"><label for="__tabbed_6_1">中文</label><label for="__tabbed_6_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>GLSL程序可以定义新函数，语法与C语言类似。与C语言不同，函数名称可以重载；也就是说，两个函数可以有相同的名称，只要它们有不同的参数数量或类型。在使用函数之前必须先声明它。像在C语言中一样，可以通过给出完整的定义或函数原型来声明它。</p>
<p>函数参数可以是任何类型。函数的返回类型可以是除数组类型之外的任何类型。结构体类型可以作为返回类型，只要结构体中不包含任何数组。当数组作为形式参数使用时，必须通过整型常量指定数组的长度。例如：</p>
<div class="highlight"><pre><span></span><code><span class="kt">float</span><span class="w"> </span><span class="nf">arraySum10</span><span class="p">(</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>函数参数可以通过限定符<em>in</em>、<em>out</em>或<em>inout</em>进行修改。如果没有指定限定符，默认为<em>in</em>。限定符表示参数是用于函数的输入、函数的输出，还是两者兼有。对于输入参数，函数调用中实际参数的值会复制到函数定义中的形式参数，并且形式参数和实际参数之间没有进一步的交互。对于输出参数，当函数返回时，形式参数的值会复制到实际参数。对于<em>inout</em>参数，值会在两个方向上复制。这种类型的参数传递被称为“按值/返回调用”。注意，对于输出或<em>inout</em>参数，实际参数必须是可以赋值的东西，比如变量或swizzler（C、Java和JavaScript中的所有参数都是输入参数，但将指针作为参数传递可以具有类似于<em>inout</em>参数的效果。当然，GLSL没有指针）。例如：</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">cumulativeSum</span><span class="p">(</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="mi">10</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="mi">-1</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>请注意，GLSL中的函数不支持递归。</p>
</div>
<div class="tabbed-block">
<p>A <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> program can define new functions, with a syntax similar to C. Unlike C, function names can be overloaded; that is, two functions can have the same name, as long as they have different numbers or types of parameters. A function must be declared before it is used. As in C, it can be declared by giving either a full definition or a function prototype.</p>
<p>Function parameters can be of any type. The return type for a function can be any type except for array types. A struct type can be a return type, as long as the structure does not include any arrays. When an array is used a formal parameter, the length of the array must be specified by an integer constant. For example,</p>
<div class="highlight"><pre><span></span><code><span class="kt">float</span><span class="w"> </span><span class="nf">arraySum10</span><span class="p">(</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="kt">float</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
<span class="k">return</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Function parameters can be modified by the qualifiers <em>in</em>, <em>out</em>, or <em>inout</em>. The default, if no qualifier is specified, is <em>in</em>. The qualifier indicates whether the parameter is used for input to the function, output from the function, or both. For input parameters, the value of the actual parameter in the function call is copied into the formal parameter in the function definition, and there is no further interaction between the formal and actual parameters. For output parameters, the value of the formal parameter is copied to the actual parameter when the function returns. For an <em>inout</em> parameter, the value is copied in both directions. This type of parameter passing is referred to as "call by value/return." Note that the actual parameter for an out or <em>inout</em> parameter must be something to which a value can be assigned, such as a variable or <abbr title="In GLSL and WGSL, a notation such as v.yzx, where v is a vector and v.yzx represents the three-component vector made up of the y, z, and x components of v. Technically, any use of the dot notation with vectors is considered to be a swizzler.">swizzler</abbr>. (All parameters in C, Java, and <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> are input parameters, but passing a pointer as a parameter can have an effect similar to an <em>inout</em> parameter. <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr>, of course, has no pointers.) For example,</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">cumulativeSum</span><span class="p">(</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="mi">10</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="mi">-1</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Note that recursion is not supported for functions in <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr>.</p>
</div>
</div>
</div>
<h2 id="636-控制结构">6.3.6 控制结构<a class="headerlink" href="#636-控制结构" title="Permanent link">&para;</a></h2>
<p><strong>Control Structures</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="7:2"><input checked="checked" id="__tabbed_7_1" name="__tabbed_7" type="radio" /><input id="__tabbed_7_2" name="__tabbed_7" type="radio" /><div class="tabbed-labels"><label for="__tabbed_7_1">中文</label><label for="__tabbed_7_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>在WebGL的GLSL ES 1.00中，唯一的控制结构是<em>if</em>语句和非常受限形式的<em>for</em>循环。没有<em>while</em>或<em>do..while</em>循环，也没有<em>switch</em>语句。然而，<abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 3.00支持所有这些。</p>
<p><em>if</em>语句支持C语言的完整语法，包括<em>else</em>和<em>else if</em>。在3.00版本中，所有控制结构的语法与C语言几乎相同。</p>
<p>在1.00版本着色器中的<em>for</em>循环，循环控制变量必须在循环中声明，并且必须是<strong><em>int</em></strong>或<strong><em>float</em></strong>类型。循环控制变量的初始值必须是常量表达式（即，它可以包含运算符，但所有操作数必须是字面量常量或<em>const</em>变量）。循环内的代码不允许更改循环控制变量的值。结束循环的测试只能有形式<em>var op expression</em>，其中var是循环控制变量，op是关系或等式运算符之一，expression是常量表达式。最后，更新表达式必须具有<em>var++</em>、<em>var--</em>、<em>var+=expression</em>或<em>var-=expression</em>的形式，其中<em>var</em>是循环控制变量，<em>expression</em>是常量表达式。当然，这是其他语言中<em>for</em>循环最典型的形式。一些合法的<em>for</em>循环的首行示例：</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mf">0.1</span><span class="p">)</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
</code></pre></div>
<p>在3.00版本中，这些限制不适用。请注意，所有循环都可以包含<em>break</em>和<em>continue</em>语句。</p>
</div>
<div class="tabbed-block">
<p>The only control structures in <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 1.00 for <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> are the <em>if</em> statement and a very restricted form of the <em>for</em> loop. There is no <em>while</em> or <em>do..while</em> loop, and there is no <em>switch</em> statement. However, all of these are supported in <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 3.00.</p>
<p><em>If</em> statements are supported with the full syntax from C, including <em>else</em> and else <em>if</em>. In version 3.00, the syntax for all control structures is pretty much the same as in C.</p>
<p>In a <em>for</em> loop in a version 1.00 <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>, the loop control variable must be declared in the loop, and it must be of type <strong><em>int</em></strong> or <strong><em>float</em></strong>. The initial value for the loop control variable must be a constant expression (that is, it can include operators, but all the operands must be literal constants or <em>const</em> variables) The code inside the loop is not allowed to change the value of the loop control variable. The test for ending the loop can only have the form <em>var op expression</em>, where var is the loop control variable, the op is one of the relational or equality operators, and the expression is a constant expression. Finally, the update expression must have one of the forms <em>var++</em>, <em>var--</em>, <em>var+=expression</em>, or <em>var-=expression</em>, where <em>var</em> is the loop control variable, and <em>expression</em> is a constant expression. Of course, this is the most typical form for <em>for</em> loops in other languages. Some examples of legal first lines for <em>for</em> loops:</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mf">0.1</span><span class="p">)</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
</code></pre></div>
<p>In version 3.00, these restrictions do not apply. Note that all loops can include break and continue statements.</p>
</div>
</div>
</div>
<h2 id="637-限制">6.3.7 限制<a class="headerlink" href="#637-限制" title="Permanent link">&para;</a></h2>
<p><strong>Limits</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="8:2"><input checked="checked" id="__tabbed_8_1" name="__tabbed_8" type="radio" /><input id="__tabbed_8_2" name="__tabbed_8" type="radio" /><div class="tabbed-labels"><label for="__tabbed_8_1">中文</label><label for="__tabbed_8_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>WebGL对WebGL及其GLSL程序使用的某些资源设置了限制，例如属性变量的数量或纹理图像的大小。这些限制在许多情况下是由于GPU的硬件限制，它们取决于程序运行的设备以及该设备上WebGL的实现。移动设备（如平板电脑和手机）的硬件限制可能较低，但现代平板电脑和手机拥有相当令人印象深刻的GPU。尽管这些限制可能有所不同，但WebGL规定了所有实现都必须满足的一组最低要求。我将给出WebGL 1.0的最低值。<abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0的最低值更高。</p>
<p>例如，任何WebGL实现都必须允许在顶点着色器中至少有8个属性。特定实现的实际限制可能更多，但不能更少。实际限制在GLSL程序中作为预定义常量<em>gl_MaxVertexAttribs</em>的值提供。更方便的是，在JavaScript方面，它作为表达式的值提供</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">getParameter</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">MAX_VERTEX_ATTRIBS</span><span class="w"> </span><span class="p">)</span>
</code></pre></div>
<p>类型为<em>float</em>、<em>vec2</em>、<em>vec3</em>和<em>vec4</em>的属性变量都计为对限制的一个属性。对于矩阵值属性，每个列在限制方面都计为单独的属性。</p>
<p>类似地，变化变量有限制，并且在顶点和片段着色器中对统一变量有单独的限制。（限制是针对四个分量的“<abbr title="向量空间中的元素。向量空间的元素可以相加，并且可以乘以常数。对于计算机图形，向量只是包含两个、三个或四个数字的列表或数组。在这个意义上，向量通常用于表示2D、3D或4D空间中的点。然而，准确地说，向量表示具有长度和方向的数量；以这种方式使用的向量可以被可视化为箭头。">向量</abbr>”的数量。可以将单独的变量打包到一个向量中，但使用的打包不必是最优的。属性变量不执行打包。）限制必须满足</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl_MaxVertexAttribs</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">8</span><span class="p">;</span>
<span class="nx">gl_MaxVertexUniformVectors</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">128</span><span class="p">;</span>
<span class="nx">gl_MaxFragmentUniformVectors</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">16</span><span class="p">;</span>
<span class="nx">gl_MaxVaryingVectors</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">8</span><span class="p">;</span>
</code></pre></div>
<p>GLSL中还有纹理单元的数量限制，这基本上意味着可以同时使用的纹理数量。这些限制必须满足</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl_MaxTextureImageUnits</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">8</span><span class="p">;</span><span class="w">         </span><span class="c1">// 片段着色器的限制</span>
<span class="nx">gl_MaxVertexTextureImageUnits</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w">   </span><span class="c1">// 顶点着色器的限制</span>
<span class="nx">gl_MaxCombinedTextureImageUnits</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">8</span><span class="p">;</span><span class="w"> </span><span class="c1">// 两个着色器的总限制</span>
</code></pre></div>
<p>纹理通常在片段着色器中使用，但有时在顶点着色器中也可能有用。但请注意，<em>gl_MaxVertexTextureImageUnits</em>可以是零，这意味着实现不需要允许在顶点着色器中使用纹理单元。（这种可能性仅适用于WebGL 1.0。）</p>
<p>还有其他事情的限制，包括视口大小、纹理图像大小、线原语的线宽和<em>POINTS</em>原语的点大小。所有限制都可以使用<em>gl.getParameter()</em>从JavaScript方面查询。</p>
<p>以下演示显示了您正在查看此页面的设备上资源限制的实际值。演示显示了WebGL 1.0图形上下文的限制。您可以使用它来检查您希望您的WebGL程序运行的各种设备的功能。通常，实际限制将明显大于所需的最小值值。</p>
<p><iframe src="../../../en/demos/c6/webgl-limits.html" width="600" height="380"></iframe></p>
</div>
<div class="tabbed-block">
<p><abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> puts limits on certain resources that are used by <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> and its <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> programs, such as the number of <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> variables or the size of a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image. The limits are due in many cases to hardware limits in the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>, and they depend on the device on which the program is running, and on the implementation of <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> on that device. The hardware limits can be lower on mobile devices such as tablets and phones, but modern tablets and phones have pretty impressive GPUs. Although the limits can vary, <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> imposes a set of minimum requirements that all implementations must satisfy. I will give the minimums for <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0. The minimums for <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 are greater.</p>
<p>For example, any <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> implementation must allow at least 8 <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr> in a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>. The actual limit for a particular implementation might be more, but cannot be less. The actual limit is available in a <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> program as the value of a predefined constant, <em>gl_MaxVertexAttribs</em>. More conveniently, it is available on the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side as the value of the expression</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">getParameter</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">MAX_VERTEX_ATTRIBS</span><span class="w"> </span><span class="p">)</span>
</code></pre></div>
<p>Attribute variables of type <em>float</em>, <em>vec2</em>, <em>vec3</em>, and <em>vec4</em> all count as one <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> against the limit. For a <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>-valued <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>, each column counts as a separate <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> as far as the limit goes.</p>
<p>Similarly, there are limits on varying variables, and there are separate limits on uniform variables in the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> and fragment shaders. (The limits are on the number of four-component "vectors." There can be some packing of separate variables into a single <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr>, but the packing that is used does not have to be optimal. No packing is done for <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> variables.) The limits must satisfy</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl_MaxVertexAttribs</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">8</span><span class="p">;</span>
<span class="nx">gl_MaxVertexUniformVectors</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">128</span><span class="p">;</span>
<span class="nx">gl_MaxFragmentUniformVectors</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">16</span><span class="p">;</span>
<span class="nx">gl_MaxVaryingVectors</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">8</span><span class="p">;</span>
</code></pre></div>
<p>There are also limits in <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> on the number of <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> units, which means essentially the number of textures that can be used simultaneously. These limits must satisfy</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl_MaxTextureImageUnits</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">8</span><span class="p">;</span><span class="w">         </span><span class="c1">// limit for fragment shader</span>
<span class="nx">gl_MaxVertexTextureImageUnits</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w">   </span><span class="c1">// limit for vertex shader</span>
<span class="nx">gl_MaxCombinedTextureImageUnits</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">8</span><span class="p">;</span><span class="w"> </span><span class="c1">// total limit for both shaders</span>
</code></pre></div>
<p>Textures are usually used in fragment shaders, but they can sometimes be useful in <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> shaders. Note however, that <em>gl_MaxVertexTextureImageUnits</em> can be zero, which means that implementations are not required to allow <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> units to be used in <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> shaders. (This possibility is for <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 only.)</p>
<p>There are also limits on other things, including <abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr> size, <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image size, line width for line primitives, and point size for the <em>POINTS</em> primitive. All of the limits can be queried from the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side using <em>gl.getParameter()</em>.</p>
<p>The following demo shows the actual values of the resource limits on the device on which you are <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> this page. The demo shows the limits for a <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 graphics context. You can use it to check the capabilities of various devices on which you want your <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> programs to run. In general, the actual limits will be significantly larger than the required minimum values.</p>
<p><iframe src="../../../en/demos/c6/webgl-limits.html" width="600" height="380"></iframe></p>
</div>
</div>
</div>







  
    
  
  
    
  


  <aside class="md-source-file">
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="最后更新">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1-2.1-2M12.5 7v5.2l4 2.4-1 1L11 13V7h1.5M11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2v1.8Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">2024年6月13日</span>
  </span>

    
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="创建日期">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.47 15.08 11 13V7h1.5v5.25l3.08 1.83c-.41.28-.79.62-1.11 1m-1.39 4.84c-.36.05-.71.08-1.08.08-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8c0 .37-.03.72-.08 1.08.69.1 1.33.32 1.92.64.1-.56.16-1.13.16-1.72 0-5.5-4.5-10-10-10S2 6.5 2 12s4.47 10 10 10c.59 0 1.16-.06 1.72-.16-.32-.59-.54-1.23-.64-1.92M18 15v3h-3v2h3v3h2v-3h3v-2h-3v-3h-2Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">2024年5月26日</span>
  </span>

    
    
    
  </aside>





                
              </article>
            </div>
          
          
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var tab,labels=set.querySelector(".tabbed-labels");for(tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script>

<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../../..", "features": ["content.code.copy", "content.tabs.link", "navigation.tabs", "navigation.tabs.sticky", "navigation.indexes", "navigation.top", "toc.follow", "content.tooltips"], "search": "../../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.3220b9d7.min.js"></script>
      
        <script src="../../../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="https://unpkg.com/mermaid@9.4.0/dist/mermaid.min.js"></script>
      
    
  <script>document$.subscribe(() => {const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});})</script></body>
</html>