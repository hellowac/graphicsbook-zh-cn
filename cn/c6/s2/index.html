
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="计算机图形学概论(graphicsbook)">
      
      
      
        <link rel="canonical" href="https://hellowac.github.io/graphicsbook-zh-cn/cn/c6/s2/">
      
      
        <link rel="prev" href="../s1/">
      
      
        <link rel="next" href="../s3/">
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.5.18">
    
    
      
        <title>6.2 第一个例子 - 计算机图形学概论</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.66ac8b77.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.06af60db.min.css">
      
      

  
  
  
  
  <style>:root{--md-annotation-icon:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M22 12a10 10 0 0 1-10 10A10 10 0 0 1 2 12 10 10 0 0 1 12 2a10 10 0 0 1 10 10M6 13h8l-3.5 3.5 1.42 1.42L17.84 12l-5.92-5.92L10.5 7.5 14 11H6v2Z"/></svg>');}</style>


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
   <link href="../../../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
        html.glightbox-open { overflow: initial; height: 100%; }
        .gslide-title { margin-top: 0px; user-select: text; }
        .gslide-desc { color: #666; user-select: text; }
        .gslide-image img { background: white; }
        
            .gscrollbar-fixer { padding-right: 15px; }
            .gdesc-inner { font-size: 0.75rem; }
            body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
            body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
            body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}
            </style> <script src="../../../assets/javascripts/glightbox.min.js"></script></head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="default" data-md-color-accent="red">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#62-第一个例子" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="计算机图形学概论" class="md-header__button md-logo" aria-label="计算机图形学概论" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            计算机图形学概论
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              6.2 第一个例子
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
      <div class="md-header__option">
  <div class="md-select">
    
    <button class="md-header__button md-icon" aria-label="选择当前语言">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m12.87 15.07-2.54-2.51.03-.03A17.52 17.52 0 0 0 14.07 6H17V4h-7V2H8v2H1v2h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04M18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12m-2.62 7 1.62-4.33L19.12 17h-3.24Z"/></svg>
    </button>
    <div class="md-select__inner">
      <ul class="md-select__list">
        
          <li class="md-select__item">
            <a href="/graphicsbook-zh-cn/en/" hreflang="en" class="md-select__link">
              English
            </a>
          </li>
        
          <li class="md-select__item">
            <a href="/graphicsbook-zh-cn/cn/" hreflang="cn" class="md-select__link">
              中文
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</div>
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/hellowac/graphicsbook-zh-cn" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    graphicsbook
  </div>
</a>
      </div>
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../" class="md-tabs__link">
        
  
    
  
  首页

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../preface/" class="md-tabs__link">
        
  
    
  
  前言

      </a>
    </li>
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c1/" class="md-tabs__link">
          
  
    
  
  1.简介

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c2/" class="md-tabs__link">
          
  
    
  
  2.二维图形

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c3/" class="md-tabs__link">
          
  
    
  
  3.几何

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c4/" class="md-tabs__link">
          
  
    
  
  4.灯光和材质

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c5/" class="md-tabs__link">
          
  
    
  
  5.three.js

        </a>
      </li>
    
  

      
        
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../" class="md-tabs__link">
          
  
    
  
  6.WebGL

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c7/" class="md-tabs__link">
          
  
    
  
  7.WebGL 3D

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c8/" class="md-tabs__link">
          
  
    
  
  8.高阶3D

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c9/" class="md-tabs__link">
          
  
    
  
  9.WEBGPU

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../a1/" class="md-tabs__link">
          
  
    
  
  附录

        </a>
      </li>
    
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../.." class="md-tabs__link">
        
  
    
  
  关于

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="计算机图形学概论" class="md-nav__button md-logo" aria-label="计算机图形学概论" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    计算机图形学概论
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/hellowac/graphicsbook-zh-cn" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    graphicsbook
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    首页
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../preface/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    前言
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c1/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    1.简介
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_3" id="__nav_3_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            1.简介
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 1 节 绘画与绘图
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 2 节：三维(3D)图形的要素
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 3 节：硬件与软件
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c2/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    2.二维图形
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_4" id="__nav_4_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            2.二维图形
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第1节: 像素、坐标和颜色
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第2节: 形状
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第3节: 变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第4节: 分层建模
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第5节: Java 绘制2D
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第6节: HTML Canvas图形
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第7节: SVG：一种场景描述语言
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c3/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    3.几何
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_5" id="__nav_5_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            3.几何
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.1 OpenGL 1.1 中的形状和颜色
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.2 3D 坐标和变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.3 投影与观看
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.4 多边形网格和 glDrawArrays
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.5 部分线性代数基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.6 使用 GLUT 和 JOGL
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c4/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    4.灯光和材质
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_6" id="__nav_6_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6">
            <span class="md-nav__icon md-icon"></span>
            4.灯光和材质
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.1 照明简介
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.2 OpenGL 1.1 中的光和材质
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.3 图像纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.4 灯光、相机、动作
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c5/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    5.three.js
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_7" id="__nav_7_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7">
            <span class="md-nav__icon md-icon"></span>
            5.three.js
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.1 Three.js 基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.2 构建对象
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.3 其他功能
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" checked>
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    6.WebGL
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_8" id="__nav_8_label" tabindex="">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_8">
            <span class="md-nav__icon md-icon"></span>
            6.WebGL
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.1 可编程流水线
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    6.2 第一个例子
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    6.2 第一个例子
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#621-webgl-上下文选项" class="md-nav__link">
    <span class="md-ellipsis">
      6.2.1 WebGL 上下文选项
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#622-glsl-简介" class="md-nav__link">
    <span class="md-ellipsis">
      6.2.2 GLSL 简介
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#623-webgl-中的-rgb-三角形" class="md-nav__link">
    <span class="md-ellipsis">
      6.2.3 WebGL 中的 RGB 三角形
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#624-形状压模" class="md-nav__link">
    <span class="md-ellipsis">
      6.2.4 形状压模
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#625-points原语" class="md-nav__link">
    <span class="md-ellipsis">
      6.2.5 POINTS原语
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#626-webgl-错误处理" class="md-nav__link">
    <span class="md-ellipsis">
      6.2.6 WebGL 错误处理
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.3 GLSL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.4 图像纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.5 实现 2D 变换
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c7/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    7.WebGL 3D
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_9" id="__nav_9_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9">
            <span class="md-nav__icon md-icon"></span>
            7.WebGL 3D
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.1 3D变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.2 照明和材质
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.3 纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.4 帧缓冲区
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.5 WebGL 扩展
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c8/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    8.高阶3D
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_10" id="__nav_10_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_10_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10">
            <span class="md-nav__icon md-icon"></span>
            8.高阶3D
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c8/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8.1 光线追踪
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c8/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8.2 路径追踪
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_11" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c9/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    9.WEBGPU
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_11" id="__nav_11_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_11_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_11">
            <span class="md-nav__icon md-icon"></span>
            9.WEBGPU
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.1 WebGPU 基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.2 实例和索引
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.3 WGSL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.4 WebGPU 中的 3D 图形
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.5 纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.6 计算着色器
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.7 细节
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_12" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../a1/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    附录
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_12" id="__nav_12_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_12_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_12">
            <span class="md-nav__icon md-icon"></span>
            附录
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a2/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Blender 3D建模
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a3/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Gimp和Inkscape
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../source/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    示例程序源代码
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../glossary/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    术语表
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    关于
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#621-webgl-上下文选项" class="md-nav__link">
    <span class="md-ellipsis">
      6.2.1 WebGL 上下文选项
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#622-glsl-简介" class="md-nav__link">
    <span class="md-ellipsis">
      6.2.2 GLSL 简介
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#623-webgl-中的-rgb-三角形" class="md-nav__link">
    <span class="md-ellipsis">
      6.2.3 WebGL 中的 RGB 三角形
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#624-形状压模" class="md-nav__link">
    <span class="md-ellipsis">
      6.2.4 形状压模
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#625-points原语" class="md-nav__link">
    <span class="md-ellipsis">
      6.2.5 POINTS原语
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#626-webgl-错误处理" class="md-nav__link">
    <span class="md-ellipsis">
      6.2.6 WebGL 错误处理
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="62-第一个例子">6.2 第一个例子<a class="headerlink" href="#62-第一个例子" title="Permanent link">&para;</a></h1>
<p><strong>First Examples</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="1:2"><input checked="checked" id="__tabbed_1_1" name="__tabbed_1" type="radio" /><input id="__tabbed_1_2" name="__tabbed_1" type="radio" /><div class="tabbed-labels"><label for="__tabbed_1_1">中文</label><label for="__tabbed_1_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>我们已经准备好开始我们的第一批WebGL程序。本节首先介绍一些关于WebGL图形上下文的更多细节，然后是对GLSL（WebGL着色器的编程语言）的简短介绍。有了这些知识，我们可以转向标准的第一个示例：RGB颜色三角形。</p>
</div>
<div class="tabbed-block">
<p>We are ready to start working towards our first <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> programs. This section begins with a few more details about the <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> graphics context, followed by a short introduction to <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr>, the programming language for <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> shaders. With that in hand, we can turn to the standard first example: the <abbr title="A color specified by three numbers giving the amount of red, green, and blue in the color.">RGB color</abbr> triangle.</p>
</div>
</div>
</div>
<h2 id="621-webgl-上下文选项">6.2.1 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 上下文选项<a class="headerlink" href="#621-webgl-上下文选项" title="Permanent link">&para;</a></h2>
<p><strong><abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> Context Options</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="2:2"><input checked="checked" id="__tabbed_2_1" name="__tabbed_2" type="radio" /><input id="__tabbed_2_2" name="__tabbed_2" type="radio" /><div class="tabbed-labels"><label for="__tabbed_2_1">中文</label><label for="__tabbed_2_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>在<a href="../s1/#611-webgl-图形上下文">6.1.1小节</a>中我们看到了，WebGL图形上下文是通过函数<em>canvas.getContext</em>创建的，其中canvas是对将要绘制图形上下文的<code>&lt;canvas&gt;</code>元素的引用。这个函数接受一个可选的第二个参数，该参数可以用来设置图形上下文中某些选项的值。只有当你想要为至少一个选项设置非默认值时，才需要第二个参数。该参数是一个JavaScript对象，其属性是选项的名称。下面是一个带选项的上下文创建示例：</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">options</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">alpha</span><span class="o">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span>
<span class="w">    </span><span class="nx">depth</span><span class="o">:</span><span class="w"> </span><span class="kc">false</span>
<span class="p">};</span>
<span class="nx">gl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">canvas</span><span class="p">.</span><span class="nx">getContext</span><span class="p">(</span><span class="s2">&quot;webgl&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">options</span><span class="p">);</span><span class="w">  </span><span class="c1">// 或者 &quot;webgl2&quot;</span>
</code></pre></div>
<p>所有选项都是布尔值。我将在这里讨论最有用的几个：</p>
<p><strong><abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr></strong> — 决定绘图缓冲区是否有alpha分量。这是整个图像画布的alpha分量。如果有alpha分量，那么画布上的像素就可以是透明的或半透明的，允许背景（在画布后面的网页）透过来。默认值是<em>true</em>。如果你想让画布完全不透明，将值设置为<em>false</em>是安全的。将值设置为false不会阻止你进行绘图颜色与图像颜色的alpha混合；RGB颜色分量仍然可以通过混合计算出来。然而，只有在你的程序输出alpha分量小于1.0的像素，并且你不希望图像与画布的背景混合时，设置为false才有必要。（但请注意，具有alpha分量的图形上下文可能处理得更高效，因为网页使用RGBA颜色进行显示。）</p>
<p><strong>depth</strong> — 决定是否分配深度缓冲区。默认值是<em>true</em>。只有在启用深度测试时才需要深度缓冲区。深度缓冲区通常对2D图形不是必需的。如果你的应用程序不需要它，消除深度缓冲区可以节省GPU中的一些内存。</p>
<p><strong>antialias</strong> — 用于请求对图像应用反锯齿。WebGL实现可能会忽略请求，例如如果GPU不支持反锯齿。默认值是<em>true</em>。反锯齿可以提高图像质量，但它也可能显著增加计算时间。</p>
<p><strong>preserveDrawingBuffer</strong> — 决定在图像被复制到网页后，是否丢弃绘图缓冲区的内容。默认值是<em>false</em>。绘图缓冲区是WebGL内部的。只有当Web浏览器将图像复制到网页上时，它的内容才会在屏幕上变得可见。<em>preserveDrawingBuffer</em>的默认值意味着一旦发生这种情况，WebGL可以丢弃它自己的图像副本，这允许GPU释放资源以供其他操作使用。只要你的渲染函数每次被调用时都完全重绘图像，默认值就可以了。只有在你需要保留图像以便随着时间推移逐步添加内容时，才应该将值设置为true。</p>
</div>
<div class="tabbed-block">
<p>We saw in <a href="../s1/#611-webgl-图形上下文">Subsection 6.1.1</a> that a <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> graphics context is created by the function <em>canvas.getContext</em>, where canvas is a reference to the <code>&lt;canvas&gt;</code> element where the graphics context will draw. This function takes an optional second parameter that can be used to set the value of certain options in the graphics context. The second parameter is only needed if you want to give a non-default value to at least one of the options. The parameter is a <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> object whose properties are the names of the options. Here is an example of context creation with options:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">options</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">alpha</span><span class="o">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span>
<span class="w">    </span><span class="nx">depth</span><span class="o">:</span><span class="w"> </span><span class="kc">false</span>
<span class="p">};</span>
<span class="nx">gl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">canvas</span><span class="p">.</span><span class="nx">getContext</span><span class="p">(</span><span class="w"> </span><span class="s2">&quot;webgl&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">options</span><span class="w"> </span><span class="p">);</span><span class="w">  </span><span class="c1">// (or &quot;webgl2&quot;)</span>
</code></pre></div>
<p>All of the options are boolean-valued. I will discuss the most useful ones here:</p>
<p><strong><abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr></strong> — determines whether the drawing buffer has an <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> component. This is the <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> component for the image canvas as a whole. If there is an <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> component, then it is possible for <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr> in the canvas to be transparent or translucent, letting the background (on the web page behind the canvas) show through. The default value is <em>true</em>. It is safe to set the value to <em>false</em>, if you want the canvas to be fully opaque. Setting it to false does not stop you from doing <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> blending of the drawing color with the image color; the <abbr title="A color specified by three numbers giving the amount of red, green, and blue in the color.">RGB color</abbr> components can still be computed by blending. However, setting the value to false is only necessary if your program outputs <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr> with <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> component less than 1.0, and you don't want your image to blend with the background of the canvas. (Note however that a graphics context with an <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> component might be handled more efficiently, because web pages use RGBA colors for their display.)</p>
<p><strong>depth</strong> — determines whether a <abbr title="A region of memory that stores the information needed for the depth test in 3D graphics, that is, a depth value for each pixel in the image. Also called the &quot;z-buffer.&quot;">depth buffer</abbr> is allocated. The default value is <em>true</em>. You only need a <abbr title="A region of memory that stores the information needed for the depth test in 3D graphics, that is, a depth value for each pixel in the image. Also called the &quot;z-buffer.&quot;">depth buffer</abbr> if you enable the <abbr title="A solution to the hidden surface problem that involves keeping track of the depth, or distance from the viewer, of the object currently visible at each pixel in the image. When a new object is drawn at a pixel, the depth of the new object is compared to the depth of the current object to decide which one is closer to the viewer. The advantage of the depth test is that objects can be rendered in any order. A disadvantage is that only a limited range of depths can be represented in the image.">depth test</abbr>. The <abbr title="A region of memory that stores the information needed for the depth test in 3D graphics, that is, a depth value for each pixel in the image. Also called the &quot;z-buffer.&quot;">depth buffer</abbr> is generally not needed for 2D graphics. If your application doesn't need it, eliminating the <abbr title="A region of memory that stores the information needed for the depth test in 3D graphics, that is, a depth value for each pixel in the image. Also called the &quot;z-buffer.&quot;">depth buffer</abbr> can save some memory in the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>.</p>
<p><strong>antialias</strong> — is used to request that <abbr title="A technique used to reduce the jagged or &quot;staircase&quot; appearance of diagonal lines, text, and other shapes that are drawn using pixels. When a pixel is only partly covered by a geometric shape, then the color of the pixel is a blend of the color of the shape and the color of the background, with the degree of blending depending on the fraction of the pixel that is covered by the geometric shape.">antialiasing</abbr> be applied to the image. A <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> implementation might ignore the request, for example if <abbr title="A technique used to reduce the jagged or &quot;staircase&quot; appearance of diagonal lines, text, and other shapes that are drawn using pixels. When a pixel is only partly covered by a geometric shape, then the color of the pixel is a blend of the color of the shape and the color of the background, with the degree of blending depending on the fraction of the pixel that is covered by the geometric shape.">antialiasing</abbr> is not supported by the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>. The default value is <em>true</em>. <abbr title="A technique used to reduce the jagged or &quot;staircase&quot; appearance of diagonal lines, text, and other shapes that are drawn using pixels. When a pixel is only partly covered by a geometric shape, then the color of the pixel is a blend of the color of the shape and the color of the background, with the degree of blending depending on the fraction of the pixel that is covered by the geometric shape.">Antialiasing</abbr> can improve the quality of an image, but it can also significantly increase the computation time.</p>
<p><strong>preserveDrawingBuffer</strong> — determines whether the contents of the drawing buffer are discarded after the image has been copied to the web page. The default value is <em>false</em>. The drawing buffer is internal to <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>. Its contents only become visible on the screen when the web browser copies the image onto the web page. The default value for <em>preserveDrawingBuffer</em> means that once that happens, <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> can discard its own copy of the image, which allows the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> to free up resources for other operations. As long as your <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> functions completely redraw the image every time they called, the default is fine. You should set the value to true only if you need to keep the image around so that you can add to it incrementally over time.</p>
</div>
</div>
</div>
<h2 id="622-glsl-简介">6.2.2 <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> 简介<a class="headerlink" href="#622-glsl-简介" title="Permanent link">&para;</a></h2>
<p><strong>A Bit of <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr></strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="3:2"><input checked="checked" id="__tabbed_3_1" name="__tabbed_3" type="radio" /><input id="__tabbed_3_2" name="__tabbed_3" type="radio" /><div class="tabbed-labels"><label for="__tabbed_3_1">中文</label><label for="__tabbed_3_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>下一节将更全面地介绍GLSL。但你将需要了解一些关于这门语言的知识，以理解本节中的示例。本节仅讨论GLSL ES 1.00，但请记住，这门语言可以与WebGL 1.0和WebGL 2.0一起使用。</p>
<p>顶点或片段着色器可以包含全局变量声明、类型定义和函数定义。其中一个函数必须是<em>main()</em>，这是着色器的入口点；也就是说，它是GPU处理顶点或片段时调用的函数。<em>main()</em>例程不接受任何参数，也不返回值，所以它的形式是</p>
<div class="highlight"><pre><span></span><code><span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span>
<span class="w">    </span><span class="p">.</span>
<span class="w">    </span><span class="p">.</span>
<span class="p">}</span>
</code></pre></div>
<p>（或者，它可以被声明为<em>void main(void)</em>。）</p>
<p>控制结构是有限的。<em>if</em>语句与C或Java中的格式相同。但对<em>for</em>循环语法施加了一些限制，不允许使用<em>while</em>和<em>do...while</em>循环。数据结构包括数组和<em>structs</em>，也有一些限制。我们将在<a href="../s3/">下一节</a>中详细介绍所有这些。</p>
<p>GLSL的优势在于其内置的数据类型和用于处理向量和矩阵的函数。在本节中，我们只需要数据类型<em>float</em>、<em>vec2</em>、<em>vec3</em>和<em>vec4</em>。这些类型分别表示1、2、3或4个浮点数。变量声明与C类似。一些示例是：</p>
<div class="highlight"><pre><span></span><code><span class="nx">attribute</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">a_coords</span><span class="p">;</span><span class="w">  </span><span class="c1">// （仅在顶点着色器中）</span>
<span class="nx">vec3</span><span class="w"> </span><span class="nx">rgb</span><span class="p">;</span>
<span class="kr">float</span><span class="w"> </span><span class="nx">width</span><span class="p">,</span><span class="w"> </span><span class="nx">height</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">vec2</span><span class="w"> </span><span class="nx">u_size</span><span class="p">;</span>
<span class="nx">varying</span><span class="w"> </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">v_color</span><span class="p">;</span>
</code></pre></div>
<p><em>Attribute</em>、<em>uniform</em>和<em>varying</em>变量在<a href="../s1/">第6.1节</a>中讨论过。它们用于在JavaScript与着色器程序之间以及顶点着色器与片段着色器之间进行通信。在上面的示例中，我在变量名中使用了前缀"a_"、"u_"和"v_"，但这不是必须的。</p>
<p>通常，我们会从单独的数字或较短的向量构造向量的值。GLSL具有灵活的符号表示法来实现这一点。使用上述声明的变量，我们可以编写</p>
<div class="highlight"><pre><span></span><code><span class="nx">rgb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.7</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span><span class="w">  </span><span class="c1">// 从常数构造vec3</span>
<span class="nx">v_color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="nx">rgb</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span><span class="w">  </span><span class="c1">// 从vec3和常数构造vec4</span>
<span class="nx">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="nx">a_coords</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span><span class="w">  </span><span class="c1">// 从vec2和2个常数构造vec4</span>
</code></pre></div>
<p>在最后一个赋值语句中，<em>gl_Position</em>是特殊内置变量，用于在顶点着色器中给出顶点的坐标。<em>gl_Position</em>是vec4类型，需要四个数字，因为坐标是以齐次坐标<a href="../../c3/s5/#353-齐次坐标">3.5.3小节</a>指定的。片段着色器中的特殊变量<em>gl_FragCoord</em>也是vec4类型，给出像素的坐标作为齐次坐标。而<em>gl_FragColor</em>是vec4类型，给出像素的四个RGBA颜色分量。</p>
<p>顶点着色器至少需要一个属性来给出顶点的坐标。对于2D绘图，很自然地该属性是<em>vec2</em>类型。如果我们假设属性的值已经用裁剪坐标表示，那么顶点着色器的完整源代码可能非常简单：</p>
<div class="highlight"><pre><span></span><code><span class="nx">attribute</span><span class="w"> </span><span class="nx">vec2</span><span class="w"> </span><span class="nx">coords</span><span class="p">;</span>
<span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="nx">coords</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>对于相应的最小片段着色器，我们可能只是简单地将所有内容绘制为黄色。</p>
<div class="highlight"><pre><span></span><code><span class="nx">precision</span><span class="w"> </span><span class="nx">mediump</span><span class="w"> </span><span class="kr">float</span><span class="p">;</span>
<span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">gl_FragColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>这段片段着色器中的第一行看起来有些奇怪，还没有解释，但需要类似的语句。它将在<a href="../s3/">下一节</a>中解释。</p>
</div>
<div class="tabbed-block">
<p>The <a href="../s3/">next section</a> will cover <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> more thoroughly. But you will need to know something about the language to understand the examples in this section. This section discusses <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 1.00 only, but remember that that language can be used with both <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 and <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0.</p>
<p>A <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> or <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> can contain global variable declarations, type definitions, and function definitions. One of the functions must be <em>main()</em>, which is the entry point for the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>; that is, it is the function that is called by the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> to process the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> or fragment. The <em>main()</em> routine takes no parameters and does not return a value, so it takes the form</p>
<div class="highlight"><pre><span></span><code><span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span>
<span class="w">    </span><span class="p">.</span>
<span class="w">    </span><span class="p">.</span>
<span class="p">}</span>
</code></pre></div>
<p>(Alternatively, it can be declared as <em>void main(void)</em>.)</p>
<p>Control structures are limited. <em>If</em> statements take the same form as in C or Java. But some limitations are placed on the <em>for</em> loop syntax, and <em>while</em> and <em>do...while</em> loops are not allowed. Data structures include arrays and <em>structs</em>, again with some limitations. We will cover all this in some detail in the <a href="../s3/">next section</a>.</p>
<p><abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr>'s strength lies in its built-in data types and functions for working with vectors and matrices. In this section, we will only need the data types <em>float</em>, <em>vec2</em>, <em>vec3</em>, and <em>vec4</em>. These types represent, respectively, 1, 2, 3, or 4 floating point numbers. Variable declarations are similar to C. Some examples are:</p>
<div class="highlight"><pre><span></span><code><span class="nx">attribute</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">a_coords</span><span class="p">;</span><span class="w">  </span><span class="c1">// (only in vertex shader)</span>
<span class="nx">vec3</span><span class="w"> </span><span class="nx">rgb</span><span class="p">;</span>
<span class="kr">float</span><span class="w"> </span><span class="nx">width</span><span class="p">,</span><span class="w"> </span><span class="nx">height</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">vec2</span><span class="w"> </span><span class="nx">u_size</span><span class="p">;</span>
<span class="nx">varying</span><span class="w"> </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">v_color</span><span class="p">;</span>
</code></pre></div>
<p><em>Attribute</em>, <em>uniform</em>, and <em>varying</em> variables were discussed in <a href="../s1/">Section 6.1</a>. They are used for communication between <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> and the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program and between the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> and the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr>. In the above examples, I used the prefixes "a_", "u_", and "v_" in the names of the variables, but that is not required.</p>
<p>It is common to construct a value for a <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> from individual numbers or from shorter vectors. <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> has a flexible notation for doing this. Using the variables declared in the above examples, we can write</p>
<div class="highlight"><pre><span></span><code><span class="nx">rgb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec3</span><span class="p">(</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.7</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">);</span><span class="w">  </span><span class="c1">// construct a vec3 from constants</span>
<span class="nx">v_color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="w"> </span><span class="nx">rgb</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">);</span><span class="w">  </span><span class="c1">// construct a vec4 from a vec3 and a constant</span>
<span class="nx">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="w"> </span><span class="nx">a_coords</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">);</span><span class="w">  </span><span class="c1">// vec4 from a vec2 and 2 constants</span>
</code></pre></div>
<p>In the last assignment statement, <em>gl_Position</em> is the special built-in variable that is used in the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> to give the coordinates of the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>. <em>gl_Position</em> is of type vec4, requiring four numbers, because the coordinates are specified as <abbr title="A way of representing n-dimensional vectors as (n+1)-dimensional vectors where two (n+1) vectors represent the same n-dimensional vector if they differ by a scalar multiple. In 3D, for example, if w is not zero, then the homogeneous coordinates (x,y,z,w) are equivalent to homogeneous coordinates (x/w,y/w,z/w,1), since they differ by multiplication by the scalar w. Both sets of coordinates represent the 3D vector (x/w,y/w,z/w)">homogeneous coordinates</abbr> (<a href="../../c3/s5/#353-齐次坐标">Subsection 3.5.3</a>). The special variable <em>gl_FragCoord</em> in the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> is also a <em>vec4</em>, giving the coordinates of the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> as <abbr title="A way of representing n-dimensional vectors as (n+1)-dimensional vectors where two (n+1) vectors represent the same n-dimensional vector if they differ by a scalar multiple. In 3D, for example, if w is not zero, then the homogeneous coordinates (x,y,z,w) are equivalent to homogeneous coordinates (x/w,y/w,z/w,1), since they differ by multiplication by the scalar w. Both sets of coordinates represent the 3D vector (x/w,y/w,z/w)">homogeneous coordinates</abbr>. And <em>gl_FragColor</em> is a <em>vec4</em>, giving the four <abbr title="An RGB color—specified by red, green, and blue component values—together with an alpha component. The alpha component is most often take to specify the degree of transparency of the color, with a maximal alpha value giving a fully opaque color.">RGBA color</abbr> components for the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>.</p>
<p>A <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> needs, at a minimum, an <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> to give the coordinates of the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>. For 2D drawing, it's natural for that <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> to be of type <em>vec2</em>. If we assume that the values for the <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> are already expressed in <abbr title="The default coordinate system in OpenGL. The projection transform maps the 3D scene to clip coordinates. The rendered image will show the contents of the cube in the clip coordinate system that contains x, y, and z values in the range from -1 to 1; anything outside that range is &quot;clipped&quot; away.">clip coordinates</abbr>, then the complete source code for the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> could be as simple as:</p>
<div class="highlight"><pre><span></span><code><span class="nx">attribute</span><span class="w"> </span><span class="nx">vec2</span><span class="w"> </span><span class="nx">coords</span><span class="p">;</span>
<span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="w"> </span><span class="nx">coords</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>For a corresponding minimal <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr>, we might simply draw everything in yellow.</p>
<div class="highlight"><pre><span></span><code><span class="nx">precision</span><span class="w"> </span><span class="nx">mediump</span><span class="w"> </span><span class="kr">float</span><span class="p">;</span>
<span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">gl_FragColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">);</span><span class="w">  </span>
<span class="p">}</span>
</code></pre></div>
<p>The strange first line in this <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> has not been explained, but something like it is required. It will be explained in the <a href="../s3/">next section</a>.</p>
</div>
</div>
</div>
<h2 id="623-webgl-中的-rgb-三角形">6.2.3 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 中的 RGB 三角形<a class="headerlink" href="#623-webgl-中的-rgb-三角形" title="Permanent link">&para;</a></h2>
<p><strong>The RGB Triangle in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr></strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="4:2"><input checked="checked" id="__tabbed_4_1" name="__tabbed_4" type="radio" /><input id="__tabbed_4_2" name="__tabbed_4" type="radio" /><div class="tabbed-labels"><label for="__tabbed_4_1">中文</label><label for="__tabbed_4_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>我们已经准备好查看我们的第一个完整的WebGL示例，它将绘制一个常见的RGB颜色三角形，如下所示：</p>
<p><a href="../../../en/c6/rgb-triangle-webgl.png">123</a></p>
<p>源代码可以在 <a href="../../../en/source/webgl/webgl-rgb-triangle.html">webgl/webgl-rgb-triangle.html</a> 中找到。该代码包括了在<a href="../s1/#611-webgl-图形上下文">6.1.1小节</a>和<a href="../s1/#612-着色器程序">6.1.2小节</a>中讨论的通常的<em>init()</em>和<em>createProgram()</em>函数，只是我已关闭了WebGL上下文中的“<abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr>”和“depth”选项。我将不再进一步讨论这两个函数。</p>
<p>该示例使用类型为<em>vec2</em>的属性来指定三角形顶点的坐标。在默认的WebGL坐标系中，坐标范围从-1到1。对于三角形，我使用的顶点坐标在该范围内，因此不需要坐标变换。由于三角形的每个顶点处的颜色都不同，顶点颜色也是一个属性。由于此程序不需要alpha分量，因此我使用类型为<em>vec3</em>的属性来表示顶点颜色。</p>
<p>三角形内部像素的颜色是通过插值顶点处的颜色来确定的。插值意味着我们需要一个变化变量来表示颜色。变化变量在顶点着色器中被赋值，并在片段着色器中使用其值。</p>
<p>看起来我们需要两个颜色变量：一个属性和一个变化变量。我们不能将同一个变量用于两个目的。属性将顶点颜色从JavaScript传入顶点着色器；变化变量将颜色从顶点着色器传入片段着色器。在这种情况下，从顶点着色器传出的颜色值与传入的值相同，因此着色器只需要将颜色属性的值复制到变化变量中。这种模式实际上相当常见。以下是顶点着色器：</p>
<div class="highlight"><pre><span></span><code><span class="nx">attribute</span><span class="w"> </span><span class="nx">vec2</span><span class="w"> </span><span class="nx">a_coords</span><span class="p">;</span>
<span class="nx">attribute</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">a_color</span><span class="p">;</span>
<span class="nx">varying</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">v_color</span><span class="p">;</span>

<span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="nx">a_coords</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="w">    </span><span class="nx">v_color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">a_color</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>片段着色器只需要将来自变化变量的传入颜色值复制到<em>gl_FragColor</em>中，后者指定了片段的颜色：</p>
<div class="highlight"><pre><span></span><code><span class="nx">precision</span><span class="w"> </span><span class="nx">mediump</span><span class="w"> </span><span class="kr">float</span><span class="p">;</span>
<span class="nx">varying</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">v_color</span><span class="p">;</span>

<span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">gl_FragColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="nx">v_color</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>为了编译着色器程序，着色器的源代码必须在JavaScript字符串中。在这种情况下，我通过连接代表代码各行的常量字符串来构造字符串。例如，片段着色器源代码作为全局变量包含在JavaScript脚本中：</p>
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">fragmentShaderSource</span><span class="w"> </span><span class="o">=</span>
<span class="w">            </span><span class="s2">&quot;precision mediump float;\n&quot;</span><span class="w"> </span><span class="o">+</span>
<span class="w">            </span><span class="s2">&quot;varying vec3 v_color;\n&quot;</span><span class="w"> </span><span class="o">+</span>
<span class="w">            </span><span class="s2">&quot;void main() {\n&quot;</span><span class="w"> </span><span class="o">+</span>
<span class="w">            </span><span class="s2">&quot;   gl_FragColor = vec4(v_color, 1.0);\n&quot;</span><span class="w"> </span><span class="o">+</span>
<span class="w">            </span><span class="s2">&quot;}\n&quot;</span><span class="p">;</span>
</code></pre></div>
<p>每行末尾的换行符"\n"不是必需的，但它允许GLSL编译器在其生成的任何错误消息中包含一个有意义的行号。</p>
<p>在JavaScript方面，我们还需要一个全局变量来表示WebGL上下文。我们还需要为属性变量提供值。在<a href="../s1/#615-属性值">6.1.5小节</a>中讨论了一个相当复杂的过程。我们需要全局变量来表示着色器程序中每个属性的位置，以及表示将保存属性值的VBO。我使用以下变量：</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">gl</span><span class="p">;</span><span class="w">  </span><span class="c1">// WebGL图形上下文。</span>

<span class="kd">let</span><span class="w"> </span><span class="nx">attributeCoords</span><span class="p">;</span><span class="w">  </span><span class="c1">// 属性 &quot;a_coords&quot; 的位置。</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">bufferCoords</span><span class="p">;</span><span class="w">     </span><span class="c1">// 一个顶点缓冲对象，用于保存 a_coords 的值。</span>

<span class="kd">let</span><span class="w"> </span><span class="nx">attributeColor</span><span class="p">;</span><span class="w">   </span><span class="c1">// 属性 &quot;a_color&quot; 的位置。</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">bufferColor</span><span class="p">;</span><span class="w">      </span><span class="c1">// 一个顶点缓冲对象，用于保存 a_color 的值。</span>
</code></pre></div>
<p>图形上下文是在<em>init()</em>函数中创建的。其他变量在从<em>init()</em>调用的<em>initGL()</em>函数中初始化。该函数还使用<a href="../s1/#612-着色器程序">6.1.2小节</a>中的<em>createProgram()</em>函数创建着色器程序：</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span><span class="w"> </span><span class="nx">initGL</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">prog</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">createProgram</span><span class="p">(</span><span class="nx">gl</span><span class="p">,</span><span class="w"> </span><span class="nx">vertexShaderSource</span><span class="p">,</span><span class="w"> </span><span class="nx">fragmentShaderSource</span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">useProgram</span><span class="p">(</span><span class="nx">prog</span><span class="p">);</span>

<span class="w">    </span><span class="nx">attributeCoords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getAttribLocation</span><span class="p">(</span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;a_coords&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="nx">bufferCoords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">();</span>

<span class="w">    </span><span class="nx">attributeColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getAttribLocation</span><span class="p">(</span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;a_color&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="nx">bufferColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>要设置属性的值，我们需要六个不同的JavaScript命令（如果还要计算将属性值放入类型化数组，需要更多的命令）。<em>getAttribLocation</em>和<em>createBuffer</em>命令很可能只需为每个属性调用一次，所以我将它们放在我的初始化程序中。其他四个命令在<em>draw()</em>中，这个函数用于绘制图像。在这个程序中，<em>draw()</em>只被调用一次，所以将代码分成两个函数并不是真的必要，但通常，绘制函数旨在被多次调用。（每次调用<em>draw()</em>时都创建一个新的VBO将是一个特别糟糕的主意！）</p>
<p>在绘制三角形之前，<em>draw()</em>函数用黑色背景填充画布。这是使用WebGL函数<em>gl.clearColor</em>和<em>gl.clear</em>完成的，它们与OpenGL 1.1函数<em>glClearColor</em>和<em>glClear</em>具有完全相同的功能。以下是代码：</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span><span class="w"> </span><span class="nx">draw</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>

<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">clearColor</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">);</span><span class="w">  </span><span class="c1">// 指定用于清除的颜色</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">clear</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">COLOR_BUFFER_BIT</span><span class="p">);</span><span class="w">  </span><span class="c1">// 清除画布（变为黑色）</span>

<span class="w">    </span><span class="cm">/* 设置 &quot;a_coords&quot; 属性的值 */</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Float32Array</span><span class="p">(</span><span class="w"> </span><span class="p">[</span><span class="o">-</span><span class="mf">0.9</span><span class="p">,</span><span class="o">-</span><span class="mf">0.8</span><span class="p">,</span><span class="w"> </span><span class="mf">0.9</span><span class="p">,</span><span class="o">-</span><span class="mf">0.8</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="mf">0.9</span><span class="p">]</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">bindBuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">bufferCoords</span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">bufferData</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">coords</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">STREAM_DRAW</span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">vertexAttribPointer</span><span class="p">(</span><span class="nx">attributeCoords</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">FLOAT</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">enableVertexAttribArray</span><span class="p">(</span><span class="nx">attributeCoords</span><span class="p">);</span><span class="w"> </span>

<span class="w">    </span><span class="cm">/* 设置 &quot;a_color&quot; 属性的值 */</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Float32Array</span><span class="p">(</span><span class="w"> </span><span class="p">[</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">]</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">bindBuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">bufferColor</span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">bufferData</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">color</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">STREAM_DRAW</span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">vertexAttribPointer</span><span class="p">(</span><span class="nx">attributeColor</span><span class="p">,</span><span class="w"> </span><span class="mf">3</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">FLOAT</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">enableVertexAttribArray</span><span class="p">(</span><span class="nx">attributeColor</span><span class="p">);</span><span class="w"> </span>

<span class="w">    </span><span class="cm">/* 绘制三角形 */</span>

<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">drawArrays</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TRIANGLES</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">3</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div>
<p>在这个函数中，变量<em>coords</em>包含顶点着色器中名为"a_coords"的属性的值。该属性表示顶点的x和y坐标。由于属性是<em>vec2</em>类型，每个顶点需要两个数字。<em>coords</em>的值是在这里使用带普通JavaScript数组作为参数的<strong><em>Float32Array</em></strong>构造函数创建的；JavaScript数组中的值被复制到新创建的类型化数组中。类似地，变量color包含顶点着色器中"a_color"属性的值，每个顶点有三个数字。</p>
<p>现在我们已经解释了RGB三角形程序的所有部分。阅读完整的<a href="../../../en/source/webgl/webgl-rgb-triangle.html">源代码</a>以了解它是如何组合在一起的。</p>
</div>
<div class="tabbed-block">
<p>We are ready to look at our first full <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> example, which will draw the usual <abbr title="A color specified by three numbers giving the amount of red, green, and blue in the color.">RGB color</abbr> triangle, as shown here:</p>
<p><a href="../../../en/c6/rgb-triangle-webgl.png">123</a></p>
<p>The source code can be found in <a href="../../../en/source/webgl/webgl-rgb-triangle.html">webgl/webgl-rgb-triangle.html</a>. The code includes the usual <em>init()</em> and <em>createProgram()</em> functions as discussed in <a href="../s1/#611-webgl-图形上下文">Subsection 6.1.1</a> and <a href="../s1/#612-着色器程序">Subsection 6.1.2</a>, except that I have turned off the "<abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr>" and "depth" options in the <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> context. I won't discuss those two functions further.</p>
<p>The example uses an <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> of type <em>vec2</em> to specify the coordinates of the vertices of the triangle. Coordinates range from −1 to 1 in the default <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr>. For the triangle, the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> coordinates that I use are in that range, so no coordinate transformation is needed. Since the color is different at each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> of the triangle, the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> color is also an <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>. I use an <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> of type <em>vec3</em> for the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> colors, since no <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> component is needed in this program.</p>
<p>The color of interior <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr> in the triangle is interpolated from the colors at the vertices. The <abbr title="Given values for some quantity at certain reference points, computing a value for that quantity at other points by some kind of averaging applied to the values at the reference points.">interpolation</abbr> means that we need a <abbr title="A variable that is used to communicate values from the vertex shader to the fragment shader in the WebGL or OpenGL ES 2.0 graphics pipeline. A varying variable is assigned a value in the vertex shader. The value of the variable in the fragment shader for a pixel in the primitive is obtained by interpolating the values from the vertices of the primitive. (In newer versions of GLSL, which support additional shader stages, the term &quot;varying variable&quot; is replaced by the more general terms &quot;in variable&quot; and &quot;out variable,&quot; which refer to variables that are used for input to or output from a shader.)">varying variable</abbr> to represent the color. A <abbr title="A variable that is used to communicate values from the vertex shader to the fragment shader in the WebGL or OpenGL ES 2.0 graphics pipeline. A varying variable is assigned a value in the vertex shader. The value of the variable in the fragment shader for a pixel in the primitive is obtained by interpolating the values from the vertices of the primitive. (In newer versions of GLSL, which support additional shader stages, the term &quot;varying variable&quot; is replaced by the more general terms &quot;in variable&quot; and &quot;out variable,&quot; which refer to variables that are used for input to or output from a shader.)">varying variable</abbr> is assigned a value in the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>, and its value is used in the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr>.</p>
<p>It looks like we need two color variables: an <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> and a <abbr title="A variable that is used to communicate values from the vertex shader to the fragment shader in the WebGL or OpenGL ES 2.0 graphics pipeline. A varying variable is assigned a value in the vertex shader. The value of the variable in the fragment shader for a pixel in the primitive is obtained by interpolating the values from the vertices of the primitive. (In newer versions of GLSL, which support additional shader stages, the term &quot;varying variable&quot; is replaced by the more general terms &quot;in variable&quot; and &quot;out variable,&quot; which refer to variables that are used for input to or output from a shader.)">varying variable</abbr>. We can't use the same variable for both purposes. The <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> carries the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> color from <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> into the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>; the <abbr title="A variable that is used to communicate values from the vertex shader to the fragment shader in the WebGL or OpenGL ES 2.0 graphics pipeline. A varying variable is assigned a value in the vertex shader. The value of the variable in the fragment shader for a pixel in the primitive is obtained by interpolating the values from the vertices of the primitive. (In newer versions of GLSL, which support additional shader stages, the term &quot;varying variable&quot; is replaced by the more general terms &quot;in variable&quot; and &quot;out variable,&quot; which refer to variables that are used for input to or output from a shader.)">varying variable</abbr> carries the color from the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> to the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr>. In this case, the color value going out of the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> is the same as the value coming in, so the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> just has to copy the value from the color <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> to the <abbr title="A variable that is used to communicate values from the vertex shader to the fragment shader in the WebGL or OpenGL ES 2.0 graphics pipeline. A varying variable is assigned a value in the vertex shader. The value of the variable in the fragment shader for a pixel in the primitive is obtained by interpolating the values from the vertices of the primitive. (In newer versions of GLSL, which support additional shader stages, the term &quot;varying variable&quot; is replaced by the more general terms &quot;in variable&quot; and &quot;out variable,&quot; which refer to variables that are used for input to or output from a shader.)">varying variable</abbr>. This pattern is actually fairly common. Here is the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>:</p>
<div class="highlight"><pre><span></span><code><span class="nx">attribute</span><span class="w"> </span><span class="nx">vec2</span><span class="w"> </span><span class="nx">a_coords</span><span class="p">;</span>
<span class="nx">attribute</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">a_color</span><span class="p">;</span>
<span class="nx">varying</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">v_color</span><span class="p">;</span>

<span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="nx">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="nx">a_coords</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="nx">v_color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">a_color</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>The <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> only has to copy the incoming color value from the <abbr title="A variable that is used to communicate values from the vertex shader to the fragment shader in the WebGL or OpenGL ES 2.0 graphics pipeline. A varying variable is assigned a value in the vertex shader. The value of the variable in the fragment shader for a pixel in the primitive is obtained by interpolating the values from the vertices of the primitive. (In newer versions of GLSL, which support additional shader stages, the term &quot;varying variable&quot; is replaced by the more general terms &quot;in variable&quot; and &quot;out variable,&quot; which refer to variables that are used for input to or output from a shader.)">varying variable</abbr> into <em>gl_FragColor</em>, which specifies the outgoing color for the fragment:</p>
<div class="highlight"><pre><span></span><code><span class="nx">precision</span><span class="w"> </span><span class="nx">mediump</span><span class="w"> </span><span class="kr">float</span><span class="p">;</span>
<span class="nx">varying</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">v_color</span><span class="p">;</span>

<span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="nx">gl_FragColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="nx">v_color</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>In order to compile the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program, the source code for the shaders has to be in <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> strings. In this case, I construct the strings by concatenating constant strings representing the individual lines of code. For example, the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> source code is included in the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> script as the global variable</p>
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">fragmentShaderSource</span><span class="w"> </span><span class="o">=</span>
<span class="w">            </span><span class="s2">&quot;precision mediump float;\n&quot;</span><span class="w"> </span><span class="o">+</span>
<span class="w">            </span><span class="s2">&quot;varying vec3 v_color;\n&quot;</span><span class="w"> </span><span class="o">+</span>
<span class="w">            </span><span class="s2">&quot;void main() {\n&quot;</span><span class="w"> </span><span class="o">+</span>
<span class="w">            </span><span class="s2">&quot;   gl_FragColor = vec4(v_color, 1.0);\n&quot;</span><span class="w"> </span><span class="o">+</span>
<span class="w">            </span><span class="s2">&quot;}\n&quot;</span><span class="p">;</span>
</code></pre></div>
<p>The line feed character, "\n", at the end of each line is not required, but it allows the <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> compiler to include a meaningful line number in any error message that it generates.</p>
<p>Also on the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side, we need a global variable for the <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> context. And we need to provide values for the <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> variables. The rather complicated process was discussed in <a href="../s1/#615-属性值">Subsection 6.1.5</a>. We need global variables to represent the location of each <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program, and to represent the VBOs that will hold the <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> values. I use the variables</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">gl</span><span class="p">;</span><span class="w">  </span><span class="c1">// The WebGL graphics context.</span>

<span class="kd">let</span><span class="w"> </span><span class="nx">attributeCoords</span><span class="p">;</span><span class="w">  </span><span class="c1">// Location of the attribute named &quot;a_coords&quot;.</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">bufferCoords</span><span class="p">;</span><span class="w">     </span><span class="c1">// A vertex buffer object to hold the values for a_coords.</span>

<span class="kd">let</span><span class="w"> </span><span class="nx">attributeColor</span><span class="p">;</span><span class="w">   </span><span class="c1">// Location of the attribute named &quot;a_color&quot;.</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">bufferColor</span><span class="p">;</span><span class="w">      </span><span class="c1">// A vertex buffer object to hold the values for a_color.</span>
</code></pre></div>
<p>The graphics context is created in the <em>init()</em> function. The other variables are initialized in a function <em>initGL()</em> that is called from <em>init()</em>. That function also creates the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program, using the <em>createProgram()</em> function from <a href="../s1/#612-着色器程序">Subsection 6.1.2</a>:</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span><span class="w"> </span><span class="nx">initGL</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">prog</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">createProgram</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">,</span><span class="w"> </span><span class="nx">vertexShaderSource</span><span class="p">,</span><span class="w"> </span><span class="nx">fragmentShaderSource</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">useProgram</span><span class="p">(</span><span class="nx">prog</span><span class="p">);</span>

<span class="w">    </span><span class="nx">attributeCoords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getAttribLocation</span><span class="p">(</span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;a_coords&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="nx">bufferCoords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">();</span>

<span class="w">    </span><span class="nx">attributeColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getAttribLocation</span><span class="p">(</span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;a_color&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="nx">bufferColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>To set up the values for an <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>, we need six different <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> commands (and more if you count placing the <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> values into a <abbr title="In JavaScript, an array type that is limited to holding numerical values of a single type. For example, the type Float32Array represents arrays that can hold 32-bit floating point values, and Uint8Array arrays can hold only 8-bit integer values. Such arrays are more efficient than general JavaScript arrays for numerical calculations. The were introduced into JavaScript along with HTML canvas graphics and WebGL.">typed array</abbr>). The commands <em>getAttribLocation</em> and <em>createBuffer</em> will most likely be called just once for each <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>, so I put them in my initialization routine. The other four commands are in <em>draw()</em>, the function that draws the image. In this program, <em>draw()</em> is called just once, so the division of the code into two functions is not really necessary, but in general, a draw function is meant to be called many times. (It would be a particularly bad idea to create a new <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr> every time <em>draw()</em> is called!)</p>
<p>Before drawing the triangle, the <em>draw()</em> function fills the canvas with a black background. This is done using the <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> functions <em>gl.clearColor</em> and <em>gl.clear</em>, which have exactly the same functionality as the <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1 functions <em>glClearColor</em> and glClear. Here is the code:</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span><span class="w"> </span><span class="nx">draw</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>

<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">clearColor</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">);</span><span class="w">  </span><span class="c1">// specify the color to be used for clearing</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">clear</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">COLOR_BUFFER_BIT</span><span class="p">);</span><span class="w">  </span><span class="c1">// clear the canvas (to black)</span>

<span class="w">    </span><span class="cm">/* Set up values for the &quot;a_coords&quot; attribute */</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Float32Array</span><span class="p">(</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="o">-</span><span class="mf">0.9</span><span class="p">,</span><span class="o">-</span><span class="mf">0.8</span><span class="p">,</span><span class="w"> </span><span class="mf">0.9</span><span class="p">,</span><span class="o">-</span><span class="mf">0.8</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="mf">0.9</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">bindBuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">bufferCoords</span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">bufferData</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">coords</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">STREAM_DRAW</span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">vertexAttribPointer</span><span class="p">(</span><span class="nx">attributeCoords</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">FLOAT</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">enableVertexAttribArray</span><span class="p">(</span><span class="nx">attributeCoords</span><span class="p">);</span><span class="w"> </span>

<span class="w">    </span><span class="cm">/* Set up values for the &quot;a_color&quot; attribute */</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Float32Array</span><span class="p">(</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">bindBuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">bufferColor</span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">bufferData</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">color</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">STREAM_DRAW</span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">vertexAttribPointer</span><span class="p">(</span><span class="nx">attributeColor</span><span class="p">,</span><span class="w"> </span><span class="mf">3</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">FLOAT</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">enableVertexAttribArray</span><span class="p">(</span><span class="nx">attributeColor</span><span class="p">);</span><span class="w"> </span>

<span class="w">    </span><span class="cm">/* Draw the triangle. */</span>

<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">drawArrays</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TRIANGLES</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">3</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div>
<p>In this function, the variable <em>coords</em> contains values for the <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> named "a_coords" in the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>. That <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> represents the x and y coordinates of the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>. Since the <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> is of type <em>vec2</em>, two numbers are required for each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>. The value for <em>coords</em> is created here with a <strong><em>Float32Array</em></strong> <abbr title="In object-oriented programming, a subroutine that is used to create objects. A constructor for a class creates and initializes objects belonging to that class.">constructor</abbr> that takes an ordinary <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> array as its parameter; the values from the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> array are copied into the newly created <abbr title="In JavaScript, an array type that is limited to holding numerical values of a single type. For example, the type Float32Array represents arrays that can hold 32-bit floating point values, and Uint8Array arrays can hold only 8-bit integer values. Such arrays are more efficient than general JavaScript arrays for numerical calculations. The were introduced into JavaScript along with HTML canvas graphics and WebGL.">typed array</abbr>. Similarly, the variable color contains values for the "a_color" <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> in the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>, with three numbers per <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>.</p>
<p>We have now accounted for all the pieces of the RGB triangle program. Read the complete <a href="../../../en/source/webgl/webgl-rgb-triangle.html">source code</a> to see how it fits together.</p>
</div>
</div>
</div>
<h2 id="624-形状压模">6.2.4 形状压模<a class="headerlink" href="#624-形状压模" title="Permanent link">&para;</a></h2>
<p><strong>Shape Stamper</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="5:2"><input checked="checked" id="__tabbed_5_1" name="__tabbed_5" type="radio" /><input id="__tabbed_5_2" name="__tabbed_5" type="radio" /><div class="tabbed-labels"><label for="__tabbed_5_1">中文</label><label for="__tabbed_5_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>我们的下一个示例将介绍一些新特性。这个示例是一个简单的交互式程序，用户可以通过点击画布放置形状。形状的属性来自一组弹出菜单。属性包括形状的颜色和透明度，以及绘制的几种可能形状中的哪一种。形状以用户点击的点为中心。</p>
<p>示例程序是 <a href="../../../en/source/webgl/shape-stamper.html">webgl/shape-stamper.html</a>。这是一个程序的演示版本，你可以看到它的工作原理。</p>
<p><iframe src="../../../en/demos/c6/shape-stamper-demo.html" width="610" height="470"></iframe></p>
<p>在RGB三角形示例中，<em>color</em>是一个属性，因为每个三角形原语的顶点都被分配了不同的颜色。在<em>shape-stamper</em>程序中，所有顶点，实际上所有像素，在原语中都有相同的颜色。这意味着颜色可以是一个统一变量。示例还允许透明度，所以颜色需要alpha分量以及RGB分量。在程序中将alpha和RGB分量作为单独的数量处理是方便的，所以我在着色器程序中将它们表示为两个单独的统一变量。颜色和alpha统一变量在片段着色器中用于分配片段的颜色。实际上，片段着色器只做这件事，所以完整的源代码如下：</p>
<div class="highlight"><pre><span></span><code><span class="nx">precision</span><span class="w"> </span><span class="nx">mediump</span><span class="w"> </span><span class="kr">float</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">u_color</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="kr">float</span><span class="w"> </span><span class="nx">u_alpha</span><span class="p">;</span>
<span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">gl_FragColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="nx">u_color</span><span class="p">,</span><span class="w"> </span><span class="nx">u_alpha</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>要在JavaScript方面使用统一变量，我们需要知道它在着色器程序中的位置。程序使用命令在<em>initGL()</em>函数中获取两个统一变量的位置：</p>
<div class="highlight"><pre><span></span><code><span class="nx">uniformColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getUniformLocation</span><span class="p">(</span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;u_color&quot;</span><span class="p">);</span>
<span class="nx">uniformAlpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getUniformLocation</span><span class="p">(</span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;u_alpha&quot;</span><span class="p">);</span>
</code></pre></div>
<p>程序有两个弹出菜单，让用户选择用于绘制原语的颜色和alpha。绘制形状时，菜单中的值决定了统一变量的值：</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">colorNumber</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Number</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;colorChoice&quot;</span><span class="p">).</span><span class="nx">value</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Number</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;opacityChoice&quot;</span><span class="p">).</span><span class="nx">value</span><span class="p">);</span>

<span class="nx">gl</span><span class="p">.</span><span class="nx">uniform3fv</span><span class="p">(</span><span class="nx">uniformColor</span><span class="p">,</span><span class="w"> </span><span class="nx">colorList</span><span class="p">[</span><span class="nx">colorNumber</span><span class="p">]);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">uniform1f</span><span class="p">(</span><span class="nx">uniformAlpha</span><span class="p">,</span><span class="w"> </span><span class="nx">alpha</span><span class="p">);</span>
</code></pre></div>
<p>使用<em>gl.uniform*</em>系列函数设置统一变量的值。在这种情况下，<em>colorList[colorNumber]</em>是一个包含颜色的RGB颜色分量的三个数字数组，所以使用函数<em>gl.uniform3fv</em>来设置值："3f"意味着提供了3个浮点值，"v"意味着这三个值在数组中。请注意，需要三个浮点值来匹配着色器中统一变量的类型，<em>vec3</em>。<em><abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr></em>的值是一个单独的浮点数，所以使用<em>gl.uniform1f</em>设置相应的统一变量。</p>
<p>为了让颜色的alpha分量产生任何效果，必须启用alpha混合。这是通过初始化完成的，使用以下两个命令：</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">enable</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">BLEND</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">blendFunc</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">SRC_ALPHA</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">ONE_MINUS_SRC_ALPHA</span><span class="p">);</span>
</code></pre></div>
<p>第一行启用了alpha分量的使用。第二行告诉如何使用alpha分量。这里使用的"blendFunc"适用于2D中的透明度。在OpenGL 1.1的<a href="../../c3/s1/#312--opengl颜色">3.1.2小节</a>中也使用了相同的命令。</p>
<hr />
<p>当程序启动时，用户看到一个空白的白色画布。当用户点击画布时，会添加一个形状。当用户再次点击时，会添加第二个形状——第一个形状最好还在那里！然而，这不是WebGL的默认行为！</p>
<p>当用户点击画布时，会调用mousedown事件的事件处理程序函数。该函数中绘制了形状。当函数返回时，WebGL告诉网络浏览器图像已被修改，网络浏览器将新图像复制到屏幕上。一旦发生这种情况，正如本节前面讨论的，WebGL的默认行为是丢弃图像。但这意味着第二次鼠标点击是在空白画布上绘制，因为第一次鼠标点击的形状已被擦除。</p>
<p>为了解决这个问题，必须将WebGL图形上下文中的<em>preserveDrawingBuffer</em>选项设置为<em>true</em>。<em>shape-stamper</em>程序使用以下方式创建上下文：</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">options</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// 不需要alpha通道或深度缓冲区，但我们需要保留绘图缓冲区中的图像。</span>
<span class="w">    </span><span class="nx">alpha</span><span class="o">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span>
<span class="w">    </span><span class="nx">depth</span><span class="o">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span>
<span class="w">    </span><span class="nx">preserveDrawingBuffer</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="p">};</span>
<span class="nx">gl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">canvas</span><span class="p">.</span><span class="nx">getContext</span><span class="p">(</span><span class="s2">&quot;webgl&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">options</span><span class="p">);</span>
</code></pre></div>
<p>请注意，这个程序没有一个<em>draw()</em>函数来重新绘制整个图像。所有的绘制都在鼠标处理函数<em>doMouseDown</em>中完成。事情可以做得不同。程序可以使用数据结构来存储有关已绘制形状的信息。点击画布将向列表中添加一个项目，然后重新绘制整个图像，包括新形状。然而在实际程序中，图像中的内容的唯一记录就是图像本身。（用<a href="../../c1/s1/">第1.1节</a>的术语来说，它是一个绘画程序，而不是绘图程序。）</p>
<hr />
<p>WebGL使用一个默认的坐标系统，其中每个坐标的范围是-1到1。当然，我们希望使用一个更方便的坐标系统，这意味着我们需要应用坐标变换，将我们使用的坐标转换为默认坐标系统。在<em>shape-stamper</em>程序中，自然坐标系统是画布上的像素坐标。在像素坐标系统中，x坐标从左侧的0到右侧的<em>canvas.width</em>，y坐标从顶部的0到底部的<em>canvas.height</em>。将像素坐标(<em>x1,y1</em>)转换为默认坐标(<em>x2,y2</em>)的方程是：</p>
<div class="highlight"><pre><span></span><code><span class="nx">x2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mf">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">2</span><span class="o">*</span><span class="p">(</span><span class="w"> </span><span class="nx">x1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span><span class="w"> </span><span class="p">);</span>
<span class="nx">y2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2</span><span class="o">*</span><span class="p">(</span><span class="w"> </span><span class="nx">y1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>在WebGL中，坐标变换通常在顶点着色器中应用。在这种情况下，为了实现变换，顶点着色器只需要知道画布的宽度和高度。程序将宽度和高度作为统一变量提供给顶点着色器。顶点的原始像素坐标作为属性输入到顶点着色器。着色器应用坐标变换来计算<em>gl_Position</em>的值，该值必须以默认坐标系统表示。以下是顶点着色器源代码：</p>
<div class="highlight"><pre><span></span><code><span class="nx">attribute</span><span class="w"> </span><span class="nx">vec2</span><span class="w"> </span><span class="nx">a_coords</span><span class="p">;</span><span class="w">   </span><span class="c1">// 像素坐标</span>
<span class="nx">uniform</span><span class="w"> </span><span class="kr">float</span><span class="w"> </span><span class="nx">u_width</span><span class="p">;</span><span class="w">     </span><span class="c1">// 画布宽度</span>
<span class="nx">uniform</span><span class="w"> </span><span class="kr">float</span><span class="w"> </span><span class="nx">u_height</span><span class="p">;</span><span class="w">    </span><span class="c1">// 画布高度</span>
<span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">float</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mf">1.0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">2.0</span><span class="o">*</span><span class="p">(</span><span class="nx">a_coords</span><span class="p">.</span><span class="nx">x</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nx">u_width</span><span class="p">);</span>
<span class="w">    </span><span class="kr">float</span><span class="w"> </span><span class="nx">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2.0</span><span class="o">*</span><span class="p">(</span><span class="nx">a_coords</span><span class="p">.</span><span class="nx">y</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nx">u_height</span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>变换可能比这更复杂，特别是在3D中，但一般模式保持不变：变换由统一变量表示，并在顶点着色器中应用。通常，变换以矩阵形式实现。我们将在后面看到，统一变量可以是矩阵，着色器语言GLSL对矩阵操作有良好的支持。</p>
<p>为了绘制一个形状，我们需要在<strong><em>Float32Array</em></strong>中存储该形状的像素坐标；然后，我们必须将该数组中的值加载到与“a_coords”属性相关联的缓冲区中；最后，我们必须调用gl.drawArrays进行实际绘制。形状的坐标可以根据正在绘制的形状类型以及用户点击的点来计算。例如，以下是创建圆形坐标数组的代码，其中x和y是被点击的点的像素坐标：</p>
<div class="highlight"><pre><span></span><code><span class="nx">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Float32Array</span><span class="p">(</span><span class="mf">64</span><span class="p">);</span>
<span class="nx">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">32</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">angle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">i</span><span class="o">/</span><span class="mf">32</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">2</span><span class="o">*</span><span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="p">;</span>
<span class="w">    </span><span class="nx">coords</span><span class="p">[</span><span class="nx">k</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">50</span><span class="o">*</span><span class="nb">Math</span><span class="p">.</span><span class="nx">cos</span><span class="p">(</span><span class="nx">angle</span><span class="p">);</span><span class="w">  </span><span class="c1">// 顶点i的x坐标</span>
<span class="w">    </span><span class="nx">coords</span><span class="p">[</span><span class="nx">k</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">50</span><span class="o">*</span><span class="nb">Math</span><span class="p">.</span><span class="nx">sin</span><span class="p">(</span><span class="nx">angle</span><span class="p">);</span><span class="w">  </span><span class="c1">// 顶点i的y坐标</span>
<span class="p">}</span>
</code></pre></div>
<p>圆被近似为一个32边的规则多边形，半径为50像素。每个顶点需要两个坐标，所以数组的长度是64。其他形状的代码类似。一旦数组被创建，使用以下代码绘制形状：</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">bindBuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">bufferCoords</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bufferData</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">coords</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">STREAM_DRAW</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">vertexAttribPointer</span><span class="p">(</span><span class="nx">attributeCoords</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">FLOAT</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">);</span>

<span class="nx">gl</span><span class="p">.</span><span class="nx">drawArrays</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TRIANGLE_FAN</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">coords</span><span class="p">.</span><span class="nx">length</span><span class="o">/</span><span class="mf">2</span><span class="p">);</span>
</code></pre></div>
<p>在最后一行中，<em>coords.length/2</em>是形状中的顶点数，因为数组每个顶点保存两个数字。还要注意，<em>gl.bufferData</em>的最后一个参数是<em>gl.STREAM_DRAW</em>，当VBO中的数据只使用一次或几次后就被丢弃时，这是合适的。</p>
<hr />
<p>尽管示例程序的演示版本具有相同的功能，但我在两个版本中以不同的方式实现了形状绘制。注意，程序中的所有圆都是相同的；它们只是位于不同的地点。应该可以在自己的对象坐标中绘制圆，然后应用建模变换将圆移动到场景中所需位置。这是我在程序的演示版本中采用的方法。</p>
<p>有四种形状：圆形、正方形、三角形和星形。在演示版本中，我为每种形状创建了一个单独的VBO。一个形状的VBO包含该形状在对象坐标中的顶点坐标，形状以(0,0)为中心。由于对象坐标永远不会改变，VBO可以一次性创建，并作为程序初始化的一部分。例如，使用以下代码创建圆的VBO：</p>
<div class="highlight"><pre><span></span><code><span class="nx">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Float32Array</span><span class="p">(</span><span class="mf">64</span><span class="p">);</span><span class="w"> </span>
<span class="kd">let</span><span class="w"> </span><span class="nx">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w">  </span><span class="c1">// 索引到coords数组</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">32</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">angle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">i</span><span class="o">/</span><span class="mf">32</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">2</span><span class="o">*</span><span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="p">;</span>
<span class="w">    </span><span class="nx">coords</span><span class="p">[</span><span class="nx">k</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">50</span><span class="o">*</span><span class="nb">Math</span><span class="p">.</span><span class="nx">cos</span><span class="p">(</span><span class="nx">angle</span><span class="p">);</span><span class="w">  </span><span class="c1">// 顶点的x坐标</span>
<span class="w">    </span><span class="nx">coords</span><span class="p">[</span><span class="nx">k</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">50</span><span class="o">*</span><span class="nb">Math</span><span class="p">.</span><span class="nx">sin</span><span class="p">(</span><span class="nx">angle</span><span class="p">);</span><span class="w">  </span><span class="c1">// 顶点的y坐标</span>
<span class="p">}</span>

<span class="nx">bufferCoordsCircle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">();</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bindBuffer</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">bufferCoordsCircle</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bufferData</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">coords</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">STATIC_DRAW</span><span class="p">);</span>
</code></pre></div>
<p>注意最后一行中使用了<em>gl.STATIC_DRAW</em>。由于数据可以重用来绘制许多不同的圆，这是合适的。</p>
<p>要绘制一个中心位于(x,y)的形状，必须对VBO中的坐标应用平移。我在顶点着色器中添加了平移，并使用一个新的统一变量来表示平移量：</p>
<div class="highlight"><pre><span></span><code><span class="nx">attribute</span><span class="w"> </span><span class="nx">vec2</span><span class="w"> </span><span class="nx">a_coords</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="kr">float</span><span class="w"> </span><span class="nx">u_width</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="kr">float</span><span class="w"> </span><span class="nx">u_height</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">vec2</span><span class="w"> </span><span class="nx">u_translation</span><span class="p">;</span>
<span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">float</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mf">1.0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">2.0</span><span class="o">*</span><span class="p">((</span><span class="nx">a_coords</span><span class="p">.</span><span class="nx">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">u_translation</span><span class="p">.</span><span class="nx">x</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nx">u_width</span><span class="p">);</span>
<span class="w">    </span><span class="kr">float</span><span class="w"> </span><span class="nx">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2.0</span><span class="o">*</span><span class="p">((</span><span class="nx">a_coords</span><span class="p">.</span><span class="nx">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">u_translation</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nx">u_height</span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>你可能会觉得阅读<a href="../../../en/demos/c6/shape-stamper-demo.html">演示</a>和<a href="../../../en/source/webgl/shape-stamper.html">示例程序</a>的完整源代码是值得的。</p>
</div>
<div class="tabbed-block">
<p>Our next example will introduce a few new features. The example is a simple interactive program where the user can place shapes in a canvas by clicking the canvas with the mouse. Properties of the shape are taken from a set of popup menus. The properties include the color and degree of transparency of the shape, as well as which of several possible shapes is drawn. The shape is centered at the point where the user clicks.</p>
<p>The sample program is <a href="../../../en/source/webgl/shape-stamper.html">webgl/shape-stamper.html</a>. Here is a demo version of the program so you can see how it works.</p>
<p><iframe src="../../../en/demos/c6/shape-stamper-demo.html" width="610" height="470"></iframe></p>
<p>In the RGB triangle example, <em>color</em> is an <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>, since a different color is assigned to each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> of the triangle primitive. In the <em>shape-stamper</em> program, all vertices, and in fact all <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr>, in a primitive have the same color. That means that color can be a <abbr title="Variables that represent input to a shader program in a programmable graphics pipeline. A uniform variable has the same value at every vertex and at every pixel of a primitive.">uniform variable</abbr>. The example also allows transparency, so colors need an <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> component as well as the RGB components. It was convenient in the program to treat the <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> and RGB components as separate quantities, so I represent them as two separate uniform variables in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program. The color and <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> uniforms are used in the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> to assign the fragment's color. In fact, that's the only thing the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> does, so the complete source code is as follows:</p>
<div class="highlight"><pre><span></span><code><span class="nx">precision</span><span class="w"> </span><span class="nx">mediump</span><span class="w"> </span><span class="kr">float</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">u_color</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="kr">float</span><span class="w"> </span><span class="nx">u_alpha</span><span class="p">;</span>
<span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="nx">gl_FragColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="nx">u_color</span><span class="p">,</span><span class="w"> </span><span class="nx">u_alpha</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>To work with a <abbr title="Variables that represent input to a shader program in a programmable graphics pipeline. A uniform variable has the same value at every vertex and at every pixel of a primitive.">uniform variable</abbr> on the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side, we need to know its location in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program. The program gets the locations of the two uniform variables in the <em>intiGL()</em> function using the commands</p>
<div class="highlight"><pre><span></span><code><span class="nx">uniformColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getUniformLocation</span><span class="p">(</span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;u_color&quot;</span><span class="p">);</span>
<span class="nx">uniformAlpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getUniformLocation</span><span class="p">(</span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;u_alpha&quot;</span><span class="p">);</span>
</code></pre></div>
<p>The program has two popup menus that let the user select the color and <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> that are to be used for drawing a primitive. When a shape is drawn, the values from the menus determine the values of the uniforms:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">colorNumber</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Number</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;colorChoice&quot;</span><span class="p">).</span><span class="nx">value</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Number</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;opacityChoice&quot;</span><span class="p">).</span><span class="nx">value</span><span class="p">);</span>

<span class="nx">gl</span><span class="p">.</span><span class="nx">uniform3fv</span><span class="p">(</span><span class="w"> </span><span class="nx">uniformColor</span><span class="p">,</span><span class="w"> </span><span class="nx">colorList</span><span class="p">[</span><span class="nx">colorNumber</span><span class="p">]</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">uniform1f</span><span class="p">(</span><span class="w"> </span><span class="nx">uniformAlpha</span><span class="p">,</span><span class="w"> </span><span class="nx">alpha</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>Values for uniform variables are set using the <em>gl.uniform*</em> family of functions. In this case, <em>colorList[colorNumber]</em> is an array of three numbers holding the <abbr title="A color specified by three numbers giving the amount of red, green, and blue in the color.">RGB color</abbr> components for the color, so the function <em>gl.uniform3fv</em> is used to set the value: The "3f" means that 3 floating point values are provided, and the "v" means that the three values are in an array. Note that three floating point values are required to match the type, <em>vec3</em>, of the <abbr title="Variables that represent input to a shader program in a programmable graphics pipeline. A uniform variable has the same value at every vertex and at every pixel of a primitive.">uniform variable</abbr> in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>. The value of <em><abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr></em> is a single floating point number, so the corresponding <abbr title="Variables that represent input to a shader program in a programmable graphics pipeline. A uniform variable has the same value at every vertex and at every pixel of a primitive.">uniform variable</abbr> is set using <em>gl.uniform1f</em>.</p>
<p>In order for the <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> component of the color to have any effect, <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> blending must be enabled. This is done as part of initialization with the two commands</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">enable</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">BLEND</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">blendFunc</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">SRC_ALPHA</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">ONE_MINUS_SRC_ALPHA</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>The first line enables use of the <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> component. The second tells how the <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> component is to be used. The "blendFunc" used here is appropriate for transparency in 2D. The same commands were used in <a href="../../c3/s1/#312--opengl颜色">Subsection 3.1.2</a> in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1.</p>
<hr />
<p>When the program starts, the user sees a blank white canvas. When the user clicks the canvas, a shape is added. When the user clicks again, a second shape is added—and the first shape better still be there! However, this is not the default behavior for <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>!</p>
<p>When the user clicks the canvas, an event-handler function for the mousedown event is called. The shape is drawn in that function. When the function returns, <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> tells the web browser that the image has been modified, and the web browser copies the new image to the screen. Once that happens, as discussed earlier in this section, the default behavior for <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> is to discard the image. But this means that the second mouse click is drawing on a blank canvas, since the shape from the first mouse click has been erased.</p>
<p>To fix this problem, the <em>preserveDrawingBuffer</em> option in the <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> graphics context must be set to <em>true</em>. The <em>shape-stamper</em> program creates the context with</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">options</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// No need for alpha channel or depth buffer, but we</span>
<span class="w">                </span><span class="c1">// need to preserve the image in the drawing buffer.</span>
<span class="w">            </span><span class="nx">alpha</span><span class="o">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span>
<span class="w">            </span><span class="nx">depth</span><span class="o">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span>
<span class="w">            </span><span class="nx">preserveDrawingBuffer</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">    </span><span class="p">};</span>
<span class="nx">gl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">canvas</span><span class="p">.</span><span class="nx">getContext</span><span class="p">(</span><span class="s2">&quot;webgl&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">options</span><span class="p">);</span>
</code></pre></div>
<p>Note that this program does not have a <em>draw()</em> function that redraws the entire image. All the drawing is done in the mouse-handling function, <em>doMouseDown</em>. Things could have been done differently. The program could have used a data structure to store information about the shapes that have been drawn. Clicking the canvas would add an item to the list, and the entire image would then be redrawn, including the new shape. In the actual program, however, the only record of what's in the image is the image itself. (In the terminology of <a href="../../c1/s1/">Section 1.1</a>, it is a <abbr title="A computer program for creating images using raster-style graphics, where the user creates the image by controlling the colors of each pixel.">painting program</abbr> rather than a <abbr title="A computer program for creating images using vector-style graphics, where the user creates the image by specifying shapes that make up the image and their attributes.">drawing program</abbr>.)</p>
<hr />
<p><abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> uses a default <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr> in which each of the coordinates ranges from −1 to 1. Of course, we would like to use a more convenient <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr>, which means that we need to apply a coordinate transformation to transform the coordinates that we use into the default <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr>. In the <em>shape-stamper</em> program, the natural <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr> is <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> coordinates on the canvas. In the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr>, the x-coordinate ranges from 0 at the left to <em>canvas.width</em> at the right, and <em>y</em> ranges from 0 at the top to <em>canvas.height</em> at the bottom. The equations for transforming <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> coordinates (<em>x1,y1</em>) to default coordinates (<em>x2,y2</em>) are</p>
<div class="highlight"><pre><span></span><code><span class="nx">x2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mf">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">2</span><span class="o">*</span><span class="p">(</span><span class="w"> </span><span class="nx">x1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span><span class="w"> </span><span class="p">);</span>
<span class="nx">y2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2</span><span class="o">*</span><span class="p">(</span><span class="w"> </span><span class="nx">y1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>In <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>, the coordinate transformation is usually applied in the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>. In this case, to implement the transformation, the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> just needs to know the width and height of the canvas. The program provides the width and height to the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> as uniform variables. The original <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> coordinates of the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> are input to the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> as an <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>. The <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> applies the coordinate transformation to compute the value of <em>gl_Position</em>, which must be expressed in the default <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr>. Here is the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> source code:</p>
<div class="highlight"><pre><span></span><code><span class="nx">attribute</span><span class="w"> </span><span class="nx">vec2</span><span class="w"> </span><span class="nx">a_coords</span><span class="p">;</span><span class="w">   </span><span class="c1">// pixel coordinates</span>
<span class="nx">uniform</span><span class="w"> </span><span class="kr">float</span><span class="w"> </span><span class="nx">u_width</span><span class="p">;</span><span class="w">     </span><span class="c1">// width of canvas</span>
<span class="nx">uniform</span><span class="w"> </span><span class="kr">float</span><span class="w"> </span><span class="nx">u_height</span><span class="p">;</span><span class="w">    </span><span class="c1">// height of canvas</span>
<span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="kr">float</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mf">1.0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">2.0</span><span class="o">*</span><span class="p">(</span><span class="nx">a_coords</span><span class="p">.</span><span class="nx">x</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nx">u_width</span><span class="p">);</span>
<span class="kr">float</span><span class="w"> </span><span class="nx">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2.0</span><span class="o">*</span><span class="p">(</span><span class="nx">a_coords</span><span class="p">.</span><span class="nx">y</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nx">u_height</span><span class="p">);</span>
<span class="nx">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Transformations can be much more complicated than this, especially in 3D, but the general pattern holds: Transformations are represented by uniform variables and are applied in the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>. In general, transformations are implemented as matrices. We will see later that uniform variables can be matrices and that the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> language <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> has good support for <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> operations.</p>
<p>In order to draw a shape, we need to store the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> coordinates for that shape in a <strong><em>Float32Array</em></strong>; then, we have to load the values from that array into the buffer associated with the "a_coords" <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>; and finally, we must call gl.drawArrays to do the actual drawing. The coordinates for the shape can be computed based on what type of shape is being drawn and on the point where the user clicked. For example, the coordinate array for a circle is created by the following code, where x and y are the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> coordinates for the point that was clicked:</p>
<div class="highlight"><pre><span></span><code><span class="nx">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Float32Array</span><span class="p">(</span><span class="mf">64</span><span class="p">);</span>
<span class="nx">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">32</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">angle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">i</span><span class="o">/</span><span class="mf">32</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">2</span><span class="o">*</span><span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="p">;</span>
<span class="w">    </span><span class="nx">coords</span><span class="p">[</span><span class="nx">k</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">50</span><span class="o">*</span><span class="nb">Math</span><span class="p">.</span><span class="nx">cos</span><span class="p">(</span><span class="nx">angle</span><span class="p">);</span><span class="w">  </span><span class="c1">// x-coord of vertex i</span>
<span class="w">    </span><span class="nx">coords</span><span class="p">[</span><span class="nx">k</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">50</span><span class="o">*</span><span class="nb">Math</span><span class="p">.</span><span class="nx">sin</span><span class="p">(</span><span class="nx">angle</span><span class="p">);</span><span class="w">  </span><span class="c1">// y-coord of vertex i</span>
<span class="p">}</span>
</code></pre></div>
<p>The circle is approximated as a 32-sided regular <abbr title="A multi-sided shape lying in a plane and specified by a list of points, called its vertices, and made up of the line segments from each point in the list to the next point in the list, plus a line segment from the last point in the list to the first point. All the points are required to lie in the same plane. Sometimes the term &quot;polygon&quot; includes the interior of the shape as well as its boundary.">polygon</abbr>, with a radius of 50 <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr>. Two coordinates are required for each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>, so the length of the array is 64. The code for the other shapes is similar. Once the array has been created, the shape is drawn using</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">bindBuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">bufferCoords</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bufferData</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">coords</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">STREAM_DRAW</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">vertexAttribPointer</span><span class="p">(</span><span class="nx">attributeCoords</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">FLOAT</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">);</span>

<span class="nx">gl</span><span class="p">.</span><span class="nx">drawArrays</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TRIANGLE_FAN</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">coords</span><span class="p">.</span><span class="nx">length</span><span class="o">/</span><span class="mf">2</span><span class="p">);</span>
</code></pre></div>
<p>In the last line, <em>coords.length/2</em> is the number of vertices in the shape, since the array holds two numbers per <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>. Note also that the last parameter to <em>gl.bufferData</em> is <em>gl.STREAM_DRAW</em>, which is appropriate when the data in the <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr> will only be used once or a few times before being discarded.</p>
<hr />
<p>Although the demo version of the sample program has the same functionality, I implemented shape drawing differently in the two versions. Notice that all circles in the program are the same; they are just in different locations. It should be possible to draw the circle in its own <abbr title="The coordinate system in which the coordinates for points in an object are originally specified, before they are transformed by any modeling or other transform that will be applied to the object.">object coordinates</abbr>, and then apply a <abbr title="A transformation that is applied to an object to map that object into the world coordinate system or into the object coordinate system for a more complex, hierarchical object.">modeling transformation</abbr> to move the circle to its desired position in the scene. This is the approach that I take in the demo version of the program.</p>
<p>There are four kinds of shape: circles, squares, triangles, and stars. In the demo version, I create a separate <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr> for each kind of shape. The <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr> for a shape contains <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> coordinates for that shape in <abbr title="The coordinate system in which the coordinates for points in an object are originally specified, before they are transformed by any modeling or other transform that will be applied to the object.">object coordinates</abbr>, with the shape centered at (0,0). Since the <abbr title="The coordinate system in which the coordinates for points in an object are originally specified, before they are transformed by any modeling or other transform that will be applied to the object.">object coordinates</abbr> will never change, the <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr> can be created once and for all as part of program initialization. For example, the <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr> for the circle is created with</p>
<div class="highlight"><pre><span></span><code><span class="nx">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Float32Array</span><span class="p">(</span><span class="mf">64</span><span class="p">);</span><span class="w"> </span>
<span class="kd">let</span><span class="w"> </span><span class="nx">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w">  </span><span class="c1">// index into the coords array</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">32</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">angle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">i</span><span class="o">/</span><span class="mf">32</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">2</span><span class="o">*</span><span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="p">;</span>
<span class="w">    </span><span class="nx">coords</span><span class="p">[</span><span class="nx">k</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">50</span><span class="o">*</span><span class="nb">Math</span><span class="p">.</span><span class="nx">cos</span><span class="p">(</span><span class="nx">angle</span><span class="p">);</span><span class="w">  </span><span class="c1">// x-coord of vertex</span>
<span class="w">    </span><span class="nx">coords</span><span class="p">[</span><span class="nx">k</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">50</span><span class="o">*</span><span class="nb">Math</span><span class="p">.</span><span class="nx">sin</span><span class="p">(</span><span class="nx">angle</span><span class="p">);</span><span class="w">  </span><span class="c1">// y-coord of vertex</span>
<span class="p">}</span>

<span class="nx">bufferCoordsCircle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">();</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bindBuffer</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">bufferCoordsCircle</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bufferData</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">coords</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">STATIC_DRAW</span><span class="p">);</span>
</code></pre></div>
<p>Note the use of <em>gl.STATIC_DRAW</em> in the last line. It is appropriate since the data can be reused to draw many different circles.</p>
<p>To draw a shape with its center at (x,y), a <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr> must be applied to the coordinates in the <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr>. I added the <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr> to the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>, with a new <abbr title="Variables that represent input to a shader program in a programmable graphics pipeline. A uniform variable has the same value at every vertex and at every pixel of a primitive.">uniform variable</abbr> to represent the <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr> amount:</p>
<div class="highlight"><pre><span></span><code><span class="nx">attribute</span><span class="w"> </span><span class="nx">vec2</span><span class="w"> </span><span class="nx">a_coords</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="kr">float</span><span class="w"> </span><span class="nx">u_width</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="kr">float</span><span class="w"> </span><span class="nx">u_height</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">vec2</span><span class="w"> </span><span class="nx">u_translation</span><span class="p">;</span>
<span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="kr">float</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mf">1.0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">2.0</span><span class="o">*</span><span class="p">((</span><span class="nx">a_coords</span><span class="p">.</span><span class="nx">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">u_translation</span><span class="p">.</span><span class="nx">x</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nx">u_width</span><span class="p">);</span>
<span class="kr">float</span><span class="w"> </span><span class="nx">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2.0</span><span class="o">*</span><span class="p">((</span><span class="nx">a_coords</span><span class="p">.</span><span class="nx">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">u_translation</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nx">u_height</span><span class="p">);</span>
<span class="nx">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>You would probably find it worthwhile to read the full source code for the <a href="../../../en/demos/c6/shape-stamper-demo.html">demo</a> as well as the <a href="../../../en/source/webgl/shape-stamper.html">sample program</a>.</p>
</div>
</div>
</div>
<h2 id="625-points原语">6.2.5 POINTS原语<a class="headerlink" href="#625-points原语" title="Permanent link">&para;</a></h2>
<p><strong>The POINTS Primitive</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="6:2"><input checked="checked" id="__tabbed_6_1" name="__tabbed_6" type="radio" /><input id="__tabbed_6_2" name="__tabbed_6" type="radio" /><div class="tabbed-labels"><label for="__tabbed_6_1">中文</label><label for="__tabbed_6_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>这一节的最后一个示例演示了<em>gl.POINTS</em>原语。<em>POINTS</em>原语基本上是一组不相连的顶点。默认情况下，每个顶点被渲染为一个像素。然而，程序可以指定更大的大小。在OpenGL 1.1中，这是通过函数<em>gl_PointSize()</em>完成的。在WebGL中，那个函数不存在。相反，大小由顶点着色器控制。</p>
<p>在处理<em>POINTS</em>原语的顶点时，顶点着色器应该给特殊的内置变量<em>gl_PointSize</em>赋值。该变量是float类型。它给出了顶点的大小，以像素为单位。顶点被渲染为一个正方形，中心位于顶点位置，宽度和高度由<em>gl_PointSize</em>给出。这实际上意味着，片段着色器将为正方形中的每个像素调用一次。注意，有一个依赖于实现的限制，大小可能相当小。唯一保证存在的大小是一个像素，但大多数实现似乎支持至少到64像素的点大小，可能更大。</p>
<p>当片段着色器被调用处理<em>POINTS</em>原语时，它正在处理围绕顶点的像素正方形中的一个像素。特殊的片段着色器变量<em>gl_PointCoord</em>告诉着色器像素在正方形内的位置。<em>gl_PointCoord</em>的值是着色器的输入。<em>gl_PointCoord</em>的类型是<em>vec2</em>，所以它有两个浮点分量。每个分量的值在0到1的范围内。第一个分量，<em>gl_PointCoord.x</em>，在正方形的左边缘为0，在右边缘为1。第二个分量，<em>gl_PointCoord.y</em>，在正方形的顶部为0，在底部为1。例如，该值在左上角为(0,0)，在右上角为(1,0)，在正方形中心为(0.5,0.5)。（至少，规格是这样的，但我遇到过实现错误地将(0,0)放在左下角。希望现代网络浏览器已经修复了这个问题。）</p>
<p>如果片段着色器在其计算中使用<em>gl_PointCoord</em>，正方形的颜色可以逐像素变化。作为一个简单的例子，设置</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl_FragColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="w"> </span><span class="nx">gl_PointCoord</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>将把原语中的每个顶点渲染为一个正方形颜色渐变，颜色从正方形左边缘的黑色水平变化到右边缘的红色。在示例程序中，我使用gl_PointCoord将顶点渲染为圆盘而不是正方形。该技术使用了一个新的GLSL语句，discard，仅在片段着色器中可用。当片段着色器执行语句</p>
<div class="highlight"><pre><span></span><code><span class="nx">discard</span><span class="p">;</span>
</code></pre></div>
<p>片段着色器终止，阻止对像素的所有进一步处理。特别是，图像中像素的颜色不会改变。我使用<em>discard</em>，如果从<em>gl_PointCoord</em>到中心(0.5,0.5)的距离大于0.5。这将丢弃不位于半径为0.5的圆盘内的像素。GLSL有一个函数用于计算两个向量之间的距离，所以在片段着色器中的测试编写为</p>
<div class="highlight"><pre><span></span><code><span class="kr">float</span><span class="w"> </span><span class="nx">distanceFromCenter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">distance</span><span class="p">(</span><span class="w"> </span><span class="nx">gl_PointCoord</span><span class="p">,</span><span class="w"> </span><span class="nx">vec2</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="nx">distanceFromCenter</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">discard</span><span class="p">;</span><span class="w">  </span><span class="c1">// 不绘制此像素！</span>
<span class="p">}</span>
</code></pre></div>
<p>示例程序是<a href="../../../en/source/webgl/moving-points.html">webgl/moving-points.html</a>。它展示了一个动画，彩色圆盘在画布中移动并从边缘反弹。所有圆盘都是一步中作为<em>gl.POINTS</em>类型的单个原语绘制的。圆盘的大小实现为统一变量，以便所有圆盘具有相同的大小，但统一大小在动画的不同帧中可以不同。在程序中，用户可以通过弹出菜单控制大小。这是程序的演示版本，功能相同：</p>
<p><iframe src="../../../en/demos/c6/moving-points-demo.html" width="570" height="370"></iframe></p>
<p>在程序中，用户可以选择圆盘是随机颜色还是全部为红色。由于每个圆盘是一个单个POINTS原语的顶点，圆盘可以有不同的颜色意味着颜色必须由属性变量给出。要实现随机颜色，一个<strong><em>Float32Array</em></strong>用随机数字填充，每个顶点三个。值被加载到VBO中，颜色属性的值来自VBO。但是当所有圆盘都是红色时会发生什么？我们必须用多个“1, 0, 0”的副本填充数组，并使用该数据作为属性吗？事实上，我们不必。如果我们禁用颜色属性的VertexAttribArray，那么该属性将对每个顶点具有相同的值。该值由gl.vertexAttrib*系列函数指定。所以，在示例程序中，提供颜色属性值的代码是</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="nx">randomColors</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="c1">// 使用在初始化期间填充的颜色VBO中的属性值。</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">enableVertexAttribArray</span><span class="p">(</span><span class="w"> </span><span class="nx">attributeColor</span><span class="w"> </span><span class="p">);</span><span class="w"> </span>
<span class="p">}</span>
<span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="c1">// 关闭VertexAttribArray，</span>
<span class="w">    </span><span class="c1">//     并设置一个恒定的属性颜色。</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">disableVertexAttribArray</span><span class="p">(</span><span class="w"> </span><span class="nx">attributeColor</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">vertexAttrib3f</span><span class="p">(</span><span class="w"> </span><span class="nx">attributeColor</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>查看<a href="../../../en/source/webgl/moving-points.html">源代码</a>了解示例的完整细节。</p>
</div>
<div class="tabbed-block">
<p>The final example in this section demonstrates the <em>gl.POINTS</em> primitive. A <em>POINTS</em> primitive is basically a set of disconnected vertices. By default, each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> is rendered as a single <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>. However, a program can specify a larger size. In <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1, this was done with the function <em>gl_PointSize()</em>. In <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>, that function does not exist. Instead, the size is under the control of the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>.</p>
<p>When working on one of the vertices of a <em>POINTS</em> primitive, the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> should assign a value to the special built-in variable <em>gl_PointSize</em>. The variable is of type float. It gives the size of the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>, in <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr>. The <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> is rendered as a square, centered at the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> position, whose width and height are given by <em>gl_PointSize</em>. What this really means is that the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> will be called once for each <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> in that square. Note that there is an implementation-dependent limit on the size of points, which can be fairly small. The only size that is guaranteed to exist is one <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>, but most implementations seem to support point sizes at least up to 64 <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr>, and possibly much larger.</p>
<p>When the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> is called for a <em>POINTS</em> primitive, it is processing one <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> in the square of <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr> surrounding the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>. The special <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> variable <em>gl_PointCoord</em> tells the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> the location of the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> within that square. The value of <em>gl_PointCoord</em> is an input to the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>. The type of <em>gl_PointCoord</em> is <em>vec2</em>, so it has two floating point components. The value of each component is in the range 0 to 1. The first component, <em>gl_PointCoord.x</em>, is 0 at the left edge of the square and 1 at the right. The second component, <em>gl_PointCoord.y</em>, is 0 at the top of the square and 1 at the bottom. So, for example, the value is (0,0) at the top-left corner, (1,0) at the top-right corner, and (0.5,0.5) at the center of the square. (That, at least, is what the specification says, but I have encountered implementations that incorrectly put (0,0) at the bottom left corner. Hopefully that is fixed in modern web browsers.)</p>
<p>If the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> uses <em>gl_PointCoord</em> in its computation, the color of the square can vary from <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> to <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>. As a simple example, setting</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl_FragColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="w"> </span><span class="nx">gl_PointCoord</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>would render each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> in the primitive as a square color <abbr title="A pattern of color produced by assigning colors to certain reference points and computing color for other points by interpolating or extrapolating colors from the reference points. The effect is a color progression along line segments between reference points. Different rules for extending the colors beyond those lines produce different types of gradient, such as linear gradients and radial gradients.">gradient</abbr> whose color varies horizontally from black on the left edge of the square to red on the right edge. In the sample program, I use gl_PointCoord to render the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> as a disk instead of a square. The technique uses a new <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> statement, discard, which is available only in the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr>. When the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> executes the statement</p>
<div class="highlight"><pre><span></span><code><span class="nx">discard</span><span class="p">;</span>
</code></pre></div>
<p>the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> terminates, and all further processing of the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> is prevented. In particular, the color of the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> in the image does not change. I use <em>discard</em> if the distance from <em>gl_PointCoord</em> to the center, (0.5,0.5), is greater than 0.5. This discards <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr> that do not lie in the disk of radius 0.5. <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> has a function for computing the distance between two vectors, so the test in the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> is written</p>
<div class="highlight"><pre><span></span><code><span class="kr">float</span><span class="w"> </span><span class="nx">distanceFromCenter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">distance</span><span class="p">(</span><span class="w"> </span><span class="nx">gl_PointCoord</span><span class="p">,</span><span class="w"> </span><span class="nx">vec2</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="nx">distanceFromCenter</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="nx">discard</span><span class="p">;</span><span class="w">  </span><span class="c1">// don&#39;t draw this pixel!</span>
<span class="p">}</span>
</code></pre></div>
<p>The sample program is <a href="../../../en/source/webgl/moving-points.html">webgl/moving-points.html</a>. It shows an <abbr title="A sequence of images that, when displayed quickly one after the other, will produce the impression of continuous motion or change. The term animation also refers to the process of creating such image sequences.">animation</abbr> of colored disks moving in the canvas and bouncing off the edges. All of the disks are drawn in one step as a single primitive of type <em>gl.POINTS</em>. The size of the disks is implemented as a <abbr title="Variables that represent input to a shader program in a programmable graphics pipeline. A uniform variable has the same value at every vertex and at every pixel of a primitive.">uniform variable</abbr>, so that all the disks have the same size, but the uniform size can be different in different frames of the <abbr title="A sequence of images that, when displayed quickly one after the other, will produce the impression of continuous motion or change. The term animation also refers to the process of creating such image sequences.">animation</abbr>. In the program, the user controls the size with a popup menu. Here is a demo version of the program, with the same functionality:</p>
<p><iframe src="../../../en/demos/c6/moving-points-demo.html" width="570" height="370"></iframe></p>
<p>In the program, the user can select whether the disks have random colors or are all colored red. Since each disk is a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> of a single POINTS primitive, the fact that the disks can have different colors means that the color has to be given by an <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> variable. To implement random colors, a <strong><em>Float32Array</em></strong> is filled with random numbers, three for each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>. The values are loaded into a <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr>, and the values for the color <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> are taken from the <abbr title="Vertex Buffer Object. A block of memory that can hold the coordinates or other attributes for a set of vertices. A VBO can be stored on a GPU. VBOs make it possible to send such data to the GPU once and then reuse it several times. In OpenGL, VBOs are used with the functions glDrawArrays and glDrawElements.">VBO</abbr>. But what happens when all the disks are red? Do we have to fill an array with multiple copies of "1, 0, 0" and use that data for the <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>? In fact, we don't. If we disable the VertexAttribArray for the color <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>, then that <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> will have the same value for every <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>. The value is specified by the gl.vertexAttrib* family of functions. So, in the sample program, the code for providing values for the color <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> is</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="nx">randomColors</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="c1">// Use the attribute values from the color VBO, </span>
<span class="w">        </span><span class="c1">//     which was filled during initialization.</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">enableVertexAttribArray</span><span class="p">(</span><span class="w"> </span><span class="nx">attributeColor</span><span class="w"> </span><span class="p">);</span><span class="w"> </span>
<span class="p">}</span>
<span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="c1">// Turn off VertexAttribArray,</span>
<span class="w">        </span><span class="c1">//     and set a constant attribute color.</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">disableVertexAttribArray</span><span class="p">(</span><span class="w"> </span><span class="nx">attributeColor</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">vertexAttrib3f</span><span class="p">(</span><span class="w"> </span><span class="nx">attributeColor</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>See the <a href="../../../en/source/webgl/moving-points.html">source code</a> for full details of the example.</p>
</div>
</div>
</div>
<h2 id="626-webgl-错误处理">6.2.6 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 错误处理<a class="headerlink" href="#626-webgl-错误处理" title="Permanent link">&para;</a></h2>
<p><strong><abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> Error Handling</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="7:2"><input checked="checked" id="__tabbed_7_1" name="__tabbed_7" type="radio" /><input id="__tabbed_7_2" name="__tabbed_7" type="radio" /><div class="tabbed-labels"><label for="__tabbed_7_1">中文</label><label for="__tabbed_7_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>OpenGL程序员经常发现自己面对一个空白屏幕，没有清楚地指示出了什么问题。在许多情况下，这是由于编程逻辑错误，例如意外地绘制了一个不包含任何几何体的3D空间区域。然而，有时这是由于API使用错误。在WebGL中，以及更普遍的OpenGL中，像非法参数值这样的错误通常不会使程序崩溃或产生任何自动的错误通知。相反，当WebGL检测到这样的错误时，它会忽略非法的函数调用，并设置一个错误代码的值，该值提供了一些关于错误性质的指示。</p>
<p>程序可以通过调用<em>gl.getError()</em>来检查当前的错误代码值。这个函数返回一个整数错误代码。如果没有发生错误，返回值是<em>gl.NO_ERROR</em>。任何其他返回值意味着发生了错误。一旦设置了错误代码，它就会一直保持设置状态，直到调用<em>gl.getError()</em>，即使在此期间执行了其他正确的WebGL操作。调用<em>gl.getError()</em>检索错误代码的值，并将值重置为<em>gl.NO_ERROR</em>。（所以，如果你连续两次调用<em>gl.getError()</em>，第二次调用总是返回<em>gl.NO_ERROR</em>。）这意味着当<em>gl.getError()</em>返回错误时，错误实际上可能是由之前执行的某个指令生成的。</p>
<p>作为一个例子，考虑调用<em>gl.drawArrays(primitive,first,count)</em>。如果primitive不是七个合法的WebGL原语之一，那么WebGL将把错误代码设置为<em>gl.INVALID_ENUM</em>。如果first或count是负数，错误代码设置为<em>gl.INVALID_VALUE</em>。如果没有使用gl.useProgram安装着色器程序，错误是<em>gl.INVALID_OPERATION</em>。如果没有为启用的顶点属性指定数据，就会发生<em>gl.INVALID_STATE</em>类型的错误。这四个错误代码实际上是最常见的。</p>
<p>在每个WebGL函数调用后调用<em>gl.getError</em>既不切实际也不高效。然而，当出现问题时，它可以作为调试工具。当我怀疑有错误时，我可能会在代码的几个点插入如下代码：</p>
<div class="highlight"><pre><span></span><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;Error code is &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getError</span><span class="p">());</span>
</code></pre></div>
<p><em>gl.NO_ERROR</em>的数值是零。任何非零值意味着在调用<em>gl.getError()</em>之前的某个点发生了错误。通过在代码中移动输出语句，我可以缩小到实际产生错误的语句。</p>
<p>请注意，一些浏览器会自动将有关WebGL不正确使用的某些信息输出到它们的JavaScript控制台，这是许多浏览器内置的开发工具的一部分。那个控制台也是使用<em>console.log()</em>写入消息的目的地。在运行正在开发的WebGL程序时，始终检查控制台是一个好主意！</p>
</div>
<div class="tabbed-block">
<p>It is a sad fact that <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> programmers often find themselves looking at a blank screen, with no clear indication of what went wrong. In many cases, this is due to a programming logic error, such as accidentally drawing a region of 3D space that contains no geometry. However, sometimes it's due to an error in the use of the <abbr title="Application Programming Interface. A collection of related classes, functions, constants, etc., for performing some task. An API is an &quot;interface&quot; in the sense that it can be used without understanding how its functionality is actually implemented.">API</abbr>. In <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>, and in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> more generally, an error such as an illegal parameter value will not in general crash the program or produce any automatic notification of the error. Instead, when <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> detects such an error, it ignores the illegal function call, and it sets the value of an error code that gives some indication of the nature of the error.</p>
<p>A program can check the current value of the error code by calling <em>gl.getError()</em>. This function returns an integer error code. The return value is <em>gl.NO_ERROR</em> if no error has occurred. Any other return value means that an error has occurred. Once an error code has been set, it stays set until <em>gl.getError()</em> is called, even if other, correct <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> operations have been executed in the meantime. Calling <em>gl.getError()</em> retrieves the value of the error code and resets its value to <em>gl.NO_ERROR</em>. (So, if you call <em>gl.getError()</em> twice in a row, the second call will always return <em>gl.NO_ERROR</em>.) This means that when <em>gl.getError()</em> returns an error, the error might actually have been generated by an instruction that was executed some time ago.</p>
<p>As an example, consider a call to <em>gl.drawArrays(primitive,first,count)</em>. If primitive is not one of the seven legal <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> primitives, then <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> will set the error code to <em>gl.INVALID_ENUM</em>. If first or count is negative, the error code is set to <em>gl.INVALID_VALUE</em>. If no <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program has been installed with gl.useProgram, the error is <em>gl.INVALID_OPERATION</em>. If no data has been specified for an enabled <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>, an error of type <em>gl.INVALID_STATE</em> occurs. These four error codes are, in fact, the most common.</p>
<p>It is both impractical and inefficient to call <em>gl.getError</em> after each <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> function call. However, when something goes wrong, it can be used as a debugging aid. When I suspect an error, I might insert code such as</p>
<div class="highlight"><pre><span></span><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;Error code is &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getError</span><span class="p">());</span>
</code></pre></div>
<p>at several points in my code. The numeric value of <em>gl.NO_ERROR</em> is zero. Any non-zero value means that an error occurred at some point before the call to <em>gl.getError</em>. By moving the output statements around in the code, I can narrow in on the statement that actually produced the error.</p>
<p>Note that some browsers automatically output certain information about incorrect use of <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> to their <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> console, which is part of the development tools built into many browsers. That console is also the destination for messages written using <em>console.log()</em>. It's always a good idea to check the console when running a <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> program that is under development!</p>
</div>
</div>
</div>







  
    
  
  
    
  


  <aside class="md-source-file">
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="最后更新">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1-2.1-2M12.5 7v5.2l4 2.4-1 1L11 13V7h1.5M11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2v1.8Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">2024年6月13日</span>
  </span>

    
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="创建日期">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.47 15.08 11 13V7h1.5v5.25l3.08 1.83c-.41.28-.79.62-1.11 1m-1.39 4.84c-.36.05-.71.08-1.08.08-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8c0 .37-.03.72-.08 1.08.69.1 1.33.32 1.92.64.1-.56.16-1.13.16-1.72 0-5.5-4.5-10-10-10S2 6.5 2 12s4.47 10 10 10c.59 0 1.16-.06 1.72-.16-.32-.59-.54-1.23-.64-1.92M18 15v3h-3v2h3v3h2v-3h3v-2h-3v-3h-2Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">2024年5月26日</span>
  </span>

    
    
    
  </aside>





                
              </article>
            </div>
          
          
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var tab,labels=set.querySelector(".tabbed-labels");for(tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script>

<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../../..", "features": ["content.code.copy", "content.tabs.link", "navigation.tabs", "navigation.tabs.sticky", "navigation.indexes", "navigation.top", "toc.follow", "content.tooltips"], "search": "../../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.3220b9d7.min.js"></script>
      
        <script src="../../../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="https://unpkg.com/mermaid@9.4.0/dist/mermaid.min.js"></script>
      
    
  <script>document$.subscribe(() => {const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});})</script></body>
</html>