
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="计算机图形学概论(graphicsbook)">
      
      
      
        <link rel="canonical" href="https://hellowac.github.io/graphicsbook-zh-cn/cn/c6/s4/">
      
      
        <link rel="prev" href="../s3/">
      
      
        <link rel="next" href="../s5/">
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.5.18">
    
    
      
        <title>6.4 图像纹理 - 计算机图形学概论</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.66ac8b77.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.06af60db.min.css">
      
      

  
  
  
  
  <style>:root{--md-annotation-icon:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M22 12a10 10 0 0 1-10 10A10 10 0 0 1 2 12 10 10 0 0 1 12 2a10 10 0 0 1 10 10M6 13h8l-3.5 3.5 1.42 1.42L17.84 12l-5.92-5.92L10.5 7.5 14 11H6v2Z"/></svg>');}</style>


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
   <link href="../../../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
        html.glightbox-open { overflow: initial; height: 100%; }
        .gslide-title { margin-top: 0px; user-select: text; }
        .gslide-desc { color: #666; user-select: text; }
        .gslide-image img { background: white; }
        
            .gscrollbar-fixer { padding-right: 15px; }
            .gdesc-inner { font-size: 0.75rem; }
            body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
            body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
            body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}
            </style> <script src="../../../assets/javascripts/glightbox.min.js"></script></head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="default" data-md-color-accent="red">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#64-图像纹理" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="计算机图形学概论" class="md-header__button md-logo" aria-label="计算机图形学概论" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            计算机图形学概论
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              6.4 图像纹理
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
      <div class="md-header__option">
  <div class="md-select">
    
    <button class="md-header__button md-icon" aria-label="选择当前语言">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m12.87 15.07-2.54-2.51.03-.03A17.52 17.52 0 0 0 14.07 6H17V4h-7V2H8v2H1v2h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04M18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12m-2.62 7 1.62-4.33L19.12 17h-3.24Z"/></svg>
    </button>
    <div class="md-select__inner">
      <ul class="md-select__list">
        
          <li class="md-select__item">
            <a href="/graphicsbook-zh-cn/en/" hreflang="en" class="md-select__link">
              English
            </a>
          </li>
        
          <li class="md-select__item">
            <a href="/graphicsbook-zh-cn/cn/" hreflang="cn" class="md-select__link">
              中文
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</div>
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/hellowac/graphicsbook-zh-cn" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    graphicsbook
  </div>
</a>
      </div>
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../" class="md-tabs__link">
        
  
    
  
  首页

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../preface/" class="md-tabs__link">
        
  
    
  
  前言

      </a>
    </li>
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c1/" class="md-tabs__link">
          
  
    
  
  1.简介

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c2/" class="md-tabs__link">
          
  
    
  
  2.二维图形

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c3/" class="md-tabs__link">
          
  
    
  
  3.几何

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c4/" class="md-tabs__link">
          
  
    
  
  4.灯光和材质

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c5/" class="md-tabs__link">
          
  
    
  
  5.three.js

        </a>
      </li>
    
  

      
        
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../" class="md-tabs__link">
          
  
    
  
  6.WebGL

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c7/" class="md-tabs__link">
          
  
    
  
  7.WebGL 3D

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c8/" class="md-tabs__link">
          
  
    
  
  8.高阶3D

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c9/" class="md-tabs__link">
          
  
    
  
  9.WEBGPU

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../a1/" class="md-tabs__link">
          
  
    
  
  附录

        </a>
      </li>
    
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../.." class="md-tabs__link">
        
  
    
  
  关于

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="计算机图形学概论" class="md-nav__button md-logo" aria-label="计算机图形学概论" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    计算机图形学概论
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/hellowac/graphicsbook-zh-cn" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    graphicsbook
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    首页
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../preface/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    前言
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c1/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    1.简介
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_3" id="__nav_3_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            1.简介
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 1 节 绘画与绘图
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 2 节：三维(3D)图形的要素
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 3 节：硬件与软件
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c2/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    2.二维图形
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_4" id="__nav_4_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            2.二维图形
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第1节: 像素、坐标和颜色
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第2节: 形状
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第3节: 变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第4节: 分层建模
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第5节: Java 绘制2D
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第6节: HTML Canvas图形
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第7节: SVG：一种场景描述语言
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c3/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    3.几何
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_5" id="__nav_5_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            3.几何
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.1 OpenGL 1.1 中的形状和颜色
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.2 3D 坐标和变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.3 投影与观看
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.4 多边形网格和 glDrawArrays
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.5 部分线性代数基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.6 使用 GLUT 和 JOGL
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c4/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    4.灯光和材质
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_6" id="__nav_6_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6">
            <span class="md-nav__icon md-icon"></span>
            4.灯光和材质
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.1 照明简介
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.2 OpenGL 1.1 中的光和材质
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.3 图像纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.4 灯光、相机、动作
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c5/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    5.three.js
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_7" id="__nav_7_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7">
            <span class="md-nav__icon md-icon"></span>
            5.three.js
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.1 Three.js 基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.2 构建对象
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.3 其他功能
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" checked>
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    6.WebGL
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_8" id="__nav_8_label" tabindex="">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_8">
            <span class="md-nav__icon md-icon"></span>
            6.WebGL
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.1 可编程流水线
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.2 第一个例子
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.3 GLSL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    6.4 图像纹理
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    6.4 图像纹理
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#641-纹理单元和纹理对象" class="md-nav__link">
    <span class="md-ellipsis">
      6.4.1 纹理单元和纹理对象
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#642-处理图像" class="md-nav__link">
    <span class="md-ellipsis">
      6.4.2 处理图像
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#643-更多制作纹理的方法" class="md-nav__link">
    <span class="md-ellipsis">
      6.4.3 更多制作纹理的方法
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#644-立方体贴图纹理" class="md-nav__link">
    <span class="md-ellipsis">
      6.4.4 立方体贴图纹理
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#645-计算示例" class="md-nav__link">
    <span class="md-ellipsis">
      6.4.5 计算示例
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#646-webgl-20-中的纹理" class="md-nav__link">
    <span class="md-ellipsis">
      6.4.6 WebGL 2.0 中的纹理
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.5 实现 2D 变换
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c7/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    7.WebGL 3D
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_9" id="__nav_9_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9">
            <span class="md-nav__icon md-icon"></span>
            7.WebGL 3D
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.1 3D变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.2 照明和材质
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.3 纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.4 帧缓冲区
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.5 WebGL 扩展
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c8/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    8.高阶3D
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_10" id="__nav_10_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_10_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10">
            <span class="md-nav__icon md-icon"></span>
            8.高阶3D
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c8/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8.1 光线追踪
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c8/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8.2 路径追踪
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_11" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c9/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    9.WEBGPU
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_11" id="__nav_11_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_11_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_11">
            <span class="md-nav__icon md-icon"></span>
            9.WEBGPU
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.1 WebGPU 基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.2 实例和索引
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.3 WGSL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.4 WebGPU 中的 3D 图形
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.5 纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.6 计算着色器
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.7 细节
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_12" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../a1/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    附录
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_12" id="__nav_12_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_12_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_12">
            <span class="md-nav__icon md-icon"></span>
            附录
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a2/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Blender 3D建模
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a3/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Gimp和Inkscape
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../source/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    示例程序源代码
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../glossary/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    术语表
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    关于
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#641-纹理单元和纹理对象" class="md-nav__link">
    <span class="md-ellipsis">
      6.4.1 纹理单元和纹理对象
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#642-处理图像" class="md-nav__link">
    <span class="md-ellipsis">
      6.4.2 处理图像
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#643-更多制作纹理的方法" class="md-nav__link">
    <span class="md-ellipsis">
      6.4.3 更多制作纹理的方法
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#644-立方体贴图纹理" class="md-nav__link">
    <span class="md-ellipsis">
      6.4.4 立方体贴图纹理
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#645-计算示例" class="md-nav__link">
    <span class="md-ellipsis">
      6.4.5 计算示例
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#646-webgl-20-中的纹理" class="md-nav__link">
    <span class="md-ellipsis">
      6.4.6 WebGL 2.0 中的纹理
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="64-图像纹理">6.4 <abbr title="应用于表面的图像，看起来就像是“画”在表面上。">图像纹理</abbr><a class="headerlink" href="#64-图像纹理" title="Permanent link">&para;</a></h1>
<p><strong>Image Textures</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="1:2"><input checked="checked" id="__tabbed_1_1" name="__tabbed_1" type="radio" /><input id="__tabbed_1_2" name="__tabbed_1" type="radio" /><div class="tabbed-labels"><label for="__tabbed_1_1">中文</label><label for="__tabbed_1_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>纹理在3D图形中扮演着重要的角色，现代GPU在硬件层面上内置了对图像纹理的支持。在本节中，我们将探讨WebGL API中用于图像纹理的功能。<abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1中的图像纹理在<a href="../../c4/s3/">第4.3节</a>中有所介绍。那一节的许多内容在现代OpenGL中，包括WebGL中仍然相关。因此，当我们在WebGL中介绍图像纹理时，大部分内容对您来说并不新鲜。然而，自OpenGL 1.1以来，有一个新特性：<strong>纹理单元</strong>。</p>
<p><abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0和WebGL 2.0之间的一个显著区别是增加了对不同类型的纹理以及不同使用方式的纹理的支持。访问大多数新特性需要使用GLSL ES 3.00编写着色器程序。我们将在本节的大部分时间里坚持使用WebGL 1.0，但将在最后一小节中讨论一些新的WebGL 2.0特性。</p>
</div>
<div class="tabbed-block">
<p>Textures play an essential role in 3D graphics, and support for image textures is built into modern GPUs on the hardware level. In this section, we look at the <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> <abbr title="Application Programming Interface. A collection of related classes, functions, constants, etc., for performing some task. An API is an &quot;interface&quot; in the sense that it can be used without understanding how its functionality is actually implemented.">API</abbr> for image textures. Image textures in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1 were covered in <a href="../../c4/s3/">Section 4.3</a>. Much of that section is still relevant in modern <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr>, including <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>. So, as we cover image textures in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>, much of the <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> will not be new to you. However, there is one feature that is new since <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1: <strong><abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> units</strong>.</p>
<p>One of the significant differences between <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 and <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 is an increase in support for different types of textures and for different ways of using textures. Access to most of the new features requires using <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 3.00 for the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> programs. We will stick to <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 for most of this section, but will discuss some of the new <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 features in the final subsection.</p>
</div>
</div>
</div>
<h2 id="641-纹理单元和纹理对象">6.4.1 纹理单元和纹理对象<a class="headerlink" href="#641-纹理单元和纹理对象" title="Permanent link">&para;</a></h2>
<p><strong>Texture Units and Texture Objects</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="2:2"><input checked="checked" id="__tabbed_2_1" name="__tabbed_2" type="radio" /><input id="__tabbed_2_2" name="__tabbed_2" type="radio" /><div class="tabbed-labels"><label for="__tabbed_2_1">中文</label><label for="__tabbed_2_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>纹理单元，也称为纹理映射单元（<abbr title="Texture Mapping Unit, another name for texture unit (perhaps with a stronger implication of actual hardware support). Also called a TPU (Texture Processing Unit).">TMU</abbr>）或纹理处理单元（TPU），是GPU中的一个硬件组件，用于进行采样。采样是从图像纹理和纹理坐标中计算颜色的过程。将纹理图像映射到表面上是一个相当复杂的操作，因为它不仅需要返回包含某些给定纹理坐标的纹理元素（<abbr title="A pixel in a texture image.">texel</abbr>）的颜色。它还需要应用适当的缩放或放大滤波器，如果可用，可能还会使用mipmap。快速的纹理采样是GPU良好性能的关键要求之一。</p>
<p>不应将纹理单元与纹理对象混淆。我们在<a href="../../c4/s3/#437-纹理对象">4.3.7小节</a>中遇到了纹理对象。纹理对象是一个数据结构，包含图像纹理的颜色数据，可能还包括纹理的一组mipmap，以及纹理属性的值，如缩放和放大滤波器和纹理重复模式。纹理单元必须访问纹理对象以完成其工作。纹理单元是处理器；纹理对象保存被处理的数据。</p>
<p>（顺便说一下，我确实应该更加小心地使用“<abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>”和“硬件”这些术语。尽管纹理单元可能确实使用了GPU中的实际硬件组件，但它也可能在软件中被更慢地模拟。即使涉及硬件，拥有八个纹理单元也不一定意味着有八个硬件组件；纹理单元可能在较少数量的硬件组件上共享时间。同样，我之前说过纹理对象存储在GPU的内存中，这在特定情况下可能或可能不是字面意义上的真实。然而，您可能会发现，将纹理单元视为GPU中的一块硬件，将纹理对象视为GPU中的数据结构，在概念上更容易理解。）最后一小节。</p>
<hr />
<p>在GLSL中，纹理查找是使用<strong>采样器变量</strong>完成的。采样器变量是着色器程序中的一个变量。在GLSL ES 1.00中，唯一的采样器类型是<em>sampler2D</em>和<em>samplerCube</em>。<em>sampler2D</em>用于在标准纹理图像中进行查找；<em>samplerCube</em>用于在立方体贴图中进行查找(<a href="../../c5/s3/#534-立方体贴图纹理和天空盒">5.3.4小节</a>)。采样器变量的值是对纹理单元的引用。该值指明了在使用采样器变量进行纹理查找时调用的纹理单元。采样器变量必须被声明为全局统一变量。着色器程序不能为采样器变量赋值是非法的。值必须来自JavaScript方面。</p>
<p>在JavaScript方面，可用的纹理单元编号为0、1、2、...，其中最大值取决于实现。可以通过以下表达式的值来确定单元数量：</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">getParameter</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">MAX_COMBINED_TEXTURE_IMAGE_UNITS</span><span class="p">)</span>
</code></pre></div>
<p>（请再次记住，这里的gl是指向WebGL上下文的JavaScript变量的名称，名称由程序员决定。）</p>
<p>就JavaScript而言，采样器变量的值是一个整数。如果你想让采样器变量使用编号为2的纹理单元，那么你需要将采样器变量的值设置为2。这可以通过使用函数<em>gl.uniform1i</em>(<a href="../s1/#614-统一变量的值">6.1.4小节</a>)来完成。例如，假设着色器程序声明了一个采样器变量：</p>
<div class="highlight"><pre><span></span><code><span class="nx">uniform</span><span class="w"> </span><span class="nx">sampler2D</span><span class="w"> </span><span class="nx">u_texture</span><span class="p">;</span>
</code></pre></div>
<p>要从JavaScript设置它的值，你需要在着色器程序中获取变量的位置。如果<em>prog</em>是着色器程序，位置是通过调用以下代码获得的：</p>
<div class="highlight"><pre><span></span><code><span class="nx">u_texture_location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getUniformLocation</span><span class="p">(</span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;u_texture&quot;</span><span class="p">);</span>
</code></pre></div>
<p>然后，你可以通过调用以下代码来告诉采样器变量使用编号为2的纹理单元：</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">uniform1i</span><span class="p">(</span><span class="nx">u_texture_location</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">);</span>
</code></pre></div>
<p>请注意，在GLSL中，整数值是不可见的。整数值告诉采样器使用哪个纹理单元，但着色器程序没有办法找出正在使用的单元编号。</p>
<hr />
<p>要使用图像纹理，你还需要创建一个纹理对象，并将图像加载到纹理对象中。你可能想要设置纹理对象的一些属性，也可能想要为纹理创建一组mipmap。你还需要将纹理对象与纹理单元关联起来。所有这些操作都是在JavaScript方面完成的。</p>
<p>创建纹理对象的命令是<em>gl.createTexture()</em>。<abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1中的命令是<em>glGenTextures</em>。WebGL命令更易于使用。它创建一个单一的纹理对象并返回对它的引用。例如，</p>
<div class="highlight"><pre><span></span><code><span class="nx">textureObj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createTexture</span><span class="p">();</span>
</code></pre></div>
<p>这仅为对象分配了一些内存。为了使用它，你必须首先通过调用gl.bindTexture来“绑定”<abbr title="可能存储在显卡上的数据结构，可以保存纹理图像、一组mipmaps以及配置数据，例如当前的缩放和放大过滤器设置。使用纹理对象可以快速切换纹理，而无需重新将数据加载到显卡中。">纹理对象</abbr>。例如，</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">bindTexture</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">textureObj</span><span class="p">);</span>
</code></pre></div>
<p>第一个参数，<em>gl.TEXTURE_2D</em>，是纹理目标。这个目标用于使用普通的纹理图像。对于立方体贴图有不同的目标。</p>
<p>函数gl.texImage2D用于将图像加载到当前绑定的纹理对象中。我们将在下一小节中回到这个问题。但请记住，这个命令和其他命令始终适用于当前绑定的纹理对象。命令中没有提到纹理对象；相反，在调用命令之前，必须先绑定纹理对象。</p>
<p>你还需要告诉纹理单元使用纹理对象。在此之前，你需要通过调用函数<em>gl.activeTexture</em>来使纹理单元“激活”。参数是<em>gl.TEXTURE0</em>、<em>gl.TEXTURE1</em>、<em>gl.TEXTURE2</em>等常量之一，它们代表可用的纹理单元。（这些常量的值不是0、1、2……）。最初，纹理单元0处于激活状态。例如，要使纹理单元2处于激活状态，请使用</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">activeTexture</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE2</span><span class="p">);</span>
</code></pre></div>
<p>（这个函数本应该叫做<strong><em>activeTextureUnit</em></strong>，或者可能是bindTextureUnit，因为它的工作方式类似于WebGL的各种“bind”函数。）如果你接着调用</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">bindTexture</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">textureObj</span><span class="p">);</span>
</code></pre></div>
<p>在纹理单元2处于激活状态时绑定一个纹理对象，那么纹理对象<em>textureObj</em>就被绑定到纹理单元2，用于<em>gl.TEXTURE_2D</em>操作。绑定只是告诉纹理单元使用哪个纹理对象。也就是说，当纹理单元2执行<em>TEXTURE_2D</em>查找时，它将使用存储在<em>textureObj</em>中的图像和设置进行操作。一个纹理对象可以同时绑定到多个纹理单元上。然而，一个给定的纹理单元一次只能有一个绑定的<em>TEXTURE_2D</em>。</p>
<p>在WebGL中使用纹理图像涉及使用纹理对象、纹理单元和采样器变量。三者之间的关系如图中所示：</p>
<p><a class="glightbox" href="../../../en/c6/texture-units-and-objects.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c6/texture-units-and-objects.png" /></a></p>
<p>采样器变量使用纹理单元，该纹理单元使用纹理对象，该对象保存纹理图像。设置此链的JavaScript命令在插图中显示。要将纹理图像应用于原语，您必须设置整个链。当然，您还必须为原语提供纹理坐标，并需要在着色器程序中使用采样器变量来访问纹理。</p>
<p>假设您有几张想要在几个不同的原语上使用的图像。在绘制原语之间，您需要更改要使用的纹理图像。在WebGL中至少有三种不同的方式来管理图像：</p>
<ol>
<li>您可以使用单个纹理对象和单个纹理单元。绑定的纹理对象、活动的纹理单元和采样器变量的值可以设置一次，然后不再更改。要更改为新图像，您将使用<em>gl.texImage2D</em>将图像加载到纹理对象中。这基本上是OpenGL 1.0中的操作方式。这是非常低效的，除非您只使用每个图像一次。这就是为什么引入了纹理对象的原因。</li>
<li>您可以为每个图像使用不同的纹理对象，但只使用单个纹理单元。活动的纹理和采样器变量的值将不需要更改。您将使用<em>gl.bindTexture</em>绑定包含所需图像的纹理对象来切换到新的纹理图像。</li>
<li>您可以为每个图像使用不同的纹理单元。您将每个图像加载到自己的纹理对象中，并将该对象绑定到其中一个纹理单元。您可以通过更改采样器变量的值来切换到新的纹理图像。</li>
</ol>
<p>我不知道选项2和3在效率方面如何比较。请注意，只有在您想要将多个纹理图像应用于同一原语时，才<strong>被迫</strong>使用多个纹理单元。要做到这一点，您将需要着色器程序中的几个采样器变量。它们将具有不同的值，以便它们引用不同的纹理单元，并且像素的颜色将以某种方式依赖于两个图像的样本。这张图片显示了以简单方式组合两个纹理以计算纹理正方形的颜色：</p>
<p><a class="glightbox" href="../../../en/c6/multi-texture.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c6/multi-texture.png" /></a></p>
<p>在左侧的图像中，<abbr title="指一种颜色方案或图像，其中每种颜色都是灰色的一种色调（此处的“灰色色调(shade of gray)”包括黑色和白色）。通常使用256种灰度级别。灰度也称为“单色(monochrome)”。">灰度</abbr>“砖”图像乘以“地球”图像；也就是说，像素的红色分量是通过将砖纹理的红色分量乘以地球纹理的红色分量计算的，绿色和蓝色也是如此。在右侧，相同的地球纹理从一个“布”纹理中减去。此外，图案因为在使用纹理坐标采样纹理之前进行了修改，使用了公式 <code>texCoords.y += 0.25*sin(6.28*texCoords.x)</code>。这是只能使用可编程着色器完成的事情！图像取自以下演示。试试看！</p>
<p><iframe src="../../../en/demos/c6/multi-texture.html" width="625" height="475"></iframe></p>
<p>您可能想要查看<a href="../../../en/demos/c6/multi-texture.html">source code</a>以了解如何编程纹理。使用两个纹理单元。两个统一采样器变量<em>u_texture1</em>和<em>u_texture2</em>的值在初始化期间使用以下代码设置</p>
<div class="highlight"><pre><span></span><code><span class="nx">u_texture1_location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getUniformLocation</span><span class="p">(</span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;u_texture1&quot;</span><span class="p">);</span>
<span class="nx">u_texture2_location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getUniformLocation</span><span class="p">(</span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;u_texture2&quot;</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">uniform1i</span><span class="p">(</span><span class="nx">u_texture1_location</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">uniform1i</span><span class="p">(</span><span class="nx">u_texture2_location</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">);</span>
</code></pre></div>
<p>这些值从未更改。程序使用了几个纹理图像。每个图像都有一个纹理对象。在JavaScript方面，纹理对象的ID存储在数组<em>textureObjects</em>中。两个弹出菜单允许用户选择应用于原语的纹理图像。这是通过将两个选定的纹理对象绑定到纹理单元0和1来实现的，这两个单元是两个采样器变量使用的单元。代码如下：</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">tex1Num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Number</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;textureChoice1&quot;</span><span class="p">).</span><span class="nx">value</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">activeTexture</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE0</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bindTexture</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">textureObjects</span><span class="p">[</span><span class="nx">tex1Num</span><span class="p">]);</span>

<span class="kd">let</span><span class="w"> </span><span class="nx">tex2Num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Number</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;textureChoice2&quot;</span><span class="p">).</span><span class="nx">value</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">activeTexture</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE1</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bindTexture</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">textureObjects</span><span class="p">[</span><span class="nx">tex2Num</span><span class="p">]);</span>
</code></pre></div>
<p>将图像放入纹理对象是另一个问题，我们接下来讨论。</p>
</div>
<div class="tabbed-block">
<p>A <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> unit, also called a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> mapping unit (<strong><abbr title="Texture Mapping Unit, another name for texture unit (perhaps with a stronger implication of actual hardware support). Also called a TPU (Texture Processing Unit).">TMU</abbr></strong>) or a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> processing unit (TPU), is a hardware component in a <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> that does <abbr title="The operation of mapping texture coordinates to colors from a texture, including using mipmaps if available and applying a minification or magnification filter if necessary.">sampling</abbr>. <strong>Sampling</strong> is the process of computing a color from an <abbr title="An image that is applied to a surface as a texture, so that it looks at if the image is &quot;painted&quot; onto the surface.">image texture</abbr> and <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates. Mapping a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image to a surface is a fairly complex operation, since it requires more than just returning the color of the <abbr title="A pixel in a texture image.">texel</abbr> that contains some given <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates. It also requires applying the appropriate minification or <abbr title="An operation that is used when applying a texture to an object, when the texture has to be stretched to fit the object. For an image texture, a magnification filter is applied to compute the color of a pixel when that pixel covers just a fraction of a pixel in the image.">magnification filter</abbr>, possibly using <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr> if available. Fast <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> <abbr title="The operation of mapping texture coordinates to colors from a texture, including using mipmaps if available and applying a minification or magnification filter if necessary.">sampling</abbr> is one of the key requirements for good <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> performance.</p>
<p>Texture units are not to be confused with <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> objects. We encountered <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> objects in <a href="../../c4/s3/#437-纹理对象">Subsection 4.3.7</a>. A <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object is a data structure that contains the color data for an <abbr title="An image that is applied to a surface as a texture, so that it looks at if the image is &quot;painted&quot; onto the surface.">image texture</abbr>, and possibly for a set of <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr> for the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>, as well as the values of <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> properties such as the minification and magnification filters and the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> repeat mode. A <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> unit must access a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object to do its work. The <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> unit is the processor; the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object holds the data that is processed.</p>
<p>(By the way, I should really be more careful about throwing around the terms "<abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>" and "hardware." Although a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> unit probably does use an actual hardware component in the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>, it could also be emulated, more slowly, in software. And even if there is hardware involved, having eight <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> units does not necessarily mean that there are eight hardware components; the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> units might share time on a smaller number of hardware components. Similarly, I said previously that <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> objects are stored in memory in the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>, which might or might not be literally true in a given case. Nevertheless, you will probably find it conceptually easier to think of a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> unit as a piece of hardware and a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object as a data structure in the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>.)final subsection.</p>
<hr />
<p>In <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr>, <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> lookup is done using <strong>sampler variables</strong>. A <abbr title="In GLSL, a variable in a shader program that can be used to do lookup in an image texture. The value of a sampler variable specifies the texture unit that will be used to do the lookup. In WebGL, sampler variables are of type &quot;sampler2D&quot; or &quot;samplerCube.&quot;">sampler variable</abbr> is a variable in a <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program. In <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 1.00, the only sampler types are <em>sampler2D</em> and <em>samplerCube</em>. A <em>sampler2D</em> is used to do lookup in a standard <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image; a <em>samplerCube</em> is used to do lookup in a <abbr title="A texture made up of six images, one for each of the directions positive x, negative x, positive y, negative y, positive z, and negative z. The images are intended to include everything that can be seen from a given point. Cubemap textures are used for environment mapping and skyboxes.">cubemap texture</abbr> (<a href="../../c5/s3/#534-立方体贴图纹理和天空盒">Subsection 5.3.4</a>). The value of a <abbr title="In GLSL, a variable in a shader program that can be used to do lookup in an image texture. The value of a sampler variable specifies the texture unit that will be used to do the lookup. In WebGL, sampler variables are of type &quot;sampler2D&quot; or &quot;samplerCube.&quot;">sampler variable</abbr> is a reference to a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> unit. The value tells which <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> unit is invoked when the <abbr title="In GLSL, a variable in a shader program that can be used to do lookup in an image texture. The value of a sampler variable specifies the texture unit that will be used to do the lookup. In WebGL, sampler variables are of type &quot;sampler2D&quot; or &quot;samplerCube.&quot;">sampler variable</abbr> is used to do <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> lookup. Sampler variables must be declared as global uniform variables. It is not legal for a <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program to assign a value to a <abbr title="In GLSL, a variable in a shader program that can be used to do lookup in an image texture. The value of a sampler variable specifies the texture unit that will be used to do the lookup. In WebGL, sampler variables are of type &quot;sampler2D&quot; or &quot;samplerCube.&quot;">sampler variable</abbr>. The value must come from the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side.</p>
<p>On the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side, the available <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> units are numbered 0, 1, 2, ..., where the maximum value is implementation dependent. The number of units can be determined as the value of the expression</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">getParameter</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">MAX_COMBINED_TEXTURE_IMAGE_UNITS</span><span class="w"> </span><span class="p">)</span>
</code></pre></div>
<p>(Please remember, again, that gl here is the name of a <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> variable that refers to the <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> context, and that the name is up to the programmer.)</p>
<p>As far as <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> is concerned, the value of a <abbr title="In GLSL, a variable in a shader program that can be used to do lookup in an image texture. The value of a sampler variable specifies the texture unit that will be used to do the lookup. In WebGL, sampler variables are of type &quot;sampler2D&quot; or &quot;samplerCube.&quot;">sampler variable</abbr> is an integer. If you want a <abbr title="In GLSL, a variable in a shader program that can be used to do lookup in an image texture. The value of a sampler variable specifies the texture unit that will be used to do the lookup. In WebGL, sampler variables are of type &quot;sampler2D&quot; or &quot;samplerCube.&quot;">sampler variable</abbr> to use <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> unit number 2, then you set the value of the <abbr title="In GLSL, a variable in a shader program that can be used to do lookup in an image texture. The value of a sampler variable specifies the texture unit that will be used to do the lookup. In WebGL, sampler variables are of type &quot;sampler2D&quot; or &quot;samplerCube.&quot;">sampler variable</abbr> to 2. This can be done using the function <em>gl.uniform1i</em> (<a href="../s1/#614-统一变量的值">Subsection 6.1.4</a>). For example, suppose a <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program declares a <abbr title="In GLSL, a variable in a shader program that can be used to do lookup in an image texture. The value of a sampler variable specifies the texture unit that will be used to do the lookup. In WebGL, sampler variables are of type &quot;sampler2D&quot; or &quot;samplerCube.&quot;">sampler variable</abbr></p>
<div class="highlight"><pre><span></span><code><span class="nx">uniform</span><span class="w"> </span><span class="nx">sampler2D</span><span class="w"> </span><span class="nx">u_texture</span><span class="p">;</span>
</code></pre></div>
<p>To set its value from <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr>, you need the location of the variable in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program. If <em>prog</em> is the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program, the location is obtained by calling</p>
<div class="highlight"><pre><span></span><code><span class="nx">u_texture_location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getUniformLocation</span><span class="p">(</span><span class="w"> </span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;u_texture&quot;</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>Then, you can tell the <abbr title="In GLSL, a variable in a shader program that can be used to do lookup in an image texture. The value of a sampler variable specifies the texture unit that will be used to do the lookup. In WebGL, sampler variables are of type &quot;sampler2D&quot; or &quot;samplerCube.&quot;">sampler variable</abbr> to use <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> unit number 2 by calling</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">uniform1i</span><span class="p">(</span><span class="w"> </span><span class="nx">u_texture_location</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>Note that the integer value is not accessible in <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr>. The integer tells the sampler which <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> unit to use, but there is no way for the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program to find out the number of the unit that is being used.</p>
<hr />
<p>To use an <abbr title="An image that is applied to a surface as a texture, so that it looks at if the image is &quot;painted&quot; onto the surface.">image texture</abbr>, you also need to create a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object, and you need to load an image into the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object. You might want to set some properties of the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object, and you might want to create a set of <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr> for the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. And you will have to associate the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object with a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> unit. All this is done on the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side.</p>
<p>The command for creating a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object is <em>gl.createTexture()</em>. The command in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1 was <em>glGenTextures</em>. The <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> command is easier to use. It creates a single <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object and returns a reference to it. For example,</p>
<div class="highlight"><pre><span></span><code><span class="nx">textureObj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createTexture</span><span class="p">();</span>
</code></pre></div>
<p>This just allocates some memory for the object. In order to use it, you must first "bind" the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object by calling gl.bindTexture. For example,</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">bindTexture</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">textureObj</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>The first parameter, <em>gl.TEXTURE_2D</em>, is the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> target. This target is used for working with an ordinary <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image. There is a different target for cubemap textures.</p>
<p>The function gl.texImage2D is used to load an image into the currently bound <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object. We will come back to that in the next subsection. But remember that this command and other commands always apply to the currently bound <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object. The <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object is not mentioned in the command; instead, the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object must be bound before the command is called.</p>
<p>You also need to tell a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> unit to use the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object. Before you can do that, you need to make the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> unit "active," which is done by calling the function <em>gl.activeTexture</em>. The parameter is one of the constants <em>gl.TEXTURE0</em>, <em>gl.TEXTURE1</em>, <em>gl.TEXTURE2</em>, ..., which represent the available <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> units. (The values of these constants are <strong>not</strong> 0, 1, 2, ....) Initially, <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> unit number 0 is active. To make <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> unit number 2 active, for example, use</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">activeTexture</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE2</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>(This function should really have been called <strong><em>activeTextureUnit</em></strong>, or maybe bindTextureUnit, since it works similarly to the various <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> "bind" functions.) If you then call</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">bindTexture</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">textureObj</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>to bind a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object, while <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> unit 2 is active, then the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object <em>textureObj</em> is bound to <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> unit number 2 for <em>gl.TEXTURE_2D</em> operations. The binding just tells the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> unit which <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object to use. That is, when <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> unit 2 does <em>TEXTURE_2D</em> lookups, it will do so using the image and the settings that are stored in <em>textureObj</em>. A <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object can be bound to several <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> units at the same time. However, a given <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> unit can have only one bound <em>TEXTURE_2D</em> at a time.</p>
<p>So, working with <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> images in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> involves working with <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> objects, <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> units, and sampler variables. The relationship among the three is illustrated in this picture:</p>
<p><a class="glightbox" href="../../../en/c6/texture-units-and-objects.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c6/texture-units-and-objects.png" /></a></p>
<p>A <abbr title="In GLSL, a variable in a shader program that can be used to do lookup in an image texture. The value of a sampler variable specifies the texture unit that will be used to do the lookup. In WebGL, sampler variables are of type &quot;sampler2D&quot; or &quot;samplerCube.&quot;">sampler variable</abbr> uses a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> unit, which uses a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object, which holds a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image. The <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> commands for setting up this chain are shown in the illustration. To apply a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image to a primitive, you have to set up the entire chain. Of course, you also have to provide <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates for the primitive, and you need to use the <abbr title="In GLSL, a variable in a shader program that can be used to do lookup in an image texture. The value of a sampler variable specifies the texture unit that will be used to do the lookup. In WebGL, sampler variables are of type &quot;sampler2D&quot; or &quot;samplerCube.&quot;">sampler variable</abbr> in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program to access the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>.</p>
<p>Suppose that you have several images that you would like to use on several different primitives. Between drawing primitives, you need to change the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image that will be used. There are at least three different ways to manage the images in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>:</p>
<ol>
<li>You could use a single <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object and a single <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> unit. The bound <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object, the active <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> unit, and the value of the <abbr title="In GLSL, a variable in a shader program that can be used to do lookup in an image texture. The value of a sampler variable specifies the texture unit that will be used to do the lookup. In WebGL, sampler variables are of type &quot;sampler2D&quot; or &quot;samplerCube.&quot;">sampler variable</abbr> can be set once and never changed. To change to a new image, you would use <em>gl.texImage2D</em> to load the image into the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object. This is essentially how things were done in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.0. It's very inefficient, except when you are going to use each image just once. That's why <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> objects were introduced.</li>
<li>You could use a different <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object for each image, but use just a single <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> unit. The active <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> and the value of the <abbr title="In GLSL, a variable in a shader program that can be used to do lookup in an image texture. The value of a sampler variable specifies the texture unit that will be used to do the lookup. In WebGL, sampler variables are of type &quot;sampler2D&quot; or &quot;samplerCube.&quot;">sampler variable</abbr> will never have to be changed. You would switch to a new <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image using <em>gl.bindTexture</em> to bind the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object that contains the desired image.</li>
<li>You could use a different <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> unit for each image. You would load each image into its own <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object and bind that object to one of the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> units. You would switch to a new <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image by changing the value of the <abbr title="In GLSL, a variable in a shader program that can be used to do lookup in an image texture. The value of a sampler variable specifies the texture unit that will be used to do the lookup. In WebGL, sampler variables are of type &quot;sampler2D&quot; or &quot;samplerCube.&quot;">sampler variable</abbr>.</li>
</ol>
<p>I don't know how options 2 and 3 compare in terms of efficiency. Note that you are only <strong>forced</strong> to use more than one <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> unit if you want to apply more than one <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image to the same primitive. To do that, you will need several sampler variables in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program. They will have different values so that they refer to different <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> units, and the color of a <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> will somehow depend on samples from both images. This picture shows two textures being combined in simple ways to compute the colors of <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr> in a textured square:</p>
<p><a class="glightbox" href="../../../en/c6/multi-texture.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c6/multi-texture.png" /></a></p>
<p>In the image on the left, a <abbr title="Refers to a color scheme or image in which each color is a shade of gray (where the term &quot;shade of gray&quot; here includes black and white). Typically, 256 shades of gray are used. Grayscale is also called &quot;monochrome.&quot;">grayscale</abbr> "brick" image is multiplied by an "Earth" image; that is, the red component of a <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> is computed by multiplying the red component from the brick <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> by the red component from the Earth <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>, and same for green and blue. On the right, the same Earth <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> is subtracted from a "cloth" <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. Furthermore, the pattern is distorted because the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates were modified before being used to sample the textures, using the formula <code>texCoords.y += 0.25*sin(6.28*texCoords.x)</code>. That's the kind of thing that could only be done with programmable shaders! The images are taken from the following demo. Try it out!</p>
<p><iframe src="../../../en/demos/c6/multi-texture.html" width="625" height="475"></iframe></p>
<p>You might want to view the <a href="../../../en/demos/c6/multi-texture.html">source code</a> to see how the textures are programmed. Two <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> units are used. The values of two uniform sampler variables, <em>u_texture1</em> and <em>u_texture2</em>, are set during initialization with the code</p>
<div class="highlight"><pre><span></span><code><span class="nx">u_texture1_location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getUniformLocation</span><span class="p">(</span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;u_texture1&quot;</span><span class="p">);</span>
<span class="nx">u_texture2_location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getUniformLocation</span><span class="p">(</span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;u_texture2&quot;</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">uniform1i</span><span class="p">(</span><span class="nx">u_texture1_location</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">uniform1i</span><span class="p">(</span><span class="nx">u_texture2_location</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">);</span>
</code></pre></div>
<p>The values are never changed. The program uses several <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> images. There is a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object for each image. On the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side, the IDs for the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> objects are stored in an array, <em>textureObjects</em>. Two popup menus allow the user to select which <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> images are applied to the primitive. This is implemented in the drawing routine by binding the two selected <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> objects to <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> units 0 and 1, which are the units used by the two sampler variables. The code for that is:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">tex1Num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Number</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;textureChoice1&quot;</span><span class="p">).</span><span class="nx">value</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">activeTexture</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE0</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bindTexture</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">textureObjects</span><span class="p">[</span><span class="nx">tex1Num</span><span class="p">]</span><span class="w"> </span><span class="p">);</span>

<span class="kd">let</span><span class="w"> </span><span class="nx">tex2Num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Number</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;textureChoice2&quot;</span><span class="p">).</span><span class="nx">value</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">activeTexture</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE1</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bindTexture</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">textureObjects</span><span class="p">[</span><span class="nx">tex2Num</span><span class="p">]</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>Getting images into the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> objects is another question, which we turn to next.</p>
</div>
</div>
</div>
<h2 id="642-处理图像">6.4.2 处理图像<a class="headerlink" href="#642-处理图像" title="Permanent link">&para;</a></h2>
<p><strong>Working with Images</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="3:2"><input checked="checked" id="__tabbed_3_1" name="__tabbed_3" type="radio" /><input id="__tabbed_3_2" name="__tabbed_3" type="radio" /><div class="tabbed-labels"><label for="__tabbed_3_1">中文</label><label for="__tabbed_3_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>可以使用函数<em>gl.texImage2D</em>将图像加载到纹理对象中。对于WebGL的使用，这个函数通常具有以下形式：</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">texImage2D</span><span class="p">(</span><span class="w"> </span><span class="nx">target</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">UNSIGNED_BYTE</span><span class="p">,</span><span class="w"> </span><span class="nx">image</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>目标是<em>gl.TEXTURE_2D</em>，用于普通纹理；加载立方体贴图时有其他目标。第二个参数是mipmap级别，主图像为0。尽管可以加载单独的mipmap，但很少这样做。接下来两个参数提供了纹理对象内和原始图像的纹理格式。在WebGL 1.0中，两个格式参数应该具有相同的值。由于网络图像以RGBA格式存储，<em>gl.RGBA</em>可能是最有效的选择，很少有其他需求。但如果不需要alpha分量，可以使用<em>gl.RGB</em>。通过使用<em>gl.LUMINANCE</em>或<em>gl.LUMINANCE_ALPHA</em>，可以将图像转换为灰度。（亮度是对红色、绿色和蓝色加权平均，近似于颜色的感知亮度。）第四个参数始终是<em>gl.UNSIGNED_BYTE</em>，表示图像中的颜色使用每个颜色分量一个字节存储。尽管其他值是可能的，但它们对于网络图像没有实际意义。</p>
<p>调用<em>gl.texImage2D</em>的最后一个参数是图像。通常，<em>image</em>将是一个由JavaScript异步加载的DOM图像元素。<em>image</em>也可以是<canvas>元素。这意味着你可以在画布上绘制，使用HTML画布2D图形API，然后将画布作为纹理图像的源。你甚至可以使用在网页上不可见的离屏画布。</p>
<p>图像被加载到当前绑定到当前活动纹理单元的目标的纹理对象中。没有默认的纹理对象；也就是说，如果在调用<em>gl.texImage2D</em>时没有纹理被绑定，就会发生错误。活动纹理单元是使用<em>gl.activeTexture</em>选择的单元，或者如果从未调用过<em>gl.activeTexture</em>，则为纹理单元0。通过<em>gl.bindTexture</em>将纹理对象绑定到活动纹理单元。这在本节前面已经讨论过。</p>
<p>使用WebGL中的图像比较复杂，因为图像是异步加载的。也就是说，加载图像的命令只启动了加载图像的过程。你可以指定一个回调函数，在加载完成后执行。图像实际上要到回调函数被调用后才可用于使用。当加载图像用作纹理时，回调函数应将图像加载到纹理对象中。通常，它还会调用一个渲染函数来绘制场景，带或不带纹理。</p>
<p>示例程序<a href="../../../en/source/webgl/simple-texture.html">webgl/simple-<abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>.html</a>是在一个三角形上使用单个纹理的示例。这里是一个用于在该程序中加载纹理图像的函数。在调用该函数之前创建了纹理对象。</p>
<div class="highlight"><pre><span></span><code><span class="cm">/**</span>
<span class="cm"> * 异步加载纹理图像。第一个参数是要加载图像的url。</span>
<span class="cm"> * 第二个参数是要加载图像的纹理对象。当图像加载完成后，</span>
<span class="cm"> * 将调用draw()函数来绘制带纹理的三角形。（如果加载过程中出现错误，</span>
<span class="cm"> * 则会在页面上显示错误消息，并调用draw()绘制不带纹理的三角形。）</span>
<span class="cm"> */</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">loadTexture</span><span class="p">(</span><span class="w"> </span><span class="nx">url</span><span class="p">,</span><span class="w"> </span><span class="nx">textureObject</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w">  </span><span class="nx">img</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">Image</span><span class="p">();</span><span class="w">  </span><span class="c1">// 一个代表图像的DOM图像元素。</span>
<span class="w">    </span><span class="nx">img</span><span class="p">.</span><span class="nx">onload</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kd">function</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="c1">// 这个函数将在图像成功加载后调用。</span>
<span class="w">        </span><span class="c1">// 在将图像加载到纹理对象之前，我们必须将纹理对象绑定到TEXTURE_2D目标。</span>
<span class="w">        </span><span class="nx">gl</span><span class="p">.</span><span class="nx">bindTexture</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">textureObject</span><span class="p">);</span>
<span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">gl</span><span class="p">.</span><span class="nx">texImage2D</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span><span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span><span class="nx">gl</span><span class="p">.</span><span class="nx">UNSIGNED_BYTE</span><span class="p">,</span><span class="nx">img</span><span class="p">);</span>
<span class="w">        </span><span class="nx">gl</span><span class="p">.</span><span class="nx">generateMipmap</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">);</span><span class="w">  </span><span class="c1">// 创建mipmap；你必须要么这样做</span>
<span class="w">                            </span><span class="c1">// 或者更改缩小过滤器。</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="nx">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 可能是安全异常，因为此页面已通过file:// URL加载。</span>
<span class="w">            </span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;headline&quot;</span><span class="p">).</span><span class="nx">innerHTML</span><span class="w"> </span><span class="o">=</span>
<span class="w">            </span><span class="s2">&quot;Sorry, couldn&#39;t load texture.&lt;br&gt;&quot;</span><span class="w"> </span><span class="o">+</span>
<span class="w">            </span><span class="s2">&quot;Some web browsers won&#39;t use images from a local disk&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="nx">draw</span><span class="p">();</span><span class="w">  </span><span class="c1">// 绘制画布，带或不带纹理。  </span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="nx">img</span><span class="p">.</span><span class="nx">onerror</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kd">function</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="c1">// 如果加载过程中出现错误，将调用此函数。</span>
<span class="w">        </span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;headline&quot;</span><span class="p">).</span><span class="nx">innerHTML</span><span class="w"> </span><span class="o">=</span>
<span class="w">                        </span><span class="s2">&quot;&lt;p&gt;Sorry, texture image could not be loaded.&lt;/p&gt;&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="nx">draw</span><span class="p">();</span><span class="w">  </span><span class="c1">// 绘制不带纹理的图像；三角形将为黑色。</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="nx">img</span><span class="p">.</span><span class="nx">src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">url</span><span class="p">;</span><span class="w">  </span><span class="c1">// 开始加载图像。</span>
<span class="w">                    </span><span class="c1">// 这必须在设置onload和onerror之后完成。</span>
<span class="p">}</span>
</code></pre></div>
<p>请注意，<abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0的图像纹理应该是2的幂纹理。也就是说，图像的宽度和高度应该是2的幂，例如128、256或512。实际上，你可以使用非2的幂纹理，但你不能使用这样的纹理的mipmap，这样的纹理支持的唯一纹理重复模式是<em>gl.CLAMP_TO_EDGE</em>。（<abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0没有这些限制。）</p>
<p>（在该函数中使用try..catch语句，因为大多数网络浏览器在页面尝试使用本地文件系统的图像作为纹理时会抛出安全异常。这意味着如果你尝试运行一个使用下载的本书中的纹理的程序，使用纹理的程序可能无法工作。）</p>
<hr />
<p>与纹理对象关联的几个参数，包括纹理重复模式和缩放与放大滤波器。它们可以使用函数<em>gl.texParameteri</em>设置。设置将应用于当前绑定的纹理对象。大多数细节与OpenGL 1.1中的相同(<a href="../../c4/s3/#433-纹理目标和纹理参数">4.3.3小节</a>)。例如，可以将最小化滤波器设置为LINEAR：</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">texParameteri</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_MIN_FILTER</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">LINEAR</span><span class="p">);</span>
</code></pre></div>
<p>回想一下，默认的最小化滤波器在没有mipmap的情况下无法工作。要获得一个工作的纹理，你必须更改最小化滤波器或安装一组完整的mipmap。幸运的是，WebGL有一个函数可以为你生成mipmap：</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">generateMipmap</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">);</span>
</code></pre></div>
<p>纹理重复模式决定了当纹理坐标超出0.0到1.0的范围时会发生什么。纹理坐标系统中的每个方向都有单独的重复模式。在WebGL中，可能的值是<em>gl.REPEAT</em>、<em>gl.CLAMP_TO_EDGE</em>和<em>gl.MIRRORED_REPEAT</em>。默认值是<em>gl.REPEAT</em>。在OpenGL 1.1中，模式<em>CLAMP_TO_EDGE</em>被称为<em>CLAMP</em>，而<em>MIRRORED_REPEAT</em>是WebGL中的新功能。使用<em>MIRRORED_REPEAT</em>时，纹理图像会重复以覆盖整个平面，但每隔一个图像就会被反射。这可以消除副本之间的可见接缝。要在两个方向上设置纹理使用镜像重复，使用：</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">texParameteri</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_WRAP_S</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">MIRRORED_REPEAT</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">texParameteri</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_WRAP_T</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">MIRRORED_REPEAT</span><span class="p">);</span>
</code></pre></div>
<hr />
<p>在WebGL中，纹理坐标通常作为类型为<em>vec2</em>的属性输入到顶点着色器中。它们通过变化变量传递到片段着色器。通常，顶点着色器会将属性的值简单地复制到变化变量中。另一种可能性是在将坐标传递到片段着色器之前，在顶点着色器中对坐标应用仿射纹理变换。在片段着色器中，纹理坐标用于对纹理进行采样。<abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 1.00中用于采样普通纹理的函数是：</p>
<div class="highlight"><pre><span></span><code><span class="nx">texture2D</span><span class="p">(</span><span class="nx">samplerVariable</span><span class="p">,</span><span class="w"> </span><span class="nx">textureCoordinates</span><span class="p">);</span>
</code></pre></div>
<p>其中<em>samplerVariable</em>是代表纹理的类型为<em>sampler2D</em>的统一变量，<em>textureCoordinates</em>是包含纹理坐标的<em>vec2</em>。返回值是一个RGBA颜色，表示为类型<em>vec4</em>的值。作为一个非常简单的例子，这里有一个片段着色器，它简单地使用从纹理中采样的值作为像素的颜色。</p>
<div class="highlight"><pre><span></span><code><span class="nx">precision</span><span class="w"> </span><span class="nx">mediump</span><span class="w"> </span><span class="kr">float</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">sampler2D</span><span class="w"> </span><span class="nx">u_texture</span><span class="p">;</span>
<span class="nx">varying</span><span class="w"> </span><span class="nx">vec2</span><span class="w"> </span><span class="nx">v_texCoords</span><span class="p">;</span>
<span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">texture2D</span><span class="p">(</span><span class="nx">u_texture</span><span class="p">,</span><span class="w"> </span><span class="nx">v_texCoords</span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl_FragColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">color</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>这个着色器来自示例程序<a href="../../../en/source/webgl/simple-texture.html">webgl/simple-<abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>.html</a>。</p>
<p>有时纹理会用在<em>gl.POINTS</em>类型的原语上。在这种情况下，很自然地从特殊的片段着色器变量<em>gl_PointCoord</em>中获取像素的纹理坐标。一个点被渲染为一个正方形，<em>gl_PointCoord</em>中的坐标在正方形上从0.0到1.0范围内。所以，使用<em>gl_PointCoord</em>意味着一个纹理副本将被粘贴到点上。如果<em>POINTS</em>原语有多个顶点，你将在每个顶点的位置看到纹理的副本。这是一种将图像或多个图像副本放入场景的简单方法。这种技术有时被称为“点精灵”。</p>
<p>以下演示绘制了一个类型为<em>gl.POINTS</em>的单纹理原语，以便你可以看到它的外观。在演示中，只绘制了每个正方形点的圆形切口。</p>
<p><iframe src="../../../en/demos/c6/textured-points.html" width="600" height="375"></iframe></p>
<p>WebGL中的纹理图像的像素数据从图像底部的像素行开始存储，并从那里向上工作。当WebGL通过从图像中读取数据来创建纹理时，它假设图像使用相同的格式。然而，网络浏览器中的图像以相反的顺序存储，从图像的顶部像素行开始并向下工作。这种不匹配的结果是纹理图像将出现倒置。你可以通过修改纹理坐标来解决这个问题。然而，你也可以告诉WebGL在“解包”它们时为你反转图像。要做到这一点，调用</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">pixelStorei</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">UNPACK_FLIP_Y_WEBGL</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">);</span>
</code></pre></div>
<p>通常，你可以在初始化过程中这样做。但请注意，对于<em>gl.POINTS</em>原语，<em>gl_PointCoord</em>使用的坐标系已经是倒置的，y坐标从上到下增加。所以，如果你正在为使用在<em>POINTS</em>原语上的图像加载纹理，你可能想要将<em>gl.UNPACK_FLIP_Y_WEBGL</em>设置回其默认值0。</p>
</div>
<div class="tabbed-block">
<p>An image can be loaded into a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object using the function gl.texImage2D. For use with <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>, this function usually has the form</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">texImage2D</span><span class="p">(</span><span class="w"> </span><span class="nx">target</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">UNSIGNED_BYTE</span><span class="p">,</span><span class="w"> </span><span class="nx">image</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>The target is <em>gl.TEXTURE_2D</em> for ordinary textures; there are other targets for loading cubemap textures. The second parameter is the <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmap</abbr> level, which is 0 for the main image. Although it is possible to load individual <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr>, that is rarely done. The next two parameters give the format of the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> inside the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object and in the original image. In <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0, the two format parameters should have the same value. Since web images are stored in RGBA format, <em>gl.RGBA</em> is probably the most efficient choice, and there is rarely a need to use anything else. But you can use <em>gl.RGB</em> if you don't need the <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> component. And by using <em>gl.LUMINANCE</em> or <em>gl.LUMINANCE_ALPHA</em>, you can convert the image to <abbr title="Refers to a color scheme or image in which each color is a shade of gray (where the term &quot;shade of gray&quot; here includes black and white). Typically, 256 shades of gray are used. Grayscale is also called &quot;monochrome.&quot;">grayscale</abbr>. (Luminance is a weighted average of red, green, and blue that approximates the perceived brightness of a color.) The fourth parameter is always going to be <em>gl.UNSIGNED_BYTE</em>, indicating that the colors in the image are stored using one byte for each <abbr title="One of the numbers used in a color model to specify a color. For example, in the RGB color model, a color is specified by three color components representing the amounts of red, green, and blue in the color.">color component</abbr>. Although other values are possible, they don't really make sense for web images.</p>
<p>The last parameter in the call to <em>gl.texImage2D</em> is the image. Ordinarily, <em>image</em> will be a <abbr title="Document Object Model. A specification for representing a web page (and other kinds of structured document) as a tree-like data structure. Can also refer to the data structure itself, as in &quot;the DOM for this web page.&quot; A web page can be modified dynamically by manipulating its DOM, using the JavaScript programming language.">DOM</abbr> image element that has been loaded asynchronously by <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr>. The <em>image</em> can also be a <code>&lt;canvas&gt;</code> element. This means that you can draw on a canvas, using the <abbr title="HyperText Markup Language. A language that is used for specifying the content of web pages. An HTML document is made up of text, along with &quot;elements&quot; for adding other content, such as images, and for defining the structure of the document. Because of nesting of elements, the document can be represented by a tree-like data structure.">HTML</abbr> canvas 2D graphics <abbr title="Application Programming Interface. A collection of related classes, functions, constants, etc., for performing some task. An API is an &quot;interface&quot; in the sense that it can be used without understanding how its functionality is actually implemented.">API</abbr>, and then use the canvas as the source for a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image. You can even do that with an <abbr title="My term for a segment of the computer's memory that can be used as a drawing surface, for drawing images that are not visible on the screen. Some method should exist for copying the image from an off-screen canvas onto the screen. In Java, for example, an off-screen canvas can be implemented as an object of type BufferedImage.">off-screen canvas</abbr> that is not visible on the web page.</p>
<p>The image is loaded into the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object that is currently bound to target in the currently active <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> unit. There is no default <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object; that is, if no <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> has been bound when <em>gl.texImage2D</em> is called, an error occurs. The active <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> unit is the one that has been selected using <em>gl.activeTexture</em>, or is <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> unit 0 if <em>gl.activeTexture</em> has never been called. A <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object is bound to the active <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> unit by <em>gl.bindTexture</em>. This was discussed earlier in this section.</p>
<p>Using images in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> is complicated by the fact that images are loaded asynchronously. That is, the command for loading an image just starts the process of loading the image. You can specify a callback function that will be executed when the loading completes. The image won't actually be available for use until after the callback function is called. When loading an image to use as a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>, the callback function should load the image into a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object. Often, it will also call a <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> function to draw the scene, with the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image.</p>
<p>The sample program <a href="../../../en/source/webgl/simple-texture.html">webgl/simple-<abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>.html</a> is an example of using a single <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> on a triangle. Here is a function that is used to load the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image in that program. The <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object is created before the function is called.</p>
<div class="highlight"><pre><span></span><code><span class="cm">/**</span>
<span class="cm"> *  Loads a texture image asynchronously.  The first parameter is the url</span>
<span class="cm"> *  from which the image is to be loaded.  The second parameter is the</span>
<span class="cm"> *  texture object into which the image is to be loaded.  When the image</span>
<span class="cm"> *  has finished loading, the draw() function will be called to draw the</span>
<span class="cm"> *  triangle with the texture.  (Also, if an error occurs during loading,</span>
<span class="cm"> *  an error message is displayed on the page, and draw() is called to</span>
<span class="cm"> *  draw the triangle without the texture.)</span>
<span class="cm"> */</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">loadTexture</span><span class="p">(</span><span class="w"> </span><span class="nx">url</span><span class="p">,</span><span class="w"> </span><span class="nx">textureObject</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w">  </span><span class="nx">img</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">Image</span><span class="p">();</span><span class="w">  </span><span class="c1">//  A DOM image element to represent the image.</span>
<span class="w">    </span><span class="nx">img</span><span class="p">.</span><span class="nx">onload</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kd">function</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="c1">// This function will be called after the image loads successfully.</span>
<span class="w">        </span><span class="c1">// We have to bind the texture object to the TEXTURE_2D target before</span>
<span class="w">        </span><span class="c1">// loading the image into the texture object. </span>
<span class="w">        </span><span class="nx">gl</span><span class="p">.</span><span class="nx">bindTexture</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">textureObject</span><span class="p">);</span>
<span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">gl</span><span class="p">.</span><span class="nx">texImage2D</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span><span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span><span class="nx">gl</span><span class="p">.</span><span class="nx">UNSIGNED_BYTE</span><span class="p">,</span><span class="nx">img</span><span class="p">);</span>
<span class="w">        </span><span class="nx">gl</span><span class="p">.</span><span class="nx">generateMipmap</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">);</span><span class="w">  </span><span class="c1">// Create mipmaps; you must either</span>
<span class="w">                            </span><span class="c1">// do this or change the minification filter.</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="nx">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Probably a security exception, because this page has been</span>
<span class="w">                    </span><span class="c1">// loaded through a file:// URL.</span>
<span class="w">            </span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;headline&quot;</span><span class="p">).</span><span class="nx">innerHTML</span><span class="w"> </span><span class="o">=</span>
<span class="w">            </span><span class="s2">&quot;Sorry, couldn&#39;t load texture.&lt;br&gt;&quot;</span><span class="w"> </span><span class="o">+</span>
<span class="w">            </span><span class="s2">&quot;Some web browsers won&#39;t use images from a local disk&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="nx">draw</span><span class="p">();</span><span class="w">  </span><span class="c1">// Draw the canvas, with or without the texture.  </span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="nx">img</span><span class="p">.</span><span class="nx">onerror</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kd">function</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="c1">// This function will be called if an error occurs while loading.</span>
<span class="w">        </span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;headline&quot;</span><span class="p">).</span><span class="nx">innerHTML</span><span class="w"> </span><span class="o">=</span>
<span class="w">                        </span><span class="s2">&quot;&lt;p&gt;Sorry, texture image could not be loaded.&lt;/p&gt;&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="nx">draw</span><span class="p">();</span><span class="w">  </span><span class="c1">// Draw without the texture; triangle will be black.</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="nx">img</span><span class="p">.</span><span class="nx">src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">url</span><span class="p">;</span><span class="w">  </span><span class="c1">// Start loading of the image.</span>
<span class="w">                    </span><span class="c1">// This must be done after setting onload and onerror.</span>
<span class="p">}</span>
</code></pre></div>
<p>Note that image textures for <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 should be power-of-two textures. That is, the width and the height of the image should each be a power of 2, such as 128, 256, or 512. You can, in fact, use non-power-of-two textures, but you can't use <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr> with such textures, and the only <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> repeat mode that is supported by such textures is <em>gl.CLAMP_TO_EDGE</em>. (<abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 does not have these restrictions.)</p>
<p>(The try..catch statement is used in this function because most web browsers will throw a security exception when a page attempts to use an image from the local file system as a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. This means that if you attempt to run a program that uses textures from a downloaded version of this book, the programs that use textures might not work.)</p>
<hr />
<p>There are several parameters associated with a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object, including the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> repeat modes and the minification and magnification filters. They can be set using the function <em>gl.texParameteri</em>. The setting applies to the currently bound <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object. Most of the details are the same as in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1 (<a href="../../c4/s3/#433-纹理目标和纹理参数">Subsection 4.3.3</a>). For example, the <abbr title="An operation that is used when applying a texture to an object, when the texture has to be shrunk to fit the object. For an image texture, a minification filter is applied to compute the color of a pixel when that pixel covers several pixels in the image.">minification filter</abbr> can be set to LINEAR using</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">texParameteri</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_MIN_FILTER</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">LINEAR</span><span class="p">);</span>
</code></pre></div>
<p>Recall that the default <abbr title="An operation that is used when applying a texture to an object, when the texture has to be shrunk to fit the object. For an image texture, a minification filter is applied to compute the color of a pixel when that pixel covers several pixels in the image.">minification filter</abbr> won't work without <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr>. To get a working <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>, you have to change the <abbr title="An operation that is used when applying a texture to an object, when the texture has to be shrunk to fit the object. For an image texture, a minification filter is applied to compute the color of a pixel when that pixel covers several pixels in the image.">minification filter</abbr> or install a full set of <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr>. Fortunately, <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> has a function that will generate the <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr> for you:</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">generateMipmap</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>The <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> repeat modes determine what happens when <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates lie outside the range 0.0 to 1.0. There is a separate repeat mode for each direction in the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr>. In <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>, the possible values are <em>gl.REPEAT</em>, <em>gl.CLAMP_TO_EDGE</em>, and <em>gl.MIRRORED_REPEAT</em>. The default is <em>gl.REPEAT</em>. The mode <em>CLAMP_TO_EDGE</em> was called <em>CLAMP</em> in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1, and <em>MIRRORED_REPEAT</em> is new in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>. With <em>MIRRORED_REPEAT</em>, the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image is repeated to cover the entire plane, but every other copy of the image is reflected. This can eliminate visible seams between the copies. To set a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> to use mirrored repeat in both directions, use</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">texParameteri</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_WRAP_S</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">MIRRORED_REPEAT</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">texParameteri</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_WRAP_T</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">MIRRORED_REPEAT</span><span class="p">);</span>
</code></pre></div>
<hr />
<p>In <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>, <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates are usually input to the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> as an <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> of type <em>vec2</em>. They are communicated to the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> in a <abbr title="A variable that is used to communicate values from the vertex shader to the fragment shader in the WebGL or OpenGL ES 2.0 graphics pipeline. A varying variable is assigned a value in the vertex shader. The value of the variable in the fragment shader for a pixel in the primitive is obtained by interpolating the values from the vertices of the primitive. (In newer versions of GLSL, which support additional shader stages, the term &quot;varying variable&quot; is replaced by the more general terms &quot;in variable&quot; and &quot;out variable,&quot; which refer to variables that are used for input to or output from a shader.)">varying variable</abbr>. Often, the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> will simply copy the value of the <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> into the <abbr title="A variable that is used to communicate values from the vertex shader to the fragment shader in the WebGL or OpenGL ES 2.0 graphics pipeline. A varying variable is assigned a value in the vertex shader. The value of the variable in the fragment shader for a pixel in the primitive is obtained by interpolating the values from the vertices of the primitive. (In newer versions of GLSL, which support additional shader stages, the term &quot;varying variable&quot; is replaced by the more general terms &quot;in variable&quot; and &quot;out variable,&quot; which refer to variables that are used for input to or output from a shader.)">varying variable</abbr>. Another possibility is to apply an affine <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> transformation to the coordinates in the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> before passing them on to the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr>. In the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr>, the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates are used to sample a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. The <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 1.00 function for <abbr title="The operation of mapping texture coordinates to colors from a texture, including using mipmaps if available and applying a minification or magnification filter if necessary.">sampling</abbr> an ordinary <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> is</p>
<div class="highlight"><pre><span></span><code><span class="nx">texture2D</span><span class="p">(</span><span class="w"> </span><span class="nx">samplerVariable</span><span class="p">,</span><span class="w"> </span><span class="nx">textureCoordinates</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>where <em>samplerVariable</em> is the <abbr title="Variables that represent input to a shader program in a programmable graphics pipeline. A uniform variable has the same value at every vertex and at every pixel of a primitive.">uniform variable</abbr> of type <em>sampler2D</em> that represents the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>, and <em>textureCoordinates</em> is a <em>vec2</em> containing the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates. The return value is an <abbr title="An RGB color—specified by red, green, and blue component values—together with an alpha component. The alpha component is most often take to specify the degree of transparency of the color, with a maximal alpha value giving a fully opaque color.">RGBA color</abbr>, represented as a value of type <em>vec4</em>. As a very minimal example, here is a <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> that simply uses the sampled value from the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> as the color of the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>.</p>
<div class="highlight"><pre><span></span><code><span class="nx">precision</span><span class="w"> </span><span class="nx">mediump</span><span class="w"> </span><span class="kr">float</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">sampler2D</span><span class="w"> </span><span class="nx">u_texture</span><span class="p">;</span>
<span class="nx">varying</span><span class="w"> </span><span class="nx">vec2</span><span class="w"> </span><span class="nx">v_texCoords</span><span class="p">;</span>
<span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="nx">vec4</span><span class="w"> </span><span class="nx">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">texture2D</span><span class="p">(</span><span class="w"> </span><span class="nx">u_texture</span><span class="p">,</span><span class="w"> </span><span class="nx">v_texCoords</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl_FragColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">color</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>This <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> is from the sample program <a href="../../../en/source/webgl/simple-texture.html">webgl/simple-<abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>.html</a>.</p>
<p>Textures are sometimes used on primitives of type <em>gl.POINTS</em>. In that case, it's natural to get the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates for a <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> from the special <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> variable <em>gl_PointCoord</em>. A point is rendered as a square, and the coordinates in <em>gl_PointCoord</em> range from 0.0 to 1.0 over that square. So, using <em>gl_PointCoord</em> means that one copy of the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> will be pasted onto the point. If the <em>POINTS</em> primitive has more than one <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>, you will see a copy of the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> at the location of each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>. This is an easy way to put an image, or multiple copies of an image, into a scene. The technique is sometimes referred to as "point sprites."</p>
<p>The following demo draws a single textured primitive of type <em>gl.POINTS</em>, so you can see what it looks like. In the demo, only a circular cutout from each square point is drawn.</p>
<p><iframe src="../../../en/demos/c6/textured-points.html" width="600" height="375"></iframe></p>
<p>The <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> data for a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> is stored in memory starting with the row of <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr> at the bottom of the image and working up from there. When <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> creates the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> by reading the data from an image, it assumes that the image uses the same format. However, images in a web browser are stored in the opposite order, starting with the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr> in the top row of the image and working down. The result of this mismatch is that <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> images will appear upside down. You can account for this by modifying your <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates. However, you can also tell <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> to invert the images for you as it "unpacks" them. To do that, call</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">pixelStorei</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">UNPACK_FLIP_Y_WEBGL</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>Generally, you can do this as part of initialization. Note however that for <em>gl.POINTS</em> primitives, the <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr> used by <em>gl_PointCoord</em> is already upside down, with the y-coordinate increasing from top to bottom. So, if you are loading an image for use on a <em>POINTS</em> primitive, you might want to set <em>gl.UNPACK_FLIP_Y_WEBGL</em> to its default value, 0.</p>
</div>
</div>
</div>
<h2 id="643-更多制作纹理的方法">6.4.3 更多制作纹理的方法<a class="headerlink" href="#643-更多制作纹理的方法" title="Permanent link">&para;</a></h2>
<p><strong>More Ways to Make Textures</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="4:2"><input checked="checked" id="__tabbed_4_1" name="__tabbed_4" type="radio" /><input id="__tabbed_4_2" name="__tabbed_4" type="radio" /><div class="tabbed-labels"><label for="__tabbed_4_1">中文</label><label for="__tabbed_4_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>我们已经看到了如何使用<em>gl.texImage2D</em>从图像或画布元素创建纹理。在WebGL中，还有几种方法可以制作图像纹理。首先，函数</p>
<div class="highlight"><pre><span></span><code><span class="nx">glCopyTexImage2D</span><span class="p">(</span><span class="w"> </span><span class="nx">target</span><span class="p">,</span><span class="w"> </span><span class="nx">mipmapLevel</span><span class="p">,</span><span class="w"> </span><span class="nx">internalFormat</span><span class="p">,</span>
<span class="w">                </span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="p">,</span><span class="w"> </span><span class="nx">width</span><span class="p">,</span><span class="w"> </span><span class="nx">height</span><span class="p">,</span><span class="w"> </span><span class="nx">border</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>在WebGL中也存在，这在<a href="../../c4/s3/#436-来自颜色缓冲区的纹理">4.3.6小节</a>中有所涵盖。这个函数从颜色缓冲区（WebGL在其上渲染图像的地方）复制数据到当前绑定的纹理对象中。数据来自颜色缓冲区中的矩形区域，该区域具有指定的<em>width</em>和高度，其左下角位于<em>(x,y)</em>。<em>internalFormat</em>通常是<em>gl.RGBA</em>。对于WebGL，<em>border</em>必须是零。例如，</p>
<div class="highlight"><pre><span></span><code><span class="nx">glCopyTexImage2D</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">256</span><span class="p">,</span><span class="w"> </span><span class="mf">256</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">);</span>
</code></pre></div>
<p>这从颜色缓冲区的左下角256像素正方形中获取纹理数据。（在后续章节中，我们将看到，实际上可能，并且更有效，让WebGL直接将图像渲染到纹理对象中，使用所谓的“<abbr title="包含数字图像的颜色数据的内存区域。通常指的是包含显示在计算机屏幕上的图像的内存。">帧缓冲区</abbr>”。）</p>
<p>也许更有趣的是，能够直接从数字数组中获取纹理数据。这些数字将成为纹理中像素的颜色分量值。用于此的函数是<em>texImage2D</em>的替代版本：</p>
<div class="highlight"><pre><span></span><code><span class="nx">texImage2D</span><span class="p">(</span><span class="w"> </span><span class="nx">target</span><span class="p">,</span><span class="w"> </span><span class="nx">mipmapLevel</span><span class="p">,</span><span class="w"> </span><span class="nx">internalFormat</span><span class="p">,</span><span class="w"> </span><span class="nx">width</span><span class="p">,</span><span class="w"> </span><span class="nx">height</span><span class="p">,</span>
<span class="w">        </span><span class="nx">border</span><span class="p">,</span><span class="w"> </span><span class="nx">dataFormat</span><span class="p">,</span><span class="w"> </span><span class="nx">dataType</span><span class="p">,</span><span class="w"> </span><span class="nx">dataArray</span><span class="w"> </span><span class="p">)</span>
</code></pre></div>
<p>一个典型的函数调用形式为</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">texImage2D</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span><span class="w"> </span><span class="mf">16</span><span class="p">,</span><span class="w"> </span><span class="mf">16</span><span class="p">,</span><span class="w"> </span>
<span class="w">            </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">UNSIGNED_BYTE</span><span class="p">,</span><span class="w"> </span><span class="nx">pixels</span><span class="p">);</span>
</code></pre></div>
<p>与<em>texImage2D</em>的原始版本相比，这里有三个额外的参数，<em>width</em>、<em>height</em>和<em>border</em>。<em>width</em>和<em>height</em>指定了纹理图像的大小。对于WebGL，border必须是零，对于WebGL 1.0，internalFormat和dataFormat必须相同。</p>
<p>这个版本的<em>texImage2D</em>的最后一个参数必须是类型化数组，类型为<strong><em>Uint8Array</em></strong>或<strong><em>Uint16Array</em></strong>，具体取决于纹理的<em>dataFormat</em>。我的例子将使用<strong><em>Uint8Array</em></strong>和纹理格式<em>gl.RGBA</em>或<em>gl.LUMINANCE</em>。</p>
<p>对于RGBA纹理，每个像素需要四个颜色分量值。这些值将以无符号字节的形式给出，值范围从0到255，在<em>Uint8Array</em>中。数组的长度将是<em>4</em>width<em>height</em>（即图像中像素数量的四倍）。数组中底部像素行的数据首先出现，然后是上面的行，以此类推，给定行中的像素从左到右运行。在单个像素的数据中，红色分量首先出现，然后是蓝色，然后是绿色，然后是alpha。</p>
<p>作为从头开始制作纹理数据的示例，让我们制作一个16x16的纹理图像，图像被划分为四个8x8的正方形，分别着上红色、白色和蓝色。代码利用了创建类型化数组时，它最初填充了零的事实。我们只需要改变其中的一些零为255。</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">pixels</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Uint8Array</span><span class="p">(</span><span class="mf">4</span><span class="o">*</span><span class="mf">16</span><span class="o">*</span><span class="mf">16</span><span class="p">);</span><span class="w">  </span><span class="c1">// 每个像素四个字节</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">16</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="nx">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">16</span><span class="p">;</span><span class="w"> </span><span class="nx">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="nx">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">64</span><span class="o">*</span><span class="nx">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">4</span><span class="o">*</span><span class="nx">j</span><span class="p">;</span><span class="w">    </span><span class="c1">// 此像素的数据起始索引</span>
<span class="w">        </span><span class="nx">pixels</span><span class="p">[</span><span class="nx">offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">255</span><span class="p">;</span><span class="w">    </span><span class="c1">// 像素的alpha值</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">8</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">8</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 左下象限是红色</span>
<span class="w">            </span><span class="nx">pixels</span><span class="p">[</span><span class="nx">offset</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">255</span><span class="p">;</span><span class="w">  </span><span class="c1">// 将红色分量设置为最大</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">8</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">j</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">8</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 右上象限是蓝色</span>
<span class="w">            </span><span class="nx">pixels</span><span class="p">[</span><span class="nx">offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">255</span><span class="p">;</span><span class="w"> </span><span class="c1">// 将蓝色分量设置为最大</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 另外两个象限是白色</span>
<span class="w">            </span><span class="nx">pixels</span><span class="p">[</span><span class="nx">offset</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">255</span><span class="p">;</span><span class="w">     </span><span class="c1">// 将所有分量设置为最大</span>
<span class="w">            </span><span class="nx">pixels</span><span class="p">[</span><span class="nx">offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">255</span><span class="p">;</span>
<span class="w">            </span><span class="nx">pixels</span><span class="p">[</span><span class="nx">offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">255</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="nx">texture</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createTexture</span><span class="p">();</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bindTexture</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">texture</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">texImage2D</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span><span class="w"> </span><span class="mf">16</span><span class="p">,</span><span class="w"> </span><span class="mf">16</span><span class="p">,</span><span class="w"> </span>
<span class="w">                </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">UNSIGNED_BYTE</span><span class="p">,</span><span class="w"> </span><span class="nx">pixels</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">texParameteri</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_MIN_FILTER</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">LINEAR</span><span class="p">);</span>
</code></pre></div>
<p>最后一行是因为没有mipmap时，默认的最小化滤波器无法工作。纹理使用默认的放大滤波器，也是<em>gl.LINEAR</em>。这个纹理用在下图中左上角的正方形上。图像来自示例程序<a href="../../../en/source/webgl/texture-from-pixels.html">webgl/<abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>-from-<abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr>.html</a>。</p>
<p><a class="glightbox" href="../../../en/c6/textures-from-pixels.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c6/textures-from-pixels.png" /></a></p>
<p>注意左上角正方形中颜色边缘之间的混合。混合是由<em>gl.LINEAR</em>放大滤波器引起的。第二个正方形使用相同的纹理，但是使用<em>gl.NEAREST</em>放大滤波器，它消除了混合。在接下来的两个正方形中也可以看到相同的效果，它们使用黑白棋盘格图案，一个使用<em>gl.Linear</em>作为放大滤波器，一个使用<em>gl.NEAREST</em>。纹理在正方形上水平和垂直重复了十次。在这种情况下，纹理是一个非常小的2x2图像，有两个黑色和两个白色像素。</p>
<p>作为另一个示例，考虑图像中右下角的正方形。该正方形上的渐变效果来自于一个纹理。纹理大小为256x1像素，颜色沿着纹理的长度从黑色变为白色。纹理的一个副本被映射到正方形上。对于渐变纹理，我使用<em>gl.LUMINANCE</em>作为纹理格式，这意味着数据由每个像素一个字节组成，给出该像素的灰度值。纹理可以使用以下方式创建：</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">pixels</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Uint8Array</span><span class="p">(</span><span class="mf">256</span><span class="p">);</span><span class="w">  </span><span class="c1">// 每个像素一个字节</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">256</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">pixels</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">i</span><span class="p">;</span><span class="w">  </span><span class="c1">// 像素i的灰度值是i。</span>
<span class="p">}</span>

<span class="nx">gl</span><span class="p">.</span><span class="nx">texImage2D</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">LUMINANCE</span><span class="p">,</span><span class="w"> </span><span class="mf">256</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span>
<span class="w">                </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">LUMINANCE</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">UNSIGNED_BYTE</span><span class="p">,</span><span class="w"> </span><span class="nx">pixels</span><span class="p">);</span>
</code></pre></div>
<p>有关更多详细信息，请参见<a href="../../../en/source/webgl/texture-from-pixels.html">示例程序</a>。</p>
</div>
<div class="tabbed-block">
<p>We have seen how to create a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> from an image or canvas element using <em>gl.texImage2D</em>. There are several more ways to make an <abbr title="An image that is applied to a surface as a texture, so that it looks at if the image is &quot;painted&quot; onto the surface.">image texture</abbr> in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>. First of all, the function</p>
<div class="highlight"><pre><span></span><code><span class="nx">glCopyTexImage2D</span><span class="p">(</span><span class="w"> </span><span class="nx">target</span><span class="p">,</span><span class="w"> </span><span class="nx">mipmapLevel</span><span class="p">,</span><span class="w"> </span><span class="nx">internalFormat</span><span class="p">,</span>
<span class="w">                                    </span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="p">,</span><span class="w"> </span><span class="nx">width</span><span class="p">,</span><span class="w"> </span><span class="nx">height</span><span class="p">,</span><span class="w"> </span><span class="nx">border</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>which was covered in <a href="../../c4/s3/#436-来自颜色缓冲区的纹理">Subsection 4.3.6</a> also exists in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>. This function copies data from the <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr> (where <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> renders its images) into the currently bound <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object. The data is taken from the rectangular region in the <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr> with the specified <em>width</em> and height and with its lower left corner at <em>(x,y)</em>. The <em>internalFormat</em> is usually <em>gl.RGBA</em>. For <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>, the <em>border</em> must be zero. For example,</p>
<div class="highlight"><pre><span></span><code><span class="nx">glCopyTexImage2D</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">256</span><span class="p">,</span><span class="w"> </span><span class="mf">256</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">);</span>
</code></pre></div>
<p>This takes the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> data from a 256-<abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> square in the bottom left corner of the <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr>. (In a later chapter, we will see that it is actually possible, and more efficient, for <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> to render an image directly to a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object, using something called a "<abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr>.")</p>
<p>More interesting, perhaps, is the ability to take the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> data directly from an array of numbers. The numbers will become the <abbr title="One of the numbers used in a color model to specify a color. For example, in the RGB color model, a color is specified by three color components representing the amounts of red, green, and blue in the color.">color component</abbr> values for the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr> in the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. The function that is used for this is an alternative version of <em>texImage2D</em>:</p>
<div class="highlight"><pre><span></span><code><span class="nx">texImage2D</span><span class="p">(</span><span class="w"> </span><span class="nx">target</span><span class="p">,</span><span class="w"> </span><span class="nx">mipmapLevel</span><span class="p">,</span><span class="w"> </span><span class="nx">internalFormat</span><span class="p">,</span><span class="w"> </span><span class="nx">width</span><span class="p">,</span><span class="w"> </span><span class="nx">height</span><span class="p">,</span>
<span class="w">                                </span><span class="nx">border</span><span class="p">,</span><span class="w"> </span><span class="nx">dataFormat</span><span class="p">,</span><span class="w"> </span><span class="nx">dataType</span><span class="p">,</span><span class="w"> </span><span class="nx">dataArray</span><span class="w"> </span><span class="p">)</span>
</code></pre></div>
<p>and a typical function call would have the form</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">texImage2D</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span><span class="w"> </span><span class="mf">16</span><span class="p">,</span><span class="w"> </span><span class="mf">16</span><span class="p">,</span><span class="w"> </span>
<span class="w">                                </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">UNSIGNED_BYTE</span><span class="p">,</span><span class="w"> </span><span class="nx">pixels</span><span class="p">);</span>
</code></pre></div>
<p>Compared to the original version of <em>texImage2D</em>, there are three extra parameters, <em>width</em>, <em>height</em>, and <em>border</em>. The <em>width</em> and <em>height</em> specify the size of the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image. For <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>, the border must be zero, and for <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0, the internalFormat and dataFormat must be the same.</p>
<p>The last parameter in this version of <em>texImage2D</em> must be a <abbr title="In JavaScript, an array type that is limited to holding numerical values of a single type. For example, the type Float32Array represents arrays that can hold 32-bit floating point values, and Uint8Array arrays can hold only 8-bit integer values. Such arrays are more efficient than general JavaScript arrays for numerical calculations. The were introduced into JavaScript along with HTML canvas graphics and WebGL.">typed array</abbr> of type <strong><em>Uint8Array</em></strong> or <strong><em>Uint16Array</em></strong>, depending on the <em>dataFormat</em> of the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. My examples will use <strong><em>Uint8Array</em></strong> and <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> format <em>gl.RGBA</em> or <em>gl.LUMINANCE</em>.</p>
<p>For an RGBA <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>, four <abbr title="One of the numbers used in a color model to specify a color. For example, in the RGB color model, a color is specified by three color components representing the amounts of red, green, and blue in the color.">color component</abbr> values are needed for each <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>. The values will be given as unsigned bytes, with values ranging from 0 to 255, in a <em>Uint8Array</em>. The length of the array will be <em>4*width*height</em> (that is, four times the number of <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr> in the image). The data for the bottom row of <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr> comes first in the array, followed by the row on top of that, and so on, with the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr> in a given row running from left to right. And within the data for one <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>, the red component comes first, followed by the blue, then the green, then the <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr>.</p>
<p>As an example of making up <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> data from scratch, let's make a 16-by-16 <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image, with the image divided into four 8-by-8 squares that are colored red, white, and blue. The code uses the fact that when a <abbr title="In JavaScript, an array type that is limited to holding numerical values of a single type. For example, the type Float32Array represents arrays that can hold 32-bit floating point values, and Uint8Array arrays can hold only 8-bit integer values. Such arrays are more efficient than general JavaScript arrays for numerical calculations. The were introduced into JavaScript along with HTML canvas graphics and WebGL.">typed array</abbr> is created, it is initially filled with zeros. We just have to change some of those zeros to 255.</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">pixels</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Uint8Array</span><span class="p">(</span><span class="w"> </span><span class="mf">4</span><span class="o">*</span><span class="mf">16</span><span class="o">*</span><span class="mf">16</span><span class="w"> </span><span class="p">);</span><span class="w">  </span><span class="c1">// four bytes per pixel</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">16</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="nx">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">16</span><span class="p">;</span><span class="w"> </span><span class="nx">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="nx">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">64</span><span class="o">*</span><span class="nx">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">4</span><span class="o">*</span><span class="nx">j</span><span class="w"> </span><span class="p">;</span><span class="w">    </span><span class="c1">// starting index of data for this pixel</span>
<span class="w">        </span><span class="nx">pixels</span><span class="p">[</span><span class="nx">offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">255</span><span class="p">;</span><span class="w">    </span><span class="c1">// alpha value for the pixel</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">8</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">8</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// bottom left quadrant is red</span>
<span class="w">            </span><span class="nx">pixels</span><span class="p">[</span><span class="nx">offset</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">255</span><span class="p">;</span><span class="w">  </span><span class="c1">// set red component to maximum</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">8</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">j</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">8</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// top right quadrant is blue</span>
<span class="w">            </span><span class="nx">pixels</span><span class="p">[</span><span class="nx">offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">255</span><span class="p">;</span><span class="w"> </span><span class="c1">// set blue component to maximum</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// the other two quadrants are white</span>
<span class="w">            </span><span class="nx">pixels</span><span class="p">[</span><span class="nx">offset</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">255</span><span class="p">;</span><span class="w">     </span><span class="c1">// set all components to maximum</span>
<span class="w">            </span><span class="nx">pixels</span><span class="p">[</span><span class="nx">offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">255</span><span class="p">;</span>
<span class="w">            </span><span class="nx">pixels</span><span class="p">[</span><span class="nx">offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">255</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="nx">texture</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createTexture</span><span class="p">();</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bindTexture</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">texture</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">texImage2D</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span><span class="w"> </span><span class="mf">16</span><span class="p">,</span><span class="w"> </span><span class="mf">16</span><span class="p">,</span><span class="w"> </span>
<span class="w">                            </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">UNSIGNED_BYTE</span><span class="p">,</span><span class="w"> </span><span class="nx">pixels</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">texParameteri</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_MIN_FILTER</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">LINEAR</span><span class="p">);</span>
</code></pre></div>
<p>The last line is there because the default <abbr title="An operation that is used when applying a texture to an object, when the texture has to be shrunk to fit the object. For an image texture, a minification filter is applied to compute the color of a pixel when that pixel covers several pixels in the image.">minification filter</abbr> won't work without <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr>. The <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> uses the default <abbr title="An operation that is used when applying a texture to an object, when the texture has to be stretched to fit the object. For an image texture, a magnification filter is applied to compute the color of a pixel when that pixel covers just a fraction of a pixel in the image.">magnification filter</abbr>, which is also <em>gl.LINEAR</em>. This <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> is used on the leftmost square in the image shown below. The image is from the sample program <a href="../../../en/source/webgl/texture-from-pixels.html">webgl/<abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>-from-<abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr>.html</a>.</p>
<p><a class="glightbox" href="../../../en/c6/textures-from-pixels.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c6/textures-from-pixels.png" /></a></p>
<p>Note the blending along the edges between colors in the leftmost square. The blending is caused by the <em>gl.LINEAR</em> <abbr title="An operation that is used when applying a texture to an object, when the texture has to be stretched to fit the object. For an image texture, a magnification filter is applied to compute the color of a pixel when that pixel covers just a fraction of a pixel in the image.">magnification filter</abbr>. The second square uses the same <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>, but with the <em>gl.NEAREST</em> <abbr title="An operation that is used when applying a texture to an object, when the texture has to be stretched to fit the object. For an image texture, a magnification filter is applied to compute the color of a pixel when that pixel covers just a fraction of a pixel in the image.">magnification filter</abbr>, which eliminates the blending. The same effect can be seen in the next two squares, which use a black/white checkerboard pattern, one with <em>gl.Linear</em> as the <abbr title="An operation that is used when applying a texture to an object, when the texture has to be stretched to fit the object. For an image texture, a magnification filter is applied to compute the color of a pixel when that pixel covers just a fraction of a pixel in the image.">magnification filter</abbr> and one using <em>gl.NEAREST</em>. The <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> is repeated ten times horizontally and vertically on the square. In this case, the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> is a tiny 2-by-2 image with two black and two white <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr>.</p>
<p>As another example, consider the rightmost square in the image. The <abbr title="A pattern of color produced by assigning colors to certain reference points and computing color for other points by interpolating or extrapolating colors from the reference points. The effect is a color progression along line segments between reference points. Different rules for extending the colors beyond those lines produce different types of gradient, such as linear gradients and radial gradients.">gradient</abbr> effect on that square comes from a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. The <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> size is 256-by-1 <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr>, with the color changing from black to white along the length of the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. One copy of the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> is mapped to the square. For the <abbr title="A pattern of color produced by assigning colors to certain reference points and computing color for other points by interpolating or extrapolating colors from the reference points. The effect is a color progression along line segments between reference points. Different rules for extending the colors beyond those lines produce different types of gradient, such as linear gradients and radial gradients.">gradient</abbr> <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>, I used <em>gl.LUMINANCE</em> as the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> format, which means that the data consists of one byte per <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>, giving the <abbr title="Refers to a color scheme or image in which each color is a shade of gray (where the term &quot;shade of gray&quot; here includes black and white). Typically, 256 shades of gray are used. Grayscale is also called &quot;monochrome.&quot;">grayscale</abbr> value for that <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>. The <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> can be created using</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">pixels</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">Unit8Array</span><span class="p">(</span><span class="w"> </span><span class="mf">256</span><span class="w"> </span><span class="p">);</span><span class="w">  </span><span class="c1">// One byte per pixel</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">256</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">pixels</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">i</span><span class="p">;</span><span class="w">  </span><span class="c1">// Grayscale value for pixel number i is i.</span>
<span class="p">}</span>

<span class="nx">gl</span><span class="p">.</span><span class="nx">texImage2D</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">LUMINANCE</span><span class="p">,</span><span class="w"> </span><span class="mf">256</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span>
<span class="w">                            </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">LUMINANCE</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">UNSIGNED_BYTE</span><span class="p">,</span><span class="w"> </span><span class="nx">pixels</span><span class="p">);</span>
</code></pre></div>
<p>See the <a href="../../../en/source/webgl/texture-from-pixels.html">sample program</a> for more detail.</p>
</div>
</div>
</div>
<h2 id="644-立方体贴图纹理">6.4.4 立方体贴图纹理<a class="headerlink" href="#644-立方体贴图纹理" title="Permanent link">&para;</a></h2>
<p><strong>Cubemap Textures</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="5:2"><input checked="checked" id="__tabbed_5_1" name="__tabbed_5" type="radio" /><input id="__tabbed_5_2" name="__tabbed_5" type="radio" /><div class="tabbed-labels"><label for="__tabbed_5_1">中文</label><label for="__tabbed_5_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>我们在<a href="../../c5/s3/#534-立方体贴图纹理和天空盒">5.3.4小节</a>中遇到了立方体贴图纹理，在那里我们看到了它们是如何在<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>中用于天空盒和环境映射的。WebGL内置了对立方体贴图的支持。与表示普通图像纹理不同，纹理对象可以包含一个立方体贴图。并且两个纹理对象可以同时绑定到同一个纹理单元，一个包含普通纹理，一个包含立方体贴图。这两种纹理绑定到不同的目标，<em>gl.TEXTURE_2D</em>和<em>gl.TEXTURE_CUBE_MAP</em>。通过调用</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">bindTexture</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP</span><span class="p">,</span><span class="w"> </span><span class="nx">texObj</span><span class="p">);</span>
</code></pre></div>
<p>可以将纹理对象<em>texObj</em>绑定到当前活动纹理单元的立方体贴图目标上。</p>
<p>一个给定的纹理对象可以是常规纹理或立方体贴图，但不能两者都是。一旦它被绑定到一个纹理目标上，它就不能被重新绑定到另一个目标。</p>
<p>立方体贴图由六幅图像组成，每个立方体的每个面一幅。包含立方体贴图的纹理对象有六个图像插槽，由以下常量标识</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_NEGATIVE_X</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_POSITIVE_X</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_NEGATIVE_Y</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_POSITIVE_Y</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_NEGATIVE_Z</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_POSITIVE_Z</span>
</code></pre></div>
<p>这些常量被用作<em>gl.texImage2D</em>和<em>gl.copyTexImage2D</em>中的目标，在gl.TEXTURE_2D的位置。（注意，有六个目标用于将图像加载到立方体贴图对象中，但只有一个目标，<em>gl.TEXTURE_CUBE_MAP</em>，用于将纹理对象绑定到纹理单元。）立方体贴图通常存储为一组六个图像，这些图像必须分别加载到纹理对象中。当然，WebGL也可以通过渲染这六个图像来创建立方体。</p>
<p>与网络上的图像一样，这里也有异步图像加载的问题需要处理。下面是一个示例，展示了在我的示例程序<a href="../../../en/source/webgl/cubemap-fisheye.html">webgl/cubemap-fisheye.html</a>中如何创建立方体贴图：</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span><span class="w"> </span><span class="nx">loadCubemapTexture</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">tex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createTexture</span><span class="p">();</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">imageCt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// 完成加载的图像数量。</span>

<span class="w">    </span><span class="nx">load</span><span class="p">(</span><span class="s2">&quot;cubemap-textures/park/negx.jpg&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_NEGATIVE_X</span><span class="p">);</span>
<span class="w">    </span><span class="nx">load</span><span class="p">(</span><span class="s2">&quot;cubemap-textures/park/posx.jpg&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_POSITIVE_X</span><span class="p">);</span>
<span class="w">    </span><span class="nx">load</span><span class="p">(</span><span class="s2">&quot;cubemap-textures/park/negy.jpg&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_NEGATIVE_Y</span><span class="p">);</span>
<span class="w">    </span><span class="nx">load</span><span class="p">(</span><span class="s2">&quot;cubemap-textures/park/posy.jpg&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_POSITIVE_Y</span><span class="p">);</span>
<span class="w">    </span><span class="nx">load</span><span class="p">(</span><span class="s2">&quot;cubemap-textures/park/negz.jpg&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_NEGATIVE_Z</span><span class="p">);</span>
<span class="w">    </span><span class="nx">load</span><span class="p">(</span><span class="s2">&quot;cubemap-textures/park/posz.jpg&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_POSITIVE_Z</span><span class="p">);</span>

<span class="w">    </span><span class="kd">function</span><span class="w"> </span><span class="nx">load</span><span class="p">(</span><span class="nx">url</span><span class="p">,</span><span class="w"> </span><span class="nx">target</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="nx">img</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">Image</span><span class="p">();</span>
<span class="w">        </span><span class="nx">img</span><span class="p">.</span><span class="nx">onload</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kd">function</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">gl</span><span class="p">.</span><span class="nx">bindTexture</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP</span><span class="p">,</span><span class="w"> </span><span class="nx">tex</span><span class="p">);</span>
<span class="w">            </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nx">gl</span><span class="p">.</span><span class="nx">texImage2D</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">UNSIGNED_BYTE</span><span class="p">,</span><span class="w"> </span><span class="nx">img</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="nx">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;headline&quot;</span><span class="p">).</span><span class="nx">innerHTML</span><span class="w"> </span><span class="o">=</span>
<span class="w">                </span><span class="s2">&quot;无法访问纹理。请注意，一些浏览器&quot;</span><span class="w"> </span><span class="o">+</span>
<span class="w">                </span><span class="s2">&quot;无法从本地文件使用纹理。&quot;</span><span class="p">;</span>
<span class="w">                </span><span class="k">return</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="nx">imageCt</span><span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">imageCt</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mf">6</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// 所有6个图像都已加载</span>
<span class="w">                </span><span class="nx">gl</span><span class="p">.</span><span class="nx">generateMipmap</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP</span><span class="p">);</span>
<span class="w">                </span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;headline&quot;</span><span class="p">).</span><span class="nx">innerHTML</span><span class="w"> </span><span class="o">=</span>
<span class="w">                </span><span class="s2">&quot;有趣的立方体贴图（鱼眼相机效果）&quot;</span><span class="p">;</span>
<span class="w">                </span><span class="nx">textureObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">tex</span><span class="p">;</span>
<span class="w">                </span><span class="nx">draw</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">};</span>
<span class="w">        </span><span class="nx">img</span><span class="p">.</span><span class="nx">onerror</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kd">function</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;headline&quot;</span><span class="p">).</span><span class="nx">innerHTML</span><span class="w"> </span><span class="o">=</span>
<span class="w">            </span><span class="s2">&quot;对不起，无法加载纹理&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="p">};</span>
<span class="w">        </span><span class="nx">img</span><span class="p">.</span><span class="nx">src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">url</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>立方体贴图的图像必须具有相同的大小。它们必须是正方形。大小应该是2的幂。对于立方体贴图，诸如最小化滤波器之类的纹理参数是使用目标<em>gl.TEXTURE_CUBE_MAP</em>设置的，它们适用于立方体的所有六个面。例如，</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">texParameteri</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_MIN_FILTER</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">LINEAR</span><span class="p">);</span>
</code></pre></div>
<p>同样，<em>gl.generateMipmap</em>将为所有六个面生成mipmap（因此直到所有六个图像都已加载后才应该调用它）。</p>
<hr />
<p>在着色器程序中，立方体贴图由类型为<em>samplerCube</em>的统一变量表示。在GLSL ES 1.00中，使用函数<em>textureCube</em>对纹理进行采样。例如，</p>
<div class="highlight"><pre><span></span><code><span class="nx">vec4</span><span class="w"> </span><span class="nx">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">textureCube</span><span class="p">(</span><span class="nx">u_texture</span><span class="p">,</span><span class="w"> </span><span class="nx">vector</span><span class="p">);</span>
</code></pre></div>
<p>第一个参数是表示纹理的<em>samplerCube</em>变量。第二个参数是一个<em>vec3</em>。立方体贴图不是使用常规纹理坐标进行采样的。相反，使用一个3D向量。目标是在纹理中选取一个点。纹理位于立方体的表面上。要使用向量在纹理中选取一个点，从立方体中心沿着向量方向投射一条射线，并检查该射线与立方体的交点。也就是说，如果你把向量的起始点放在立方体的中心，它就指向要采样纹理的立方体上的点。</p>
<p>由于我们在这一章中没有进行3D图形处理，我们不能以常规方式使用立方图。示例程序<a href="../../../en/source/webgl/cubemap-fisheye.html">webgl/cubemap-fisheye.html</a>以一种有趣但可能不太实用的方式使用立方图。该程序使用2D纹理坐标。片段着色器将一对2D纹理坐标转换为3D向量，然后用于采样立方体贴图。效果类似于由鱼眼镜头相机拍摄的照片。它看起来像这样。</p>
<p><a class="glightbox" href="../../../en/c6/cubemap-fisheye.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c6/cubemap-fisheye.png" /></a></p>
<p>左侧的图片模仿了一个170度视场的鱼眼镜头相机。右侧的视场是330度，以至于圆盘边缘附近的像素实际上显示了位于相机后面的立方体的部分。</p>
<p>对于每张图片，程序绘制一个纹理坐标范围从0.0到1.0的正方形。在纹理坐标系统中，距离点(0.5,0.5)大于0.5的像素被着色为白色。在半径为0.5的圆盘内，围绕中心的每个圆圈被映射到单位球上的一个圆圈。然后该点被用作采样立方体贴图的方向向量。在圆盘中心出现的纹理中的点是立方体与正z轴相交的点，即立方图中“正z”图像的中心。实际上你不需要理解这些，但这里是完成这项工作的片段着色器：</p>
<div class="highlight"><pre><span></span><code><span class="cp">#ifdef GL_FRAGMENT_PRECISION_HIGH</span>
<span class="w">    </span><span class="n">precision</span><span class="w"> </span><span class="n">highp</span><span class="w"> </span><span class="kt">float</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="w">    </span><span class="n">precision</span><span class="w"> </span><span class="n">mediump</span><span class="w"> </span><span class="kt">float</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="n">uniform</span><span class="w"> </span><span class="n">samplerCube</span><span class="w"> </span><span class="n">u_texture</span><span class="p">;</span><span class="w">  </span>
<span class="n">uniform</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">u_angle</span><span class="p">;</span><span class="w">  </span><span class="c1">// 视场角度</span>
<span class="n">varying</span><span class="w"> </span><span class="n">vec2</span><span class="w"> </span><span class="n">v_texCoords</span><span class="p">;</span><span class="w">  </span>
<span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">distance</span><span class="p">(</span><span class="n">v_texCoords</span><span class="p">,</span><span class="w"> </span><span class="n">vec2</span><span class="p">(</span><span class="mf">0.5</span><span class="p">));</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dist</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.5</span><span class="p">)</span>
<span class="w">        </span><span class="n">gl_FragColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec4</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span><span class="w">  </span><span class="c1">// 白色</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"> </span><span class="c1">// 相对于中心(0.5,0.5)的坐标</span>
<span class="w">        </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v_texCoords</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">0.5</span><span class="p">;</span><span class="w"> </span>
<span class="w">        </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v_texCoords</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">0.5</span><span class="p">;</span>
<span class="w">        </span><span class="n">vec2</span><span class="w"> </span><span class="n">circ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">vec2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">));</span><span class="w">  </span><span class="c1">// 在单位圆上</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">phi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">radians</span><span class="p">(</span><span class="n">u_angle</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">dist</span><span class="p">);</span><span class="w">  </span><span class="c1">// “纬度”</span>
<span class="w">        </span><span class="n">vec3</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">circ</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">circ</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">));</span>
<span class="w">        </span><span class="n">gl_FragColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">textureCube</span><span class="p">(</span><span class="n">u_texture</span><span class="p">,</span><span class="w"> </span><span class="n">vector</span><span class="p">);</span><span class="w">  </span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span>
<span class="p">}</span>
</code></pre></div>
</div>
<div class="tabbed-block">
<p>We encountered cubemap textures in <a href="../../c5/s3/#534-立方体贴图纹理和天空盒">Subsection 5.3.4</a>, where saw how they are used in <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em> for skyboxes and <abbr title="A way of simulating mirror-like reflection from the surface of an object. The environment that is to be reflected from the surface is represented as a cubemap texture. To determine what point in the texture is visible at a given point on the object, a ray from the viewpoint is reflected from the surface point, and the reflected ray is intersected with the texture cube. Environment mapping is also called reflection mapping.">environment mapping</abbr>. <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> has built-in support for cubemap textures. Instead of representing an ordinary <abbr title="An image that is applied to a surface as a texture, so that it looks at if the image is &quot;painted&quot; onto the surface.">image texture</abbr>, a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object can hold a <abbr title="A texture made up of six images, one for each of the directions positive x, negative x, positive y, negative y, positive z, and negative z. The images are intended to include everything that can be seen from a given point. Cubemap textures are used for environment mapping and skyboxes.">cubemap texture</abbr>. And two <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> objects can be bound to the same <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> unit simultaneously, one holding an ordinary <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> and one holding a <abbr title="A texture made up of six images, one for each of the directions positive x, negative x, positive y, negative y, positive z, and negative z. The images are intended to include everything that can be seen from a given point. Cubemap textures are used for environment mapping and skyboxes.">cubemap texture</abbr>. The two textures are bound to different targets, <em>gl.TEXTURE_2D</em> and <em>gl.TEXTURE_CUBE_MAP</em>. A <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object, <em>texObj</em>, is bound to the cubemap target in the currently active <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> unit by calling</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">bindTexture</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP</span><span class="p">,</span><span class="w"> </span><span class="nx">texObj</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>A given <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object can be either a regular <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> or a <abbr title="A texture made up of six images, one for each of the directions positive x, negative x, positive y, negative y, positive z, and negative z. The images are intended to include everything that can be seen from a given point. Cubemap textures are used for environment mapping and skyboxes.">cubemap texture</abbr>, not both. Once it has been bound to one <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> target, it cannot be rebound to the other target.</p>
<p>A <abbr title="A texture made up of six images, one for each of the directions positive x, negative x, positive y, negative y, positive z, and negative z. The images are intended to include everything that can be seen from a given point. Cubemap textures are used for environment mapping and skyboxes.">cubemap texture</abbr> consists of six images, one for each face of the cube. A <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object that holds a <abbr title="A texture made up of six images, one for each of the directions positive x, negative x, positive y, negative y, positive z, and negative z. The images are intended to include everything that can be seen from a given point. Cubemap textures are used for environment mapping and skyboxes.">cubemap texture</abbr> has six image slots, identified by the constants</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_NEGATIVE_X</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_POSITIVE_X</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_NEGATIVE_Y</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_POSITIVE_Y</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_NEGATIVE_Z</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_POSITIVE_Z</span>
</code></pre></div>
<p>The constants are used as the targets in <em>gl.texImage2D</em> and <em>gl.copyTexImage2D</em>, in place of gl.TEXTURE_2D. (Note that there are six targets for loading images into a <abbr title="A texture made up of six images, one for each of the directions positive x, negative x, positive y, negative y, positive z, and negative z. The images are intended to include everything that can be seen from a given point. Cubemap textures are used for environment mapping and skyboxes.">cubemap texture</abbr> object, but only one target, <em>gl.TEXTURE_CUBE_MAP</em>, for binding the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object to a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> unit.) A <abbr title="A texture made up of six images, one for each of the directions positive x, negative x, positive y, negative y, positive z, and negative z. The images are intended to include everything that can be seen from a given point. Cubemap textures are used for environment mapping and skyboxes.">cubemap texture</abbr> is often stored as a set of six images, which must be loaded separately into a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object. Of course, it is also possible for <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> to create a cubemap by <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> the six images.</p>
<p>As usual for images on the web, there is the problem of asynchronous image loading to be dealt with. Here, for example, is a function that creates a <abbr title="A texture made up of six images, one for each of the directions positive x, negative x, positive y, negative y, positive z, and negative z. The images are intended to include everything that can be seen from a given point. Cubemap textures are used for environment mapping and skyboxes.">cubemap texture</abbr> in my sample program <a href="../../../en/source/webgl/cubemap-fisheye.html">webgl/cubemap-fisheye.html</a>:</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span><span class="w"> </span><span class="nx">loadCubemapTexture</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w">  </span><span class="nx">tex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createTexture</span><span class="p">();</span>
<span class="w">    </span><span class="kd">let</span><span class="w">  </span><span class="nx">imageCt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// Number of images that have finished loading.</span>

<span class="w">    </span><span class="nx">load</span><span class="p">(</span><span class="w"> </span><span class="s2">&quot;cubemap-textures/park/negx.jpg&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_NEGATIVE_X</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="nx">load</span><span class="p">(</span><span class="w"> </span><span class="s2">&quot;cubemap-textures/park/posx.jpg&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_POSITIVE_X</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="nx">load</span><span class="p">(</span><span class="w"> </span><span class="s2">&quot;cubemap-textures/park/negy.jpg&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_NEGATIVE_Y</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="nx">load</span><span class="p">(</span><span class="w"> </span><span class="s2">&quot;cubemap-textures/park/posy.jpg&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_POSITIVE_Y</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="nx">load</span><span class="p">(</span><span class="w"> </span><span class="s2">&quot;cubemap-textures/park/negz.jpg&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_NEGATIVE_Z</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="nx">load</span><span class="p">(</span><span class="w"> </span><span class="s2">&quot;cubemap-textures/park/posz.jpg&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_POSITIVE_Z</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="kd">function</span><span class="w"> </span><span class="nx">load</span><span class="p">(</span><span class="nx">url</span><span class="p">,</span><span class="w"> </span><span class="nx">target</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w">  </span><span class="nx">img</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">Image</span><span class="p">();</span>
<span class="w">        </span><span class="nx">img</span><span class="p">.</span><span class="nx">onload</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kd">function</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">gl</span><span class="p">.</span><span class="nx">bindTexture</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP</span><span class="p">,</span><span class="w"> </span><span class="nx">tex</span><span class="p">);</span>
<span class="w">            </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nx">gl</span><span class="p">.</span><span class="nx">texImage2D</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">UNSIGNED_BYTE</span><span class="p">,</span><span class="w"> </span><span class="nx">img</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="nx">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;headline&quot;</span><span class="p">).</span><span class="nx">innerHTML</span><span class="w"> </span><span class="o">=</span>
<span class="w">                </span><span class="s2">&quot;Can&#39;t access texture.  Note that some browsers&quot;</span><span class="w"> </span><span class="o">+</span>
<span class="w">                </span><span class="s2">&quot; can&#39;t use  a texture from a local file.&quot;</span><span class="p">;</span>
<span class="w">                </span><span class="k">return</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="nx">imageCt</span><span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">imageCt</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mf">6</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// all 6 images have been loaded</span>
<span class="w">                </span><span class="nx">gl</span><span class="p">.</span><span class="nx">generateMipmap</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;headline&quot;</span><span class="p">).</span><span class="nx">innerHTML</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>
<span class="w">                                    </span><span class="s2">&quot;Funny Cubemap (Fisheye Camera Effect)&quot;</span><span class="p">;</span>
<span class="w">                </span><span class="nx">textureObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">tex</span><span class="p">;</span>
<span class="w">                </span><span class="nx">draw</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">};</span>
<span class="w">        </span><span class="nx">img</span><span class="p">.</span><span class="nx">onerror</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kd">function</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;headline&quot;</span><span class="p">).</span><span class="nx">innerHTML</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>
<span class="w">                                            </span><span class="s2">&quot;SORRY, COULDN&#39;T LOAD TEXTURES&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="p">};</span>
<span class="w">        </span><span class="nx">img</span><span class="p">.</span><span class="nx">src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">url</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>The images for a cubemap must all be the same size. They must be square. The size should, as usual, be a power of two. For a <abbr title="A texture made up of six images, one for each of the directions positive x, negative x, positive y, negative y, positive z, and negative z. The images are intended to include everything that can be seen from a given point. Cubemap textures are used for environment mapping and skyboxes.">cubemap texture</abbr>, <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> parameters such as the <abbr title="An operation that is used when applying a texture to an object, when the texture has to be shrunk to fit the object. For an image texture, a minification filter is applied to compute the color of a pixel when that pixel covers several pixels in the image.">minification filter</abbr> are set using the target <em>gl.TEXTURE_CUBE_MAP</em>, and they apply to all six faces of the cube. For example,</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">texParameteri</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_MIN_FILTER</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">LINEAR</span><span class="p">);</span>
</code></pre></div>
<p>Similarly, <em>gl.generateMipmap</em> will generate <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr> for all six faces (so it should not be called until all six images have been loaded).</p>
<hr />
<p>In a <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program, a cube map <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> is represented by a <abbr title="Variables that represent input to a shader program in a programmable graphics pipeline. A uniform variable has the same value at every vertex and at every pixel of a primitive.">uniform variable</abbr> of type <em>samplerCube</em>. In <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 1.00, the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> is sampled using function <em>textureCube</em>. For example,</p>
<div class="highlight"><pre><span></span><code><span class="nx">vec4</span><span class="w"> </span><span class="nx">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">textureCube</span><span class="p">(</span><span class="w"> </span><span class="nx">u_texture</span><span class="p">,</span><span class="w"> </span><span class="nx">vector</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>The first parameter is the <em>samplerCube</em> variable that represents the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. The second parameter is a <em>vec3</em>. Cube map textures are not sampled using regular <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates. Instead, a 3D <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> is used. The goal is to pick out a point in the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. The <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> lies on the surface of a cube. To use a <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> to pick out a point in the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>, cast a ray from the center of the cube in the direction given by the <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr>, and check where that ray intersects the cube. That is, if you put the starting point of the <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> at the center of the cube, it points to the point on the cube where the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> is to be sampled.</p>
<p>Since we aren't doing 3D graphics in this chapter, we can't use cube maps in the ordinary way. The sample program <a href="../../../en/source/webgl/cubemap-fisheye.html">webgl/cubemap-fisheye.html</a> uses a cube map in an interesting, if not very useful way. The program uses 2D <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates. The <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> transforms a pair of 2D <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates into a 3D <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> that is then used to sample the <abbr title="A texture made up of six images, one for each of the directions positive x, negative x, positive y, negative y, positive z, and negative z. The images are intended to include everything that can be seen from a given point. Cubemap textures are used for environment mapping and skyboxes.">cubemap texture</abbr>. The effect is something like a photograph produced by a fisheye <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>. Here's what it looks like.</p>
<p><a class="glightbox" href="../../../en/c6/cubemap-fisheye.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c6/cubemap-fisheye.png" /></a></p>
<p>The picture on the left imitates a fisheye <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> with a 170-degree field of view. On the right the field of view is 330-degrees, so that <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr> near the edge of the disk actually show parts of the cube that lie behind the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>.</p>
<p>For each picture, the program draws a square with <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates ranging from 0.0 to 1.0. In the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr>, <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr> at a distance greater than 0.5 from the point (0.5,0.5) are colored white. Within the disk of radius 0.5, each circle around the center is mapped to a circle on the unit sphere. That point is then used as the direction <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> for <abbr title="The operation of mapping texture coordinates to colors from a texture, including using mipmaps if available and applying a minification or magnification filter if necessary.">sampling</abbr> the <abbr title="A texture made up of six images, one for each of the directions positive x, negative x, positive y, negative y, positive z, and negative z. The images are intended to include everything that can be seen from a given point. Cubemap textures are used for environment mapping and skyboxes.">cubemap texture</abbr>. The point in the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> that appears at the center of the disk is the point where the cube intersects the positive z-axis, that is, the center of the "positive z" image from the cube map. You don't actually need to understand this, but here, for your information, is the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> that does the work:</p>
<div class="highlight"><pre><span></span><code><span class="cp">#ifdef GL_FRAGMENT_PRECISION_HIGH</span>
<span class="w">    </span><span class="n">precision</span><span class="w"> </span><span class="n">highp</span><span class="w"> </span><span class="kt">float</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="w">    </span><span class="n">precision</span><span class="w"> </span><span class="n">mediump</span><span class="w"> </span><span class="kt">float</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="n">uniform</span><span class="w"> </span><span class="n">samplerCube</span><span class="w"> </span><span class="n">u_texture</span><span class="p">;</span><span class="w">  </span>
<span class="n">uniform</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">u_angle</span><span class="p">;</span><span class="w">  </span><span class="c1">// field of view angle</span>
<span class="n">varying</span><span class="w"> </span><span class="n">vec2</span><span class="w"> </span><span class="n">v_texCoords</span><span class="p">;</span><span class="w">  </span>
<span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="kt">float</span><span class="w"> </span><span class="n">dist</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">distance</span><span class="p">(</span><span class="w"> </span><span class="n">v_texCoords</span><span class="p">,</span><span class="w"> </span><span class="n">vec2</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dist</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.5</span><span class="p">)</span>
<span class="w">    </span><span class="n">gl_FragColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec4</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span><span class="w">  </span><span class="c1">// white</span>
<span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">;</span><span class="w"> </span><span class="c1">// coords relative to a center at (0.5,0.5)</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v_texCoords</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">0.5</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v_texCoords</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">0.5</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec2</span><span class="w"> </span><span class="n">circ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">vec2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">));</span><span class="w">  </span><span class="c1">// on the unit circle</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">phi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">radians</span><span class="p">(</span><span class="n">u_angle</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">dist</span><span class="p">);</span><span class="w">  </span><span class="c1">// &quot;latitude&quot;</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">circ</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">circ</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">));</span>
<span class="w">    </span><span class="n">gl_FragColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">textureCube</span><span class="p">(</span><span class="w"> </span><span class="n">u_texture</span><span class="p">,</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="p">);</span><span class="w">  </span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span>
<span class="p">}</span>
</code></pre></div>
</div>
</div>
</div>
<h2 id="645-计算示例">6.4.5 计算示例<a class="headerlink" href="#645-计算示例" title="Permanent link">&para;</a></h2>
<p><strong>A Computational Example</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="6:2"><input checked="checked" id="__tabbed_6_1" name="__tabbed_6" type="radio" /><input id="__tabbed_6_2" name="__tabbed_6" type="radio" /><div class="tabbed-labels"><label for="__tabbed_6_1">中文</label><label for="__tabbed_6_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>GPU可以提供巨大的处理能力。虽然GPU最初是设计用来渲染图像的，但人们很快意识到，同样的能力可以用来进行更通用的编程。并非每个编程任务都能利用典型GPU的高度并行架构，但如果一个任务可以分解为许多可以并行运行的子任务，那么通过将其适应在GPU上运行，就可能显著加速任务。现代GPU已经变得更加计算多样化，但在仅设计用于处理颜色的GPU中，这可能意味着以颜色值的方式表示计算的数据。通常的技巧是将数据表示为纹理中的颜色，并使用纹理查找函数访问数据。</p>
<p>示例程序<a href="../../../en/source/webgl/webgl-game-of-life.html">webgl/webgl-game-of-life.html</a>是这种方法的一个简单示例。该程序实现了约翰·康威（John Conway）著名的<a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">生命游戏</a>（这并不是一个游戏）。生命游戏板由一个可以是活细胞或死细胞的单元格网格组成。有一套规则，根据棋盘的当前状态或“一代”，产生新的一代。一旦为每个单元格分配了一些初始状态，游戏就可以自行进行，根据规则产生一代又一代。规则根据当前一代的细胞及其八个邻近细胞的状态计算下一代的细胞状态。要应用规则，您必须查看每个邻近细胞并计算活细胞邻居的数量。相同的过程适用于每个细胞，因此它是一个非常易于并行化的任务，可以轻松适应在GPU上运行。</p>
<p>在示例程序中，生命游戏板是一个1024x1024的画布，每个像素代表一个单元格。活细胞被涂成白色，死细胞是黑色的。该程序使用WebGL根据当前棋盘计算棋盘的下一代。工作是在片段着色器中完成的。要触发计算，绘制一个覆盖整个画布的正方形，这会导致片段着色器被调用画布上的每个像素。片段着色器需要访问片段及其八个邻居的当前颜色，但它无法直接查询这些颜色。为了给着色器提供这些信息，程序使用函数<em>gl.copyTexImage2D()</em>将棋盘复制到纹理对象中。然后，片段着色器可以使用GLSL纹理查找函数<em>texture2D()</em>获取所需的信息。</p>
<p>有趣的一点是，片段着色器不仅需要自身的纹理坐标，还需要其邻居的纹理坐标。片段本身的纹理坐标作为变化变量传递到片段着色器，每个坐标的值范围为0到1。它可以通过在其自身的纹理坐标上添加偏移量来获取邻居的纹理坐标。由于纹理是1024x1024像素，因此邻居的纹理坐标需要偏移1.0/1024.0。以下是完整的GLSL ES 1.00片段着色器程序：</p>
<div class="highlight"><pre><span></span><code><span class="cp">#ifdef GL_FRAGMENT_PRECISION_HIGH</span>
<span class="w">    </span><span class="n">precision</span><span class="w"> </span><span class="n">highp</span><span class="w"> </span><span class="kt">float</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="w">    </span><span class="n">precision</span><span class="w"> </span><span class="n">mediump</span><span class="w"> </span><span class="kt">float</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="n">varying</span><span class="w"> </span><span class="n">vec2</span><span class="w"> </span><span class="n">v_coords</span><span class="p">;</span><span class="w">     </span><span class="c1">// 此单元格的纹理坐标</span>
<span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">scale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="o">/</span><span class="mf">1024.0</span><span class="p">;</span><span class="w">  </span><span class="c1">// 1.0/画布大小；（在纹理坐标中</span>
<span class="w">                                </span><span class="c1">//   邻近单元格之间的偏移）</span>
<span class="n">uniform</span><span class="w"> </span><span class="n">sampler2D</span><span class="w"> </span><span class="n">source</span><span class="p">;</span><span class="w">  </span><span class="c1">// 持有前一代的纹理</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">alive</span><span class="p">;</span><span class="w">  </span><span class="c1">// 这个单元格是活的吗？</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">texture2D</span><span class="p">(</span><span class="n">source</span><span class="p">,</span><span class="n">v_coords</span><span class="p">).</span><span class="n">r</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">        </span><span class="n">alive</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="n">alive</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 计算活邻居的数量。要检查是否活着，只需测试</span>
<span class="w">    </span><span class="c1">// 颜色的红色分量，这将是一个活细胞的1.0和一个</span>
<span class="w">    </span><span class="c1">// 死细胞的0.0。</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">neighbors</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// 将是一个活邻居的数量</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">texture2D</span><span class="p">(</span><span class="n">source</span><span class="p">,</span><span class="n">v_coords</span><span class="o">+</span><span class="n">vec2</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span><span class="n">scale</span><span class="p">)).</span><span class="n">r</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">        </span><span class="n">neighbors</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">texture2D</span><span class="p">(</span><span class="n">source</span><span class="p">,</span><span class="n">v_coords</span><span class="o">+</span><span class="n">vec2</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span><span class="mi">0</span><span class="p">)).</span><span class="n">r</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">        </span><span class="n">neighbors</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">texture2D</span><span class="p">(</span><span class="n">source</span><span class="p">,</span><span class="n">v_coords</span><span class="o">+</span><span class="n">vec2</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span><span class="o">-</span><span class="n">scale</span><span class="p">)).</span><span class="n">r</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">        </span><span class="n">neighbors</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">texture2D</span><span class="p">(</span><span class="n">source</span><span class="p">,</span><span class="n">v_coords</span><span class="o">+</span><span class="n">vec2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">scale</span><span class="p">)).</span><span class="n">r</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">        </span><span class="n">neighbors</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">texture2D</span><span class="p">(</span><span class="n">source</span><span class="p">,</span><span class="n">v_coords</span><span class="o">+</span><span class="n">vec2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="n">scale</span><span class="p">)).</span><span class="n">r</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">        </span><span class="n">neighbors</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">texture2D</span><span class="p">(</span><span class="n">source</span><span class="p">,</span><span class="n">v_coords</span><span class="o">+</span><span class="n">vec2</span><span class="p">(</span><span class="o">-</span><span class="n">scale</span><span class="p">,</span><span class="n">scale</span><span class="p">)).</span><span class="n">r</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">        </span><span class="n">neighbors</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">texture2D</span><span class="p">(</span><span class="n">source</span><span class="p">,</span><span class="n">v_coords</span><span class="o">+</span><span class="n">vec2</span><span class="p">(</span><span class="o">-</span><span class="n">scale</span><span class="p">,</span><span class="mi">0</span><span class="p">)).</span><span class="n">r</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">        </span><span class="n">neighbors</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">texture2D</span><span class="p">(</span><span class="n">source</span><span class="p">,</span><span class="n">v_coords</span><span class="o">+</span><span class="n">vec2</span><span class="p">(</span><span class="o">-</span><span class="n">scale</span><span class="p">,</span><span class="o">-</span><span class="n">scale</span><span class="p">)).</span><span class="n">r</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">        </span><span class="n">neighbors</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 使用生命规则输出此单元格的新颜色。</span>

<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"> </span><span class="c1">// 死细胞的颜色</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">alive</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">neighbors</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">neighbors</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>
<span class="w">            </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span><span class="w"> </span><span class="c1">// 活细胞的颜色；细胞保持活力</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">neighbors</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span><span class="w"> </span><span class="c1">// 活细胞的颜色；细胞复活</span>

<span class="w">    </span><span class="n">gl_FragColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec4</span><span class="p">(</span><span class="n">color</span><span class="p">,</span><span class="w"> </span><span class="n">color</span><span class="p">,</span><span class="w"> </span><span class="n">color</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>程序中还有一些其他有趣的点。在创建WebGL图形上下文时，会关闭反锯齿以确保每个像素完全是黑色或白色。反锯齿可能会通过平均附近像素的颜色来模糊颜色。类似地，纹理的放大和缩小滤波器被设置为<em>gl.NEAREST</em>以避免颜色平均。还有在棋盘上设置初始配置的问题——这是通过使用具有不同片段着色器的另一个着色器程序在棋盘上绘制来完成的。</p>
<p>在我的电脑上，<a href="../../../en/source/webgl/webgl-game-of-life.html">webgl/webgl-game-of-life.html</a>可以轻松地每秒计算360代。我强烈建议您尝试一下。观看它可以很有趣。</p>
<p>GPU上的通用编程变得越来越重要。现代GPU可以执行与颜色无关的计算，使用各种数值数据类型。正如我们将看到的，<abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0已经朝这个方向迈进了一点，但从Web访问GPU的全部计算能力将需要一个新的API。目前正在开发中的<strong><abbr title="A new JavaScript graphics API, similar to WebGL, but designed to let web programs access modern GPU capabilities such as compute shaders.">WebGPU</abbr></strong>，已经在一些网络浏览器中作为实验性功能提供，是满足这一需求的尝试。（然而，与WebGL不同，它不基于OpenGL。）</p>
</div>
<div class="tabbed-block">
<p>A <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> can offer an immense amount of processing power. Although GPUs were originally designed to apply that power to <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> images, it was quickly realized that the same power could be harnessed to do much more general types of programming. Not every programming task can take advantage of the highly parallel architecture of the typical <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>, but if a task can be broken down into many subtasks that can be run in parallel, then it might be possible to speed up the task significantly by adapting it to run on a <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>. Modern GPUs have become much more computationally versatile, but in GPUs that were designed to work only with colors, that might mean somehow representing the data for a computation as color values. The trick often involves representing the data as colors in a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>, and accessing the data using <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> lookup functions.</p>
<p>The sample program <a href="../../../en/source/webgl/webgl-game-of-life.html">webgl/webgl-game-of-life.html</a> is a simple example of this approach. The program implements John Conway's well-known <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Game of Life</a> (which is not really a game). A Life board consists of a grid of cells that can be either alive or dead. There is a set of rules that takes the current state, or "generation," of the board and produces a new generation. Once some initial state has been assigned to each cell, the game can play itself, producing generation after generation, according to the rules. The rules compute the state of a cell in the next generation from the states of the cell and its eight neighboring cells in the current generation. To apply the rules, you have to look at each neighboring cell and count the number of neighbors that are alive. The same process is applied to every cell, so it is a highly parallelizable task that can be easily adapted to run on a <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>.</p>
<p>In the sample program, the Life board is a 1024-by-1024 canvas, with each <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> representing a cell. Living cells are colored white, and dead cells are black. The program uses <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> to compute the next generation of the board from the current board. The work is done in a <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr>. To trigger the computation, a single square is drawn that covers the entire canvas, which causes the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> to be called for every <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> in the canvas. The <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> needs access to the current color of the fragment and of its eight neighbors, but it has no way to query those colors directly. To give the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> access to that information, the program copies the board into a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object, using the function <em>gl.copyTexImage2D()</em>. The <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> can then get the information that it needs using the <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> lookup function <em>texture2D()</em>.</p>
<p>An interesting point is that the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> needs the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates not just for itself but for its neighbors. The <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates for the fragment itself are passed into the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> as a <abbr title="A variable that is used to communicate values from the vertex shader to the fragment shader in the WebGL or OpenGL ES 2.0 graphics pipeline. A varying variable is assigned a value in the vertex shader. The value of the variable in the fragment shader for a pixel in the primitive is obtained by interpolating the values from the vertices of the primitive. (In newer versions of GLSL, which support additional shader stages, the term &quot;varying variable&quot; is replaced by the more general terms &quot;in variable&quot; and &quot;out variable,&quot; which refer to variables that are used for input to or output from a shader.)">varying variable</abbr>, with values in the range 0 to 1 for each coordinate. It can get the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates for a neighbor by adding an offset to its own <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates. Since the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> is 1024-by-1024 <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr>, the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates for a neighbor need to be offset by 1.0/1024.0. Here is the complete <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 1.00 <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> program:</p>
<div class="highlight"><pre><span></span><code><span class="cp">#ifdef GL_FRAGMENT_PRECISION_HIGH</span>
<span class="n">precision</span><span class="w"> </span><span class="n">highp</span><span class="w"> </span><span class="kt">float</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="n">precision</span><span class="w"> </span><span class="n">mediump</span><span class="w"> </span><span class="kt">float</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="n">varying</span><span class="w"> </span><span class="n">vec2</span><span class="w"> </span><span class="n">v_coords</span><span class="p">;</span><span class="w">     </span><span class="c1">// texture coordinates for this cell</span>
<span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">scale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="o">/</span><span class="mf">1024.0</span><span class="p">;</span><span class="w">  </span><span class="c1">// 1.0 / canvas_size; (offset between </span>
<span class="w">                                </span><span class="c1">//   neighboring cells, in texture coords)</span>
<span class="n">uniform</span><span class="w"> </span><span class="n">sampler2D</span><span class="w"> </span><span class="n">source</span><span class="p">;</span><span class="w">  </span><span class="c1">// the texture holding the previous generation</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">alive</span><span class="p">;</span><span class="w">  </span><span class="c1">// is this cell alive ?</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">texture2D</span><span class="p">(</span><span class="n">source</span><span class="p">,</span><span class="n">v_coords</span><span class="p">).</span><span class="n">r</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">    </span><span class="n">alive</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="n">alive</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Count the living neighbors.  To check for living, just test</span>
<span class="w">    </span><span class="c1">// the red component of the color, which will be 1.0 for a</span>
<span class="w">    </span><span class="c1">// living cell and 0.0. for a dead cell.</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">neighbors</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// will be the number of neighbors that are alive</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">texture2D</span><span class="p">(</span><span class="n">source</span><span class="p">,</span><span class="n">v_coords</span><span class="o">+</span><span class="n">vec2</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span><span class="n">scale</span><span class="p">)).</span><span class="n">r</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">    </span><span class="n">neighbors</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">texture2D</span><span class="p">(</span><span class="n">source</span><span class="p">,</span><span class="n">v_coords</span><span class="o">+</span><span class="n">vec2</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span><span class="mi">0</span><span class="p">)).</span><span class="n">r</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">    </span><span class="n">neighbors</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">texture2D</span><span class="p">(</span><span class="n">source</span><span class="p">,</span><span class="n">v_coords</span><span class="o">+</span><span class="n">vec2</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span><span class="o">-</span><span class="n">scale</span><span class="p">)).</span><span class="n">r</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">    </span><span class="n">neighbors</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">texture2D</span><span class="p">(</span><span class="n">source</span><span class="p">,</span><span class="n">v_coords</span><span class="o">+</span><span class="n">vec2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">scale</span><span class="p">)).</span><span class="n">r</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">    </span><span class="n">neighbors</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">texture2D</span><span class="p">(</span><span class="n">source</span><span class="p">,</span><span class="n">v_coords</span><span class="o">+</span><span class="n">vec2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="n">scale</span><span class="p">)).</span><span class="n">r</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">    </span><span class="n">neighbors</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">texture2D</span><span class="p">(</span><span class="n">source</span><span class="p">,</span><span class="n">v_coords</span><span class="o">+</span><span class="n">vec2</span><span class="p">(</span><span class="o">-</span><span class="n">scale</span><span class="p">,</span><span class="n">scale</span><span class="p">)).</span><span class="n">r</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">    </span><span class="n">neighbors</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">texture2D</span><span class="p">(</span><span class="n">source</span><span class="p">,</span><span class="n">v_coords</span><span class="o">+</span><span class="n">vec2</span><span class="p">(</span><span class="o">-</span><span class="n">scale</span><span class="p">,</span><span class="mi">0</span><span class="p">)).</span><span class="n">r</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">    </span><span class="n">neighbors</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">texture2D</span><span class="p">(</span><span class="n">source</span><span class="p">,</span><span class="n">v_coords</span><span class="o">+</span><span class="n">vec2</span><span class="p">(</span><span class="o">-</span><span class="n">scale</span><span class="p">,</span><span class="o">-</span><span class="n">scale</span><span class="p">)).</span><span class="n">r</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">    </span><span class="n">neighbors</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Output the new color for this cell. using the rules of Life.</span>

<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"> </span><span class="c1">// color for dead cell</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">alive</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">neighbors</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">neighbors</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>
<span class="w">        </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span><span class="w"> </span><span class="c1">// color for living cell; cell stays alive</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">neighbors</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span><span class="w"> </span><span class="c1">// color for living cell; cell comes to life</span>

<span class="w">    </span><span class="n">gl_FragColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec4</span><span class="p">(</span><span class="n">color</span><span class="p">,</span><span class="w"> </span><span class="n">color</span><span class="p">,</span><span class="w"> </span><span class="n">color</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>There are some other points of interest in the program. When the <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> graphics context is created, anti-aliasing is turned off to make sure that every <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> is either perfectly black or perfectly white. <abbr title="A technique used to reduce the jagged or &quot;staircase&quot; appearance of diagonal lines, text, and other shapes that are drawn using pixels. When a pixel is only partly covered by a geometric shape, then the color of the pixel is a blend of the color of the shape and the color of the background, with the degree of blending depending on the fraction of the pixel that is covered by the geometric shape.">Antialiasing</abbr> could smear out the colors by averaging the colors of nearby <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr>. Similarly, the magnification and minification filters for the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> are set to <em>gl.NEAREST</em> to avoid averaging of colors. Also, there is the issue of setting the initial configuration onto the board—that's done by drawing onto the board using another <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program with a different <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr>.</p>
<p>On my computer, the <a href="../../../en/source/webgl/webgl-game-of-life.html">webgl/webgl-game-of-life.html</a> can easily compute 360 generations per second. I urge you to try it. It can be fun to watch.</p>
<p>General purpose programming on GPUs has become more and more important. Modern GPUs can do computations that have nothing to do with color, using various numerical data types. <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0, as we'll see, has moved a bit in that direction, but accessing the full computational power of GPUs from the Web will require a new <abbr title="Application Programming Interface. A collection of related classes, functions, constants, etc., for performing some task. An API is an &quot;interface&quot; in the sense that it can be used without understanding how its functionality is actually implemented.">API</abbr>. <strong><abbr title="A new JavaScript graphics API, similar to WebGL, but designed to let web programs access modern GPU capabilities such as compute shaders.">WebGPU</abbr></strong>, currently under development and already available as an experimental feature in some web browsers, is an attempt to fulfill that need. (However, unlike <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>, it is not based on <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr>.)</p>
</div>
</div>
</div>
<h2 id="646-webgl-20-中的纹理">6.4.6 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 中的纹理<a class="headerlink" href="#646-webgl-20-中的纹理" title="Permanent link">&para;</a></h2>
<p><strong>Textures in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="7:2"><input checked="checked" id="__tabbed_7_1" name="__tabbed_7" type="radio" /><input id="__tabbed_7_2" name="__tabbed_7" type="radio" /><div class="tabbed-labels"><label for="__tabbed_7_1">中文</label><label for="__tabbed_7_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p><abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0中的一个重大变化是大大增加了对纹理的支持。增加了许多新的纹理格式。在OpenGL中，RGBA颜色分量被表示为介于零和一之间的浮点值，但实际上通常被存储为一个字节的无符号整数，值范围在0到255之间，这与大多数屏幕上显示颜色的格式相匹配。事实上，您无法真正控制用于显示的颜色的内部表示方式。有些计算机显示器每个像素只用16位而不是32位，而新的HDR（高动态范围）显示器每个像素可以使用更多的位。但是，在存储纹理数据时，并不真正需要与物理显示上使用的颜色格式相匹配。</p>
<p><abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0引入了大量所谓的“有大小”的纹理格式，这使程序员能够控制纹理中数据的表示方式。例如，如果格式是gl.RGBA32F，则纹理包含每个像素的四个32位浮点数，每个RGBA颜色分量一个。格式gl.R32UI表示每个像素一个32位无符号整数。而gl.RG8I意味着每个像素两个8位整数。gl.RGBA8对应于通常的格式，每个颜色分量使用一个8位无符号整数。这些大小格式用于纹理的内部格式，在调用gl.texImage2D()等函数时作为internalFormat参数，指定数据在纹理中的实际存储方式。您可以将具有大小内部格式的纹理用作图像纹理进行渲染。但是，对于颜色分量来说，32位编码了比视觉上能区分的还要多的颜色。这些数据格式特别适用于计算应用程序，您真正需要控制您正在处理的数据类型。但是，要有效地计算存储在纹理中的数据，我们确实需要能够将数据写入纹理，以及从纹理中读取数据。而这，我们需要帧缓冲区，直到<a href="../../c7/s4/">第7.4节</a>才会介绍。现在，我们只看看WebGL 2.0 API用于处理纹理的一些方面。</p>
<p>可以使用各种版本的texImage2D()函数从图像或数据数组初始化纹理，或者在没有提供数据源时将其初始化为零。<abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0还有另一个可能更高效的函数来为纹理分配存储空间并将其初始化为零：</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">texStorage2D</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span><span class="w"> </span><span class="nx">levels</span><span class="p">,</span><span class="w"> </span><span class="nx">internalFormat</span><span class="p">,</span><span class="w"> </span><span class="nx">width</span><span class="p">,</span><span class="w"> </span><span class="nx">height</span><span class="p">);</span>
</code></pre></div>
<p>第一个参数是gl.TEXTURE_2D或gl.TEXTURE_CUBE_MAP。第二个参数指定应生成的mipmap级别数量；通常，这将是1。width和height给出纹理的大小，当然，internalFormat指定纹理的数据格式。internalFormat必须是大小内部格式之一，如gl.RGBA8。</p>
<p><abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0支持3D纹理，它们保存3D网格的texels数据，有函数gl.texImage3D()和gl.texStorage3D()。它有深度纹理，存储像深度测试中使用的深度值，通常用于阴影映射。它可以处理压缩纹理，这可以减少CPU和GPU之间需要传输的数据量。但是，如果您需要这些功能，我将让您自己探索。</p>
<p>着色器程序使用采样器变量从纹理中读取数据。着色器编程语言GLSL ES 3.00引入了许多新的采样器类型来处理WebGL 2.0中的新纹理格式。<abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 1.00只有<strong><em>sampler2D</em></strong>和<strong><em>samplerCube</em></strong>，新语言增加了类型，如用于3D纹理的<strong><em>sampler3D</em></strong>，用于采样值为有符号整数的纹理的<strong><em>isampler2D</em></strong>，以及用于采样深度纹理的<strong><em>sampler2DShadow</em></strong>。例如，对于采样具有32位整数格式的纹理，您可能会声明一个采样器变量，如下所示：</p>
<div class="highlight"><pre><span></span><code><span class="nx">uniform</span><span class="w"> </span><span class="nx">highp</span><span class="w"> </span><span class="nx">isampler2D</span><span class="w"> </span><span class="nx">datatexture</span><span class="p">;</span>
</code></pre></div>
<p>由于isampler2D变量没有默认精度，因此必须指定精度限定符<em>highp</em>。使用高精度确保您可以精确地读取32位整数。（sampler2D类型具有默认精度lowp，当颜色分量确实是8位整数时足够，但可能不是您想要的浮点数据纹理。）</p>
<p><abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 1.00使用函数<em>texture2D()</em>对2D纹理进行采样，使用<em>textureCube()</em>对立方体贴图进行采样。而不是为每种采样器类型都有单独的函数，<abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 3.00去除了<em>texture2D</em>和<em>textureCube</em>，并用一个重载函数<em><abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>()</em>替换它们，该函数可用于采样任何类型的纹理。所以，上面定义的<em>datatexture</em>可能使用以下方式进行采样：</p>
<div class="highlight"><pre><span></span><code><span class="nx">highp</span><span class="w"> </span><span class="nx">ivec4</span><span class="w"> </span><span class="nx">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">texture</span><span class="p">(</span><span class="nx">datatexture</span><span class="p">,</span><span class="w"> </span><span class="nx">coords</span><span class="p">);</span>
</code></pre></div>
<p>其中coords是一个包含纹理坐标的<strong><em>vec2</em></strong>。但实际上，您可能想要更直接地访问texel值。有一个新的<em>texelFetch()</em>函数，它从纹理中提取texel值，将纹理视为texel数组。使用从0到纹理大小的整数值来访问texels。应用于<em>datatexture</em>，这可能看起来像：</p>
<div class="highlight"><pre><span></span><code><span class="nx">highp</span><span class="w"> </span><span class="nx">ivec4</span><span class="w"> </span><span class="nx">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">texelFetch</span><span class="p">(</span><span class="nx">datatexture</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">ivec2</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">));</span>
</code></pre></div>
<p>其中i的范围是0到纹理宽度减一，j的范围是0到高度减一。这里的第二个参数0，指定了正在访问的mipmap级别。（对于整数纹理，您可能不会使用mipmap。）</p>
<p>（示例程序<a href="../../../en/source/webgl/texelFetch-MonaLisa-webgl2.html">webgl/texelFetch-MonaLisa-webgl2.html</a>是使用<em>texelFetch()</em>的一个相当奇特的例子，尽管它使用的是普通图像纹理而不是数据纹理。）</p>
<p>关于WebGL 2.0纹理还有更多可以讨论的内容，但这将使我们远远超出这本入门教科书所需的范围。</p>
</div>
<div class="tabbed-block">
<p>One of the major changes in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 is greatly increased support for textures. A large number of new <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> formats have been added. <abbr title="An RGB color—specified by red, green, and blue component values—together with an alpha component. The alpha component is most often take to specify the degree of transparency of the color, with a maximal alpha value giving a fully opaque color.">RGBA color</abbr> components in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> are represented as floating point values in the range zero to one, but in practice are often stored as one-byte unsigned integers, with values in the range 0 to 255, which matches the format that is used for displaying colors on most screens. In fact, you don't really have control over how colors are represented internally for use on displays. There have been computer displays that used only 16 bits per <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> instead of 32, and new HDR (High Dynamic Range) displays can use even more bits per <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>. But when storing data in a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>, it's not really necessary to match the color format that is used on a physical display.</p>
<p><abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 introduced a large number of so-called "sized" <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> formats, which give the programmer control over how the data in the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> is represented. For example, if the format is <em>gl.RGBA32F</em>, then the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> contains four 32-bit floating point numbers for each <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>, one for each of the four <abbr title="An RGB color—specified by red, green, and blue component values—together with an alpha component. The alpha component is most often take to specify the degree of transparency of the color, with a maximal alpha value giving a fully opaque color.">RGBA color</abbr> components. The format <em>gl.R32UI</em> indicates one 32-bit unsigned integer per <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>. And <em>gl.RG8I</em> means two 8-bit integers per <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>. And <em>gl.RGBA8</em> corresponds to the usual format, using one 8-bit unsigned integer for each <abbr title="One of the numbers used in a color model to specify a color. For example, in the RGB color model, a color is specified by three color components representing the amounts of red, green, and blue in the color.">color component</abbr>. These sized formats are used for the internal format of a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>, the internalFormat parameter in a call to a function like <em>gl.texImage2D()</em>, which specifies how the data is actually stored in the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. You can use textures with sized internal formats as image textures for <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr>. But 32 bits for a <abbr title="One of the numbers used in a color model to specify a color. For example, in the RGB color model, a color is specified by three color components representing the amounts of red, green, and blue in the color.">color component</abbr> encodes far more different colors than could ever be distinguished visually. These data formats are particularly useful for computational applications, where you really need to control what kind of data you are working with. But to effectively compute with data stored in textures, we really need to be able to write data to textures, as well as read from textures. And for that, we need framebuffers, which won't be covered until <a href="../../c7/s4/">Section 7.4</a>. For now, we will just look at a few aspects of the <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 <abbr title="Application Programming Interface. A collection of related classes, functions, constants, etc., for performing some task. An API is an &quot;interface&quot; in the sense that it can be used without understanding how its functionality is actually implemented.">API</abbr> for working with textures.</p>
<p>Various versions of the <em>texImage2D()</em> function can be used to initialize a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> from an image or from an array of data—or to zero, when no data source is provided. <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 has another, potentially more efficient, function for allocating the storage for a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> and initializing it to zero:</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">texStorage2D</span><span class="p">(</span><span class="w"> </span><span class="nx">target</span><span class="p">,</span><span class="w"> </span><span class="nx">levels</span><span class="p">,</span><span class="w"> </span><span class="nx">internalFormat</span><span class="p">,</span><span class="w"> </span><span class="nx">width</span><span class="p">,</span><span class="w"> </span><span class="nx">height</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>The first parameter is <em>gl.TEXTURE_2D</em> or <em>gl.TEXTURE_CUBE_MAP</em>. The second parameter specifies the number of <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmap</abbr> level that should be generated; generally, this will be 1. The <em>width</em> and <em>height</em> give the size of the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>, and of course the <em>internalFormat</em> specifies the data format for the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. The <em>internalFormat</em> must be one of the sized internal formats, such as <em>gl.RGBA8</em>.</p>
<p><abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 has support for 3D textures, which hold data for a 3D grid of texels, with functions <em>gl.texImage3D()</em> and <em>gl.texStorage3D()</em>. It has depth textures, which store depth values like those used in the <abbr title="A solution to the hidden surface problem that involves keeping track of the depth, or distance from the viewer, of the object currently visible at each pixel in the image. When a new object is drawn at a pixel, the depth of the new object is compared to the depth of the current object to decide which one is closer to the viewer. The advantage of the depth test is that objects can be rendered in any order. A disadvantage is that only a limited range of depths can be represented in the image.">depth test</abbr> and are commonly used for <abbr title="A technique for determining which parts of a scene are illuminated and which are in shadow from a given light source. The technique involves rendering the scene from the point of the view of the light source, but uses only the depth buffer from that rendering. The depth buffer is the &quot;shadow map.&quot; Along a given direction from the light source, the object that is illuminated by the light is the one that is closest to the light. The distance to that object is essentially encoded in the depth buffer. Objects at greater distance are in shadow.">shadow mapping</abbr>. And it can work with compressed textures, which can decrease the amount of data that needs to be transferred between the <abbr title="The Central Processing Unit in a computer, the component that actually executes programs. The CPU reads machine language instructions from the computer's memory and carries them out.">CPU</abbr> and the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>. However, I will leave you to explore these capabilities on your own if you need them.</p>
<p>Shader programs use sampler variables to read data from textures. The <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> programming language <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 3.00 introduces a number of new sampler types to deal with the new <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> formats in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0. Where <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 1.00 had only <strong><em>sampler2D</em></strong> and <strong><em>samplerCube</em></strong>, the newer language adds types such as <strong><em>sampler3D</em></strong> for 3D textures, <strong><em>isampler2D</em></strong> for <abbr title="The operation of mapping texture coordinates to colors from a texture, including using mipmaps if available and applying a minification or magnification filter if necessary.">sampling</abbr> textures whose values are signed integers, and <strong><em>sampler2DShadow</em></strong> for <abbr title="The operation of mapping texture coordinates to colors from a texture, including using mipmaps if available and applying a minification or magnification filter if necessary.">sampling</abbr> depth textures. For example, for <abbr title="The operation of mapping texture coordinates to colors from a texture, including using mipmaps if available and applying a minification or magnification filter if necessary.">sampling</abbr> a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> with a 32-bit integer format, you might declare a <abbr title="In GLSL, a variable in a shader program that can be used to do lookup in an image texture. The value of a sampler variable specifies the texture unit that will be used to do the lookup. In WebGL, sampler variables are of type &quot;sampler2D&quot; or &quot;samplerCube.&quot;">sampler variable</abbr> such as</p>
<div class="highlight"><pre><span></span><code><span class="nx">uniform</span><span class="w"> </span><span class="nx">highp</span><span class="w"> </span><span class="nx">isampler2D</span><span class="w"> </span><span class="nx">datatexture</span><span class="p">;</span>
</code></pre></div>
<p>The <abbr title="In GLSL, one of the following modifiers on a numeric variable declaration: lowp, mediump, or highp. A precision modifier specifies the minimum number of bits or range of values for the variable.">precision qualifier</abbr>, <em>highp</em>, must be specified because <em>isampler2D</em> variables do not have a default precision. Using high precision ensures that you can read 32-bit integers exactly. (The <em>sampler2D</em> type has default precision lowp, which is sufficient when color components are really 8-bit integers but which might not be what you want for floating point data textures.)</p>
<p><abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 1.00 uses the function <em>texture2D()</em> to sample a 2D <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> and <em>textureCube()</em> for <abbr title="The operation of mapping texture coordinates to colors from a texture, including using mipmaps if available and applying a minification or magnification filter if necessary.">sampling</abbr> a <abbr title="A texture made up of six images, one for each of the directions positive x, negative x, positive y, negative y, positive z, and negative z. The images are intended to include everything that can be seen from a given point. Cubemap textures are used for environment mapping and skyboxes.">cubemap texture</abbr>. Rather than have a separate function for each sampler type, <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 3.00 removes <em>texture2D</em> and <em>textureCube</em> and replaces them with a single overloaded function <em><abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>()</em>, which can be used to sample any kind of <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. So, the <em>datatexture</em> defined above might be sampled using</p>
<div class="highlight"><pre><span></span><code><span class="nx">highp</span><span class="w"> </span><span class="nx">ivec4</span><span class="w"> </span><span class="nx">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">texture</span><span class="p">(</span><span class="w"> </span><span class="nx">datatexture</span><span class="p">,</span><span class="w"> </span><span class="nx">coords</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>where <em>coords</em> is a <strong><em>vec2</em></strong> holding the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates. But in fact, you might want to access <abbr title="A pixel in a texture image.">texel</abbr> values more directly. There is a new <em>texelFetch()</em> function that fetches <abbr title="A pixel in a texture image.">texel</abbr> values from a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>, treating the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> as an array of texels. Texels are accessed using integer coordinates that range from 0 up to the size of the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. Applied to <em>datatexture</em>, this could look like</p>
<div class="highlight"><pre><span></span><code><span class="nx">highp</span><span class="w"> </span><span class="nx">ivec4</span><span class="w"> </span><span class="nx">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">texelFetch</span><span class="p">(</span><span class="w"> </span><span class="nx">datatexture</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">ivec2</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>where <em>i</em> ranges from 0 to the width of the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> minus one, and j ranges from 0 to the height minus one. The second parameter, 0 here, specifies the <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmap</abbr> level that is being accessed. (For integer textures, you are not likely to be using <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr>.)</p>
<p>(The sample program <a href="../../../en/source/webgl/texelFetch-MonaLisa-webgl2.html">webgl/texelFetch-MonaLisa-webgl2.html</a> is a rather fanciful example of using <em>texelFetch()</em>, though with an ordinary <abbr title="An image that is applied to a surface as a texture, so that it looks at if the image is &quot;painted&quot; onto the surface.">image texture</abbr> rather than a data <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>.)</p>
<p>There is a lot more that could be said about <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 textures, but it would take us well beyond what I need for this introductory textbook.</p>
</div>
</div>
</div>
<p>*[纹理单元]：GPU中的一个硬件组件，用于进行纹理查找。（也可以指代这样一个组件的抽象，无论它是否实际在硬件中实现。）也就是说，它将纹理坐标映射到图像纹理的颜色上。这个操作被称为“采样”，纹理单元与GLSL着色器程序中的采样器变量相关联。</p>
<p>*[<abbr title="Texture Mapping Unit, another name for texture unit (perhaps with a stronger implication of actual hardware support). Also called a TPU (Texture Processing Unit).">TMU</abbr>]：纹理映射单元，纹理单元的另一个名称（可能更强调实际的硬件支持）。也称为TPU（纹理处理单元）。</p>
<p>*[采样]：将纹理坐标映射到纹理的颜色上的操作，包括如果可用则使用mipmap，并且在必要时应用缩放或放大滤波器。</p>
<p>*[采样器变量]：在GLSL中，着色器程序中的一个变量，可以用来在图像纹理中进行查找。采样器变量的值指定了将用于进行查找的纹理单元。在WebGL中，采样器变量的类型为“sampler2D”或“samplerCube”。</p>
<p>*[<abbr title="A new JavaScript graphics API, similar to WebGL, but designed to let web programs access modern GPU capabilities such as compute shaders.">WebGPU</abbr>]：一种新的JavaScript图形API，类似于WebGL，但设计上允许Web程序访问现代GPU功能，如计算着色器。</p>







  
    
  
  
    
  


  <aside class="md-source-file">
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="最后更新">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1-2.1-2M12.5 7v5.2l4 2.4-1 1L11 13V7h1.5M11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2v1.8Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">2024年6月14日</span>
  </span>

    
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="创建日期">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.47 15.08 11 13V7h1.5v5.25l3.08 1.83c-.41.28-.79.62-1.11 1m-1.39 4.84c-.36.05-.71.08-1.08.08-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8c0 .37-.03.72-.08 1.08.69.1 1.33.32 1.92.64.1-.56.16-1.13.16-1.72 0-5.5-4.5-10-10-10S2 6.5 2 12s4.47 10 10 10c.59 0 1.16-.06 1.72-.16-.32-.59-.54-1.23-.64-1.92M18 15v3h-3v2h3v3h2v-3h3v-2h-3v-3h-2Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">2024年5月26日</span>
  </span>

    
    
    
  </aside>





                
              </article>
            </div>
          
          
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var tab,labels=set.querySelector(".tabbed-labels");for(tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script>

<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../../..", "features": ["content.code.copy", "content.tabs.link", "navigation.tabs", "navigation.tabs.sticky", "navigation.indexes", "navigation.top", "toc.follow", "content.tooltips"], "search": "../../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.3220b9d7.min.js"></script>
      
        <script src="../../../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="https://unpkg.com/mermaid@9.4.0/dist/mermaid.min.js"></script>
      
    
  <script>document$.subscribe(() => {const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});})</script></body>
</html>