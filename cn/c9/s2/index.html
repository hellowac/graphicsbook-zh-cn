
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="计算机图形学概论(graphicsbook)">
      
      
      
        <link rel="canonical" href="https://hellowac.github.io/graphicsbook-zh-cn/cn/c9/s2/">
      
      
        <link rel="prev" href="../s1/">
      
      
        <link rel="next" href="../s3/">
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.5.18">
    
    
      
        <title>9.2 实例和索引 - 计算机图形学概论</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.66ac8b77.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.06af60db.min.css">
      
      

  
  
  
  
  <style>:root{--md-annotation-icon:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M22 12a10 10 0 0 1-10 10A10 10 0 0 1 2 12 10 10 0 0 1 12 2a10 10 0 0 1 10 10M6 13h8l-3.5 3.5 1.42 1.42L17.84 12l-5.92-5.92L10.5 7.5 14 11H6v2Z"/></svg>');}</style>


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
   <link href="../../../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
        html.glightbox-open { overflow: initial; height: 100%; }
        .gslide-title { margin-top: 0px; user-select: text; }
        .gslide-desc { color: #666; user-select: text; }
        .gslide-image img { background: white; }
        
            .gscrollbar-fixer { padding-right: 15px; }
            .gdesc-inner { font-size: 0.75rem; }
            body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
            body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
            body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}
            </style> <script src="../../../assets/javascripts/glightbox.min.js"></script></head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="default" data-md-color-accent="red">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#92-实例和索引" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="计算机图形学概论" class="md-header__button md-logo" aria-label="计算机图形学概论" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            计算机图形学概论
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              9.2 实例和索引
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
      <div class="md-header__option">
  <div class="md-select">
    
    <button class="md-header__button md-icon" aria-label="选择当前语言">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m12.87 15.07-2.54-2.51.03-.03A17.52 17.52 0 0 0 14.07 6H17V4h-7V2H8v2H1v2h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04M18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12m-2.62 7 1.62-4.33L19.12 17h-3.24Z"/></svg>
    </button>
    <div class="md-select__inner">
      <ul class="md-select__list">
        
          <li class="md-select__item">
            <a href="/graphicsbook-zh-cn/en/" hreflang="en" class="md-select__link">
              English
            </a>
          </li>
        
          <li class="md-select__item">
            <a href="/graphicsbook-zh-cn/cn/" hreflang="cn" class="md-select__link">
              中文
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</div>
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/hellowac/graphicsbook-zh-cn" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    graphicsbook
  </div>
</a>
      </div>
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../" class="md-tabs__link">
        
  
    
  
  首页

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../preface/" class="md-tabs__link">
        
  
    
  
  前言

      </a>
    </li>
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c1/" class="md-tabs__link">
          
  
    
  
  1.简介

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c2/" class="md-tabs__link">
          
  
    
  
  2.二维图形

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c3/" class="md-tabs__link">
          
  
    
  
  3.几何

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c4/" class="md-tabs__link">
          
  
    
  
  4.灯光和材质

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c5/" class="md-tabs__link">
          
  
    
  
  5.three.js

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c6/" class="md-tabs__link">
          
  
    
  
  6.WebGL

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c7/" class="md-tabs__link">
          
  
    
  
  7.WebGL 3D

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c8/" class="md-tabs__link">
          
  
    
  
  8.高阶3D

        </a>
      </li>
    
  

      
        
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../" class="md-tabs__link">
          
  
    
  
  9.WEBGPU

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../a1/" class="md-tabs__link">
          
  
    
  
  附录

        </a>
      </li>
    
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../.." class="md-tabs__link">
        
  
    
  
  关于

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="计算机图形学概论" class="md-nav__button md-logo" aria-label="计算机图形学概论" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    计算机图形学概论
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/hellowac/graphicsbook-zh-cn" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    graphicsbook
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    首页
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../preface/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    前言
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c1/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    1.简介
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_3" id="__nav_3_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            1.简介
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 1 节 绘画与绘图
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 2 节：三维(3D)图形的要素
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 3 节：硬件与软件
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c2/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    2.二维图形
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_4" id="__nav_4_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            2.二维图形
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第1节: 像素、坐标和颜色
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第2节: 形状
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第3节: 变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第4节: 分层建模
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第5节: Java 绘制2D
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第6节: HTML Canvas图形
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第7节: SVG：一种场景描述语言
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c3/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    3.几何
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_5" id="__nav_5_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            3.几何
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.1 OpenGL 1.1 中的形状和颜色
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.2 3D 坐标和变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.3 投影与观看
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.4 多边形网格和 glDrawArrays
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.5 部分线性代数基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.6 使用 GLUT 和 JOGL
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c4/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    4.灯光和材质
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_6" id="__nav_6_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6">
            <span class="md-nav__icon md-icon"></span>
            4.灯光和材质
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.1 照明简介
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.2 OpenGL 1.1 中的光和材质
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.3 图像纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.4 灯光、相机、动作
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c5/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    5.three.js
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_7" id="__nav_7_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7">
            <span class="md-nav__icon md-icon"></span>
            5.three.js
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.1 Three.js 基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.2 构建对象
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.3 其他功能
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c6/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    6.WebGL
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_8" id="__nav_8_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8">
            <span class="md-nav__icon md-icon"></span>
            6.WebGL
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.1 可编程流水线
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.2 第一个例子
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.3 GLSL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.4 图像纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.5 实现 2D 变换
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c7/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    7.WebGL 3D
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_9" id="__nav_9_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9">
            <span class="md-nav__icon md-icon"></span>
            7.WebGL 3D
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.1 3D变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.2 照明和材质
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.3 纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.4 帧缓冲区
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.5 WebGL 扩展
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c8/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    8.高阶3D
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_10" id="__nav_10_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_10_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10">
            <span class="md-nav__icon md-icon"></span>
            8.高阶3D
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c8/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8.1 光线追踪
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c8/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8.2 路径追踪
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_11" checked>
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    9.WEBGPU
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_11" id="__nav_11_label" tabindex="">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_11_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_11">
            <span class="md-nav__icon md-icon"></span>
            9.WEBGPU
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.1 WebGPU 基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    9.2 实例和索引
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    9.2 实例和索引
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#921-实例绘图" class="md-nav__link">
    <span class="md-ellipsis">
      9.2.1 实例绘图
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#922-索引绘图" class="md-nav__link">
    <span class="md-ellipsis">
      9.2.2 索引绘图
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#923-绘制多个基元" class="md-nav__link">
    <span class="md-ellipsis">
      9.2.3 绘制多个基元
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#924-在着色器中使用索引" class="md-nav__link">
    <span class="md-ellipsis">
      9.2.4 在着色器中使用索引
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#925-多重采样" class="md-nav__link">
    <span class="md-ellipsis">
      9.2.5 多重采样
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.3 WGSL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.4 WebGPU 中的 3D 图形
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.5 纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.6 计算着色器
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.7 细节
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_12" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../a1/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    附录
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_12" id="__nav_12_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_12_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_12">
            <span class="md-nav__icon md-icon"></span>
            附录
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a2/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Blender 3D建模
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a3/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Gimp和Inkscape
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../source/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    示例程序源代码
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../glossary/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    术语表
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    关于
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#921-实例绘图" class="md-nav__link">
    <span class="md-ellipsis">
      9.2.1 实例绘图
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#922-索引绘图" class="md-nav__link">
    <span class="md-ellipsis">
      9.2.2 索引绘图
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#923-绘制多个基元" class="md-nav__link">
    <span class="md-ellipsis">
      9.2.3 绘制多个基元
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#924-在着色器中使用索引" class="md-nav__link">
    <span class="md-ellipsis">
      9.2.4 在着色器中使用索引
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#925-多重采样" class="md-nav__link">
    <span class="md-ellipsis">
      9.2.5 多重采样
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="92-实例和索引">9.2 实例和索引<a class="headerlink" href="#92-实例和索引" title="Permanent link">&para;</a></h1>
<p><strong>Instances and Indices</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="1:2"><input checked="checked" id="__tabbed_1_1" name="__tabbed_1" type="radio" /><input id="__tabbed_1_2" name="__tabbed_1" type="radio" /><div class="tabbed-labels"><label for="__tabbed_1_1">中文</label><label for="__tabbed_1_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>The previous section showed how to draw one primitive in <abbr title="A new JavaScript graphics API, similar to WebGL, but designed to let web programs access modern GPU capabilities such as compute shaders.">WebGPU</abbr>. In this section we will see how to draw more than one primitive in the same image, and we will cover some new options for drawing them: <abbr title="The ability to render multiple versions of a primitive with a single function call. Each copy can have its own values for certain attributes, such as color or transformation.">instanced drawing</abbr> and <abbr title="In WebGPU, drawing a primitive using the drawIndexed() function. With that function, vertices are not generated in the order in which they are listed. Instead, a list of vertex indices in an index buffer determines the order of the vertices. Indexed drawing is used to render indexed face sets.">indexed drawing</abbr>.</p>
<p>For most of this section, we will be looking at variations on one example: an app that shows randomly colored disks moving around in a canvas. The last variation will add <abbr title="A technique used to reduce the jagged or &quot;staircase&quot; appearance of diagonal lines, text, and other shapes that are drawn using pixels. When a pixel is only partly covered by a geometric shape, then the color of the pixel is a blend of the color of the shape and the color of the background, with the degree of blending depending on the fraction of the pixel that is covered by the geometric shape.">antialiasing</abbr> to the example using a technique called <abbr title="A kind of antialiasing where the fragment shader is evaluated at several points in each pixel, and the results are averaged to get the color of the pixel.">multisampling</abbr>. Here is a demo that lets you switch between the basic version and the <abbr title="A kind of antialiasing where the fragment shader is evaluated at several points in each pixel, and the results are averaged to get the color of the pixel.">multisampling</abbr> version. The edges of the disks in the basic version are more jagged. The effect will be easier to see if you magnify the web page.</p>
<p><iframe src="../../../en/demos/c9/multisampling-demo.html" width="390" height="450"></iframe></p>
</div>
<div class="tabbed-block">
<p>The previous section showed how to draw one primitive in <abbr title="A new JavaScript graphics API, similar to WebGL, but designed to let web programs access modern GPU capabilities such as compute shaders.">WebGPU</abbr>. In this section we will see how to draw more than one primitive in the same image, and we will cover some new options for drawing them: <abbr title="The ability to render multiple versions of a primitive with a single function call. Each copy can have its own values for certain attributes, such as color or transformation.">instanced drawing</abbr> and <abbr title="In WebGPU, drawing a primitive using the drawIndexed() function. With that function, vertices are not generated in the order in which they are listed. Instead, a list of vertex indices in an index buffer determines the order of the vertices. Indexed drawing is used to render indexed face sets.">indexed drawing</abbr>.</p>
<p>For most of this section, we will be looking at variations on one example: an app that shows randomly colored disks moving around in a canvas. The last variation will add <abbr title="A technique used to reduce the jagged or &quot;staircase&quot; appearance of diagonal lines, text, and other shapes that are drawn using pixels. When a pixel is only partly covered by a geometric shape, then the color of the pixel is a blend of the color of the shape and the color of the background, with the degree of blending depending on the fraction of the pixel that is covered by the geometric shape.">antialiasing</abbr> to the example using a technique called <abbr title="A kind of antialiasing where the fragment shader is evaluated at several points in each pixel, and the results are averaged to get the color of the pixel.">multisampling</abbr>. Here is a demo that lets you switch between the basic version and the <abbr title="A kind of antialiasing where the fragment shader is evaluated at several points in each pixel, and the results are averaged to get the color of the pixel.">multisampling</abbr> version. The edges of the disks in the basic version are more jagged. The effect will be easier to see if you magnify the web page.</p>
<p><iframe src="../../../en/demos/c9/multisampling-demo.html" width="390" height="450"></iframe></p>
</div>
</div>
</div>
<h2 id="921-实例绘图">9.2.1 实例绘图<a class="headerlink" href="#921-实例绘图" title="Permanent link">&para;</a></h2>
<p><strong>Instanced Drawing</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="2:2"><input checked="checked" id="__tabbed_2_1" name="__tabbed_2" type="radio" /><input id="__tabbed_2_2" name="__tabbed_2" type="radio" /><div class="tabbed-labels"><label for="__tabbed_2_1">中文</label><label for="__tabbed_2_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>Instanced drawing makes it possible to draw multiple copies, or "instances," of the same primitive with a single function call. Instanced drawing in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 was covered in <a href="../../c6/s1/#618-webgl-20实例化绘图">Subsection 6.1.8</a>. The sample program <a href="../../../en/source/webgpu/instanced_draw.html">webgpu/instanced_draw.html</a> shows how to do it in <abbr title="A new JavaScript graphics API, similar to WebGL, but designed to let web programs access modern GPU capabilities such as compute shaders.">WebGPU</abbr>. (Again, I urge you to read the comments in the source code for all sample programs!)</p>
<p>The various instances of the primitive can look different in the rendered image, provided that they have different values for some <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr>. For example, the instances can have different colors. The color would be an "instance <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>."</p>
<p>We have used the render pass encoder method draw(N) to draw a primitive that has N vertices. For each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>, the system will pull <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> values from <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffers for that <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> and will pass them as parameters to the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> entry point. Instance properties work the same way, except that the value for an instance <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> is the same for every <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> in a given instance.</p>
<p>Instanced drawing uses the same draw() method as regular drawing, but with a second parameter. A call to draw(N,M) will draw M instances of a primitive that has N vertices. The effect is similar to the following pseudocode:</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">M</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="nx">get</span><span class="w"> </span><span class="nx">instance</span><span class="w"> </span><span class="nx">attribute</span><span class="w"> </span><span class="nx">values</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nx">instance</span><span class="w"> </span><span class="nx">i</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">N</span><span class="p">;</span><span class="w"> </span><span class="nx">v</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="nx">get</span><span class="w"> </span><span class="nx">vertex</span><span class="w"> </span><span class="nx">attribute</span><span class="w"> </span><span class="nx">values</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nx">vertex</span><span class="w"> </span><span class="nx">v</span>
<span class="w">    </span><span class="nx">call</span><span class="w"> </span><span class="nx">vertex</span><span class="w"> </span><span class="nx">shader</span><span class="w"> </span><span class="kd">function</span><span class="p">,</span><span class="w"> </span><span class="nx">passing</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nx">all</span><span class="w"> </span><span class="nx">attribute</span><span class="w"> </span><span class="nx">values</span>
</code></pre></div>
<p>(The draw() method can also take two more optional parameters specifying the start index for the vertices and the start index for the instances.)</p>
<p>Vertex <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> values come from <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffers. So do instance <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> values. The only difference is a small change in the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffer layout specification. It's time to look at an example. The sample program draws fifty colored disks which a single call to draw(). The basic primitive is a disk centered at (0,0). The coordinates for the vertices of the disk are given as a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>. Each colored disk is an instance. The color of the disk is an instance <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>. Another instance <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>, offset, specifies a <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr> transformation that is applied to the primitive. In the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> source code, the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> coordinates, color, and offset are parameters to the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> function:</p>
<div class="highlight"><pre><span></span><code><span class="err">@</span><span class="nx">vertex</span>
<span class="nx">fn</span><span class="w"> </span><span class="nx">vertexMain</span><span class="p">(</span><span class="w"> </span>
<span class="w">        </span><span class="err">@</span><span class="nx">location</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="nx">coords</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">vec2f</span><span class="p">,</span>
<span class="w">        </span><span class="err">@</span><span class="nx">location</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="nx">offset</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">vec2f</span><span class="p">,</span>
<span class="w">        </span><span class="err">@</span><span class="nx">location</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span><span class="w"> </span><span class="nx">color</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">vec3f</span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nx">VertexOutput</span><span class="w"> </span><span class="p">{</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">output</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">VertexOutput</span><span class="p">;</span><span class="w"> </span><span class="c1">// (A struct with position and color fields.)</span>
<span class="nx">output</span><span class="p">.</span><span class="nx">position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4f</span><span class="p">(</span><span class="w"> </span><span class="nx">coords</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">offset</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="p">);</span>
<span class="nx">output</span><span class="p">.</span><span class="nx">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4f</span><span class="p">(</span><span class="nx">color</span><span class="p">,</span><span class="mf">1</span><span class="p">);</span>
<span class="k">return</span><span class="w"> </span><span class="nx">output</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Recall that the @location <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr> in the parameter list are used to associate the parameters with values coming from the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side of the program. The association is made by the shaderLocation properties in the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffer layout on the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side. Here is the layout from the sample program, which specifies the source for each parameter:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">vertexBufferLayout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span>
<span class="p">{</span><span class="w"> </span><span class="c1">// First vertex buffer, for vertex coord.</span>
<span class="w">    </span><span class="nx">attributes</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span>
<span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="nx">shaderLocation</span><span class="o">:</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">offset</span><span class="o">:</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">format</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;float32x2&quot;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">],</span>
<span class="w">    </span><span class="nx">arrayStride</span><span class="o">:</span><span class="w"> </span><span class="mf">8</span><span class="p">,</span>
<span class="w">    </span><span class="nx">stepMode</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;vertex&quot;</span><span class="w">   </span><span class="c1">// This is a vertex attribute.</span>
<span class="p">},</span>
<span class="p">{</span><span class="w"> </span><span class="c1">// Second vertex buffer, for instance offsets.</span>
<span class="w">    </span><span class="nx">attributes</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span>
<span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="nx">shaderLocation</span><span class="o">:</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="nx">offset</span><span class="o">:</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">format</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;float32x2&quot;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">],</span>
<span class="w">    </span><span class="nx">arrayStride</span><span class="o">:</span><span class="w"> </span><span class="mf">8</span><span class="p">,</span>
<span class="w">    </span><span class="nx">stepMode</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;instance&quot;</span><span class="w">  </span><span class="c1">// This is an instance attribute.</span>
<span class="p">},</span>
<span class="p">{</span><span class="w"> </span><span class="c1">// Third vertex buffer, for instance colors.</span>
<span class="w">    </span><span class="nx">attributes</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span>
<span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="nx">shaderLocation</span><span class="o">:</span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="nx">offset</span><span class="o">:</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">format</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;float32x3&quot;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">],</span>
<span class="w">    </span><span class="nx">arrayStride</span><span class="o">:</span><span class="w"> </span><span class="mf">12</span><span class="p">,</span>
<span class="w">    </span><span class="nx">stepMode</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;instance&quot;</span><span class="w">  </span><span class="c1">// This is an instance attribute.</span>
<span class="p">}</span>
<span class="p">];</span>
</code></pre></div>
<p>As you can see, the only difference between <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> and instance <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr> is the value of the stepMode property. Step mode "<abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>" tells the system to pull a value from the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffer for each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> in the primitive. Step mode "instance" means to pull out a value for each instance.</p>
<p>The disks in the sample program can be animated. To draw the next frame in the <abbr title="A sequence of images that, when displayed quickly one after the other, will produce the impression of continuous motion or change. The term animation also refers to the process of creating such image sequences.">animation</abbr>, the program simply computes a new value for the offset <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> of each disk, writes the new values to the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffer that holds the offsets on the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> side, and then re-renders the image. One technical point about <abbr title="A sequence of images that, when displayed quickly one after the other, will produce the impression of continuous motion or change. The term animation also refers to the process of creating such image sequences.">animation</abbr> might be bothering you: The <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side of the program simply enqueues commands that will be executed later on the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> side. Somehow, the two sides have to be synchronized, to make sure that we don't start drawing a new image until the old image has been computed and displayed on the web page. That synchronization is taken care of by the requestAnimationFrame() method that is used to implement the <abbr title="A sequence of images that, when displayed quickly one after the other, will produce the impression of continuous motion or change. The term animation also refers to the process of creating such image sequences.">animation</abbr>. That method will not start a new frame until the previous frame is complete.</p>
<hr />
<p>Although it is not related to <abbr title="The ability to render multiple versions of a primitive with a single function call. Each copy can have its own values for certain attributes, such as color or transformation.">instanced drawing</abbr>, another interesting point from the sample program is how it draws a disk. The disk is approximated as a <abbr title="A multi-sided shape lying in a plane and specified by a list of points, called its vertices, and made up of the line segments from each point in the list to the next point in the list, plus a line segment from the last point in the list to the first point. All the points are required to lie in the same plane. Sometimes the term &quot;polygon&quot; includes the interior of the shape as well as its boundary.">polygon</abbr>. In <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>, I would draw the disk as a <em>TRIANGLE_FAN</em>, but <abbr title="A new JavaScript graphics API, similar to WebGL, but designed to let web programs access modern GPU capabilities such as compute shaders.">WebGPU</abbr> lacks that primitive type. Here, the disk is drawn using a triangle-strip primitive, which requires a careful ordering of the vertices:</p>
<p><a class="glightbox" href="../../../en/c9/triangle-strip-disk.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="How to draw a disk as a triangle strip" src="../../../en/c9/triangle-strip-disk.png" /></a></p>
</div>
<div class="tabbed-block">
<p>Instanced drawing makes it possible to draw multiple copies, or "instances," of the same primitive with a single function call. Instanced drawing in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 was covered in <a href="../../c6/s1/#618-webgl-20实例化绘图">Subsection 6.1.8</a>. The sample program <a href="../../../en/source/webgpu/instanced_draw.html">webgpu/instanced_draw.html</a> shows how to do it in <abbr title="A new JavaScript graphics API, similar to WebGL, but designed to let web programs access modern GPU capabilities such as compute shaders.">WebGPU</abbr>. (Again, I urge you to read the comments in the source code for all sample programs!)</p>
<p>The various instances of the primitive can look different in the rendered image, provided that they have different values for some <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr>. For example, the instances can have different colors. The color would be an "instance <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>."</p>
<p>We have used the render pass encoder method draw(N) to draw a primitive that has N vertices. For each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>, the system will pull <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> values from <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffers for that <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> and will pass them as parameters to the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> entry point. Instance properties work the same way, except that the value for an instance <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> is the same for every <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> in a given instance.</p>
<p>Instanced drawing uses the same draw() method as regular drawing, but with a second parameter. A call to draw(N,M) will draw M instances of a primitive that has N vertices. The effect is similar to the following pseudocode:</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">M</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="nx">get</span><span class="w"> </span><span class="nx">instance</span><span class="w"> </span><span class="nx">attribute</span><span class="w"> </span><span class="nx">values</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nx">instance</span><span class="w"> </span><span class="nx">i</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">N</span><span class="p">;</span><span class="w"> </span><span class="nx">v</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="nx">get</span><span class="w"> </span><span class="nx">vertex</span><span class="w"> </span><span class="nx">attribute</span><span class="w"> </span><span class="nx">values</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nx">vertex</span><span class="w"> </span><span class="nx">v</span>
<span class="w">    </span><span class="nx">call</span><span class="w"> </span><span class="nx">vertex</span><span class="w"> </span><span class="nx">shader</span><span class="w"> </span><span class="kd">function</span><span class="p">,</span><span class="w"> </span><span class="nx">passing</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nx">all</span><span class="w"> </span><span class="nx">attribute</span><span class="w"> </span><span class="nx">values</span>
</code></pre></div>
<p>(The draw() method can also take two more optional parameters specifying the start index for the vertices and the start index for the instances.)</p>
<p>Vertex <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> values come from <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffers. So do instance <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> values. The only difference is a small change in the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffer layout specification. It's time to look at an example. The sample program draws fifty colored disks which a single call to draw(). The basic primitive is a disk centered at (0,0). The coordinates for the vertices of the disk are given as a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>. Each colored disk is an instance. The color of the disk is an instance <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>. Another instance <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>, offset, specifies a <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr> transformation that is applied to the primitive. In the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> source code, the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> coordinates, color, and offset are parameters to the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> function:</p>
<div class="highlight"><pre><span></span><code><span class="err">@</span><span class="nx">vertex</span>
<span class="nx">fn</span><span class="w"> </span><span class="nx">vertexMain</span><span class="p">(</span><span class="w"> </span>
<span class="w">        </span><span class="err">@</span><span class="nx">location</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="nx">coords</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">vec2f</span><span class="p">,</span>
<span class="w">        </span><span class="err">@</span><span class="nx">location</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="nx">offset</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">vec2f</span><span class="p">,</span>
<span class="w">        </span><span class="err">@</span><span class="nx">location</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span><span class="w"> </span><span class="nx">color</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">vec3f</span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nx">VertexOutput</span><span class="w"> </span><span class="p">{</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">output</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">VertexOutput</span><span class="p">;</span><span class="w"> </span><span class="c1">// (A struct with position and color fields.)</span>
<span class="nx">output</span><span class="p">.</span><span class="nx">position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4f</span><span class="p">(</span><span class="w"> </span><span class="nx">coords</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">offset</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="p">);</span>
<span class="nx">output</span><span class="p">.</span><span class="nx">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4f</span><span class="p">(</span><span class="nx">color</span><span class="p">,</span><span class="mf">1</span><span class="p">);</span>
<span class="k">return</span><span class="w"> </span><span class="nx">output</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Recall that the @location <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr> in the parameter list are used to associate the parameters with values coming from the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side of the program. The association is made by the shaderLocation properties in the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffer layout on the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side. Here is the layout from the sample program, which specifies the source for each parameter:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">vertexBufferLayout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span>
<span class="p">{</span><span class="w"> </span><span class="c1">// First vertex buffer, for vertex coord.</span>
<span class="w">    </span><span class="nx">attributes</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span>
<span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="nx">shaderLocation</span><span class="o">:</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">offset</span><span class="o">:</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">format</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;float32x2&quot;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">],</span>
<span class="w">    </span><span class="nx">arrayStride</span><span class="o">:</span><span class="w"> </span><span class="mf">8</span><span class="p">,</span>
<span class="w">    </span><span class="nx">stepMode</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;vertex&quot;</span><span class="w">   </span><span class="c1">// This is a vertex attribute.</span>
<span class="p">},</span>
<span class="p">{</span><span class="w"> </span><span class="c1">// Second vertex buffer, for instance offsets.</span>
<span class="w">    </span><span class="nx">attributes</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span>
<span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="nx">shaderLocation</span><span class="o">:</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="nx">offset</span><span class="o">:</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">format</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;float32x2&quot;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">],</span>
<span class="w">    </span><span class="nx">arrayStride</span><span class="o">:</span><span class="w"> </span><span class="mf">8</span><span class="p">,</span>
<span class="w">    </span><span class="nx">stepMode</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;instance&quot;</span><span class="w">  </span><span class="c1">// This is an instance attribute.</span>
<span class="p">},</span>
<span class="p">{</span><span class="w"> </span><span class="c1">// Third vertex buffer, for instance colors.</span>
<span class="w">    </span><span class="nx">attributes</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span>
<span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="nx">shaderLocation</span><span class="o">:</span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="nx">offset</span><span class="o">:</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">format</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;float32x3&quot;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">],</span>
<span class="w">    </span><span class="nx">arrayStride</span><span class="o">:</span><span class="w"> </span><span class="mf">12</span><span class="p">,</span>
<span class="w">    </span><span class="nx">stepMode</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;instance&quot;</span><span class="w">  </span><span class="c1">// This is an instance attribute.</span>
<span class="p">}</span>
<span class="p">];</span>
</code></pre></div>
<p>As you can see, the only difference between <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> and instance <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr> is the value of the stepMode property. Step mode "<abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>" tells the system to pull a value from the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffer for each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> in the primitive. Step mode "instance" means to pull out a value for each instance.</p>
<p>The disks in the sample program can be animated. To draw the next frame in the <abbr title="A sequence of images that, when displayed quickly one after the other, will produce the impression of continuous motion or change. The term animation also refers to the process of creating such image sequences.">animation</abbr>, the program simply computes a new value for the offset <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> of each disk, writes the new values to the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffer that holds the offsets on the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> side, and then re-renders the image. One technical point about <abbr title="A sequence of images that, when displayed quickly one after the other, will produce the impression of continuous motion or change. The term animation also refers to the process of creating such image sequences.">animation</abbr> might be bothering you: The <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side of the program simply enqueues commands that will be executed later on the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> side. Somehow, the two sides have to be synchronized, to make sure that we don't start drawing a new image until the old image has been computed and displayed on the web page. That synchronization is taken care of by the requestAnimationFrame() method that is used to implement the <abbr title="A sequence of images that, when displayed quickly one after the other, will produce the impression of continuous motion or change. The term animation also refers to the process of creating such image sequences.">animation</abbr>. That method will not start a new frame until the previous frame is complete.</p>
<hr />
<p>Although it is not related to <abbr title="The ability to render multiple versions of a primitive with a single function call. Each copy can have its own values for certain attributes, such as color or transformation.">instanced drawing</abbr>, another interesting point from the sample program is how it draws a disk. The disk is approximated as a <abbr title="A multi-sided shape lying in a plane and specified by a list of points, called its vertices, and made up of the line segments from each point in the list to the next point in the list, plus a line segment from the last point in the list to the first point. All the points are required to lie in the same plane. Sometimes the term &quot;polygon&quot; includes the interior of the shape as well as its boundary.">polygon</abbr>. In <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>, I would draw the disk as a <em>TRIANGLE_FAN</em>, but <abbr title="A new JavaScript graphics API, similar to WebGL, but designed to let web programs access modern GPU capabilities such as compute shaders.">WebGPU</abbr> lacks that primitive type. Here, the disk is drawn using a triangle-strip primitive, which requires a careful ordering of the vertices:</p>
<p><a class="glightbox" href="../../../en/c9/triangle-strip-disk.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="How to draw a disk as a triangle strip" src="../../../en/c9/triangle-strip-disk.png" /></a></p>
</div>
</div>
</div>
<h2 id="922-索引绘图">9.2.2 索引绘图<a class="headerlink" href="#922-索引绘图" title="Permanent link">&para;</a></h2>
<p><strong>Indexed Drawing</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="3:2"><input checked="checked" id="__tabbed_3_1" name="__tabbed_3" type="radio" /><input id="__tabbed_3_2" name="__tabbed_3" type="radio" /><div class="tabbed-labels"><label for="__tabbed_3_1">中文</label><label for="__tabbed_3_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>Another way to draw a disk is as a triangle-list primitive, with the disk divided up like the slices of a pie. The vertices for one of the triangles would be the center of the disk plus two consecutive vertices on the circumference. Note that a given <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> can be used in several different triangles. This means that the disk can be implemented most efficiently as an <abbr title="(IFS). A data structure that represents a polyhedron or polygonal mesh. The data structure includes a numbered list of vertices and a list of faces. A face is specified by listing the indices of the vertices of the face; that is, a face is given as a list of numbers where each number is an index into the list of vertices.">indexed face set</abbr>. The data for an <abbr title="(IFS). A data structure that represents a polyhedron or polygonal mesh. The data structure includes a numbered list of vertices and a list of faces. A face is specified by listing the indices of the vertices of the face; that is, a face is given as a list of numbers where each number is an index into the list of vertices.">indexed face set</abbr> consists of a list of <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> coordinates (plus corresponding lists of values for other <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr> if needed) and a list of <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> indices. (See <a href="../../c3/s4/#341-索引面集">Subsection 3.4.1</a> for the more details.)</p>
<p>A <abbr title="A new JavaScript graphics API, similar to WebGL, but designed to let web programs access modern GPU capabilities such as compute shaders.">WebGPU</abbr> render pass encoder has a drawIndexed(N) method that implements this type of drawing. In addition to <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffers, this method requires an <abbr title="In WebGPU, an index buffer is a GPU buffer that holds vertex indices for use with the drawIndexed(). A vertex index gives the position of a vertex in the list of vertices of a primitive.">index buffer</abbr> to hold the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> indices. The values in the <strong><abbr title="In WebGPU, an index buffer is a GPU buffer that holds vertex indices for use with the drawIndexed(). A vertex index gives the position of a vertex in the list of vertices of a primitive.">index buffer</abbr></strong> must be either 16-bit unsigned integers or 32-bit unsigned integers. The effect of drawIndexed(N) is</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">N</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="nx">Let</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="nx">be</span><span class="w"> </span><span class="nx">index</span><span class="w"> </span><span class="nx">number</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">index</span><span class="w"> </span><span class="nx">buffer</span>
<span class="w">    </span><span class="nx">get</span><span class="w"> </span><span class="nx">attribute</span><span class="w"> </span><span class="nx">values</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nx">vertex</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">vertex</span><span class="w"> </span><span class="nx">buffers</span>
<span class="w">    </span><span class="nx">call</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">vertex</span><span class="w"> </span><span class="nx">shader</span><span class="w"> </span><span class="kd">function</span><span class="p">,</span><span class="w"> </span><span class="nx">passing</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">attribute</span><span class="w"> </span><span class="nx">values</span>
</code></pre></div>
<p>The sample program <a href="../../../en/source/webgpu/indexed_draw.html">webgpu/indexed_draw.html</a> draws a single disk as a triangle-list primitive using <em>drawIndexed()</em>. To add a little interest, it also draws the circumference of the disk as a line-strip primitive, using the basic <em>draw()</em> method. So the same program also shows how to render two primitives in the same render pass.</p>
<p>In the program, VERTEX_COUNT is the number of vertices of the <abbr title="A multi-sided shape lying in a plane and specified by a list of points, called its vertices, and made up of the line segments from each point in the list to the next point in the list, plus a line segment from the last point in the list to the first point. All the points are required to lie in the same plane. Sometimes the term &quot;polygon&quot; includes the interior of the shape as well as its boundary.">polygon</abbr> that is used to approximate the disk. The vertices are numbered in counterclockwise order around the disk, with <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> number 0 repeated at the end. The VERTEX_COUNT+1 vertices can then be used in order to draw the outline of the disk as a line-strip. For drawing the interior of disk, we will also need to have the center of the disk, (0,0), in the list. The center is added as <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> number VERTEX_COUNT+1. To render the interior, we need to draw 3*VERTEX_COUNT vertices—three vertices for each triangle. The data for the <abbr title="In WebGPU, an index buffer is a GPU buffer that holds vertex indices for use with the drawIndexed(). A vertex index gives the position of a vertex in the list of vertices of a primitive.">index buffer</abbr> is loaded into a <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> <strong><em>Uint16Array</em></strong> of length 3*VERTEX_COUNT:</p>
<div class="highlight"><pre><span></span><code><span class="cm">/* Fill diskIndices with the vertex indices for the VERTEX_COUNT</span>

<span class="cm">* triangles that make up the disk.  Each triangle uses the center</span>
<span class="cm">* of the disk and two consecutive vertices on the outline. */</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">VERTEX_COUNT</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">diskIndices</span><span class="p">[</span><span class="mf">3</span><span class="o">*</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">VERTEX_COUNT</span><span class="o">+</span><span class="mf">1</span><span class="p">;</span><span class="w">  </span><span class="c1">// center of disk</span>
<span class="w">    </span><span class="nx">diskIndices</span><span class="p">[</span><span class="mf">3</span><span class="o">*</span><span class="nx">i</span><span class="o">+</span><span class="mf">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">i</span><span class="p">;</span><span class="w">             </span><span class="c1">// vertex number i</span>
<span class="w">    </span><span class="nx">diskIndices</span><span class="p">[</span><span class="mf">3</span><span class="o">*</span><span class="nx">i</span><span class="o">+</span><span class="mf">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">i</span><span class="o">+</span><span class="mf">1</span><span class="p">;</span><span class="w">           </span><span class="c1">// vertex number i+1</span>
<span class="p">}</span>
</code></pre></div>
<p>A buffer is created to hold the indices on the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> side, and the values in diskIndices are written to that buffer:</p>
<div class="highlight"><pre><span></span><code><span class="nx">indexBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">({</span>
<span class="w">    </span><span class="nx">size</span><span class="o">:</span><span class="w"> </span><span class="nx">diskIndices</span><span class="p">.</span><span class="nx">byteLength</span><span class="p">,</span>
<span class="w">    </span><span class="nx">usage</span><span class="o">:</span><span class="w"> </span><span class="nx">GPUBufferUsage</span><span class="p">.</span><span class="nx">INDEX</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">GPUBufferUsage</span><span class="p">.</span><span class="nx">COPY_DST</span>
<span class="p">});</span>
</code></pre></div>
<p>device.queue.writeBuffer(indexBuffer, 0, diskIndices);
The GPUBufferUsage.INDEX indicates that the buffer will be used as an <abbr title="In WebGPU, an index buffer is a GPU buffer that holds vertex indices for use with the drawIndexed(). A vertex index gives the position of a vertex in the list of vertices of a primitive.">index buffer</abbr>. Otherwise, this is the same as creating a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffer. But unlike <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffers, an <abbr title="In WebGPU, an index buffer is a GPU buffer that holds vertex indices for use with the drawIndexed(). A vertex index gives the position of a vertex in the list of vertices of a primitive.">index buffer</abbr> is not attached to a <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>. Instead, it is specified when creating the render pass:</p>
<div class="highlight"><pre><span></span><code><span class="nx">passEncoder</span><span class="p">.</span><span class="nx">setIndexBuffer</span><span class="p">(</span><span class="nx">indexBuffer</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;uint16&quot;</span><span class="p">);</span>
</code></pre></div>
<p>The second parameter says that the indices are 16-bit unsigned integers; the alternative is "uint32" for 32-bit integers.</p>
<p>It will be worthwhile to look at the full code for <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> the disk interior and outline. The interior and the outline use different primitive topologies. Since the primitive topology is a property of the render <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>, we need to use separate pipelines for the interior and for the outline. Since the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> is an aspect of a <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> pass, we need to encode two render passes:</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span><span class="w"> </span><span class="nx">draw</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">commandEncoder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createCommandEncoder</span><span class="p">();</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">renderPassDescriptor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">colorAttachments</span><span class="o">:</span><span class="w"> </span><span class="p">[{</span>
<span class="w">        </span><span class="nx">clearValue</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">r</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="nx">g</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="nx">a</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="c1">// White background.</span>
<span class="w">        </span><span class="nx">loadOp</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="c1">// To be assigned later!</span>
<span class="w">        </span><span class="nx">storeOp</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;store&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nx">view</span><span class="o">:</span><span class="w"> </span><span class="nx">context</span><span class="p">.</span><span class="nx">getCurrentTexture</span><span class="p">().</span><span class="nx">createView</span><span class="p">()</span>
<span class="w">    </span><span class="p">}]</span>
<span class="p">};</span>

<span class="cm">/*First render pass draws the disk, using a &quot;triangle-list&quot; topology.*/</span>

<span class="nx">renderPassDescriptor</span><span class="p">.</span><span class="nx">colorAttachments</span><span class="p">[</span><span class="mf">0</span><span class="p">].</span><span class="nx">loadOp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;clear&quot;</span><span class="p">;</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">passEncoder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">commandEncoder</span><span class="p">.</span><span class="nx">beginRenderPass</span><span class="p">(</span><span class="nx">renderPassDescriptor</span><span class="p">);</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">setPipeline</span><span class="p">(</span><span class="nx">pipelineForDisk</span><span class="p">);</span><span class="w"> </span><span class="c1">// uses &quot;triangle-list&quot;</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">setVertexBuffer</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="nx">vertexBuffer</span><span class="p">);</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">setIndexBuffer</span><span class="p">(</span><span class="nx">indexBuffer</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;uint16&quot;</span><span class="p">);</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">drawIndexed</span><span class="p">(</span><span class="w"> </span><span class="mf">3</span><span class="o">*</span><span class="nx">VERTEX_COUNT</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// 3 vertices per triangle.</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">end</span><span class="p">();</span>

<span class="cm">/*Second render pass draws the outline, using a &quot;line-strip&quot; topology.*/</span>

<span class="nx">renderPassDescriptor</span><span class="p">.</span><span class="nx">colorAttachments</span><span class="p">[</span><span class="mf">0</span><span class="p">].</span><span class="nx">loadOp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;load&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// DON&#39;T clear!</span>
<span class="nx">passEncoder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">commandEncoder</span><span class="p">.</span><span class="nx">beginRenderPass</span><span class="p">(</span><span class="nx">renderPassDescriptor</span><span class="p">);</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">setPipeline</span><span class="p">(</span><span class="nx">pipelineForOutline</span><span class="p">);</span><span class="w"> </span><span class="c1">// uses &quot;line-strip&quot;</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">setVertexBuffer</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="nx">vertexBuffer</span><span class="p">);</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">draw</span><span class="p">(</span><span class="nx">VERTEX_COUNT</span><span class="o">+</span><span class="mf">1</span><span class="p">);</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">end</span><span class="p">();</span>

<span class="kd">let</span><span class="w"> </span><span class="nx">commandBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">commandEncoder</span><span class="p">.</span><span class="nx">finish</span><span class="p">();</span>
<span class="nx">device</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">submit</span><span class="p">([</span><span class="nx">commandBuffer</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div>
<p>Note that for the first render pass, the loadOp is "clear", since we want to fill the image with the background color before <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> the disk. For the second render pass, we want to draw the outline on top of the existing image, so the loadOp must be "load". The same renderPassDescriptor can be used for both passes, with just the loadOp property changed.</p>
</div>
<div class="tabbed-block">
<p>Another way to draw a disk is as a triangle-list primitive, with the disk divided up like the slices of a pie. The vertices for one of the triangles would be the center of the disk plus two consecutive vertices on the circumference. Note that a given <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> can be used in several different triangles. This means that the disk can be implemented most efficiently as an <abbr title="(IFS). A data structure that represents a polyhedron or polygonal mesh. The data structure includes a numbered list of vertices and a list of faces. A face is specified by listing the indices of the vertices of the face; that is, a face is given as a list of numbers where each number is an index into the list of vertices.">indexed face set</abbr>. The data for an <abbr title="(IFS). A data structure that represents a polyhedron or polygonal mesh. The data structure includes a numbered list of vertices and a list of faces. A face is specified by listing the indices of the vertices of the face; that is, a face is given as a list of numbers where each number is an index into the list of vertices.">indexed face set</abbr> consists of a list of <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> coordinates (plus corresponding lists of values for other <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr> if needed) and a list of <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> indices. (See <a href="../../c3/s4/#341-索引面集">Subsection 3.4.1</a> for the more details.)</p>
<p>A <abbr title="A new JavaScript graphics API, similar to WebGL, but designed to let web programs access modern GPU capabilities such as compute shaders.">WebGPU</abbr> render pass encoder has a drawIndexed(N) method that implements this type of drawing. In addition to <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffers, this method requires an <abbr title="In WebGPU, an index buffer is a GPU buffer that holds vertex indices for use with the drawIndexed(). A vertex index gives the position of a vertex in the list of vertices of a primitive.">index buffer</abbr> to hold the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> indices. The values in the <strong><abbr title="In WebGPU, an index buffer is a GPU buffer that holds vertex indices for use with the drawIndexed(). A vertex index gives the position of a vertex in the list of vertices of a primitive.">index buffer</abbr></strong> must be either 16-bit unsigned integers or 32-bit unsigned integers. The effect of drawIndexed(N) is</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">N</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="nx">Let</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="nx">be</span><span class="w"> </span><span class="nx">index</span><span class="w"> </span><span class="nx">number</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">index</span><span class="w"> </span><span class="nx">buffer</span>
<span class="w">    </span><span class="nx">get</span><span class="w"> </span><span class="nx">attribute</span><span class="w"> </span><span class="nx">values</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nx">vertex</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">vertex</span><span class="w"> </span><span class="nx">buffers</span>
<span class="w">    </span><span class="nx">call</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">vertex</span><span class="w"> </span><span class="nx">shader</span><span class="w"> </span><span class="kd">function</span><span class="p">,</span><span class="w"> </span><span class="nx">passing</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">attribute</span><span class="w"> </span><span class="nx">values</span>
</code></pre></div>
<p>The sample program <a href="../../../en/source/webgpu/indexed_draw.html">webgpu/indexed_draw.html</a> draws a single disk as a triangle-list primitive using <em>drawIndexed()</em>. To add a little interest, it also draws the circumference of the disk as a line-strip primitive, using the basic <em>draw()</em> method. So the same program also shows how to render two primitives in the same render pass.</p>
<p>In the program, VERTEX_COUNT is the number of vertices of the <abbr title="A multi-sided shape lying in a plane and specified by a list of points, called its vertices, and made up of the line segments from each point in the list to the next point in the list, plus a line segment from the last point in the list to the first point. All the points are required to lie in the same plane. Sometimes the term &quot;polygon&quot; includes the interior of the shape as well as its boundary.">polygon</abbr> that is used to approximate the disk. The vertices are numbered in counterclockwise order around the disk, with <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> number 0 repeated at the end. The VERTEX_COUNT+1 vertices can then be used in order to draw the outline of the disk as a line-strip. For drawing the interior of disk, we will also need to have the center of the disk, (0,0), in the list. The center is added as <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> number VERTEX_COUNT+1. To render the interior, we need to draw 3*VERTEX_COUNT vertices—three vertices for each triangle. The data for the <abbr title="In WebGPU, an index buffer is a GPU buffer that holds vertex indices for use with the drawIndexed(). A vertex index gives the position of a vertex in the list of vertices of a primitive.">index buffer</abbr> is loaded into a <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> <strong><em>Uint16Array</em></strong> of length 3*VERTEX_COUNT:</p>
<div class="highlight"><pre><span></span><code><span class="cm">/* Fill diskIndices with the vertex indices for the VERTEX_COUNT</span>

<span class="cm">* triangles that make up the disk.  Each triangle uses the center</span>
<span class="cm">* of the disk and two consecutive vertices on the outline. */</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">VERTEX_COUNT</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">diskIndices</span><span class="p">[</span><span class="mf">3</span><span class="o">*</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">VERTEX_COUNT</span><span class="o">+</span><span class="mf">1</span><span class="p">;</span><span class="w">  </span><span class="c1">// center of disk</span>
<span class="w">    </span><span class="nx">diskIndices</span><span class="p">[</span><span class="mf">3</span><span class="o">*</span><span class="nx">i</span><span class="o">+</span><span class="mf">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">i</span><span class="p">;</span><span class="w">             </span><span class="c1">// vertex number i</span>
<span class="w">    </span><span class="nx">diskIndices</span><span class="p">[</span><span class="mf">3</span><span class="o">*</span><span class="nx">i</span><span class="o">+</span><span class="mf">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">i</span><span class="o">+</span><span class="mf">1</span><span class="p">;</span><span class="w">           </span><span class="c1">// vertex number i+1</span>
<span class="p">}</span>
</code></pre></div>
<p>A buffer is created to hold the indices on the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> side, and the values in diskIndices are written to that buffer:</p>
<div class="highlight"><pre><span></span><code><span class="nx">indexBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">({</span>
<span class="w">    </span><span class="nx">size</span><span class="o">:</span><span class="w"> </span><span class="nx">diskIndices</span><span class="p">.</span><span class="nx">byteLength</span><span class="p">,</span>
<span class="w">    </span><span class="nx">usage</span><span class="o">:</span><span class="w"> </span><span class="nx">GPUBufferUsage</span><span class="p">.</span><span class="nx">INDEX</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">GPUBufferUsage</span><span class="p">.</span><span class="nx">COPY_DST</span>
<span class="p">});</span>
</code></pre></div>
<p>device.queue.writeBuffer(indexBuffer, 0, diskIndices);
The GPUBufferUsage.INDEX indicates that the buffer will be used as an <abbr title="In WebGPU, an index buffer is a GPU buffer that holds vertex indices for use with the drawIndexed(). A vertex index gives the position of a vertex in the list of vertices of a primitive.">index buffer</abbr>. Otherwise, this is the same as creating a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffer. But unlike <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffers, an <abbr title="In WebGPU, an index buffer is a GPU buffer that holds vertex indices for use with the drawIndexed(). A vertex index gives the position of a vertex in the list of vertices of a primitive.">index buffer</abbr> is not attached to a <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>. Instead, it is specified when creating the render pass:</p>
<div class="highlight"><pre><span></span><code><span class="nx">passEncoder</span><span class="p">.</span><span class="nx">setIndexBuffer</span><span class="p">(</span><span class="nx">indexBuffer</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;uint16&quot;</span><span class="p">);</span>
</code></pre></div>
<p>The second parameter says that the indices are 16-bit unsigned integers; the alternative is "uint32" for 32-bit integers.</p>
<p>It will be worthwhile to look at the full code for <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> the disk interior and outline. The interior and the outline use different primitive topologies. Since the primitive topology is a property of the render <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>, we need to use separate pipelines for the interior and for the outline. Since the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> is an aspect of a <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> pass, we need to encode two render passes:</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span><span class="w"> </span><span class="nx">draw</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">commandEncoder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createCommandEncoder</span><span class="p">();</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">renderPassDescriptor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">colorAttachments</span><span class="o">:</span><span class="w"> </span><span class="p">[{</span>
<span class="w">        </span><span class="nx">clearValue</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">r</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="nx">g</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="nx">a</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="c1">// White background.</span>
<span class="w">        </span><span class="nx">loadOp</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="c1">// To be assigned later!</span>
<span class="w">        </span><span class="nx">storeOp</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;store&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nx">view</span><span class="o">:</span><span class="w"> </span><span class="nx">context</span><span class="p">.</span><span class="nx">getCurrentTexture</span><span class="p">().</span><span class="nx">createView</span><span class="p">()</span>
<span class="w">    </span><span class="p">}]</span>
<span class="p">};</span>

<span class="cm">/*First render pass draws the disk, using a &quot;triangle-list&quot; topology.*/</span>

<span class="nx">renderPassDescriptor</span><span class="p">.</span><span class="nx">colorAttachments</span><span class="p">[</span><span class="mf">0</span><span class="p">].</span><span class="nx">loadOp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;clear&quot;</span><span class="p">;</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">passEncoder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">commandEncoder</span><span class="p">.</span><span class="nx">beginRenderPass</span><span class="p">(</span><span class="nx">renderPassDescriptor</span><span class="p">);</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">setPipeline</span><span class="p">(</span><span class="nx">pipelineForDisk</span><span class="p">);</span><span class="w"> </span><span class="c1">// uses &quot;triangle-list&quot;</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">setVertexBuffer</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="nx">vertexBuffer</span><span class="p">);</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">setIndexBuffer</span><span class="p">(</span><span class="nx">indexBuffer</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;uint16&quot;</span><span class="p">);</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">drawIndexed</span><span class="p">(</span><span class="w"> </span><span class="mf">3</span><span class="o">*</span><span class="nx">VERTEX_COUNT</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// 3 vertices per triangle.</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">end</span><span class="p">();</span>

<span class="cm">/*Second render pass draws the outline, using a &quot;line-strip&quot; topology.*/</span>

<span class="nx">renderPassDescriptor</span><span class="p">.</span><span class="nx">colorAttachments</span><span class="p">[</span><span class="mf">0</span><span class="p">].</span><span class="nx">loadOp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;load&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// DON&#39;T clear!</span>
<span class="nx">passEncoder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">commandEncoder</span><span class="p">.</span><span class="nx">beginRenderPass</span><span class="p">(</span><span class="nx">renderPassDescriptor</span><span class="p">);</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">setPipeline</span><span class="p">(</span><span class="nx">pipelineForOutline</span><span class="p">);</span><span class="w"> </span><span class="c1">// uses &quot;line-strip&quot;</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">setVertexBuffer</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="nx">vertexBuffer</span><span class="p">);</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">draw</span><span class="p">(</span><span class="nx">VERTEX_COUNT</span><span class="o">+</span><span class="mf">1</span><span class="p">);</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">end</span><span class="p">();</span>

<span class="kd">let</span><span class="w"> </span><span class="nx">commandBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">commandEncoder</span><span class="p">.</span><span class="nx">finish</span><span class="p">();</span>
<span class="nx">device</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">submit</span><span class="p">([</span><span class="nx">commandBuffer</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div>
<p>Note that for the first render pass, the loadOp is "clear", since we want to fill the image with the background color before <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> the disk. For the second render pass, we want to draw the outline on top of the existing image, so the loadOp must be "load". The same renderPassDescriptor can be used for both passes, with just the loadOp property changed.</p>
</div>
</div>
</div>
<h2 id="923-绘制多个基元">9.2.3 绘制多个基元<a class="headerlink" href="#923-绘制多个基元" title="Permanent link">&para;</a></h2>
<p><strong>Drawing Multiple Primitives</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="4:2"><input checked="checked" id="__tabbed_4_1" name="__tabbed_4" type="radio" /><input id="__tabbed_4_2" name="__tabbed_4" type="radio" /><div class="tabbed-labels"><label for="__tabbed_4_1">中文</label><label for="__tabbed_4_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>I would like to draw the outlines of the colored disks in my moving disk example. However I can't simply use <abbr title="The ability to render multiple versions of a primitive with a single function call. Each copy can have its own values for certain attributes, such as color or transformation.">instanced drawing</abbr> to draw all the disks, then use it again to draw the outlines, since that would show the complete outline of every disk, even parts of the outline that should be hidden by other disks. (Actually, I can do that if I add a <abbr title="A solution to the hidden surface problem that involves keeping track of the depth, or distance from the viewer, of the object currently visible at each pixel in the image. When a new object is drawn at a pixel, the depth of the new object is compared to the depth of the current object to decide which one is closer to the viewer. The advantage of the depth test is that objects can be rendered in any order. A disadvantage is that only a limited range of depths can be represented in the image.">depth test</abbr> to the program (see <a href="../s4/#941-深度测试">Subsection 9.4.1</a>).) A solution is to abandon <abbr title="The ability to render multiple versions of a primitive with a single function call. Each copy can have its own values for certain attributes, such as color or transformation.">instanced drawing</abbr> and draw each disk separately. That's what I do in the sample program <a href="../../../en/source/webgpu/draw_multiple.html">webgpu/draw_multiple.html</a>. That program also introduces a few new <abbr title="A new JavaScript graphics API, similar to WebGL, but designed to let web programs access modern GPU capabilities such as compute shaders.">WebGPU</abbr> features.</p>
<p>Each disk in the new program is drawn in the same way as the single disk in <a href="../../../en/source/webgpu/indexed_draw.html">webgpu/indexed_draw.html</a>. The problem is that the disks have different colors and offsets. In <a href="../../../en/source/webgpu/instanced_draw.html">webgpu/instanced_draw.html</a>, the color and offset were instance properties that came from <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffers, and their values were passed as parameters into the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> function. In the new program, they are moved into a <abbr title="Variables that represent input to a shader program in a programmable graphics pipeline. A uniform variable has the same value at every vertex and at every pixel of a primitive.">uniform variable</abbr> in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program:</p>
<div class="highlight"><pre><span></span><code><span class="nx">struct</span><span class="w"> </span><span class="nx">DiskInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">color</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">vec3f</span><span class="p">,</span><span class="w">  </span><span class="c1">// interior color for the disk</span>
<span class="w">    </span><span class="nx">offset</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">vec2f</span><span class="w">  </span><span class="c1">// translation applied to the disk</span>
<span class="p">}</span>

<span class="err">@</span><span class="nx">group</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="err">@</span><span class="nx">binding</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="kd">var</span><span class="o">&lt;</span><span class="nx">uniform</span><span class="o">&gt;</span><span class="w"> </span><span class="nx">diskInfo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">DiskInfo</span><span class="p">;</span>
</code></pre></div>
<p>The values for the <abbr title="Variables that represent input to a shader program in a programmable graphics pipeline. A uniform variable has the same value at every vertex and at every pixel of a primitive.">uniform variable</abbr> are stored in a uniform buffer. Before drawing each disk, the color and offset for that disk must be copied into the uniform buffer. The basic idea is simple:</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="nx">each</span><span class="w"> </span><span class="nx">disk</span><span class="o">:</span>
<span class="w">    </span><span class="nx">copy</span><span class="w"> </span><span class="nx">offset</span><span class="w"> </span><span class="nx">and</span><span class="w"> </span><span class="nx">color</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nx">that</span><span class="w"> </span><span class="nx">disk</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">uniform</span><span class="w"> </span><span class="nx">buffer</span>
<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="nx">render</span><span class="w"> </span><span class="nx">pass</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">draw</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">disk</span><span class="w"> </span><span class="nx">interior</span>
<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="nx">render</span><span class="w"> </span><span class="nx">pass</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">draw</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">disk</span><span class="w"> </span><span class="nx">outline</span>
</code></pre></div>
<p>Previously, we have used device.queue.writeBuffer() to copy data from the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side into a buffer on the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>. That would work, provided that we use a new command encoder for each iteration of the loop. (In fact, that's what I do in an alternative version of the program, <a href="../../../en/source/webgpu/draw_multiple_2.html">webgpu/draw_multiple_2.html</a>. See the comments in that program for more information.)</p>
<p>However, I decided to complicate things—and hopefully make the program a little more efficient—by using a single command encoder to do all the drawing. But that makes it impossible to use writeBuffer(). Let's see why. A command encoder doesn't execute commands, it just makes a list of commands that will be submitted to the device queue in a batch after the list is complete. Similarly, when writeBuffer() is called, it doesn't immediately write to the buffer. But it does immediately add a command to the device queue to do the writing. If we do the calls to writeBuffer() in the middle of collecting the draw commands in a command encoder, then when we submit the draw commands in a batch at the end, all the write commands will already be in the queue. So, all of the write commands will actually be executed before <strong>any</strong> the draw commands. Only the final write will have <strong>any</strong> effect on the drawing!</p>
<p>The solution is to replace <em>writeBuffer()</em> with a copy command that can be encoded and added to the list of commands produced by a command encoder. Then, when the list of commands is executed on the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>, each copy will be done just before the draw command that uses it. But since the copying will be done on the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>, the data that is being copied must already be in a <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> buffer. The command that we want is</p>
<div class="highlight"><pre><span></span><code><span class="nx">commandEncoder</span><span class="p">.</span><span class="nx">copyBufferToBuffer</span><span class="p">(</span><span class="w"> </span><span class="nx">destinationBuffer</span><span class="p">,</span><span class="w"> </span><span class="nx">destinationStartByte</span><span class="p">,</span>
<span class="w">        </span><span class="nx">sourceBuffer</span><span class="p">,</span><span class="w"> </span><span class="nx">sourceStartByte</span><span class="p">,</span><span class="w"> </span><span class="nx">byteCount</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>To implement this, the program copies the color values for all the disks into a <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> buffer, and copies the offset values into another <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> buffer. Using buffers for these values is similar to what we did for <abbr title="The ability to render multiple versions of a primitive with a single function call. Each copy can have its own values for certain attributes, such as color or transformation.">instanced drawing</abbr>, but the buffers in this case are not <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffers. Instead, they are <strong><abbr title="In WebGPU, a general purpose buffer on the GPU, which can be used in compute shaders as well as in vertex and fragment shaders.">storage buffers</abbr></strong>, a kind of general purpose <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> buffer. They can be used much like uniform buffers but have fewer restrictions and might be a little less efficient. Here is how the <abbr title="In WebGPU, a general purpose buffer on the GPU, which can be used in compute shaders as well as in vertex and fragment shaders.">storage buffer</abbr> for the disk colors is created and filled with data as part of program initialization:</p>
<div class="highlight"><pre><span></span><code><span class="nx">diskColorBuffer</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="nx">device</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">({</span>
<span class="w">    </span><span class="nx">size</span><span class="o">:</span><span class="w"> </span><span class="nx">diskColors</span><span class="p">.</span><span class="nx">byteLength</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="nx">usage</span><span class="o">:</span><span class="w"> </span><span class="nx">GPUBufferUsage</span><span class="p">.</span><span class="nx">STORAGE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span>
<span class="w">                </span><span class="nx">GPUBufferUsage</span><span class="p">.</span><span class="nx">COPY_SRC</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">GPUBufferUsage</span><span class="p">.</span><span class="nx">COPY_DST</span>
<span class="p">});</span><span class="w">   </span>
<span class="nx">device</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">writeBuffer</span><span class="p">(</span><span class="nx">diskColorBuffer</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">diskColors</span><span class="p">);</span>
</code></pre></div>
<p>The usage property includes STORAGE because the buffer is a <abbr title="In WebGPU, a general purpose buffer on the GPU, which can be used in compute shaders as well as in vertex and fragment shaders.">storage buffer</abbr>; it includes COPY_SRC so that the buffer can be used as the source buffer in copyBufferToBuffer(); and it includes COPY_DST so that the buffer can be used as the destination buffer in writeBuffer().</p>
<p>When a <abbr title="In WebGPU, a general purpose buffer on the GPU, which can be used in compute shaders as well as in vertex and fragment shaders.">storage buffer</abbr> is used in a <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program, it must be part of a bind group. In this program, however, the <abbr title="In WebGPU, a general purpose buffer on the GPU, which can be used in compute shaders as well as in vertex and fragment shaders.">storage buffers</abbr> are not used in the shaders, and the only thing in the bind group is the small uniform buffer that holds the color and offset for one disk at a time.</p>
<p>The command for copying the color for disk number i from the <abbr title="In WebGPU, a general purpose buffer on the GPU, which can be used in compute shaders as well as in vertex and fragment shaders.">storage buffer</abbr> to the uniform buffer then becomes</p>
<div class="highlight"><pre><span></span><code><span class="nx">commandEncoder</span><span class="p">.</span><span class="nx">copyBufferToBuffer</span><span class="p">(</span><span class="w"> </span><span class="nx">diskColorBuffer</span><span class="p">,</span><span class="w"> </span><span class="mf">12</span><span class="o">*</span><span class="nx">i</span><span class="p">,</span>
<span class="w">                                            </span><span class="nx">uniformBuffer</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">12</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>The color data in diskColorBuffer for each disk takes up 12 bytes (three 32-bit floats), so the starting byte for the color for disk number i is 12*i. In uniformBuffer, the color starts at byte number 0. And the byte count, 12, is the number of bytes to be copied.</p>
<p>The disk offset is handled in a similar way, but there is one more issue to deal with: <strong><abbr title="Restrictions on the legal location of a value in memory, depending on the data type. For example, the address of a vec3f variable in WGSL must be a multiple of 16.">alignment</abbr></strong> rules in <abbr title="The WebGPU Shader Language, the programming language in which shaders for use in WebGPU are written.">WGSL</abbr>. Alignment refers to restrictions on where a value can be located in memory. The restrictions can make memory access more efficient. For example, the <abbr title="Restrictions on the legal location of a value in memory, depending on the data type. For example, the address of a vec3f variable in WGSL must be a multiple of 16.">alignment</abbr> rule for a vec2f says that its address in memory must be multiple of 8 bytes. The <abbr title="Variables that represent input to a shader program in a programmable graphics pipeline. A uniform variable has the same value at every vertex and at every pixel of a primitive.">uniform variable</abbr>, diskInfo, is a struct that contains a vec3f for the color followed by a vec2f for the offset. The vec3f takes up 12 bytes in memory. But the <abbr title="Restrictions on the legal location of a value in memory, depending on the data type. For example, the address of a vec3f variable in WGSL must be a multiple of 16.">alignment</abbr> rule for the vec2f says that it must start at a multiple of 8 bytes. So, an extra byte of padding is added after the color, moving the starting byte number for the offset to 16. When the offset is copied from the <abbr title="In WebGPU, a general purpose buffer on the GPU, which can be used in compute shaders as well as in vertex and fragment shaders.">storage buffer</abbr> to the uniform buffer, the starting byte is 16, rather than the 12 that you might have expected:</p>
<div class="highlight"><pre><span></span><code><span class="nx">commandEncoder</span><span class="p">.</span><span class="nx">copyBufferToBuffer</span><span class="p">(</span><span class="w"> </span><span class="nx">diskOffsetBuffer</span><span class="p">,</span><span class="w"> </span><span class="mf">8</span><span class="o">*</span><span class="nx">i</span><span class="p">,</span>
<span class="w">                                            </span><span class="nx">uniformBuffer</span><span class="p">,</span><span class="w"> </span><span class="mf">16</span><span class="p">,</span><span class="w"> </span><span class="mf">8</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>I will have more to say about <abbr title="Restrictions on the legal location of a value in memory, depending on the data type. For example, the address of a vec3f variable in WGSL must be a multiple of 16.">alignment</abbr> in <a href="../s3/#931-地址空间和对齐">Subsection 9.3.1</a>. You should be able to understand the rest of the <a href="../../../en/source/webgpu/draw_multiple.html">program source</a>. As always, read the comments.</p>
</div>
<div class="tabbed-block">
<p>I would like to draw the outlines of the colored disks in my moving disk example. However I can't simply use <abbr title="The ability to render multiple versions of a primitive with a single function call. Each copy can have its own values for certain attributes, such as color or transformation.">instanced drawing</abbr> to draw all the disks, then use it again to draw the outlines, since that would show the complete outline of every disk, even parts of the outline that should be hidden by other disks. (Actually, I can do that if I add a <abbr title="A solution to the hidden surface problem that involves keeping track of the depth, or distance from the viewer, of the object currently visible at each pixel in the image. When a new object is drawn at a pixel, the depth of the new object is compared to the depth of the current object to decide which one is closer to the viewer. The advantage of the depth test is that objects can be rendered in any order. A disadvantage is that only a limited range of depths can be represented in the image.">depth test</abbr> to the program (see <a href="../s4/#941-深度测试">Subsection 9.4.1</a>).) A solution is to abandon <abbr title="The ability to render multiple versions of a primitive with a single function call. Each copy can have its own values for certain attributes, such as color or transformation.">instanced drawing</abbr> and draw each disk separately. That's what I do in the sample program <a href="../../../en/source/webgpu/draw_multiple.html">webgpu/draw_multiple.html</a>. That program also introduces a few new <abbr title="A new JavaScript graphics API, similar to WebGL, but designed to let web programs access modern GPU capabilities such as compute shaders.">WebGPU</abbr> features.</p>
<p>Each disk in the new program is drawn in the same way as the single disk in <a href="../../../en/source/webgpu/indexed_draw.html">webgpu/indexed_draw.html</a>. The problem is that the disks have different colors and offsets. In <a href="../../../en/source/webgpu/instanced_draw.html">webgpu/instanced_draw.html</a>, the color and offset were instance properties that came from <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffers, and their values were passed as parameters into the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> function. In the new program, they are moved into a <abbr title="Variables that represent input to a shader program in a programmable graphics pipeline. A uniform variable has the same value at every vertex and at every pixel of a primitive.">uniform variable</abbr> in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program:</p>
<div class="highlight"><pre><span></span><code><span class="nx">struct</span><span class="w"> </span><span class="nx">DiskInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">color</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">vec3f</span><span class="p">,</span><span class="w">  </span><span class="c1">// interior color for the disk</span>
<span class="w">    </span><span class="nx">offset</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">vec2f</span><span class="w">  </span><span class="c1">// translation applied to the disk</span>
<span class="p">}</span>

<span class="err">@</span><span class="nx">group</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="err">@</span><span class="nx">binding</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="kd">var</span><span class="o">&lt;</span><span class="nx">uniform</span><span class="o">&gt;</span><span class="w"> </span><span class="nx">diskInfo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">DiskInfo</span><span class="p">;</span>
</code></pre></div>
<p>The values for the <abbr title="Variables that represent input to a shader program in a programmable graphics pipeline. A uniform variable has the same value at every vertex and at every pixel of a primitive.">uniform variable</abbr> are stored in a uniform buffer. Before drawing each disk, the color and offset for that disk must be copied into the uniform buffer. The basic idea is simple:</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="nx">each</span><span class="w"> </span><span class="nx">disk</span><span class="o">:</span>
<span class="w">    </span><span class="nx">copy</span><span class="w"> </span><span class="nx">offset</span><span class="w"> </span><span class="nx">and</span><span class="w"> </span><span class="nx">color</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nx">that</span><span class="w"> </span><span class="nx">disk</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">uniform</span><span class="w"> </span><span class="nx">buffer</span>
<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="nx">render</span><span class="w"> </span><span class="nx">pass</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">draw</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">disk</span><span class="w"> </span><span class="nx">interior</span>
<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="nx">render</span><span class="w"> </span><span class="nx">pass</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">draw</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">disk</span><span class="w"> </span><span class="nx">outline</span>
</code></pre></div>
<p>Previously, we have used device.queue.writeBuffer() to copy data from the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side into a buffer on the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>. That would work, provided that we use a new command encoder for each iteration of the loop. (In fact, that's what I do in an alternative version of the program, <a href="../../../en/source/webgpu/draw_multiple_2.html">webgpu/draw_multiple_2.html</a>. See the comments in that program for more information.)</p>
<p>However, I decided to complicate things—and hopefully make the program a little more efficient—by using a single command encoder to do all the drawing. But that makes it impossible to use writeBuffer(). Let's see why. A command encoder doesn't execute commands, it just makes a list of commands that will be submitted to the device queue in a batch after the list is complete. Similarly, when writeBuffer() is called, it doesn't immediately write to the buffer. But it does immediately add a command to the device queue to do the writing. If we do the calls to writeBuffer() in the middle of collecting the draw commands in a command encoder, then when we submit the draw commands in a batch at the end, all the write commands will already be in the queue. So, all of the write commands will actually be executed before <strong>any</strong> the draw commands. Only the final write will have <strong>any</strong> effect on the drawing!</p>
<p>The solution is to replace <em>writeBuffer()</em> with a copy command that can be encoded and added to the list of commands produced by a command encoder. Then, when the list of commands is executed on the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>, each copy will be done just before the draw command that uses it. But since the copying will be done on the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>, the data that is being copied must already be in a <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> buffer. The command that we want is</p>
<div class="highlight"><pre><span></span><code><span class="nx">commandEncoder</span><span class="p">.</span><span class="nx">copyBufferToBuffer</span><span class="p">(</span><span class="w"> </span><span class="nx">destinationBuffer</span><span class="p">,</span><span class="w"> </span><span class="nx">destinationStartByte</span><span class="p">,</span>
<span class="w">        </span><span class="nx">sourceBuffer</span><span class="p">,</span><span class="w"> </span><span class="nx">sourceStartByte</span><span class="p">,</span><span class="w"> </span><span class="nx">byteCount</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>To implement this, the program copies the color values for all the disks into a <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> buffer, and copies the offset values into another <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> buffer. Using buffers for these values is similar to what we did for <abbr title="The ability to render multiple versions of a primitive with a single function call. Each copy can have its own values for certain attributes, such as color or transformation.">instanced drawing</abbr>, but the buffers in this case are not <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffers. Instead, they are <strong><abbr title="In WebGPU, a general purpose buffer on the GPU, which can be used in compute shaders as well as in vertex and fragment shaders.">storage buffers</abbr></strong>, a kind of general purpose <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> buffer. They can be used much like uniform buffers but have fewer restrictions and might be a little less efficient. Here is how the <abbr title="In WebGPU, a general purpose buffer on the GPU, which can be used in compute shaders as well as in vertex and fragment shaders.">storage buffer</abbr> for the disk colors is created and filled with data as part of program initialization:</p>
<div class="highlight"><pre><span></span><code><span class="nx">diskColorBuffer</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="nx">device</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">({</span>
<span class="w">    </span><span class="nx">size</span><span class="o">:</span><span class="w"> </span><span class="nx">diskColors</span><span class="p">.</span><span class="nx">byteLength</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="nx">usage</span><span class="o">:</span><span class="w"> </span><span class="nx">GPUBufferUsage</span><span class="p">.</span><span class="nx">STORAGE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span>
<span class="w">                </span><span class="nx">GPUBufferUsage</span><span class="p">.</span><span class="nx">COPY_SRC</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">GPUBufferUsage</span><span class="p">.</span><span class="nx">COPY_DST</span>
<span class="p">});</span><span class="w">   </span>
<span class="nx">device</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">writeBuffer</span><span class="p">(</span><span class="nx">diskColorBuffer</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">diskColors</span><span class="p">);</span>
</code></pre></div>
<p>The usage property includes STORAGE because the buffer is a <abbr title="In WebGPU, a general purpose buffer on the GPU, which can be used in compute shaders as well as in vertex and fragment shaders.">storage buffer</abbr>; it includes COPY_SRC so that the buffer can be used as the source buffer in copyBufferToBuffer(); and it includes COPY_DST so that the buffer can be used as the destination buffer in writeBuffer().</p>
<p>When a <abbr title="In WebGPU, a general purpose buffer on the GPU, which can be used in compute shaders as well as in vertex and fragment shaders.">storage buffer</abbr> is used in a <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program, it must be part of a bind group. In this program, however, the <abbr title="In WebGPU, a general purpose buffer on the GPU, which can be used in compute shaders as well as in vertex and fragment shaders.">storage buffers</abbr> are not used in the shaders, and the only thing in the bind group is the small uniform buffer that holds the color and offset for one disk at a time.</p>
<p>The command for copying the color for disk number i from the <abbr title="In WebGPU, a general purpose buffer on the GPU, which can be used in compute shaders as well as in vertex and fragment shaders.">storage buffer</abbr> to the uniform buffer then becomes</p>
<div class="highlight"><pre><span></span><code><span class="nx">commandEncoder</span><span class="p">.</span><span class="nx">copyBufferToBuffer</span><span class="p">(</span><span class="w"> </span><span class="nx">diskColorBuffer</span><span class="p">,</span><span class="w"> </span><span class="mf">12</span><span class="o">*</span><span class="nx">i</span><span class="p">,</span>
<span class="w">                                            </span><span class="nx">uniformBuffer</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">12</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>The color data in diskColorBuffer for each disk takes up 12 bytes (three 32-bit floats), so the starting byte for the color for disk number i is 12*i. In uniformBuffer, the color starts at byte number 0. And the byte count, 12, is the number of bytes to be copied.</p>
<p>The disk offset is handled in a similar way, but there is one more issue to deal with: <strong><abbr title="Restrictions on the legal location of a value in memory, depending on the data type. For example, the address of a vec3f variable in WGSL must be a multiple of 16.">alignment</abbr></strong> rules in <abbr title="The WebGPU Shader Language, the programming language in which shaders for use in WebGPU are written.">WGSL</abbr>. Alignment refers to restrictions on where a value can be located in memory. The restrictions can make memory access more efficient. For example, the <abbr title="Restrictions on the legal location of a value in memory, depending on the data type. For example, the address of a vec3f variable in WGSL must be a multiple of 16.">alignment</abbr> rule for a vec2f says that its address in memory must be multiple of 8 bytes. The <abbr title="Variables that represent input to a shader program in a programmable graphics pipeline. A uniform variable has the same value at every vertex and at every pixel of a primitive.">uniform variable</abbr>, diskInfo, is a struct that contains a vec3f for the color followed by a vec2f for the offset. The vec3f takes up 12 bytes in memory. But the <abbr title="Restrictions on the legal location of a value in memory, depending on the data type. For example, the address of a vec3f variable in WGSL must be a multiple of 16.">alignment</abbr> rule for the vec2f says that it must start at a multiple of 8 bytes. So, an extra byte of padding is added after the color, moving the starting byte number for the offset to 16. When the offset is copied from the <abbr title="In WebGPU, a general purpose buffer on the GPU, which can be used in compute shaders as well as in vertex and fragment shaders.">storage buffer</abbr> to the uniform buffer, the starting byte is 16, rather than the 12 that you might have expected:</p>
<div class="highlight"><pre><span></span><code><span class="nx">commandEncoder</span><span class="p">.</span><span class="nx">copyBufferToBuffer</span><span class="p">(</span><span class="w"> </span><span class="nx">diskOffsetBuffer</span><span class="p">,</span><span class="w"> </span><span class="mf">8</span><span class="o">*</span><span class="nx">i</span><span class="p">,</span>
<span class="w">                                            </span><span class="nx">uniformBuffer</span><span class="p">,</span><span class="w"> </span><span class="mf">16</span><span class="p">,</span><span class="w"> </span><span class="mf">8</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>I will have more to say about <abbr title="Restrictions on the legal location of a value in memory, depending on the data type. For example, the address of a vec3f variable in WGSL must be a multiple of 16.">alignment</abbr> in <a href="../s3/#931-地址空间和对齐">Subsection 9.3.1</a>. You should be able to understand the rest of the <a href="../../../en/source/webgpu/draw_multiple.html">program source</a>. As always, read the comments.</p>
</div>
</div>
</div>
<h2 id="924-在着色器中使用索引">9.2.4 在着色器中使用索引<a class="headerlink" href="#924-在着色器中使用索引" title="Permanent link">&para;</a></h2>
<p><strong>Using Indices in Shaders</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="5:2"><input checked="checked" id="__tabbed_5_1" name="__tabbed_5" type="radio" /><input id="__tabbed_5_2" name="__tabbed_5" type="radio" /><div class="tabbed-labels"><label for="__tabbed_5_1">中文</label><label for="__tabbed_5_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>In <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>, each point in a primitive of type POINTS can have a size. The point is rendered as a square with the given size, and the square comes with <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates. (See <a href="../../c6/s2/#625-points原语">Subsection 6.2.5</a>.) In <abbr title="A new JavaScript graphics API, similar to WebGL, but designed to let web programs access modern GPU capabilities such as compute shaders.">WebGPU</abbr>, there is no similar idea of point size for primitives with the point-list topology; the points are just individual <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr>, which limits their usefulness.</p>
<p>Now, in <abbr title="A new JavaScript graphics API, similar to WebGL, but designed to let web programs access modern GPU capabilities such as compute shaders.">WebGPU</abbr>, we could easily use <abbr title="The ability to render multiple versions of a primitive with a single function call. Each copy can have its own values for certain attributes, such as color or transformation.">instanced drawing</abbr> to render multiple copies of a square and do something very similar to the <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> POINTS primitive. However, I would like to use a different approach, to illustrate a new <abbr title="A new JavaScript graphics API, similar to WebGL, but designed to let web programs access modern GPU capabilities such as compute shaders.">WebGPU</abbr> feature: using <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> and instance indices in shaders. I do that in the sample program <a href="../../../en/source/webgpu/indices_in_shader.html">webgpu/indices_in_shader.html</a>, which shows the same moving disks as the first example in this section but does so in a very different way.</p>
<p>We have seen how parameter values for a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> function can come from <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffers. But there are also certain "builtin" values that can be used as parameters. This includes the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> index and the instance index of the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> that is being processed. For example, the definition of the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> function in the sample program is</p>
<div class="highlight"><pre><span></span><code><span class="err">@</span><span class="nx">vertex</span>
<span class="nx">fn</span><span class="w"> </span><span class="nx">vertMain</span><span class="p">(</span>
<span class="w">    </span><span class="err">@</span><span class="nx">builtin</span><span class="p">(</span><span class="nx">vertex_index</span><span class="p">)</span><span class="w"> </span><span class="nx">vertexNumInPoint</span><span class="o">:</span><span class="w"> </span><span class="nx">u32</span><span class="p">,</span>
<span class="w">    </span><span class="err">@</span><span class="nx">builtin</span><span class="p">(</span><span class="nx">instance_index</span><span class="p">)</span><span class="w"> </span><span class="nx">pointNum</span><span class="o">:</span><span class="w"> </span><span class="nx">u32</span>
<span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nx">VertexOutput</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="p">.</span>
</code></pre></div>
<p>If this function is invoked by a call to draw(vertexCt,instanceCt) in a render pass encoder, the effect is similar to this pseudocode:</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">instance_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">instance_index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">instanceCt</span><span class="p">;</span><span class="w"> </span><span class="nx">instance_index</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">vertex_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">vertex_index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">vertexCt</span><span class="p">;</span><span class="w"> </span><span class="nx">vertex_index</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="nx">vertMain</span><span class="p">(</span><span class="w"> </span><span class="nx">instance_index</span><span class="p">,</span><span class="w"> </span><span class="nx">vertex_index</span><span class="w"> </span><span class="p">)</span>
</code></pre></div>
<p>Note that in this example there are no parameter inputs from <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffers. But the job of the function is still to output coordinates and possibly other data for <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> number vertex_index in instance number instance_index. It needs to create that output somehow!</p>
<p>The <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> still has access to data from other sources, such as buffers that are part of <abbr title="A data structure that can hold resources such as buffers, textures, and samples, for input into a pipeline.">bind groups</abbr>. In this example, I provide the necessary data in two <abbr title="In WebGPU, a general purpose buffer on the GPU, which can be used in compute shaders as well as in vertex and fragment shaders.">storage buffers</abbr>. One <abbr title="In WebGPU, a general purpose buffer on the GPU, which can be used in compute shaders as well as in vertex and fragment shaders.">storage buffer</abbr> contains a color for each square, and one contains the coordinates of the center point for each square. The size of the square is a constant in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program. The output for a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> consists of coordinates, <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates, and color for that <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>. Each instance is a square, generated as a triangle-list primitive with two triangles, so that the number of vertices in an instance is six. The coordinates and <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates for each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> can be computed from the center point and the size of the square:</p>
<p><a class="glightbox" href="../../../en/c9/square-as-triangle-list.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="The coords and texture coords of vertices of a square computed from center point and size" src="../../../en/c9/square-as-triangle-list.png" /></a></p>
<p>For each instance, the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> function is invoked six times, with a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> index ranging from 0 to 5. In each invocation, the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> function computes and outputs the appropriate values for just one <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>. I won't go into the coding details here; you can read them in the <a href="../../../en/source/webgpu/indices_in_shader.html">sample program</a> source code.</p>
<p>There is one more point of interest in the program: I really wanted to draw disks, not squares, and I wanted to have some use for the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates on the square. So the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> function uses the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates for a <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> to discard that <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> if it lies outside the disk. (This is similar to what was done in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> for the <a href="../../../en/demos/c6/textured-points.html">demo</a> in <a href="../../c6/s4/#642-处理图像">Subsection 6.4.2</a>.)</p>
</div>
<div class="tabbed-block">
<p>In <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>, each point in a primitive of type POINTS can have a size. The point is rendered as a square with the given size, and the square comes with <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates. (See <a href="../../c6/s2/#625-points原语">Subsection 6.2.5</a>.) In <abbr title="A new JavaScript graphics API, similar to WebGL, but designed to let web programs access modern GPU capabilities such as compute shaders.">WebGPU</abbr>, there is no similar idea of point size for primitives with the point-list topology; the points are just individual <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr>, which limits their usefulness.</p>
<p>Now, in <abbr title="A new JavaScript graphics API, similar to WebGL, but designed to let web programs access modern GPU capabilities such as compute shaders.">WebGPU</abbr>, we could easily use <abbr title="The ability to render multiple versions of a primitive with a single function call. Each copy can have its own values for certain attributes, such as color or transformation.">instanced drawing</abbr> to render multiple copies of a square and do something very similar to the <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> POINTS primitive. However, I would like to use a different approach, to illustrate a new <abbr title="A new JavaScript graphics API, similar to WebGL, but designed to let web programs access modern GPU capabilities such as compute shaders.">WebGPU</abbr> feature: using <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> and instance indices in shaders. I do that in the sample program <a href="../../../en/source/webgpu/indices_in_shader.html">webgpu/indices_in_shader.html</a>, which shows the same moving disks as the first example in this section but does so in a very different way.</p>
<p>We have seen how parameter values for a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> function can come from <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffers. But there are also certain "builtin" values that can be used as parameters. This includes the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> index and the instance index of the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> that is being processed. For example, the definition of the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> function in the sample program is</p>
<div class="highlight"><pre><span></span><code><span class="err">@</span><span class="nx">vertex</span>
<span class="nx">fn</span><span class="w"> </span><span class="nx">vertMain</span><span class="p">(</span>
<span class="w">    </span><span class="err">@</span><span class="nx">builtin</span><span class="p">(</span><span class="nx">vertex_index</span><span class="p">)</span><span class="w"> </span><span class="nx">vertexNumInPoint</span><span class="o">:</span><span class="w"> </span><span class="nx">u32</span><span class="p">,</span>
<span class="w">    </span><span class="err">@</span><span class="nx">builtin</span><span class="p">(</span><span class="nx">instance_index</span><span class="p">)</span><span class="w"> </span><span class="nx">pointNum</span><span class="o">:</span><span class="w"> </span><span class="nx">u32</span>
<span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nx">VertexOutput</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="p">.</span>
</code></pre></div>
<p>If this function is invoked by a call to draw(vertexCt,instanceCt) in a render pass encoder, the effect is similar to this pseudocode:</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">instance_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">instance_index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">instanceCt</span><span class="p">;</span><span class="w"> </span><span class="nx">instance_index</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">vertex_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">vertex_index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">vertexCt</span><span class="p">;</span><span class="w"> </span><span class="nx">vertex_index</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="nx">vertMain</span><span class="p">(</span><span class="w"> </span><span class="nx">instance_index</span><span class="p">,</span><span class="w"> </span><span class="nx">vertex_index</span><span class="w"> </span><span class="p">)</span>
</code></pre></div>
<p>Note that in this example there are no parameter inputs from <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffers. But the job of the function is still to output coordinates and possibly other data for <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> number vertex_index in instance number instance_index. It needs to create that output somehow!</p>
<p>The <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> still has access to data from other sources, such as buffers that are part of <abbr title="A data structure that can hold resources such as buffers, textures, and samples, for input into a pipeline.">bind groups</abbr>. In this example, I provide the necessary data in two <abbr title="In WebGPU, a general purpose buffer on the GPU, which can be used in compute shaders as well as in vertex and fragment shaders.">storage buffers</abbr>. One <abbr title="In WebGPU, a general purpose buffer on the GPU, which can be used in compute shaders as well as in vertex and fragment shaders.">storage buffer</abbr> contains a color for each square, and one contains the coordinates of the center point for each square. The size of the square is a constant in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program. The output for a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> consists of coordinates, <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates, and color for that <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>. Each instance is a square, generated as a triangle-list primitive with two triangles, so that the number of vertices in an instance is six. The coordinates and <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates for each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> can be computed from the center point and the size of the square:</p>
<p><a class="glightbox" href="../../../en/c9/square-as-triangle-list.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="The coords and texture coords of vertices of a square computed from center point and size" src="../../../en/c9/square-as-triangle-list.png" /></a></p>
<p>For each instance, the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> function is invoked six times, with a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> index ranging from 0 to 5. In each invocation, the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> function computes and outputs the appropriate values for just one <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>. I won't go into the coding details here; you can read them in the <a href="../../../en/source/webgpu/indices_in_shader.html">sample program</a> source code.</p>
<p>There is one more point of interest in the program: I really wanted to draw disks, not squares, and I wanted to have some use for the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates on the square. So the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> function uses the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates for a <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> to discard that <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> if it lies outside the disk. (This is similar to what was done in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> for the <a href="../../../en/demos/c6/textured-points.html">demo</a> in <a href="../../c6/s4/#642-处理图像">Subsection 6.4.2</a>.)</p>
</div>
</div>
</div>
<h2 id="925-多重采样">9.2.5 多重采样<a class="headerlink" href="#925-多重采样" title="Permanent link">&para;</a></h2>
<p><strong>Multisampling</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="6:2"><input checked="checked" id="__tabbed_6_1" name="__tabbed_6" type="radio" /><input id="__tabbed_6_2" name="__tabbed_6" type="radio" /><div class="tabbed-labels"><label for="__tabbed_6_1">中文</label><label for="__tabbed_6_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>The final example for this section is <a href="../../../en/source/webgpu/multisampling.html">webgpu/<abbr title="A kind of antialiasing where the fragment shader is evaluated at several points in each pixel, and the results are averaged to get the color of the pixel.">multisampling</abbr>.html</a>, which adds <abbr title="A kind of antialiasing where the fragment shader is evaluated at several points in each pixel, and the results are averaged to get the color of the pixel.">multisampling</abbr> to the basic moving disks example. Ordinarily, the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> entry point function is evaluated once per <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>, at the center point of the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>. With <abbr title="A kind of antialiasing where the fragment shader is evaluated at several points in each pixel, and the results are averaged to get the color of the pixel.">multisampling</abbr>, it is evaluated at several points within each <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>, and the color for that <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> is obtained by averaging the colors from each of those samples. This is a kind of <abbr title="A technique used to reduce the jagged or &quot;staircase&quot; appearance of diagonal lines, text, and other shapes that are drawn using pixels. When a pixel is only partly covered by a geometric shape, then the color of the pixel is a blend of the color of the shape and the color of the background, with the degree of blending depending on the fraction of the pixel that is covered by the geometric shape.">antialiasing</abbr>. For example, when the geometric edge of a primitive cuts through a <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>, some sampled points might lie inside the primitive and some outside. The color of the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> will then be a blend of the primitive color and the background color. Or, when a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> is applied, the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> color for the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> will be a blend of the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> colors at the sampled points.</p>
<p><abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> will do <abbr title="A technique used to reduce the jagged or &quot;staircase&quot; appearance of diagonal lines, text, and other shapes that are drawn using pixels. When a pixel is only partly covered by a geometric shape, then the color of the pixel is a blend of the color of the shape and the color of the background, with the degree of blending depending on the fraction of the pixel that is covered by the geometric shape.">antialiasing</abbr> automatically, but in <abbr title="A new JavaScript graphics API, similar to WebGL, but designed to let web programs access modern GPU capabilities such as compute shaders.">WebGPU</abbr>, you have to do some work. Fortunately, it's not very hard. There are just a few changes from a non-multisampled program. First, you need a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> for <abbr title="A kind of antialiasing where the fragment shader is evaluated at several points in each pixel, and the results are averaged to get the color of the pixel.">multisampling</abbr>, and a view of that <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. (I will admit that I don't understand why this is needed.) The code for that is a preview of creating textures and <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> views:</p>
<div class="highlight"><pre><span></span><code><span class="nx">textureForMultisampling</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createTexture</span><span class="p">({</span>
<span class="w">    </span><span class="nx">size</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="nx">context</span><span class="p">.</span><span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span><span class="w"> </span><span class="nx">context</span><span class="p">.</span><span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span><span class="p">],</span>
<span class="w">    </span><span class="nx">sampleCount</span><span class="o">:</span><span class="w"> </span><span class="mf">4</span><span class="p">,</span><span class="w">  </span><span class="c1">// (1 and 4 are currently the only possible values.)</span>
<span class="w">    </span><span class="nx">format</span><span class="o">:</span><span class="w"> </span><span class="nx">navigator</span><span class="p">.</span><span class="nx">gpu</span><span class="p">.</span><span class="nx">getPreferredCanvasFormat</span><span class="p">(),</span>
<span class="w">    </span><span class="nx">usage</span><span class="o">:</span><span class="w"> </span><span class="nx">GPUTextureUsage</span><span class="p">.</span><span class="nx">RENDER_ATTACHMENT</span><span class="p">,</span>
<span class="p">});</span>
<span class="nx">textureViewForMultisampling</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">textureForMultisampling</span><span class="p">.</span><span class="nx">createView</span><span class="p">();</span>
</code></pre></div>
<p>When drawing the image, the <abbr title="A kind of antialiasing where the fragment shader is evaluated at several points in each pixel, and the results are averaged to get the color of the pixel.">multisampling</abbr> <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> view is used as the view property in the color attachment of the render pass descriptor. And the usual value of that view property, which represents the final image, is moved to a new resolveTarget property:</p>
<div class="highlight"><pre><span></span><code><span class="nx">renderPassDescriptor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="nx">colorAttachments</span><span class="o">:</span><span class="w"> </span><span class="p">[{</span>
<span class="w">    </span><span class="nx">clearValue</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">r</span><span class="o">:</span><span class="w"> </span><span class="mf">0.9</span><span class="p">,</span><span class="w"> </span><span class="nx">g</span><span class="o">:</span><span class="w"> </span><span class="mf">0.9</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="o">:</span><span class="w"> </span><span class="mf">0.9</span><span class="p">,</span><span class="w"> </span><span class="nx">a</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="p">},</span><span class="w"> </span>
<span class="w">    </span><span class="nx">loadOp</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;clear&quot;</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="nx">storeOp</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;store&quot;</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="nx">view</span><span class="o">:</span><span class="w"> </span><span class="nx">textureViewForMultisampling</span><span class="p">,</span><span class="w"> </span><span class="c1">// Render to multisampling texture.</span>
<span class="w">    </span><span class="nx">resolveTarget</span><span class="o">:</span><span class="w"> </span><span class="nx">context</span><span class="p">.</span><span class="nx">getCurrentTexture</span><span class="p">().</span><span class="nx">createView</span><span class="p">()</span><span class="w"> </span><span class="c1">// Final image.</span>
<span class="p">}]</span>
<span class="p">};</span>
</code></pre></div>
<p>And finally, a new multisample property must be added to the render <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> descriptor, to specify that the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> does multisampled <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr>:</p>
<div class="highlight"><pre><span></span><code><span class="nx">pipelineDescriptor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="p">.</span>
<span class="w">    </span><span class="nx">multisample</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// Sets number of samples for multisampling.</span>
<span class="w">    </span><span class="nx">count</span><span class="o">:</span><span class="w"> </span><span class="mf">4</span><span class="p">,</span><span class="w">     </span><span class="c1">//  (1 and 4 are currently the only possible values).</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">.</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="p">.</span>
</code></pre></div>
<p>And that's it! (Later, we'll see that when <abbr title="A kind of antialiasing where the fragment shader is evaluated at several points in each pixel, and the results are averaged to get the color of the pixel.">multisampling</abbr> is applied to a program that uses the <abbr title="A solution to the hidden surface problem that involves keeping track of the depth, or distance from the viewer, of the object currently visible at each pixel in the image. When a new object is drawn at a pixel, the depth of the new object is compared to the depth of the current object to decide which one is closer to the viewer. The advantage of the depth test is that objects can be rendered in any order. A disadvantage is that only a limited range of depths can be represented in the image.">depth test</abbr>, one more small change in necessary, in the <abbr title="A region of memory that stores the information needed for the depth test in 3D graphics, that is, a depth value for each pixel in the image. Also called the &quot;z-buffer.&quot;">depth buffer</abbr> configuration.)</p>
</div>
<div class="tabbed-block">
<p>The final example for this section is <a href="../../../en/source/webgpu/multisampling.html">webgpu/<abbr title="A kind of antialiasing where the fragment shader is evaluated at several points in each pixel, and the results are averaged to get the color of the pixel.">multisampling</abbr>.html</a>, which adds <abbr title="A kind of antialiasing where the fragment shader is evaluated at several points in each pixel, and the results are averaged to get the color of the pixel.">multisampling</abbr> to the basic moving disks example. Ordinarily, the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> entry point function is evaluated once per <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>, at the center point of the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>. With <abbr title="A kind of antialiasing where the fragment shader is evaluated at several points in each pixel, and the results are averaged to get the color of the pixel.">multisampling</abbr>, it is evaluated at several points within each <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>, and the color for that <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> is obtained by averaging the colors from each of those samples. This is a kind of <abbr title="A technique used to reduce the jagged or &quot;staircase&quot; appearance of diagonal lines, text, and other shapes that are drawn using pixels. When a pixel is only partly covered by a geometric shape, then the color of the pixel is a blend of the color of the shape and the color of the background, with the degree of blending depending on the fraction of the pixel that is covered by the geometric shape.">antialiasing</abbr>. For example, when the geometric edge of a primitive cuts through a <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>, some sampled points might lie inside the primitive and some outside. The color of the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> will then be a blend of the primitive color and the background color. Or, when a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> is applied, the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> color for the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> will be a blend of the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> colors at the sampled points.</p>
<p><abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> will do <abbr title="A technique used to reduce the jagged or &quot;staircase&quot; appearance of diagonal lines, text, and other shapes that are drawn using pixels. When a pixel is only partly covered by a geometric shape, then the color of the pixel is a blend of the color of the shape and the color of the background, with the degree of blending depending on the fraction of the pixel that is covered by the geometric shape.">antialiasing</abbr> automatically, but in <abbr title="A new JavaScript graphics API, similar to WebGL, but designed to let web programs access modern GPU capabilities such as compute shaders.">WebGPU</abbr>, you have to do some work. Fortunately, it's not very hard. There are just a few changes from a non-multisampled program. First, you need a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> for <abbr title="A kind of antialiasing where the fragment shader is evaluated at several points in each pixel, and the results are averaged to get the color of the pixel.">multisampling</abbr>, and a view of that <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. (I will admit that I don't understand why this is needed.) The code for that is a preview of creating textures and <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> views:</p>
<div class="highlight"><pre><span></span><code><span class="nx">textureForMultisampling</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createTexture</span><span class="p">({</span>
<span class="w">    </span><span class="nx">size</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="nx">context</span><span class="p">.</span><span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span><span class="w"> </span><span class="nx">context</span><span class="p">.</span><span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span><span class="p">],</span>
<span class="w">    </span><span class="nx">sampleCount</span><span class="o">:</span><span class="w"> </span><span class="mf">4</span><span class="p">,</span><span class="w">  </span><span class="c1">// (1 and 4 are currently the only possible values.)</span>
<span class="w">    </span><span class="nx">format</span><span class="o">:</span><span class="w"> </span><span class="nx">navigator</span><span class="p">.</span><span class="nx">gpu</span><span class="p">.</span><span class="nx">getPreferredCanvasFormat</span><span class="p">(),</span>
<span class="w">    </span><span class="nx">usage</span><span class="o">:</span><span class="w"> </span><span class="nx">GPUTextureUsage</span><span class="p">.</span><span class="nx">RENDER_ATTACHMENT</span><span class="p">,</span>
<span class="p">});</span>
<span class="nx">textureViewForMultisampling</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">textureForMultisampling</span><span class="p">.</span><span class="nx">createView</span><span class="p">();</span>
</code></pre></div>
<p>When drawing the image, the <abbr title="A kind of antialiasing where the fragment shader is evaluated at several points in each pixel, and the results are averaged to get the color of the pixel.">multisampling</abbr> <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> view is used as the view property in the color attachment of the render pass descriptor. And the usual value of that view property, which represents the final image, is moved to a new resolveTarget property:</p>
<div class="highlight"><pre><span></span><code><span class="nx">renderPassDescriptor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="nx">colorAttachments</span><span class="o">:</span><span class="w"> </span><span class="p">[{</span>
<span class="w">    </span><span class="nx">clearValue</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">r</span><span class="o">:</span><span class="w"> </span><span class="mf">0.9</span><span class="p">,</span><span class="w"> </span><span class="nx">g</span><span class="o">:</span><span class="w"> </span><span class="mf">0.9</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="o">:</span><span class="w"> </span><span class="mf">0.9</span><span class="p">,</span><span class="w"> </span><span class="nx">a</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="p">},</span><span class="w"> </span>
<span class="w">    </span><span class="nx">loadOp</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;clear&quot;</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="nx">storeOp</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;store&quot;</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="nx">view</span><span class="o">:</span><span class="w"> </span><span class="nx">textureViewForMultisampling</span><span class="p">,</span><span class="w"> </span><span class="c1">// Render to multisampling texture.</span>
<span class="w">    </span><span class="nx">resolveTarget</span><span class="o">:</span><span class="w"> </span><span class="nx">context</span><span class="p">.</span><span class="nx">getCurrentTexture</span><span class="p">().</span><span class="nx">createView</span><span class="p">()</span><span class="w"> </span><span class="c1">// Final image.</span>
<span class="p">}]</span>
<span class="p">};</span>
</code></pre></div>
<p>And finally, a new multisample property must be added to the render <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> descriptor, to specify that the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> does multisampled <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr>:</p>
<div class="highlight"><pre><span></span><code><span class="nx">pipelineDescriptor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="p">.</span>
<span class="w">    </span><span class="nx">multisample</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// Sets number of samples for multisampling.</span>
<span class="w">    </span><span class="nx">count</span><span class="o">:</span><span class="w"> </span><span class="mf">4</span><span class="p">,</span><span class="w">     </span><span class="c1">//  (1 and 4 are currently the only possible values).</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">.</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="p">.</span>
</code></pre></div>
<p>And that's it! (Later, we'll see that when <abbr title="A kind of antialiasing where the fragment shader is evaluated at several points in each pixel, and the results are averaged to get the color of the pixel.">multisampling</abbr> is applied to a program that uses the <abbr title="A solution to the hidden surface problem that involves keeping track of the depth, or distance from the viewer, of the object currently visible at each pixel in the image. When a new object is drawn at a pixel, the depth of the new object is compared to the depth of the current object to decide which one is closer to the viewer. The advantage of the depth test is that objects can be rendered in any order. A disadvantage is that only a limited range of depths can be represented in the image.">depth test</abbr>, one more small change in necessary, in the <abbr title="A region of memory that stores the information needed for the depth test in 3D graphics, that is, a depth value for each pixel in the image. Also called the &quot;z-buffer.&quot;">depth buffer</abbr> configuration.)</p>
</div>
</div>
</div>







  
    
  
  
    
  


  <aside class="md-source-file">
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="最后更新">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1-2.1-2M12.5 7v5.2l4 2.4-1 1L11 13V7h1.5M11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2v1.8Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">2024年6月20日</span>
  </span>

    
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="创建日期">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.47 15.08 11 13V7h1.5v5.25l3.08 1.83c-.41.28-.79.62-1.11 1m-1.39 4.84c-.36.05-.71.08-1.08.08-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8c0 .37-.03.72-.08 1.08.69.1 1.33.32 1.92.64.1-.56.16-1.13.16-1.72 0-5.5-4.5-10-10-10S2 6.5 2 12s4.47 10 10 10c.59 0 1.16-.06 1.72-.16-.32-.59-.54-1.23-.64-1.92M18 15v3h-3v2h3v3h2v-3h3v-2h-3v-3h-2Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">2024年5月26日</span>
  </span>

    
    
    
  </aside>





                
              </article>
            </div>
          
          
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var tab,labels=set.querySelector(".tabbed-labels");for(tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script>

<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../../..", "features": ["content.code.copy", "content.tabs.link", "navigation.tabs", "navigation.tabs.sticky", "navigation.indexes", "navigation.top", "toc.follow", "content.tooltips"], "search": "../../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.3220b9d7.min.js"></script>
      
        <script src="../../../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="https://unpkg.com/mermaid@9.4.0/dist/mermaid.min.js"></script>
      
    
  <script>document$.subscribe(() => {const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});})</script></body>
</html>