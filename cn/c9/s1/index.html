
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="计算机图形学概论(graphicsbook)">
      
      
      
        <link rel="canonical" href="https://hellowac.github.io/graphicsbook-zh-cn/cn/c9/s1/">
      
      
        <link rel="prev" href="../">
      
      
        <link rel="next" href="../s2/">
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.0, mkdocs-material-9.5.28">
    
    
      
        <title>9.1 WebGPU 基础 - 计算机图形学概论</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.6543a935.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.06af60db.min.css">
      
      

  
  
  
  
  <style>:root{--md-annotation-icon:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M22 12a10 10 0 0 1-10 10A10 10 0 0 1 2 12 10 10 0 0 1 12 2a10 10 0 0 1 10 10M6 13h8l-3.5 3.5 1.42 1.42L17.84 12l-5.92-5.92L10.5 7.5 14 11H6v2Z"/></svg>');}</style>


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
   <link href="../../../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
    html.glightbox-open { overflow: initial; height: 100%; }
    .gslide-title { margin-top: 0px; user-select: text; }
    .gslide-desc { color: #666; user-select: text; }
    .gslide-image img { background: white; }
    .gscrollbar-fixer { padding-right: 15px; }
    .gdesc-inner { font-size: 0.75rem; }
    body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
    body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
    body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}</style> <script src="../../../assets/javascripts/glightbox.min.js"></script></head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="default" data-md-color-accent="red">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#91-webgpu-基础" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="计算机图形学概论" class="md-header__button md-logo" aria-label="计算机图形学概论" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            计算机图形学概论
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              9.1 WebGPU 基础
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
      <div class="md-header__option">
  <div class="md-select">
    
    <button class="md-header__button md-icon" aria-label="选择当前语言">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m12.87 15.07-2.54-2.51.03-.03A17.52 17.52 0 0 0 14.07 6H17V4h-7V2H8v2H1v2h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04M18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12m-2.62 7 1.62-4.33L19.12 17h-3.24Z"/></svg>
    </button>
    <div class="md-select__inner">
      <ul class="md-select__list">
        
          <li class="md-select__item">
            <a href="/graphicsbook-zh-cn/en/" hreflang="en" class="md-select__link">
              English
            </a>
          </li>
        
          <li class="md-select__item">
            <a href="/graphicsbook-zh-cn/cn/" hreflang="cn" class="md-select__link">
              中文
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</div>
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/hellowac/graphicsbook-zh-cn" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    graphicsbook
  </div>
</a>
      </div>
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../" class="md-tabs__link">
        
  
    
  
  首页

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../preface/" class="md-tabs__link">
        
  
    
  
  前言

      </a>
    </li>
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c1/" class="md-tabs__link">
          
  
    
  
  1.简介

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c2/" class="md-tabs__link">
          
  
    
  
  2.二维图形

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c3/" class="md-tabs__link">
          
  
    
  
  3.几何

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c4/" class="md-tabs__link">
          
  
    
  
  4.灯光和材质

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c5/" class="md-tabs__link">
          
  
    
  
  5.three.js

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c6/" class="md-tabs__link">
          
  
    
  
  6.WebGL

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c7/" class="md-tabs__link">
          
  
    
  
  7.WebGL 3D

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c8/" class="md-tabs__link">
          
  
    
  
  8.高阶3D

        </a>
      </li>
    
  

      
        
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../" class="md-tabs__link">
          
  
    
  
  9.WEBGPU

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../a1/" class="md-tabs__link">
          
  
    
  
  附录A

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../a2/" class="md-tabs__link">
          
  
    
  
  附录B

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../a3/" class="md-tabs__link">
          
  
    
  
  附录C

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../source/" class="md-tabs__link">
          
  
    
  
  附录D

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../glossary/" class="md-tabs__link">
          
  
    
  
  术语表

        </a>
      </li>
    
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../.." class="md-tabs__link">
        
  
    
  
  关于

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="计算机图形学概论" class="md-nav__button md-logo" aria-label="计算机图形学概论" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    计算机图形学概论
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/hellowac/graphicsbook-zh-cn" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    graphicsbook
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    首页
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../preface/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    前言
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c1/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    1.简介
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_3" id="__nav_3_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            1.简介
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 1 节 绘画与绘图
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 2 节：三维(3D)图形的要素
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 3 节：硬件与软件
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c2/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    2.二维图形
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_4" id="__nav_4_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            2.二维图形
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第1节: 像素、坐标和颜色
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第2节: 形状
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第3节: 变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第4节: 分层建模
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第5节: Java 绘制2D
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第6节: HTML Canvas图形
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第7节: SVG：一种场景描述语言
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c3/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    3.几何
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_5" id="__nav_5_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            3.几何
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.1 OpenGL 1.1 中的形状和颜色
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.2 3D 坐标和变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.3 投影与观看
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.4 多边形网格和 glDrawArrays
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.5 部分线性代数基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.6 使用 GLUT 和 JOGL
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c4/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    4.灯光和材质
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_6" id="__nav_6_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6">
            <span class="md-nav__icon md-icon"></span>
            4.灯光和材质
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.1 照明简介
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.2 OpenGL 1.1 中的光和材质
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.3 图像纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.4 灯光、相机、动作
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c5/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    5.three.js
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_7" id="__nav_7_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7">
            <span class="md-nav__icon md-icon"></span>
            5.three.js
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.1 Three.js 基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.2 构建对象
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.3 其他功能
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c6/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    6.WebGL
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_8" id="__nav_8_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8">
            <span class="md-nav__icon md-icon"></span>
            6.WebGL
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.1 可编程流水线
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.2 第一个例子
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.3 GLSL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.4 图像纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.5 实现 2D 变换
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c7/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    7.WebGL 3D
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_9" id="__nav_9_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9">
            <span class="md-nav__icon md-icon"></span>
            7.WebGL 3D
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.1 3D变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.2 照明和材质
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.3 纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.4 帧缓冲区
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.5 WebGL 扩展
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c8/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    8.高阶3D
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_10" id="__nav_10_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_10_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10">
            <span class="md-nav__icon md-icon"></span>
            8.高阶3D
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c8/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8.1 光线追踪
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c8/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8.2 路径追踪
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_11" checked>
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    9.WEBGPU
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_11" id="__nav_11_label" tabindex="">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_11_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_11">
            <span class="md-nav__icon md-icon"></span>
            9.WEBGPU
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    9.1 WebGPU 基础
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    9.1 WebGPU 基础
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#911-适配器设备和画布" class="md-nav__link">
    <span class="md-ellipsis">
      9.1.1 适配器、设备和画布
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#912-着色器模块" class="md-nav__link">
    <span class="md-ellipsis">
      9.1.2 着色器模块
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#913-渲染管线" class="md-nav__link">
    <span class="md-ellipsis">
      9.1.3 渲染管线
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#914-缓冲区" class="md-nav__link">
    <span class="md-ellipsis">
      9.1.4 缓冲区
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#915-绘图" class="md-nav__link">
    <span class="md-ellipsis">
      9.1.5 绘图
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#916-多个顶点输入" class="md-nav__link">
    <span class="md-ellipsis">
      9.1.6 多个顶点输入
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#917-自动绑定组布局" class="md-nav__link">
    <span class="md-ellipsis">
      9.1.7 自动绑定组布局
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.2 实例和索引
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.3 WGSL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.4 WebGPU 中的 3D 图形
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.5 纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.6 计算着色器
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.7 细节
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_12" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../a1/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    附录A
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_12" id="__nav_12_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_12_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_12">
            <span class="md-nav__icon md-icon"></span>
            附录A
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a1/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    A.1 Java 编程语言
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a1/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    A.2 C 编程语言
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a1/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    A.3 JavaScript 编程语言
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a1/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    A.4 JavaScript Promise 和异步函数
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_13" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../a2/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    附录B
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_13" id="__nav_13_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_13_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_13">
            <span class="md-nav__icon md-icon"></span>
            附录B
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a2/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    B.1 节 Blender 基础知识
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a2/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    B.2 节 Blender 建模
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a2/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    B.3 节 Blender 动画
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a2/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    B.4 节 有关光和材料的更多信息
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_14" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../a3/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    附录C
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_14" id="__nav_14_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_14_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_14">
            <span class="md-nav__icon md-icon"></span>
            附录C
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a3/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C.1 节 Gimp：2D 绘画程序
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_15" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../source/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    附录D
  </span>
  

            </a>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_15_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_15">
            <span class="md-nav__icon md-icon"></span>
            附录D
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_16" >
        
          
          <label class="md-nav__link" for="__nav_16" id="__nav_16_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    术语表
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_16_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_16">
            <span class="md-nav__icon md-icon"></span>
            术语表
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../glossary/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    术语表
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    关于
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#911-适配器设备和画布" class="md-nav__link">
    <span class="md-ellipsis">
      9.1.1 适配器、设备和画布
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#912-着色器模块" class="md-nav__link">
    <span class="md-ellipsis">
      9.1.2 着色器模块
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#913-渲染管线" class="md-nav__link">
    <span class="md-ellipsis">
      9.1.3 渲染管线
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#914-缓冲区" class="md-nav__link">
    <span class="md-ellipsis">
      9.1.4 缓冲区
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#915-绘图" class="md-nav__link">
    <span class="md-ellipsis">
      9.1.5 绘图
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#916-多个顶点输入" class="md-nav__link">
    <span class="md-ellipsis">
      9.1.6 多个顶点输入
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#917-自动绑定组布局" class="md-nav__link">
    <span class="md-ellipsis">
      9.1.7 自动绑定组布局
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="91-webgpu-基础">9.1 <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> 基础<a class="headerlink" href="#91-webgpu-基础" title="Permanent link">&para;</a></h1>
<p><strong><abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> Basics</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="1:2"><input checked="checked" id="__tabbed_1_1" name="__tabbed_1" type="radio" /><input id="__tabbed_1_2" name="__tabbed_1" type="radio" /><div class="tabbed-labels"><label for="__tabbed_1_1">中文</label><label for="__tabbed_1_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p><abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> 是网络计算机图形学的新API。WebGL基于OpenGL构建，而WebGPU则是完全从头设计的。它与更现代的计算机图形API如Vulkan、Metal和Direct3D类似。WebGPU是一个非常底层的API，这使得程序员要做更多的工作，但也提供了更多的能力和效率。另一方面，您可能发现WebGPU比WebGL是一个更清洁、更合逻辑的API，WebGL充满了旧OpenGL特性的奇怪残留物。</p>
<p>我们从WebGPU的概览开始本章。目前，我们将坚持使用基本的2D图形，没有变换或照明。尽管我会提到一些WebGL，但我会尽量使讨论对那些尚未学习WebGL或OpenGL的人也是可访问的；然而，如果您不熟悉这些旧API，您可能需要参考本书的早期部分以获取背景信息。</p>
<p>我们的WebGPU示例将用JavaScript编写。在附录A的<a href="../../a1/s3/">第3节</a>中可以找到JavaScript的简短介绍。WebGPU广泛使用类型化数组如<strong><em>Float32Array</em></strong>，以及用于创建对象（使用{...}）和数组（使用[...]）的符号。它还使用异步函数和承诺，这些高级JavaScript特性在该附录的<a href="../../a1/s4/">第4节</a>中讨论。</p>
<p>WebGPU应用程序的环境有两个部分，我将称之为JavaScript端和GPU端。JavaScript端在CPU（计算机的中央处理单元）上执行，而WebGPU计算和渲染操作在GPU（图形处理单元）上执行。CPU和GPU各自拥有自己的专用内存，但它们也有一些共享内存，可用于共享数据和发送消息。应用程序的JavaScript端和GPU端之间的通信相对较慢且效率低下。WebGPU的许多设计可能看起来繁琐且有点奇怪，但这些都可以通过尽可能高效地管理通信来解释。现在，实际上，WebGPU可以在许多不同的系统上以多种方式实现。它甚至可以完全用软件模拟，不涉及任何物理GPU。但设计必须对所有情况都高效，当你试图理解设计时，你应该记住的情况是有一个单独的CPU和GPU，它们可以访问一些共享内存。</p>
<p>在本节中，我们将主要看一个示例程序：<a href="../../../en/source/webgpu/basic_webgpu_1.html">basic_webgpu_1.html</a>，它简单地绘制了一个彩色三角形。这个例子的源代码有大量的注释，并且鼓励你去阅读它。你可以运行它来测试你的浏览器是否支持WebGPU。这里有一个演示版本（源代码不包括所有注释）：</p>
<p><iframe src="../../../en/demos/c9/first-webgpu-demo.html" width="390" height="450"></iframe></p>
</div>
<div class="tabbed-block">
<p><abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> is a new <abbr title="Application Programming Interface. A collection of related classes, functions, constants, etc., for performing some task. An API is an &quot;interface&quot; in the sense that it can be used without understanding how its functionality is actually implemented.">API</abbr> for computer graphics on the Web. Where <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> was based on <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr>, <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> has been completely designed from scratch. It is similar to more modern computer graphics APIs such as <abbr title="An open-source cross-platform API for 3D graphics and computation, designed as a more modern and efficient replacement for OpenGL.">Vulkan</abbr>, <abbr title="Apple's proprietary API for 3D graphics and computation on MacOS computers and iOS devices.">Metal</abbr>, and <abbr title="Microsoft's proprietary API for 3D graphics on the Windows operating system.">Direct3D</abbr>. <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> is a very low-level <abbr title="Application Programming Interface. A collection of related classes, functions, constants, etc., for performing some task. An API is an &quot;interface&quot; in the sense that it can be used without understanding how its functionality is actually implemented.">API</abbr>, which makes the programmer do more work but also offers more power and efficiency. On the other hand, you might find that <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> is a cleaner, more logical <abbr title="Application Programming Interface. A collection of related classes, functions, constants, etc., for performing some task. An API is an &quot;interface&quot; in the sense that it can be used without understanding how its functionality is actually implemented.">API</abbr> than <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>, which is filled with strange remnants of old <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> features.</p>
<p>We begin the chapter with an overview of <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr>. For now, we will stick to basic 2D graphics, with no transformations or <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr>. Although I will make some references to <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>, I will try to make the discussion accessible even for someone who has not already studied <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> or <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr>; however, if you are not familiar with those older APIs, you might need to refer to earlier sections of this book for background information.</p>
<p>Our <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> examples will be programmed in <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr>. A short introduction to <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> can be found in <a href="../../a1/s3/">Section 3</a> of Appendix A. <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> makes extensive use of typed arrays such as <strong><em>Float32Array</em></strong> and of the notations for creating objects (using {...}) and arrays (using [...]). And it uses <abbr title="在 JavaScript 中，异步函数是可以使用 &quot;await&quot; 语句等待承诺结果的函数。当执行 await 语句时，异步函数的执行将暂停，直到承诺被实现或被拒绝，同时让其他 JavaScript 代码有机会在此期间运行。">async functions</abbr> and <abbr title="在 JavaScript 编程中，一个承诺代表一个可能立即可用或将来某个时候可用的结果。程序员可以提供一个函数，如果承诺实现（即结果可用时）或承诺被拒绝（例如，如果发生某些错误）时被调用。承诺是异步的，因为处理成功或失败的函数将在某个不可预测的时间被调用。">promises</abbr>, advanced <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> features that are discussed in <a href="../../a1/s4/">Section 4</a> of that appendix.</p>
<p>The environment for a <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> application has two parts that I will call the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side and the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> side. The <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side is executed on the <abbr title="The Central Processing Unit in a computer, the component that actually executes programs. The CPU reads machine language instructions from the computer's memory and carries them out.">CPU</abbr> (the Central Processing Unit of the computer), while <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> computational and <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> operations are executed on the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> (Graphical Processing Unit). The <abbr title="The Central Processing Unit in a computer, the component that actually executes programs. The CPU reads machine language instructions from the computer's memory and carries them out.">CPU</abbr> and <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> each have their own dedicated memory, but they also have some shared memory that can be used for sharing data and sending messages. Communication between the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side and the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> side of the application is relatively slow and inefficient. A lot of the design of <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr>, which can seem cumbersome and a little strange, can be explained by the need to manage that communication as efficiently as possible. Now, <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> can in fact be implemented in many ways on many different systems. It can even be emulated entirely in software with no physical <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> involved. But the design has to be efficient for all cases, and the case that you should keep in mind when trying to understand the design is one with separate <abbr title="The Central Processing Unit in a computer, the component that actually executes programs. The CPU reads machine language instructions from the computer's memory and carries them out.">CPU</abbr> and <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> that have access to some shared memory.</p>
<p>In this section we will mostly be looking at one sample program: <a href="../../../en/source/webgpu/basic_webgpu_1.html">basic_webgpu_1.html</a>, which simply draws a colored triangle. The source code for this example is extensively commented, and you are encouraged to read it. You can run it to test whether your browser supports <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr>. Here is a demo version (with source code that does not include all the comments):</p>
<p><iframe src="../../../en/demos/c9/first-webgpu-demo.html" width="390" height="450"></iframe></p>
</div>
</div>
</div>
<h2 id="911-适配器设备和画布">9.1.1 适配器、设备和画布<a class="headerlink" href="#911-适配器设备和画布" title="Permanent link">&para;</a></h2>
<p><strong>Adapter, Device, and Canvas</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="2:2"><input checked="checked" id="__tabbed_2_1" name="__tabbed_2" type="radio" /><input id="__tabbed_2_2" name="__tabbed_2" type="radio" /><div class="tabbed-labels"><label for="__tabbed_2_1">中文</label><label for="__tabbed_2_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>任何WebGPU应用程序都必须从获取一个WebGPU“设备”开始，它代表了程序员几乎所有WebGPU功能的接口。要在网页上产生可见的图形图像，WebGPU会渲染到页面上的一个HTML画布元素。为此，应用程序将需要该画布的WebGPU上下文。（WebGPU除了渲染到画布之外还可以做其他事情，但我们现在只关注这一点）。获取设备和上下文的代码在任何应用程序中都可以相同：</p>
<div class="highlight"><pre><span></span><code><span class="k">async</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">initWebGPU</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">navigator</span><span class="p">.</span><span class="nx">gpu</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="ne">Error</span><span class="p">(</span><span class="s2">&quot;WebGPU not supported in this browser.&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">adapter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">navigator</span><span class="p">.</span><span class="nx">gpu</span><span class="p">.</span><span class="nx">requestAdapter</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">adapter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="ne">Error</span><span class="p">(</span><span class="s2">&quot;WebGPU is supported, but couldn&#39;t get WebGPU adapter.&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">adapter</span><span class="p">.</span><span class="nx">requestDevice</span><span class="p">();</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">canvas</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;webgpuCanvas&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="nx">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">canvas</span><span class="p">.</span><span class="nx">getContext</span><span class="p">(</span><span class="s2">&quot;webgpu&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="nx">context</span><span class="p">.</span><span class="nx">configure</span><span class="p">({</span>
<span class="w">        </span><span class="nx">device</span><span class="o">:</span><span class="w"> </span><span class="nx">device</span><span class="p">,</span>
<span class="w">        </span><span class="nx">format</span><span class="o">:</span><span class="w"> </span><span class="nx">navigator</span><span class="p">.</span><span class="nx">gpu</span><span class="p">.</span><span class="nx">getPreferredCanvasFormat</span><span class="p">(),</span>
<span class="w">        </span><span class="nx">alphaMode</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;premultiplied&quot;</span><span class="w"> </span><span class="c1">// （另一种选择是 &quot;opaque&quot;）</span>
<span class="w">    </span><span class="p">});</span>
<span class="w">    </span><span class="p">.</span>
<span class="w">    </span><span class="p">.</span>
<span class="w">    </span><span class="p">.</span>
<span class="p">}</span>
</code></pre></div>
<p>在这里，device和context是全局变量，navigator是代表网络浏览器的预定义变量，其他变量，adapter和canvas，可能在初始化函数之外不需要。（如果需要对画布的引用，它可作为context.canvas获得）。函数navigator.gpu.requestAdapter()和adapter.requestDevice()返回承诺。该函数被声明为async，因为它使用await等待这些承诺的结果。（Async函数的使用方式与其他函数相同，只是有时您需要考虑程序的其他部分在await等待结果时理论上可以运行）。</p>
<p>您可能想要在初始化中更改的唯一事项是上下文的alphaMode。值"premultiplied"允许画布上像素的alpha值确定该像素在网页上绘制时的透明度程度。另一种值"opaque"意味着忽略像素的alpha值，像素是不透明的。</p>
<p>这段初始化代码进行了一些错误检查，如果遇到问题可能会抛出错误。可以想象，程序会在其他地方捕获该错误并向用户报告。然而，作为WebGPU开发者，您应该知道WebGPU对程序进行了广泛的有效性检查，并将所有错误和警告报告给网络浏览器控制台。因此，在测试您的工作时保持控制台打开是一个好主意。</p>
</div>
<div class="tabbed-block">
<p>Any <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> application must begin by obtaining a <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> "device," which represents the programmer's interface to almost all <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> features. To produce visible graphics images on a web page, <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> renders to an <abbr title="HyperText Markup Language. A language that is used for specifying the content of web pages. An HTML document is made up of text, along with &quot;elements&quot; for adding other content, such as images, and for defining the structure of the document. Because of nesting of elements, the document can be represented by a tree-like data structure.">HTML</abbr> canvas element on the page. For that, the application will need a <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> context for the canvas. (<abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> can do other things besides render to a canvas, but we will stick to that for now). The code for obtaining the device and context can be the same in any application:</p>
<div class="highlight"><pre><span></span><code><span class="k">async</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">initWebGPU</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">navigator</span><span class="p">.</span><span class="nx">gpu</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="ne">Error</span><span class="p">(</span><span class="s2">&quot;WebGPU not supported in this browser.&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">adapter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">navigator</span><span class="p">.</span><span class="nx">gpu</span><span class="p">.</span><span class="nx">requestAdapter</span><span class="p">();</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">adapter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="ne">Error</span><span class="p">(</span><span class="s2">&quot;WebGPU is supported, but couldn&#39;t get WebGPU adapter.&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">adapter</span><span class="p">.</span><span class="nx">requestDevice</span><span class="p">();</span>

<span class="kd">let</span><span class="w"> </span><span class="nx">canvas</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;webgpuCanvas&quot;</span><span class="p">);</span>
<span class="nx">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">canvas</span><span class="p">.</span><span class="nx">getContext</span><span class="p">(</span><span class="s2">&quot;webgpu&quot;</span><span class="p">);</span>
<span class="nx">context</span><span class="p">.</span><span class="nx">configure</span><span class="p">({</span>
<span class="w">    </span><span class="nx">device</span><span class="o">:</span><span class="w"> </span><span class="nx">device</span><span class="p">,</span>
<span class="w">    </span><span class="nx">format</span><span class="o">:</span><span class="w"> </span><span class="nx">navigator</span><span class="p">.</span><span class="nx">gpu</span><span class="p">.</span><span class="nx">getPreferredCanvasFormat</span><span class="p">(),</span>
<span class="w">    </span><span class="nx">alphaMode</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;premultiplied&quot;</span><span class="w"> </span><span class="c1">// (the alternative is &quot;opaque&quot;)</span>
<span class="p">});</span>
<span class="w">    </span><span class="p">.</span>
<span class="w">    </span><span class="p">.</span>
<span class="w">    </span><span class="p">.</span>
</code></pre></div>
<p>Here, device and context are global variables, navigator is a predefined variable representing the web browser, and the other variables, adapter and canvas, are probably not needed outside the initialization function. (If a reference to the canvas is needed, it is available as context.canvas.) The functions navigator.gpu.requestAdapter() and adapter.requestDevice() return <abbr title="在 JavaScript 编程中，一个承诺代表一个可能立即可用或将来某个时候可用的结果。程序员可以提供一个函数，如果承诺实现（即结果可用时）或承诺被拒绝（例如，如果发生某些错误）时被调用。承诺是异步的，因为处理成功或失败的函数将在某个不可预测的时间被调用。">promises</abbr>. The function is declared as async because it uses await to wait for the results from those <abbr title="在 JavaScript 编程中，一个承诺代表一个可能立即可用或将来某个时候可用的结果。程序员可以提供一个函数，如果承诺实现（即结果可用时）或承诺被拒绝（例如，如果发生某些错误）时被调用。承诺是异步的，因为处理成功或失败的函数将在某个不可预测的时间被调用。">promises</abbr>. (Async functions are used in the same way as other functions, except that sometimes you have to take into account that other parts of the program can in theory run while await is waiting for a result.)</p>
<p>The only thing you might want to change in this initialization is the alphaMode for the context. The value "premultiplied" allows the <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> value of a <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> in the canvas to determine the degree of transparency of that <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> when the canvas is drawn on the web page. The alternative value, "opaque", means that the <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> value of a <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> is ignored, and the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> is opaque.</p>
<p>This initialization code does some error checking and can throw an error if a problem is encountered. Presumably, the program would catch that error elsewhere and report it to the user. However, as a <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> developer, you should be aware that <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> does extensive validity checks on programs and reports all errors and warnings to the web browser console. So, it is a good idea to keep the console open when testing your work.</p>
</div>
</div>
</div>
<h2 id="912-着色器模块">9.1.2 着色器模块<a class="headerlink" href="#912-着色器模块" title="Permanent link">&para;</a></h2>
<p><strong>Shader Module</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="3:2"><input checked="checked" id="__tabbed_3_1" name="__tabbed_3" type="radio" /><input id="__tabbed_3_2" name="__tabbed_3" type="radio" /><div class="tabbed-labels"><label for="__tabbed_3_1">中文</label><label for="__tabbed_3_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p><abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> 与 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 和 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 类似，绘制由顶点定义的图元（点、线和三角形）。渲染过程包括对图元的每个顶点进行一些计算，以及对图元中的每个像素（或“片段”）进行一些计算。<abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> 程序员必须定义函数来指定这些计算。这些函数就是着色器。要渲染图像，<abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> 程序必须提供顶点着色器主函数和片段着色器主函数。在文档中，这些函数被称为顶点着色器入口点和片段着色器入口点。<abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> 的着色器函数和支持代码是用 <strong><abbr title="WebGPU 着色器语言，是编写 WebGPU 使用的着色器的编程语言。">WGSL</abbr></strong> 编写的，即 <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> 着色器语言。着色器源代码作为一个普通的 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 字符串给出。设备对象中的 device.createShaderModule() 方法用于编译源代码，检查语法错误，并将其打包成一个着色器模块，然后在渲染管线中使用：</p>
<div class="highlight"><pre><span></span><code><span class="nx">shader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createShaderModule</span><span class="p">({</span>
<span class="w">    </span><span class="nx">code</span><span class="o">:</span><span class="w"> </span><span class="nx">shaderSource</span>
<span class="p">});</span>
</code></pre></div>
<p>这里的参数是一个对象，在这个例子中只有一个属性，名为 code；shaderSource 是包含着色器源代码的字符串；返回值 <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> 表示编译后的源代码，稍后在配置渲染管线时会用到。源代码中的语法错误不会抛出异常。然而，编译错误和警告会报告在网络控制台中。在开发期间，您应该始终检查控制台中的 <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> 消息。</p>
<p>我们将在 <a href="../s3/">第9.3节</a> 中详细查看 <abbr title="WebGPU 着色器语言，是编写 WebGPU 使用的着色器的编程语言。">WGSL</abbr>。<abbr title="WebGPU 着色器语言，是编写 WebGPU 使用的着色器的编程语言。">WGSL</abbr> 在很多方面与 <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> 相似，<abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> 是 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 的着色语言，但它的变量和函数声明非常不同。我在这里只进行简短的讨论，以帮助您理解 <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> 应用程序的 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 部分和 <abbr title="WebGPU 着色器语言，是编写 WebGPU 使用的着色器的编程语言。">WGSL</abbr> 部分之间的关系。以下是我们 <a href="../../../en/source/webgpu/basic_webgpu_1.html">第一个 <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> 示例</a> 中的简短着色器源代码。它在 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 端定义为一个模板字符串，可以跨越多行：</p>
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">shaderSource</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sb">`</span>

<span class="sb">@group(0) @binding(0) var&lt;uniform&gt; color : vec3f;</span>

<span class="sb">@vertex</span>
<span class="sb">fn vertexMain( @location(0) coords : vec2f ) -&gt; @builtin(position) vec4f {</span>
<span class="sb">    return vec4f( coords, 0, 1 );</span>
<span class="sb">}</span>

<span class="sb">@fragment</span>
<span class="sb">fn fragmentMain() -&gt; @location(0) vec4f {</span>
<span class="sb">    return vec4f( color, 1 ); </span>
<span class="sb">}</span>
<span class="sb">`</span><span class="p">;</span>
</code></pre></div>
<p><abbr title="WebGPU 着色器语言，是编写 WebGPU 使用的着色器的编程语言。">WGSL</abbr> 中的函数定义语法为</p>
<div class="highlight"><pre><span></span><code><span class="nx">fn</span><span class="w"> </span><span class="nx">function_name</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="nx">parameter_list</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nx">return_type</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="p">}</span>
</code></pre></div>
<p>这个例子中使用的类型 —— vec2f、vec3f 和 vec4f —— 表示两个、三个和四个32位浮点数的向量。变量声明可以有几种形式。这段代码中的一个示例有以下形式：</p>
<div class="highlight"><pre><span></span><code><span class="kd">var</span><span class="o">&lt;</span><span class="nx">uniform</span><span class="o">&gt;</span><span class="w"> </span><span class="nx">variable_name</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">type</span><span class="w"> </span><span class="p">;</span>
</code></pre></div>
<p>这在“uniform address space”中声明了一个全局变量，下面会讨论。在 uniform address space 中的变量从 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 端获取其值。</p>
<p>以 "@" 开头的词是注释或修饰符。例如，@<abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> 表示后面的函数可以用作顶点着色器入口点，@fragment 表示后面的函数可以用作片段着色器入口点。@builtin(position) 注释说明 vertexMain() 的返回值给出了顶点在标准 <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> 坐标系统中的坐标。示例中的 @location(0)、@group(0) 和 @binding(0) 用于指定着色器中数据和 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 端数据之间的连接，稍后将讨论。</p>
<p>这里使用的顶点和片段着色器函数非常简单。顶点着色器简单地从其参数中获取 (x,y) <abbr title="一种将数值坐标分配给几何点的方法。在二维中，每个点对应一对数字。在三维中，每个点对应一组三个数字。">坐标</abbr>，该参数来自 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 端，并添加 z- 和 w- 坐标以获得顶点的最终齐次坐标。返回值的表达式 vec4f(coords,0,1) 从其参数列表中的四个浮点值构造一个 vec4f（四个浮点数的向量）。片段着色器为其处理的像素输出 RGBA 颜色，简单地使用来自 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 端的 uniform color 变量的三个 RGB 分量，并添加 1 作为颜色的 <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> 分量。</p>
</div>
<div class="tabbed-block">
<p>Like <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> and <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr>, <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> draws primitives (points, lines, and triangles) that are defined by vertices. The <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> process involves some computation for each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> of a primitive, and some computation for each <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> (or "fragment") that is part of the primitive. A <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> programmer must define functions to specify those computations. Those functions are shaders. To render an image, a <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> program must provide a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> main function and a <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> main function. In the documentation, those functions are referred to as the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> entry point and the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> entry point. Shader functions and supporting code for <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> are written in <strong><abbr title="WebGPU 着色器语言，是编写 WebGPU 使用的着色器的编程语言。">WGSL</abbr></strong>, the <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> Shader Language. Shader source code is given as an ordinary <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> string. The device.createShaderModule() method, in the <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> device object, is used to compile the source code, check it for syntax errors, and package it into a <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> module that can then be used in a <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>:</p>
<div class="highlight"><pre><span></span><code><span class="nx">shader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createShaderModule</span><span class="p">({</span>
<span class="w">    </span><span class="nx">code</span><span class="o">:</span><span class="w"> </span><span class="nx">shaderSource</span>
<span class="p">});</span>
</code></pre></div>
<p>The parameter here is an object that in this example has just one property, named code; shaderSource is the string that contains the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> source code; and the return value, <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>, represents the compiled source code, which will be used later, when configuring the render <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>. Syntax errors in the source code will not throw an exception. However, compilation errors and warnings will be reported in the web console. You should always check the console for <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> messages during development.</p>
<hr />
<p>We will look at <abbr title="WebGPU 着色器语言，是编写 WebGPU 使用的着色器的编程语言。">WGSL</abbr> in some detail in <a href="../s3/">Section 9.3</a>. <abbr title="WebGPU 着色器语言，是编写 WebGPU 使用的着色器的编程语言。">WGSL</abbr> is similar in many ways to <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr>, the shading language for <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>, but its variable and function declarations are very different. I will give just a short discussion here, to help you understand the relationship between the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> part and the <abbr title="WebGPU 着色器语言，是编写 WebGPU 使用的着色器的编程语言。">WGSL</abbr> part of a <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> application. Here is the short <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> source code from our <a href="../../../en/source/webgpu/basic_webgpu_1.html">first <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> example</a>. It is defined (on the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side) as a template string, which can extend over multiple lines:</p>
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">shaderSource</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sb">`</span>

<span class="sb">@group(0) @binding(0) var&lt;uniform&gt; color : vec3f;</span>

<span class="sb">@vertex</span>
<span class="sb">fn vertexMain( @location(0) coords : vec2f ) -&gt; @builtin(position) vec4f {</span>
<span class="sb">    return vec4f( coords, 0, 1 );</span>
<span class="sb">}</span>

<span class="sb">@fragment</span>
<span class="sb">fn fragmentMain() -&gt; @location(0) vec4f {</span>
<span class="sb">    return vec4f( color, 1 ); </span>
<span class="sb">}</span>
<span class="sb">`</span><span class="p">;</span>
</code></pre></div>
<p>The syntax for a function definition in <abbr title="WebGPU 着色器语言，是编写 WebGPU 使用的着色器的编程语言。">WGSL</abbr> is</p>
<div class="highlight"><pre><span></span><code><span class="nx">fn</span><span class="w"> </span><span class="nx">function_name</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="nx">parameter_list</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nx">return_type</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="p">}</span>
</code></pre></div>
<p>The types used in this example—vec2f, vec3f, and vec4f—represent vectors of two, three, and four 32-bit floating point numbers. Variable declarations can have several forms. The one example in this code has the form</p>
<div class="highlight"><pre><span></span><code><span class="kd">var</span><span class="o">&lt;</span><span class="nx">uniform</span><span class="o">&gt;</span><span class="w"> </span><span class="nx">variable_name</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">type</span><span class="w"> </span><span class="p">;</span>
</code></pre></div>
<p>This declares a global variable in the "uniform address space," which will be discussed below. A variable in the uniform address space gets its value from the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side.</p>
<p>The words beginning with "@" are annotations or modifiers. For example, @<abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> means that the following function can be used as a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> entry point, and @fragment means that the following function can be used as a <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> entry point. The @builtin(position) annotation says that the return value from vertexMain() gives the coordinates of the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> in the standard <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr>. And @location(0), @group(0), and @binding(0) in this example are used to specify connections between data in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> and data on the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side, as will be discussed below.</p>
<p>The <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> and <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> functions that are used here are very simple. The <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> simply takes the (x,y) coordinates from its parameter, which comes from the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side, and adds z- and w-coordinates to get the final <abbr title="A way of representing n-dimensional vectors as (n+1)-dimensional vectors where two (n+1) vectors represent the same n-dimensional vector if they differ by a scalar multiple. In 3D, for example, if w is not zero, then the homogeneous coordinates (x,y,z,w) are equivalent to homogeneous coordinates (x/w,y/w,z/w,1), since they differ by multiplication by the scalar w. Both sets of coordinates represent the 3D vector (x/w,y/w,z/w)">homogeneous coordinates</abbr> for the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>. The expression vec4f(coords,0,1) for the return value constructs a vec4f (a <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> of four floats) from the four floating-point values in its parameter list. The <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr>, which outputs an <abbr title="An RGB color—specified by red, green, and blue component values—together with an alpha component. The alpha component is most often take to specify the degree of transparency of the color, with a maximal alpha value giving a fully opaque color.">RGBA color</abbr> for the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> that it is processing, simple uses the three RGB components from the uniform color variable, which comes from the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side, and adds a 1 for the <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> component of the color.</p>
</div>
</div>
</div>
<h2 id="913-渲染管线">9.1.3 渲染管线<a class="headerlink" href="#913-渲染管线" title="Permanent link">&para;</a></h2>
<p><strong>Render Pipeline</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="4:2"><input checked="checked" id="__tabbed_4_1" name="__tabbed_4" type="radio" /><input id="__tabbed_4_2" name="__tabbed_4" type="radio" /><div class="tabbed-labels"><label for="__tabbed_4_1">中文</label><label for="__tabbed_4_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p><abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> 中，图像是作为一系列处理阶段的输出而产生的，这些阶段构成了一个“渲染管线”。顶点着色器和片段着色器是管线中的可编程阶段，但还有其他固定功能的阶段内置于 <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> 中。管线的输入来自 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 中的数据结构。如果数据源自应用程序的 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 端，则必须先将其复制到 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>，然后才能在管线中使用。以下是通用渲染管线结构的示意图：</p>
<p><a class="glightbox" href="../../../en/c9/webgpu-render-pipeline.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="WebGPU 渲染管线中的数据流" src="../../../en/c9/webgpu-render-pipeline.png" /></a></p>
<p>该图示显示了两种类型的管线输入：<strong><abbr title="在 WebGPU 中，顶点缓冲区是一种 GPU 数据结构，用于保存作为顶点着色器输入的值。">顶点缓冲区</abbr></strong>和<strong><abbr title="一种数据结构，可以保存缓冲区、纹理和样本等资源，作为输入进入管线。">绑定组</abbr></strong>。回想一下，当绘制一个图元时，顶点着色器会针对图元中的每个顶点被调用一次。顶点着色器的每次调用都可以为顶点着色器入口点函数中的参数获取不同的值。这些值来自顶点缓冲区。缓冲区必须为每个顶点的参数加载值。管线的一个固定功能阶段，显示为顶点缓冲区和顶点着色器之间的点，会针对每个顶点调用一次顶点着色器，从缓冲区中提取该顶点的适当参数值集。（顶点缓冲区还保存实例化绘制的数据，将在<a href="../s3/">下一节</a>中介绍）。</p>
<p>顶点着色器输出一些值，这些值必须包括顶点的坐标，但也可以包括其他值，如颜色、纹理坐标和顶点的法向量。管线中位于顶点着色器和片段着色器之间的中间阶段以各种方式处理这些值。例如，顶点的坐标用于确定哪些像素位于图元中。通过插值顶点坐标来计算像素的坐标。颜色和纹理坐标等值通常也会被插值，以获得每个像素的不同值。所有这些值都可以作为输入提供给片段着色器，片段着色器将针对图元中的每个像素调用一次，并为其参数提供适当的值。</p>
<p>顶点缓冲区之所以特殊，是因为它们用于提供顶点着色器参数的方式。其他类型的输入存储在称为绑定组的数据结构中。绑定组中的值作为全局变量提供给顶点和片段着色器。</p>
<p>片段着色器可以输出多个值。这些值的目标位于管线外部，被称为管线的“颜色附件”。在最常见的情况下，只有一个输出，表示要分配给像素的颜色，相关的附件是正在渲染的图像（或者更确切地说，是保存该图像颜色数据的内存块）。多个输出可以用于高级应用，如延迟着色（见<a href="../../c7/s5/#754-延迟着色">7.5.4小节</a>）。</p>
<p><abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> 程序负责创建管线并提供它们的许多配置细节。（幸运的是，许多细节可以通过剪切和粘贴的久经考验的方法来处理。）让我们看看我们第一个示例程序中的相对简单的例子。目标是在以下代码摘录的最后创建一个渲染管线。在此之前，程序创建了一些对象来指定管线配置：</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">vertexBufferLayout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="c1">// 顶点缓冲区规范的数组。</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="nx">attributes</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">shaderLocation</span><span class="o">:</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">offset</span><span class="o">:</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">format</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;float32x2&quot;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">],</span>
<span class="w">        </span><span class="nx">arrayStride</span><span class="o">:</span><span class="w"> </span><span class="mf">8</span><span class="p">,</span><span class="w"> </span>
<span class="w">        </span><span class="nx">stepMode</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;vertex&quot;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">];</span>

<span class="kd">let</span><span class="w"> </span><span class="nx">uniformBindGroupLayout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createBindGroupLayout</span><span class="p">({</span>
<span class="w">    </span><span class="nx">entries</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="c1">// 资源规范的数组。</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="nx">binding</span><span class="o">:</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span>
<span class="w">        </span><span class="nx">visibility</span><span class="o">:</span><span class="w"> </span><span class="nx">GPUShaderStage</span><span class="p">.</span><span class="nx">FRAGMENT</span><span class="p">,</span>
<span class="w">        </span><span class="nx">buffer</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">type</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;uniform&quot;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">]</span>
<span class="p">});</span>

<span class="kd">let</span><span class="w"> </span><span class="nx">pipelineDescriptor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">vertex</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 顶点着色器的配置。</span>
<span class="w">        </span><span class="nx">module</span><span class="o">:</span><span class="w"> </span><span class="nx">shader</span><span class="p">,</span><span class="w"> </span>
<span class="w">        </span><span class="nx">entryPoint</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;vertexMain&quot;</span><span class="p">,</span><span class="w"> </span>
<span class="w">        </span><span class="nx">buffers</span><span class="o">:</span><span class="w"> </span><span class="nx">vertexBufferLayout</span><span class="w"> </span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="nx">fragment</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 片段着色器的配置。</span>
<span class="w">        </span><span class="nx">module</span><span class="o">:</span><span class="w"> </span><span class="nx">shader</span><span class="p">,</span><span class="w"> </span>
<span class="w">        </span><span class="nx">entryPoint</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;fragmentMain&quot;</span><span class="p">,</span><span class="w"> </span>
<span class="w">        </span><span class="nx">targets</span><span class="o">:</span><span class="w"> </span><span class="p">[{</span>
<span class="w">            </span><span class="nx">format</span><span class="o">:</span><span class="w"> </span><span class="nx">navigator</span><span class="p">.</span><span class="nx">gpu</span><span class="p">.</span><span class="nx">getPreferredCanvasFormat</span><span class="p">()</span>
<span class="w">        </span><span class="p">}]</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="nx">primitive</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">topology</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;triangle-list&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="nx">layout</span><span class="o">:</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createPipelineLayout</span><span class="p">({</span>
<span class="w">    </span><span class="nx">bindGroupLayouts</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="nx">uniformBindGroupLayout</span><span class="p">]</span>
<span class="w">    </span><span class="p">})</span>
<span class="p">};</span>

<span class="nx">pipeline</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createRenderPipeline</span><span class="p">(</span><span class="nx">pipelineDescriptor</span><span class="p">);</span>
</code></pre></div>
<p>（你可以在<a href="../../../en/source/webgpu/basic_webgpu_1.html">程序</a>的源代码中阅读带有更多注释的相同代码。）</p>
<p>这里有很多内容！管线描述符的 <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> 和 fragment 属性描述了管线中使用的着色器。module 属性是包含着色器函数的编译着色器模块。entryPoint 属性提供了在着色器源代码中使用的着色器入口点函数的名称。buffers 和 targets 属性与顶点着色器函数的输入和片段着色器函数的输出有关。</p>
<p>顶点缓冲区和绑定组的“布局”指定了管线所需的输入。它们只指定了输入的结构。它们基本上创建了连接点，实际的输入源可以稍后插入。这允许一个管线通过提供不同的输入来绘制不同的内容。</p>
<p>注意在整个规范中使用数组。例如，管线可以配置为使用多个顶点缓冲区作为输入。顶点缓冲区布局是一个数组，其中数组的每个元素指定一个输入缓冲区。数组元素的索引很重要，因为它标识了相应缓冲区的连接点。索引将在稍后使用，用于连接实际的缓冲区。</p>
<p>同样，管线可以从多个绑定组接收输入。在这种情况下，绑定组的索引来自 pipelineDescriptor 中的 bindGroupLayouts <abbr title="图形对象的属性，例如颜色。图像可以通过其包含的几何形状以及它们的属性来指定。">属性</abbr>，当将实际的绑定组连接到管线时将需要该索引。索引也用于着色器程序中。例如，如果你回顾上面的着色器源代码，你会看到 uniform 变量声明带有 @group(0)。这意味着该变量的值将在 bindGroupLayouts 数组的索引 0 处的绑定组中找到。</p>
<p>此外，每个绑定组可以包含一系列资源，这些资源由该绑定组的绑定组布局的 entries 属性指定。一个条目可以为着色器中的全局变量提供值。在这种情况下，令人困惑的是，不是 entries 数组中条目的索引重要；相反，条目有一个 binding 属性来标识它。在示例程序中，uniform 变量声明上的双注释 @group(0) @binding(0) 表示该变量的值特别来自索引 0 处的绑定组中 binding 数字为 0 的条目。</p>
<p>管线还有输出，这些输出来自片段着色器入口点函数，管线需要这些输出目标的连接点。pipelineDescriptor 中的 targets 属性是一个数组，每个连接点都有一个条目。当着色器源代码使用 fn fragmentMain() -&gt; @location(0) vec4f 定义片段着色器时，输出上的 @location(0) 注释表示该输出将发送到颜色附件编号 0，对应于 targets 数组中索引 0 处的元素。该元素中 format 属性的值指定输出将以适合画布颜色的格式。（系统将自动将着色器输出转换为画布格式，着色器输出使用每个颜色分量的 32 位浮点数，而画布格式使用每个分量的 8 位无符号整数。）</p>
<p>这解释了 pipelineDescriptor 的 primitive <abbr title="图形对象的属性，例如颜色。图像可以通过其包含的几何形状以及它们的属性来指定。">属性</abbr>：它指定了管线可以绘制的几何图元类型。拓扑指定了图元类型，在本例中是“triangle-list”。也就是说，当执行管线时，每组三个顶点将定义一个三角形。<abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> 只有五种图元类型：“point-list”，“line-list”，“line-strip”，“triangle-list”和“triangle-strip”，对应于 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 或 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 中的 POINTS，LINES，LINE_STRIP，TRIANGLES 和 TRIANGLE_STRIP。下图显示了相同的六个顶点在每种拓扑中如何被解释（除了三角形的轮廓和线段的端点不会是实际输出的一部分）：</p>
<p><a class="glightbox" href="../../../en/c9/webgpu-primitives.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="五种 WebGPU 图元拓扑的图片。" src="../../../en/c9/webgpu-primitives.png" /></a></p>
<p>（见<a href="../../c3/s1/#311--opengl基元">3.1.1小节</a>，了解有关如何渲染图元的更多讨论。）</p>
<p>每次绘制图像时，您不必创建一个新的管线。一个管线可以使用任意次数。它可以通过连接不同的输入源来绘制不同的内容。绘制单个图像可能需要几个管线，每个管线都可能执行多次。通常，程序在初始化期间创建管线并将它们存储在全局变量中。</p>
</div>
<div class="tabbed-block">
<p>In <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr>, an image is produced as the output of a series of processing stages that make up a "render <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>." The <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> and <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> are programmable stages in the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>, but there are other fixed function stages that are built into <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr>. Input to the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> comes from data structures in the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>. If the data originates on the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side of the application, it must be copied to the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> before it can be used in the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>. Here is an illustration of the general structure of a render <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>:</p>
<p><a class="glightbox" href="../../../en/c9/webgpu-render-pipeline.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="Data flow in a WebGPU render pipeline" src="../../../en/c9/webgpu-render-pipeline.png" /></a></p>
<p>This diagram shows two types of input to the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>, <strong><abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffers</strong> and <strong>bind groups</strong>. Recall that when a primitive is drawn, the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> is called once for each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> in the primitive. Each invocation of the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> can get different values for the parameters in the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> entry point function. Those values come from <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffers. The buffers must be loaded with values for the parameters for every <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>. A fixed function stage of the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>, shown as the dots between the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffers and the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>, calls the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> once for each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>, pulling the appropriate set of parameter values for that <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> from the buffers. (Vertex buffers also hold data for <abbr title="The ability to render multiple versions of a primitive with a single function call. Each copy can have its own values for certain attributes, such as color or transformation.">instanced drawing</abbr>, which will be covered in the <a href="../s3/">next section</a>).</p>
<p>The <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> outputs some values, which must include the coordinates of the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> but can also include other values such as color, <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates, and <abbr title="A normal vector to a surface at a point on that surface is a vector that is perpendicular to the surface at that point. Normal vectors to curves are defined similarly. Normal vectors are important for lighting calculations.">normal vector</abbr> for the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>. Intermediate stages of the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> between the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> and the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> process the values in various ways. For example, the coordinates of the vertices are used to determine which <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr> lie in the primitive. Coordinates for the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr> are computed by interpolating the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> coordinates. Values like color and <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates are also generally interpolated to get different values for each <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>. All these values are available as inputs to the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr>, which will be called once for each <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> in the primitive with appropriate values for its parameters.</p>
<p>Vertex buffers are special because of the way that they are used to supply <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> parameters. Other kinds of input are stored in the data structures called bind groups. Values from bind groups are made available to <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> and fragment shaders as global variables in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> programs.</p>
<p>The <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> can output several values. The destinations for those values lie outside the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> and are referred to as the "color attachments" for the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>. In the most common case, there is just one output that represents the color to be assigned to the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>, and the associated color attachment is the image that is being rendered (or, rather, the block of memory that holds the color data for that image). Multiple outputs can be used for advanced applications such as <abbr title="A multi-pass rendering technique where a first pass processes the geometry and saves relevant information such as transformed coordinates, normal vectors, and material properties. The data can be stored in textures, which are called &quot;geometry buffers&quot; or &quot;G-buffers&quot; in this context. Lighting and other effects can then be computed in additional passes, using the pre-computed information from the geometry buffers instead of re-computing it for each pass.">deferred shading</abbr> (see <a href="../../c7/s5/#754-延迟着色">Subsection 7.5.4</a>).</p>
<p>A <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> program is responsible for creating pipelines and providing many details of their configuration. (Fortunately, a lot of the detail can be handled by the tried-and-true method of cut-and-paste.) Let's look at the relatively simple example from our first sample program. The goal is to create a render <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> as the final step in the following code excerpt. Before that, the program creates some objects to specify the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> configuration:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">vertexBufferLayout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="c1">// An array of vertex buffer specifications.</span>
<span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="nx">attributes</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">shaderLocation</span><span class="o">:</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">offset</span><span class="o">:</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">format</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;float32x2&quot;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">],</span>
<span class="w">    </span><span class="nx">arrayStride</span><span class="o">:</span><span class="w"> </span><span class="mf">8</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="nx">stepMode</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;vertex&quot;</span>
<span class="p">}</span>
<span class="p">];</span>

<span class="kd">let</span><span class="w"> </span><span class="nx">uniformBindGroupLayout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createBindGroupLayout</span><span class="p">({</span>
<span class="w">    </span><span class="nx">entries</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="c1">// An array of resource specifications.</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="nx">binding</span><span class="o">:</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span>
<span class="w">        </span><span class="nx">visibility</span><span class="o">:</span><span class="w"> </span><span class="nx">GPUShaderStage</span><span class="p">.</span><span class="nx">FRAGMENT</span><span class="p">,</span>
<span class="w">        </span><span class="nx">buffer</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">type</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;uniform&quot;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="p">]</span>
<span class="p">});</span>

<span class="kd">let</span><span class="w"> </span><span class="nx">pipelineDescriptor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">vertex</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Configuration for the vertex shader.</span>
<span class="w">    </span><span class="nx">module</span><span class="o">:</span><span class="w"> </span><span class="nx">shader</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="nx">entryPoint</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;vertexMain&quot;</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="nx">buffers</span><span class="o">:</span><span class="w"> </span><span class="nx">vertexBufferLayout</span><span class="w"> </span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="nx">fragment</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Configuration for the fragment shader.</span>
<span class="w">    </span><span class="nx">module</span><span class="o">:</span><span class="w"> </span><span class="nx">shader</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="nx">entryPoint</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;fragmentMain&quot;</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="nx">targets</span><span class="o">:</span><span class="w"> </span><span class="p">[{</span>
<span class="w">        </span><span class="nx">format</span><span class="o">:</span><span class="w"> </span><span class="nx">navigator</span><span class="p">.</span><span class="nx">gpu</span><span class="p">.</span><span class="nx">getPreferredCanvasFormat</span><span class="p">()</span>
<span class="w">    </span><span class="p">}]</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="nx">primitive</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">topology</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;triangle-list&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="nx">layout</span><span class="o">:</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createPipelineLayout</span><span class="p">({</span>
<span class="w">    </span><span class="nx">bindGroupLayouts</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="nx">uniformBindGroupLayout</span><span class="p">]</span>
<span class="w">    </span><span class="p">})</span>
<span class="p">};</span>

<span class="nx">pipeline</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createRenderPipeline</span><span class="p">(</span><span class="nx">pipelineDescriptor</span><span class="p">);</span>
</code></pre></div>
<p>(You can read the same code with more comments in the source code for the <a href="../../../en/source/webgpu/basic_webgpu_1.html">program</a>.)</p>
<p>There is a lot going on here! The <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> and fragment properties of the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> descriptor describe the shaders that are used in the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>. The module property is the compiled <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> module that contains the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> function. The entryPoint property gives the name used for the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> entry point function in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> source code. The buffers and targets properties are concerned with inputs for the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> function and outputs from the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> function.</p>
<p>The <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffer and bind group "layouts" specify what inputs will be required for the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>. They specify only the structure of the inputs. They basically create attachment points where actual input sources can be plugged in later. This allows one <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> to draw different things by providing it with different inputs.</p>
<p>Note the use of arrays throughout the specification. For example, a <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> can be configured to use multiple <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffers for input. The <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffer layout is an array, in which each element of the array specifies one input buffer. The index of an element in the array is important, since it identifies the attachment point for the corresponding buffer. The index will be used later, when attaching an actual buffer.</p>
<p>Similarly, a <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> can take inputs from multiple bind groups. In this case, the index for a bind group comes from the bindGroupLayouts property in the pipelineDescriptor, and that index will be required when attaching an actual bind group to the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>. The index is also used in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program. For example, if you look back at the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> source code above, you'll see that the <abbr title="Variables that represent input to a shader program in a programmable graphics pipeline. A uniform variable has the same value at every vertex and at every pixel of a primitive.">uniform variable</abbr> declaration is annotated with @group(0). This means that the value for that variable will be found in the bind group at index 0 in the bindGroupLayouts array.</p>
<p>Furthermore, each bind group can hold a list of resources, which are specified by the entries property of the bind group layout for that bind group. An entry can provide the value for a global variable in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>. In this case, confusingly, it is not the index of the entry in the entries array that is important; instead, the entry has a binding property to identify it. In the sample program, the double annotation @group(0) @binding(0) on the <abbr title="Variables that represent input to a shader program in a programmable graphics pipeline. A uniform variable has the same value at every vertex and at every pixel of a primitive.">uniform variable</abbr> declaration says that the value for the variable comes specifically from the entry with binding number 0 in the bind group at index 0.</p>
<p>The <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> also has outputs, which come from the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> entry point function, and the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> needs attachment points for the destinations of those outputs. The targets property in the pipelineDescriptor is an array with one entry for each attachment point. When the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> source code defines the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> with fn fragmentMain() -&gt; @location(0) vec4f, the annotation @location(0) on the output says that that output will be sent to color attachment number 0, corresponding to the element at index 0 in the targets array. The value for the format property in that element specifies that the output will be in the appropriate format for colors in a canvas. (The system will automatically translate the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> output, which uses a 32-bit float for each <abbr title="One of the numbers used in a color model to specify a color. For example, in the RGB color model, a color is specified by three color components representing the amounts of red, green, and blue in the color.">color component</abbr>, into the canvas format, which uses an 8-bit unsigned integer for each component.)</p>
<p>That leaves the primitive property of the pipelineDescriptor to be explained: It specifies the kind of <abbr title="Geometric objects in a graphics system, such as OpenGL, that are not made up of simpler objects. Examples in OpenGL include points, lines, and triangles, but the set of available primitives depends on the graphics system. (Note that as the term is used in OpenGL, a single primitive can be made up of many points, line segments, or triangles.)">geometric primitive</abbr> that the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> can draw. The topology specifies the primitive type, which in this example is "triangle-list." That is, when the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> is executed, each group of three vertices will define a triangle. <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> has only five primitive types: "point-list", "line-list", "line-strip", "triangle-list", and "triangle-strip", corresponding to POINTS, LINES, LINE_STRIP, TRIANGLES, and TRIANGLE_STRIP in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> or <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr>. This illustration shows how the same six vertices would be interpreted in each topology (except that outlines of triangles and endpoints of line segments would not be part of the actual output):</p>
<p><a class="glightbox" href="../../../en/c9/webgpu-primitives.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="Pictures of the five WebGPU primitive topologies." src="../../../en/c9/webgpu-primitives.png" /></a></p>
<p>(See <a href="../../c3/s1/#311--opengl基元">Subsection 3.1.1</a> for more discussion of how primitives are rendered.)</p>
<p>You don't have to create a <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> every time you draw an image. A <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> can be used any number of times. It can be used to draw different things by attaching different input sources. Drawing a single image might require several pipelines, each of which might be executed several times. It is common for programs to create pipelines during initialization and store them in global variables.</p>
</div>
</div>
</div>
<h2 id="914-缓冲区">9.1.4 缓冲区<a class="headerlink" href="#914-缓冲区" title="Permanent link">&para;</a></h2>
<p><strong>Buffers</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="5:2"><input checked="checked" id="__tabbed_5_1" name="__tabbed_5" type="radio" /><input id="__tabbed_5_2" name="__tabbed_5" type="radio" /><div class="tabbed-labels"><label for="__tabbed_5_1">中文</label><label for="__tabbed_5_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>管线的输入来自顶点缓冲区以及绑定组中的通用目的缓冲区和其他资源。（其他可能的资源与纹理有关，我们将在<a href="../../c3/s5/">第9.5节</a>中才会遇到。）您需要知道如何创建缓冲区，用数据填充它，以及如何将其附加到管线。</p>
<p>使用 <code>device.createBuffer()</code> 函数创建缓冲区。它接受一个参数，该参数指定缓冲区的大小（以字节为单位）以及缓冲区的用途。例如，示例程序使用以下代码创建顶点缓冲区：</p>
<div class="highlight"><pre><span></span><code><span class="nx">vertexBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">({</span>
<span class="w">    </span><span class="nx">size</span><span class="o">:</span><span class="w"> </span><span class="nx">vertexCoords</span><span class="p">.</span><span class="nx">byteLength</span><span class="p">,</span>
<span class="w">    </span><span class="nx">usage</span><span class="o">:</span><span class="w"> </span><span class="nx">GPUBufferUsage</span><span class="p">.</span><span class="nx">VERTEX</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">GPUBufferUsage</span><span class="p">.</span><span class="nx">COPY_DST</span>
<span class="p">});</span>
</code></pre></div>
<p>顶点缓冲区的目的是保存程序 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 端顶点着色器的输入。数据将来自类型化数组，如 <code>Float32Array</code>，或来自相关的 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 数据类型，如 <code>ArrayBuffer</code>。在本例中，<code>vertexCoords</code> 是一个 <code>Float32Array</code>，它保存了三角形顶点的 xy <abbr title="一种将数值坐标分配给几何点的方法。在二维中，每个点对应一对数字。在三维中，每个点对应一组三个数字。">坐标</abbr>，而 <code>vertexCoords.byteLength</code> 提供了该数组中的字节数。（或者，大小可以指定为 <code>4*vertexCoords.length</code> 或常量 <code>24</code>。）</p>
<p>此示例中的 <code>usage</code> 属性表明缓冲区是顶点缓冲区，并且可以用作复制数据的目的地。<code>usage</code> 的值可以给定为使用常量，如 <code>GPUBufferUsage.VERTEX</code>，或通过这些常量的位或运算结果。</p>
<p>程序还使用缓冲区来保存着色器中 uniform 颜色变量的值。颜色值由三个四字节的浮点数组成，缓冲区可以这样创建：</p>
<div class="highlight"><pre><span></span><code><span class="nx">uniformBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">({</span>
<span class="w">    </span><span class="nx">size</span><span class="o">:</span><span class="w"> </span><span class="mf">3</span><span class="o">*</span><span class="mf">4</span><span class="p">,</span>
<span class="w">    </span><span class="nx">usage</span><span class="o">:</span><span class="w"> </span><span class="nx">GPUBufferUsage</span><span class="p">.</span><span class="nx">UNIFORM</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">GPUBufferUsage</span><span class="p">.</span><span class="nx">COPY_DST</span>
<span class="p">});</span>
</code></pre></div>
<p>只有顶点缓冲区直接附加到管线。其他缓冲区必须是一个绑定组的一部分，该绑定组附加到管线。示例程序创建了一个绑定组来保存 <code>uniformBuffer</code>：</p>
<div class="highlight"><pre><span></span><code><span class="nx">uniformBindGroup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createBindGroup</span><span class="p">({</span>
<span class="w">    </span><span class="nx">layout</span><span class="o">:</span><span class="w"> </span><span class="nx">uniformBindGroupLayout</span><span class="p">,</span>
<span class="w">    </span><span class="nx">entries</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="nx">binding</span><span class="o">:</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="c1">// 对应于布局中的 binding 0。</span>
<span class="w">            </span><span class="nx">resource</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">buffer</span><span class="o">:</span><span class="w"> </span><span class="nx">uniformBuffer</span><span class="p">,</span><span class="w"> </span><span class="nx">offset</span><span class="o">:</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">size</span><span class="o">:</span><span class="w"> </span><span class="mf">3</span><span class="o">*</span><span class="mf">4</span><span class="w"> </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">]</span>
<span class="p">});</span>
</code></pre></div>
<p>回想一下，<code>uniformBindGroupLayout</code> 是为了指定绑定组的结构而创建的。绑定组布局有指定资源的条目；相应的绑定组有提供实际资源的条目。在这种情况下，资源是一个缓冲区。资源的 <code>offset</code> 和 <code>size</code> 属性使得只使用缓冲区的一个片段成为可能；<code>offset</code> 是片段的起始字节号，<code>size</code> 是片段中的字节数。</p>
<p>要使缓冲区有用，必须用数据加载它。缓冲区存在于程序的 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 端。对于源自 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 端的数据，<code>device.queue.writeBuffer()</code> 函数是将数据复制到 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 缓冲区的最简单方法。例如，函数调用</p>
<div class="highlight"><pre><span></span><code><span class="nx">device</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">writeBuffer</span><span class="p">(</span><span class="nx">vertexBuffer</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">vertexCoords</span><span class="p">);</span>
</code></pre></div>
<p>将 <code>vertexCoords</code> 数组的全部内容复制到 <code>vertexBuffer</code> 中，从缓冲区的字节号 0 开始。可以复制类型化数组的子数组到缓冲区的任何位置。一般形式是</p>
<div class="highlight"><pre><span></span><code><span class="nx">device</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">writeBuffer</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span><span class="w"> </span><span class="nx">startByte</span><span class="p">,</span><span class="w"> </span><span class="nx">array</span><span class="p">,</span><span class="w"> </span><span class="nx">startIndex</span><span class="p">,</span><span class="w"> </span><span class="nx">count</span><span class="p">)</span>
</code></pre></div>
<p>其中 <code>count</code> 指定要复制到缓冲区的数组元素数量。（当数据源是类型化数组时；对于其他数据源，源中的起始位置和要复制的数据大小以字节为单位测量。）</p>
<p>在示例程序中，缓冲区和绑定组只创建一次，在初始化期间。<code>vertexBuffer</code> 和 <code>uniformBuffer</code> 是全局变量 —— <code>vertexBuffer</code> 因为在每次使用管线绘制三角形时都必须附加到管线，<code>uniformBuffer</code> 以便可以更改存储在其中的数据。每次要更改三角形的颜色时，都会向 <code>uniformBuffer</code> 写入一个新值。同样，<code>uniformBindGroup</code> 是一个全局变量，因为每次绘制三角形时都必须附加到管线。</p>
<hr />
<p>思考 <code>writeBuffer()</code> 函数为何是设备对象中的 device.queue 的一个方法是一件有趣的事情。所说的队列是 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 上要执行的操作队列。当 <code>writeBuffer()</code> 返回时，并不一定意味着数据已经被写入缓冲区。但是，执行复制的操作已经被添加到队列中了。你所能保证的是，在队列中后续操作需要使用该缓冲区之前，数据将被复制到缓冲区。这可以包括使用该缓冲区的绘制操作。同样有可能队列中已经包含了依赖于缓冲区中先前值的操作，所以新数据不能被复制到缓冲区，直到那些操作完成。</p>
<p>当调用 <code>device.queue.writeBuffer()</code> 时，它立即将数据复制到一个中间的“暂存”缓冲区，这个缓冲区存在于 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 和 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 两侧共享的内存中。这意味着你可以立即重用数组；你不必等待数据被复制到最终目的地。而不是调用 <code>writeBuffer()</code>，可以自己完成这项工作——创建一个暂存缓冲区，将数据复制到暂存缓冲区，排队一个命令将数据从暂存缓冲区复制到目标缓冲区——但是 <code>writeBuffer()</code> 使这个过程变得更加容易。</p>
</div>
<div class="tabbed-block">
<p>Inputs to a <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> come from <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffers and from general purpose buffers and other resources in bind groups. (The other possible resources relate to textures, which we will not encounter until <a href="../../c3/s5/">Section 9.5</a>). You need to know how to create a buffer, fill it with data, and attach it to a <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>.</p>
<p>The function device.createBuffer() is used for creating buffers. It takes a parameter that specifies the size of the buffer in bytes and how the buffer will be used. For example, the sample program creates a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffer with</p>
<div class="highlight"><pre><span></span><code><span class="nx">vertexBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">({</span>
<span class="w">    </span><span class="nx">size</span><span class="o">:</span><span class="w"> </span><span class="nx">vertexCoords</span><span class="p">.</span><span class="nx">byteLength</span><span class="p">,</span>
<span class="w">    </span><span class="nx">usage</span><span class="o">:</span><span class="w"> </span><span class="nx">GPUBufferUsage</span><span class="p">.</span><span class="nx">VERTEX</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">GPUBufferUsage</span><span class="p">.</span><span class="nx">COPY_DST</span>
<span class="p">});</span>
</code></pre></div>
<p>The purpose of a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffer is to hold inputs for a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> on the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> side of the program. The data will come from a <abbr title="In JavaScript, an array type that is limited to holding numerical values of a single type. For example, the type Float32Array represents arrays that can hold 32-bit floating point values, and Uint8Array arrays can hold only 8-bit integer values. Such arrays are more efficient than general JavaScript arrays for numerical calculations. The were introduced into JavaScript along with HTML canvas graphics and WebGL.">typed array</abbr>, such as a <strong><em>Float32Array</em></strong>, or from a related <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> data type such as <strong><em>ArrayBuffer</em></strong>. In this case, vertexCoords is a <strong><em>Float32Array</em></strong> that holds the xy-coordinates of the vertices of a triangle, and vertexCoords.byteLength gives the number of bytes in that array. (Alternatively, the size could be specified as 4*vertexCoords.length or as the constant 24.)</p>
<p>The usage property in this example says that the buffer is a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffer and that it can be used as a destination for copying data. The value for the usage can be given as a usage constant such as GPUBufferUsage.VERTEX or by the bitwise OR of several such constants.</p>
<p>The program also uses a buffer to hold the value for the uniform color variable in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>. The color value consists of three four-byte floats, and the buffer can be created with</p>
<div class="highlight"><pre><span></span><code><span class="nx">uniformBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">({</span>
<span class="nx">size</span><span class="o">:</span><span class="w"> </span><span class="mf">3</span><span class="o">*</span><span class="mf">4</span><span class="p">,</span>
<span class="nx">usage</span><span class="o">:</span><span class="w"> </span><span class="nx">GPUBufferUsage</span><span class="p">.</span><span class="nx">UNIFORM</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">GPUBufferUsage</span><span class="p">.</span><span class="nx">COPY_DST</span>
<span class="p">});</span>
</code></pre></div>
<p>Only <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffers are attached directly to pipelines. Other buffers must be part of a bind group that is attached to the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>. The sample program creates a bind group to hold uniformBuffer:</p>
<div class="highlight"><pre><span></span><code><span class="nx">uniformBindGroup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createBindGroup</span><span class="p">({</span>
<span class="nx">layout</span><span class="o">:</span><span class="w"> </span><span class="nx">uniformBindGroupLayout</span><span class="p">,</span>
<span class="nx">entries</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="nx">binding</span><span class="o">:</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="c1">// Corresponds to the binding 0 in the layout.</span>
<span class="w">        </span><span class="nx">resource</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">buffer</span><span class="o">:</span><span class="w"> </span><span class="nx">uniformBuffer</span><span class="p">,</span><span class="w"> </span><span class="nx">offset</span><span class="o">:</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">size</span><span class="o">:</span><span class="w"> </span><span class="mf">3</span><span class="o">*</span><span class="mf">4</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">]</span>
<span class="p">});</span>
</code></pre></div>
<p>Recall that uniformBindGroupLayout was created to specify the structure of the bind group. The bind group layout has entries that specify resources; a corresponding bind group has entries the provide the actual resources. The resource in this case is a buffer. The offset and size properties of the resource make it possible to use just a segment of a buffer; offset is the starting byte number of the segment, and size is the number of bytes in the segment.</p>
<p>To be useful, a buffer must loaded with data. The buffer exists on the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> side of the program. For data that originates on the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side, the function device.queue.writeBuffer() is the easiest way to copy the data into a <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> buffer. For example the function call</p>
<p>device.queue.writeBuffer(vertexBuffer, 0, vertexCoords);
copies the entire contents of the vertexCoords array into vertexBuffer, starting at byte number 0 in the buffer. It is possible to a copy a subarray of a <abbr title="In JavaScript, an array type that is limited to holding numerical values of a single type. For example, the type Float32Array represents arrays that can hold 32-bit floating point values, and Uint8Array arrays can hold only 8-bit integer values. Such arrays are more efficient than general JavaScript arrays for numerical calculations. The were introduced into JavaScript along with HTML canvas graphics and WebGL.">typed array</abbr> to any position in the buffer. The general form is</p>
<div class="highlight"><pre><span></span><code><span class="nx">device</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">writeBuffer</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span><span class="nx">startByte</span><span class="p">,</span><span class="nx">array</span><span class="p">,</span><span class="nx">startIndex</span><span class="p">,</span><span class="nx">count</span><span class="p">)</span>
</code></pre></div>
<p>where count gives the number of elements of array to be copied into buffer. (This is when the data source is a <abbr title="In JavaScript, an array type that is limited to holding numerical values of a single type. For example, the type Float32Array represents arrays that can hold 32-bit floating point values, and Uint8Array arrays can hold only 8-bit integer values. Such arrays are more efficient than general JavaScript arrays for numerical calculations. The were introduced into JavaScript along with HTML canvas graphics and WebGL.">typed array</abbr>; for other data sources, the starting position in the source and the size of the data to be copied are measured in bytes.)</p>
<p>In the sample program, the buffers and bind group are created just once, during initialization. And vertexBuffer and uniformBuffer are global variables—vertexBuffer because it must be attached to the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> each time the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> is used to draw a triangle, and uniformBuffer so that the data stored in it can be changed. A new value is written to uniformBuffer every time the color of the triangle is to be changed. Similarly, uniformBindGroup is a global variable because it must be attached to the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> each time a triangle is drawn.</p>
<hr />
<p>It is interesting to think about why the <code>writeBuffer()</code> function is a method in the object device.queue. The queue in question is a queue of operations to be performed on the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>. When <code>writeBuffer()</code> returns, it is not necessarily true that the data has been written to the buffer. However, the operation that does the copying has been added to the queue. What you are guaranteed is that the data will be copied to the buffer before it is needed by operations that come later in the queue. That can include drawing operations that use the buffer. It is also possible that the queue already contains operations that depend on the previous value in the buffer, so the new data can't be copied into the buffer until those operations have completed.</p>
<p>When <code>device.queue.writeBuffer()</code> is called, it immediately copies the data into an intermediate "staging" buffer that exists in memory that is shared by the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> and <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> sides. This means that you are free to reuse the array immediately; you don't have to wait for the data to be copied to its final destination. Instead of calling <code>writeBuffer()</code>, it's possible to do the work yourself—create a staging buffer, copy the data into the staging buffer, enqueue a command to copy the data from the staging buffer to the destination buffer—but <code>writeBuffer()</code> makes the process much easier.</p>
</div>
</div>
</div>
<h2 id="915-绘图">9.1.5 绘图<a class="headerlink" href="#915-绘图" title="Permanent link">&para;</a></h2>
<p><strong>Drawing</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="6:2"><input checked="checked" id="__tabbed_6_1" name="__tabbed_6" type="radio" /><input id="__tabbed_6_2" name="__tabbed_6" type="radio" /><div class="tabbed-labels"><label for="__tabbed_6_1">中文</label><label for="__tabbed_6_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>随着管线设置完毕和输入缓冲区准备就绪，是时候真正绘制三角形了！绘制命令在 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 端指定，但在 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 端执行。在 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 端使用“命令编码器”来创建一个命令列表，该列表可以以可以添加到 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 处理命令队列的形式存在。命令编码器由 <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> 设备创建：</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">commandEncoder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createCommandEncoder</span><span class="p">();</span>
</code></pre></div>
<p>为了绘制，我们需要编码一个“渲染通道”，为此，我们需要一个渲染通道描述符：</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">renderPassDescriptor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">colorAttachments</span><span class="o">:</span><span class="w"> </span><span class="p">[{</span>
<span class="w">        </span><span class="nx">clearValue</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">r</span><span class="o">:</span><span class="w"> </span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="nx">g</span><span class="o">:</span><span class="w"> </span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="o">:</span><span class="w"> </span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="nx">a</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="p">},</span><span class="w">  </span><span class="c1">// 灰色背景</span>
<span class="w">        </span><span class="nx">loadOp</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;clear&quot;</span><span class="p">,</span><span class="w"> </span><span class="c1">// 另一种选择是 &quot;load&quot;。</span>
<span class="w">        </span><span class="nx">storeOp</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;store&quot;</span><span class="p">,</span><span class="w">  </span><span class="c1">// 另一种选择是 &quot;discard&quot;。</span>
<span class="w">        </span><span class="nx">view</span><span class="o">:</span><span class="w"> </span><span class="nx">context</span><span class="p">.</span><span class="nx">getCurrentTexture</span><span class="p">().</span><span class="nx">createView</span><span class="p">()</span><span class="w">  </span><span class="c1">// 绘制到画布上。</span>
<span class="w">    </span><span class="p">}]</span>
<span class="p">};</span>
</code></pre></div>
<p>renderPassDescriptor 的 colorAttachments 属性对应于管线的输出目标。colorAttachments 数组的每个元素指定了输出目标数组中对应元素的目的地。在这种情况下，我们想要在网页上的画布上绘制。loadOp 属性的值为 "clear"，如果画布在绘制前要被填充为清除颜色；如果希望在画布的先前内容上绘制，则为 "load"。clearValue 给出了清除颜色的 RGBA 分量，为 0.0 到 1.0 范围内的浮点值。storeOp 几乎总是 "store"。view 属性指定了图像将被绘制的位置。在这种情况下，最终目的地是画布，但实际目的地是一个纹理，当网页内容刷新时，它将被复制到画布上。每次画布重新绘制时都必须调用 context.getCurrentTexture() 函数，因此我们不能简单地制作一个渲染通道描述符，并将其不变地用于每次渲染。</p>
<p>绘制命令本身由渲染通道编码器编码，渲染通道编码器从命令编码器获得。在我们的示例中，通道编码器组装了绘制所需的资源（管线、顶点缓冲区和绑定组），并发出实际进行绘制的命令。调用 passEncoder.end() 终止渲染通道：</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">passEncoder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">commandEncoder</span><span class="p">.</span><span class="nx">beginRenderPass</span><span class="p">(</span><span class="nx">renderPassDescriptor</span><span class="p">);</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">setPipeline</span><span class="p">(</span><span class="nx">pipeline</span><span class="p">);</span><span class="w">            </span><span class="c1">// 指定管线。</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">setVertexBuffer</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="nx">vertexBuffer</span><span class="p">);</span><span class="w">  </span><span class="c1">// 附加顶点缓冲区。</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">setBindGroup</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="nx">uniformBindGroup</span><span class="p">);</span><span class="w"> </span><span class="c1">// 附加绑定组。</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">draw</span><span class="p">(</span><span class="mf">3</span><span class="p">);</span><span class="w">                          </span><span class="c1">// 生成顶点。</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">end</span><span class="p">();</span>
</code></pre></div>
<p>在这种情况下，绘制命令，passEncoder.draw(3)，在执行时将简单地生成三个顶点。由于管线使用的是“triangle-list”拓扑，这些顶点形成了一个三角形。作为管线一部分指定的顶点着色器函数将被调用三次，输入来自顶点缓冲区。顶点着色器的三次调用的输出指定了一个三角形的三个顶点的位置。然后，对于三角形中的每个像素，都会调用片段着色器函数。片段着色器从作为绑定组一部分的 uniform 缓冲区获取像素的颜色。程序早期完成的所有设置最终将被用来产生图像！这是一个简单的例子。更一般地说，一个渲染通道可以涉及其他选项、多个绘制命令和其他命令。</p>
<p>您应该注意，所有这些实际上并没有进行任何绘制！它只是编码了进行绘制所需的命令，并将其添加到命令编码器中。最后一步是从命令编码器获取编码命令列表，并将其提交给 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 执行：</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">commandBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">commandEncoder</span><span class="p">.</span><span class="nx">finish</span><span class="p">();</span>
<span class="nx">device</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">submit</span><span class="p">(</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nx">commandBuffer</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>device.queue.submit() 的参数是命令缓冲区的数组，尽管在这种情况下只有一个。（命令编码器不能重复使用；如果您想提交多个命令缓冲区，您将需要为每一个创建一个新的命令编码器。）</p>
<p>请注意，命令是提交给设备队列的。submit() 函数在将命令排队后立即返回。它们将在应用程序的 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 端的单独进程中执行。</p>
</div>
<div class="tabbed-block">
<p>With the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> set up and the input buffers ready, it's time to actually draw the triangle! The drawing commands are specified on the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side but executed on the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> side. A "command encoder" is used on the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side to create a list of commands in a form that can be added to the queue of commands for processing on the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>. The command encoder is created by the <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> device:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">commandEncoder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createCommandEncoder</span><span class="p">();</span>
</code></pre></div>
<p>For drawing, we need to encode a "render pass," and for that, we need a render pass descriptor:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">renderPassDescriptor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="nx">colorAttachments</span><span class="o">:</span><span class="w"> </span><span class="p">[{</span>
<span class="w">    </span><span class="nx">clearValue</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">r</span><span class="o">:</span><span class="w"> </span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="nx">g</span><span class="o">:</span><span class="w"> </span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="o">:</span><span class="w"> </span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="nx">a</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="p">},</span><span class="w">  </span><span class="c1">// gray background</span>
<span class="w">    </span><span class="nx">loadOp</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;clear&quot;</span><span class="p">,</span><span class="w"> </span><span class="c1">// Alternative is &quot;load&quot;.</span>
<span class="w">    </span><span class="nx">storeOp</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;store&quot;</span><span class="p">,</span><span class="w">  </span><span class="c1">// Alternative is &quot;discard&quot;.</span>
<span class="w">    </span><span class="nx">view</span><span class="o">:</span><span class="w"> </span><span class="nx">context</span><span class="p">.</span><span class="nx">getCurrentTexture</span><span class="p">().</span><span class="nx">createView</span><span class="p">()</span><span class="w">  </span><span class="c1">// Draw to the canvas.</span>
<span class="p">}]</span>
<span class="p">};</span>
</code></pre></div>
<p>The colorAttachments property of the renderPassDescriptor corresponds to the output targets of the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>. Each element of the colorAttachments array specifies the destination for the corresponding element in the array of output targets. In this case, we want to draw to the canvas on the web page. The value for the loadOp property is "clear" if the canvas is to be filled with the clear color before drawing; it is "load" if you want to draw over the previous contents of the canvas. The clearValue gives the RGBA components of the clear color as floating point values in the range 0.0 to 1.0. The storeOp will almost always be "store". The view property specifies where the image will be drawn. In this case, the ultimate destination is the canvas, but the actual destination is a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> that will be copied to the canvas when the content of the web page is refreshed. The function context.getCurrentTexture() has to be called each time the canvas is redrawn, so we can't simply make a render pass descriptor and use it unchanged for every render.</p>
<p>The drawing commands themselves are encoded by a render pass encoder, which is obtained from the command encoder. The pass encoder in our example assembles the resources required for the drawing (<abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>, <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffer, and bind group), and it issues the command that actually does the drawing. A call to passEncoder.end() terminates the render pass:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">passEncoder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">commandEncoder</span><span class="p">.</span><span class="nx">beginRenderPass</span><span class="p">(</span><span class="nx">renderPassDescriptor</span><span class="p">);</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">setPipeline</span><span class="p">(</span><span class="nx">pipeline</span><span class="p">);</span><span class="w">            </span><span class="c1">// Specify pipeline.</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">setVertexBuffer</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="nx">vertexBuffer</span><span class="p">);</span><span class="w">  </span><span class="c1">// Attach vertex buffer.</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">setBindGroup</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="nx">uniformBindGroup</span><span class="p">);</span><span class="w"> </span><span class="c1">// Attach bind group.</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">draw</span><span class="p">(</span><span class="mf">3</span><span class="p">);</span><span class="w">                          </span><span class="c1">// Generate vertices.</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">end</span><span class="p">();</span>
</code></pre></div>
<p>The draw command in this case, passEncoder.draw(3), will simply generate three vertices when it is executed. Since the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> uses the "triangle-list" topology, those vertices form a triangle. The <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> function, which was specified as part of the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>, will be called three times, with inputs that are pulled from the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffer. The outputs from the three invocations of the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> specify the positions of the three vertices of a triangle. The <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> function is then called for each <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> in the triangle. The <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> gets the color for the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> from the uniform buffer that is part of the bind group. All the set up that was done earlier in the program will finally be used to produce an image! This is a simple example. More generally, a render pass can involve other options, multiple draw commands, and other commands.</p>
<p>You should note that all of this has not actually done any drawing! It has just encoded the commands that are needed to do the drawing, and has added them to the command encoder. The final step is to get the list of encoded commands from the command encoder and submit them to the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> for execution:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">commandBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">commandEncoder</span><span class="p">.</span><span class="nx">finish</span><span class="p">();</span>
<span class="nx">device</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">submit</span><span class="p">(</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nx">commandBuffer</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>The parameter to <code>device.queue.submit()</code> is an array of command buffers, although in this case there is only one. (The command encoder cannot be reused; if you want to submit multiple command buffers, you will need to create a new command encoder for each one.)</p>
<p>Note that commands are submitted to the device queue. The <code>submit()</code> function returns immediately after enqueueing the commands. They will be executed in a separate process on the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> side of the application.</p>
</div>
</div>
</div>
<h2 id="916-多个顶点输入">9.1.6 多个顶点输入<a class="headerlink" href="#916-多个顶点输入" title="Permanent link">&para;</a></h2>
<p><strong>Multiple Vertex Inputs</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="7:2"><input checked="checked" id="__tabbed_7_1" name="__tabbed_7" type="radio" /><input id="__tabbed_7_2" name="__tabbed_7" type="radio" /><div class="tabbed-labels"><label for="__tabbed_7_1">中文</label><label for="__tabbed_7_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>在我们结束本节之前，我们来看我们基本示例的两个变体：<a href="../../../en/source/webgpu/basic_webgpu_2.html">basic_webgpu_2.html</a> 和 <a href="../../../en/source/webgpu/basic_webgpu_3.html">basic_webgpu_3.html</a>。这些程序不是绘制一个纯色三角形，而是绘制一个每个顶点都有不同颜色的三角形。内部像素的颜色是从顶点颜色插值得到的。这是标准的“RGB三角形”示例。</p>
<p><a class="glightbox" href="../../../en/c9/rgb-triangle.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c9/rgb-triangle.png" /></a></p>
<p>由于每个顶点都有不同的颜色，颜色是一个顶点属性，必须作为参数传递给顶点着色器入口点。在新的示例中，该函数有两个参数，2D顶点坐标和顶点RGB颜色。这些两个值的插值版本由片段着色器使用，因此顶点着色器还需要两个输出。由于一个函数只能有一个返回值，这两个输出必须合并到一个单独的数据结构中。在WGSL中，就像在GLSL中一样，这个数据结构是一个结构体（见<a href="../../c6/s3/#632-数据结构">6.3.2小节</a>）。这是在两个新示例中使用的着色器源代码：</p>
<div class="highlight"><pre><span></span><code><span class="nx">struct</span><span class="w"> </span><span class="nx">VertexOutput</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// 顶点着色器返回值的类型</span>
<span class="w">    </span><span class="err">@</span><span class="nx">builtin</span><span class="p">(</span><span class="nx">position</span><span class="p">)</span><span class="w"> </span><span class="nx">position</span><span class="o">:</span><span class="w"> </span><span class="nx">vec4f</span><span class="p">,</span>
<span class="w">    </span><span class="err">@</span><span class="nx">location</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="nx">color</span><span class="o">:</span><span class="w"> </span><span class="nx">vec3f</span><span class="w">  </span>
<span class="p">}</span>

<span class="err">@</span><span class="nx">vertex</span>
<span class="nx">fn</span><span class="w"> </span><span class="nx">vertexMain</span><span class="p">(</span>
<span class="w">        </span><span class="err">@</span><span class="nx">location</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="nx">coords</span><span class="o">:</span><span class="w"> </span><span class="nx">vec2f</span><span class="p">,</span><span class="w"> </span>
<span class="w">        </span><span class="err">@</span><span class="nx">location</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="nx">color</span><span class="o">:</span><span class="w"> </span><span class="nx">vec3f</span><span class="w">  </span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nx">VertexOutput</span><span class="w"> </span><span class="p">{</span><span class="w">  </span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">output</span><span class="o">:</span><span class="w"> </span><span class="nx">VertexOutput</span><span class="p">;</span><span class="w">  </span>
<span class="w">    </span><span class="nx">output</span><span class="p">.</span><span class="nx">position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4f</span><span class="p">(</span><span class="nx">coords</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">);</span>
<span class="w">    </span><span class="nx">output</span><span class="p">.</span><span class="nx">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">color</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">output</span><span class="p">;</span>
<span class="p">}</span>

<span class="err">@</span><span class="nx">fragment</span>
<span class="nx">fn</span><span class="w"> </span><span class="nx">fragmentMain</span><span class="p">(</span><span class="err">@</span><span class="nx">location</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="nx">fragColor</span><span class="o">:</span><span class="w"> </span><span class="nx">vec3f</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">@</span><span class="nx">location</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="nx">vec4f</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">vec4f</span><span class="p">(</span><span class="nx">fragColor</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>传递给片段着色器函数的 fragColor 参数是顶点着色器颜色输出的插值版本，即使名称不一样。实际上，名称根本无关紧要；顶点着色器输出 color 和片段着色器参数 fragColor 之间的关联是通过 @location(0) 修饰符指定的。注意，@location(0) 在这里的含义与顶点着色器参数 coords 上的 @location(0) 注释非常不同。（回想一下，顶点着色器参数上的 @location 注释对应于 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 端顶点缓冲区布局中的 shaderLocation，它指定了该参数的值来自哪里。）</p>
<p>我再次指出，即使在这个示例中，顶点着色器的位置输出没有明确在片段着色器函数中使用，但它是隐含使用的。顶点着色器函数始终需要有一个 @builtin(position) 输出。</p>
<hr />
<p>应用程序的 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 端现在必须为顶点着色器函数提供两个输入。在第一种变体中，两个输入在两个单独的顶点缓冲区中提供，新的顶点缓冲区布局反映了这一点，有两个数组元素对应于两个顶点缓冲区：</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">vertexBufferLayout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="c1">// 第一个顶点缓冲区，用于 coords（每个顶点两个32位浮点数）。</span>
<span class="w">        </span><span class="nx">attributes</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">shaderLocation</span><span class="o">:</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">offset</span><span class="o">:</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">format</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;float32x2&quot;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">],</span>
<span class="w">        </span><span class="nx">arrayStride</span><span class="o">:</span><span class="w"> </span><span class="mf">8</span><span class="p">,</span><span class="w">  </span><span class="c1">// 缓冲区中的值之间有8个字节</span>
<span class="w">        </span><span class="nx">stepMode</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;vertex&quot;</span><span class="w"> </span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="c1">// 第二个顶点缓冲区，用于颜色（每个顶点三个32位浮点数）。</span>
<span class="w">        </span><span class="nx">attributes</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">shaderLocation</span><span class="o">:</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="nx">offset</span><span class="o">:</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">format</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;float32x3&quot;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">],</span>
<span class="w">        </span><span class="nx">arrayStride</span><span class="o">:</span><span class="w"> </span><span class="mf">12</span><span class="p">,</span><span class="w">  </span><span class="c1">// 缓冲区中的值之间有12个字节</span>
<span class="w">        </span><span class="nx">stepMode</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;vertex&quot;</span><span class="w"> </span>
<span class="w">    </span><span class="p">}</span>
<span class="p">];</span>
</code></pre></div>
<p>第二种变体做了一些更有趣的事情：它使用一个包含两个参数值的顶点缓冲区。颜色的值与坐标的值交错在一起。这是 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 端数据的样子：</p>
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">vertexData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Float32Array</span><span class="p">([</span>
<span class="w">    </span><span class="cm">/* 坐标 */</span><span class="w">     </span><span class="cm">/* 颜色 */</span>
<span class="w">    </span><span class="o">-</span><span class="mf">0.8</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mf">0.6</span><span class="p">,</span><span class="w">      </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w">      </span><span class="c1">// 第一个顶点的数据</span>
<span class="w">    </span><span class="mf">0.8</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mf">0.6</span><span class="p">,</span><span class="w">       </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w">      </span><span class="c1">// 第二个顶点的数据</span>
<span class="w">    </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.7</span><span class="p">,</span><span class="w">        </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="w">       </span><span class="c1">// 第三个顶点的数据</span>
<span class="p">]);</span>
</code></pre></div>
<p>这个数组将被复制到单个顶点缓冲区中。顶点缓冲区布局反映了缓冲区中数据的布局：</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">vertexBufferLayout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="p">{</span><span class="w">   </span><span class="c1">// 一个顶点缓冲区，包含两个属性的值。</span>
<span class="w">        </span><span class="nx">attributes</span><span class="o">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">            </span><span class="p">{</span><span class="w"> </span><span class="nx">shaderLocation</span><span class="o">:</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">offset</span><span class="o">:</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">format</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;float32x2&quot;</span><span class="w"> </span><span class="p">},</span>
<span class="w">            </span><span class="p">{</span><span class="w"> </span><span class="nx">shaderLocation</span><span class="o">:</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="nx">offset</span><span class="o">:</span><span class="mf">8</span><span class="p">,</span><span class="w"> </span><span class="nx">format</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;float32x3&quot;</span><span class="w"> </span><span class="p">}</span>
<span class="w">        </span><span class="p">],</span>
<span class="w">        </span><span class="nx">arrayStride</span><span class="o">:</span><span class="w"> </span><span class="mf">20</span><span class="p">,</span>
<span class="w">        </span><span class="nx">stepMode</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;vertex&quot;</span><span class="w"> </span>
<span class="w">    </span><span class="p">}</span>
<span class="p">];</span>
</code></pre></div>
<p>请注意，每个缓冲区的数据占用20个字节（五个4字节的浮点数）。这成为布局中的 arrayStride，它给出了一个顶点的值到下一个顶点的值之间的距离，以字节为单位。属性的 offset 属性告诉您在给定顶点的数据块中在哪里找到该属性的值：coords 的 offset 是 0，因为它位于数据的开始位置；color 的 offset 是 8，因为它位于数据开始位置的 8个字节处。</p>
<p>我们的第一个示例和两个新变体之间还有其他差异。我鼓励您查看两个新程序的源代码并阅读注释。只有每个程序的新特性有注释。</p>
</div>
<div class="tabbed-block">
<p>Before ending this section, we look at two variations on our basic example: <a href="../../../en/source/webgpu/basic_webgpu_2.html">basic_webgpu_2.html</a> and <a href="../../../en/source/webgpu/basic_webgpu_3.html">basic_webgpu_3.html</a>. Instead of drawing a solid colored triangle, these programs draw a triangle in which each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> has a different color. The colors for the interior <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr> are interpolated from the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> colors. This is the standard "RGB triangle" example.</p>
<p><a class="glightbox" href="../../../en/c9/rgb-triangle.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c9/rgb-triangle.png" /></a></p>
<p>Since each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> has a different color, the color is a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> that has to be passed as a parameter to the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> entry point. In the new examples, that function has two parameters, the 2D <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> coordinates and the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A color specified by three numbers giving the amount of red, green, and blue in the color.">RGB color</abbr>. Interpolated versions of these two values are used by the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr>, so the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> also needs two outputs. Since a function can have only one return value, the two outputs have to be combined into a single data structure. In <abbr title="WebGPU 着色器语言，是编写 WebGPU 使用的着色器的编程语言。">WGSL</abbr>, as in <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr>, that data structure is a struct (see <a href="../../c6/s3/#632-数据结构">Subsection 6.3.2</a>). Here is the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> source code that is used in both of the new examples:</p>
<div class="highlight"><pre><span></span><code><span class="nx">struct</span><span class="w"> </span><span class="nx">VertexOutput</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// type for return value of vertex shader</span>
<span class="err">@</span><span class="nx">builtin</span><span class="p">(</span><span class="nx">position</span><span class="p">)</span><span class="w"> </span><span class="nx">position</span><span class="o">:</span><span class="w"> </span><span class="nx">vec4f</span><span class="p">,</span>
<span class="err">@</span><span class="nx">location</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="nx">color</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">vec3f</span><span class="w">  </span>
<span class="p">}</span>

<span class="err">@</span><span class="nx">vertex</span>
<span class="nx">fn</span><span class="w"> </span><span class="nx">vertexMain</span><span class="p">(</span>
<span class="w">        </span><span class="err">@</span><span class="nx">location</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="nx">coords</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">vec2f</span><span class="p">,</span><span class="w"> </span>
<span class="w">        </span><span class="err">@</span><span class="nx">location</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="nx">color</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">vec3f</span><span class="w">  </span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nx">VertexOutput</span><span class="w"> </span><span class="p">{</span><span class="w">  </span>
<span class="kd">var</span><span class="w"> </span><span class="nx">output</span><span class="o">:</span><span class="w"> </span><span class="nx">VertexOutput</span><span class="p">;</span><span class="w">  </span>
<span class="nx">output</span><span class="p">.</span><span class="nx">position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4f</span><span class="p">(</span><span class="w"> </span><span class="nx">coords</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="p">);</span>
<span class="nx">output</span><span class="p">.</span><span class="nx">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">color</span><span class="p">;</span><span class="w"> </span>
<span class="k">return</span><span class="w"> </span><span class="nx">output</span><span class="p">;</span>
<span class="p">}</span>

<span class="err">@</span><span class="nx">fragment</span>
<span class="nx">fn</span><span class="w"> </span><span class="nx">fragmentMain</span><span class="p">(</span><span class="err">@</span><span class="nx">location</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="nx">fragColor</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">vec3f</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">@</span><span class="nx">location</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="nx">vec4f</span><span class="w"> </span><span class="p">{</span>
<span class="k">return</span><span class="w"> </span><span class="nx">vec4f</span><span class="p">(</span><span class="nx">fragColor</span><span class="p">,</span><span class="mf">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>The fragColor parameter to the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> function is the interpolated version of the color output from the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>, even though the name is not the same. In fact, the names don't matter at all; the association between the two values is specified by the @location(0) modifier on both the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> output, color, and the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> parameter, fragColor. Note that the meaning of @location(0) here is very different from the @location(0) annotation on the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> parameter, coords. (Recall that a @location annotation on a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> parameter corresponds to a shaderLocation in the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffer layout on the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side, and it specifies where the values for that parameter come from.)</p>
<p>I will note again that even though the position output from the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> is not used explicitly in the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> function in this example, it is used implicitly. A <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> function is always required to have a @builtin(position) output.</p>
<hr />
<p>The <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side of the application must now provide two inputs for the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> function. In the first variation, the two inputs are provided in two separate <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffers, and the new <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffer layout reflects this, with two array elements corresponding to the two <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffers:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">vertexBufferLayout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span>
<span class="p">{</span><span class="w"> </span><span class="c1">// First vertex buffer, for coords (two 32-bit floats per vertex).</span>
<span class="w">    </span><span class="nx">attributes</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">shaderLocation</span><span class="o">:</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">offset</span><span class="o">:</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">format</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;float32x2&quot;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">],</span>
<span class="w">    </span><span class="nx">arrayStride</span><span class="o">:</span><span class="w"> </span><span class="mf">8</span><span class="p">,</span><span class="w">  </span><span class="c1">// 8 bytes between values in the buffer</span>
<span class="w">    </span><span class="nx">stepMode</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;vertex&quot;</span><span class="w"> </span>
<span class="p">},</span>
<span class="p">{</span><span class="w"> </span><span class="c1">// Second vertex buffer, for colors (three 32-bit floats per vertex).</span>
<span class="w">    </span><span class="nx">attributes</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">shaderLocation</span><span class="o">:</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="nx">offset</span><span class="o">:</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">format</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;float32x3&quot;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">],</span>
<span class="w">    </span><span class="nx">arrayStride</span><span class="o">:</span><span class="w"> </span><span class="mf">12</span><span class="p">,</span><span class="w">  </span><span class="c1">// 12 bytes between values in the buffer</span>
<span class="w">    </span><span class="nx">stepMode</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;vertex&quot;</span><span class="w"> </span>
<span class="p">}</span>
<span class="p">];</span>
</code></pre></div>
<p>The second variation does something more interesting: It uses just one <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffer that contains the values for both parameters. The values for the colors are interleaved with the values for the coordinates. Here is what the data looks like on the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side:</p>
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">vertexData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Float32Array</span><span class="p">([</span>
<span class="cm">/* coords */</span><span class="w">     </span><span class="cm">/* color */</span>
<span class="w">    </span><span class="o">-</span><span class="mf">0.8</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mf">0.6</span><span class="p">,</span><span class="w">      </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w">      </span><span class="c1">// data for first vertex</span>
<span class="w">    </span><span class="mf">0.8</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mf">0.6</span><span class="p">,</span><span class="w">       </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w">      </span><span class="c1">// data for second vertex</span>
<span class="w">    </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.7</span><span class="p">,</span><span class="w">        </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="w">       </span><span class="c1">// data for third vertex</span>
<span class="p">]);</span>
</code></pre></div>
<p>This array will be copied into the single <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffer. The <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffer layout reflects the layout of the data in the buffer:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">vertexBufferLayout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span>
<span class="p">{</span><span class="w">   </span><span class="c1">// One vertex buffer, containing values for two attributes.</span>
<span class="w">    </span><span class="nx">attributes</span><span class="o">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="nx">shaderLocation</span><span class="o">:</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">offset</span><span class="o">:</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">format</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;float32x2&quot;</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="nx">shaderLocation</span><span class="o">:</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="nx">offset</span><span class="o">:</span><span class="mf">8</span><span class="p">,</span><span class="w"> </span><span class="nx">format</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;float32x3&quot;</span><span class="w"> </span><span class="p">}</span>
<span class="w">        </span><span class="p">],</span>
<span class="w">    </span><span class="nx">arrayStride</span><span class="o">:</span><span class="w"> </span><span class="mf">20</span><span class="p">,</span>
<span class="w">    </span><span class="nx">stepMode</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;vertex&quot;</span><span class="w"> </span>
<span class="p">}</span>
<span class="p">];</span>
</code></pre></div>
<p>Note that the data for each buffer takes up 20 bytes (five 4-byte floats). This becomes the arrayStride in the layout, which gives the distance, in bytes, from the values for one <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> to the values for the next <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>. The offset property for an <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> tells where to find the value for that <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> within the block of data for a given <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>: The offset for coords is 0 because it is found at the start of the data; the offset for color is 8 because it is found 8 bytes from the start of the data.</p>
<p>There are other differences between our first example and the two new variations. I encourage you to look at the source code for the two new programs and read the comments. Only the new features of each program are commented.</p>
</div>
</div>
</div>
<h2 id="917-自动绑定组布局">9.1.7 自动绑定组布局<a class="headerlink" href="#917-自动绑定组布局" title="Permanent link">&para;</a></h2>
<p><strong>Auto Bind Group Layout</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="8:2"><input checked="checked" id="__tabbed_8_1" name="__tabbed_8" type="radio" /><input id="__tabbed_8_2" name="__tabbed_8" type="radio" /><div class="tabbed-labels"><label for="__tabbed_8_1">中文</label><label for="__tabbed_8_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>最后一点说明。绑定组布局包含了组中每个绑定的信息：绑定引用的资源类型以及它所使用的着色器阶段。通常，这些信息可以从着色器程序中推断出来。当创建管线时，会组装完整的着色器程序，并且管线可以自动构造它所使用的绑定组布局。您可以通过将管线描述符的 layout 属性设置为 "auto"，让管线为您创建绑定组布局：</p>
<div class="highlight"><pre><span></span><code><span class="nx">pipelineDescriptor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span>
<span class="w">    </span><span class="p">.</span>
<span class="w">    </span><span class="p">.</span>
<span class="w">    </span><span class="nx">layout</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;auto&quot;</span>
<span class="p">};</span>
<span class="nx">pipeline</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createRenderPipeline</span><span class="p">(</span><span class="nx">pipelineDescriptor</span><span class="p">);</span>
</code></pre></div>
<p>然后，您可以使用函数 <code>pipeline.getBindGroupLayout(N)</code>，其中 N 是绑定组编号，从管线中获取布局。创建实际的绑定组时需要这个布局：</p>
<div class="highlight"><pre><span></span><code><span class="nx">bndGroup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createBindGroup</span><span class="p">({</span>
<span class="w">    </span><span class="nx">layout</span><span class="o">:</span><span class="w"> </span><span class="nx">pipeline</span><span class="p">.</span><span class="nx">getBindGroupLayout</span><span class="p">(</span><span class="mf">0</span><span class="p">),</span>
<span class="w">    </span><span class="nx">entries</span><span class="o">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">        </span><span class="p">.</span>
<span class="w">        </span><span class="p">.</span>
<span class="w">        </span><span class="p">.</span>
</code></pre></div>
<p>从现在起，我将在大多数示例中使用自动绑定组布局，但偶尔我会自己指定布局，以展示不同类型资源的布局是什么样的。</p>
</div>
<div class="tabbed-block">
<p>One final note. A bind group layout contains information about each binding in the group: what kind of resource the binding refers to and which <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> stage it is used in. In general, that information can be deduced from the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program. The full <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program is assembled when the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> is created, and the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> can automatically construct the bind group layouts that it uses. You can ask the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> to create the bind group layouts by setting the layout property of the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> descriptor to "auto":</p>
<div class="highlight"><pre><span></span><code><span class="nx">pipelineDescriptor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span>
<span class="w">    </span><span class="p">.</span>
<span class="w">    </span><span class="p">.</span>
<span class="nx">layout</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;auto&quot;</span>
<span class="p">};</span>
<span class="nx">pipeline</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createRenderPipeline</span><span class="p">(</span><span class="w"> </span><span class="nx">pipelineDescriptor</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>You can then use the function <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>.getBindGroupLayout(N), where N is the bind group number, to get the layout from the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>. The layout is needed to create the actual bind group:</p>
<div class="highlight"><pre><span></span><code><span class="nx">bndGroup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createBindGroup</span><span class="p">({</span>
<span class="nx">layout</span><span class="o">:</span><span class="w"> </span><span class="nx">pipeline</span><span class="p">.</span><span class="nx">getBindGroupLayout</span><span class="p">(</span><span class="mf">0</span><span class="p">),,</span>
<span class="nx">entries</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span>
<span class="w">    </span><span class="p">.</span>
<span class="w">    </span><span class="p">.</span>
<span class="w">    </span><span class="p">.</span>
</code></pre></div>
<p>I will use auto bind group layout in most of my examples from now on, but I will occasionally specify the layout myself, to show what it looks like for various kinds of resources.</p>
</div>
</div>
</div>







  
    
  
  
    
  


  <aside class="md-source-file">
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="最后更新">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1-2.1-2M12.5 7v5.2l4 2.4-1 1L11 13V7h1.5M11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2v1.8Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">2024年7月6日</span>
  </span>

    
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="创建日期">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.47 15.08 11 13V7h1.5v5.25l3.08 1.83c-.41.28-.79.62-1.11 1m-1.39 4.84c-.36.05-.71.08-1.08.08-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8c0 .37-.03.72-.08 1.08.69.1 1.33.32 1.92.64.1-.56.16-1.13.16-1.72 0-5.5-4.5-10-10-10S2 6.5 2 12s4.47 10 10 10c.59 0 1.16-.06 1.72-.16-.32-.59-.54-1.23-.64-1.92M18 15v3h-3v2h3v3h2v-3h3v-2h-3v-3h-2Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">2024年5月26日</span>
  </span>

    
    
    
  </aside>





                
              </article>
            </div>
          
          
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var tab,labels=set.querySelector(".tabbed-labels");for(tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script>

<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../../..", "features": ["content.code.copy", "content.tabs.link", "navigation.tabs", "navigation.tabs.sticky", "navigation.indexes", "navigation.top", "toc.follow", "content.tooltips"], "search": "../../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.fe8b6f2b.min.js"></script>
      
        <script src="../../../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="https://unpkg.com/mermaid@9.4.0/dist/mermaid.min.js"></script>
      
    
  <script id="init-glightbox">const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});
document$.subscribe(() => { lightbox.reload() });
</script></body>
</html>