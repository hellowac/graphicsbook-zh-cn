
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="计算机图形学概论(graphicsbook)">
      
      
      
        <link rel="canonical" href="https://hellowac.github.io/graphicsbook-zh-cn/cn/c9/s6/">
      
      
        <link rel="prev" href="../s5/">
      
      
        <link rel="next" href="../s7/">
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.0, mkdocs-material-9.5.28">
    
    
      
        <title>9.6 计算着色器 - 计算机图形学概论</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.6543a935.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.06af60db.min.css">
      
      

  
  
  
  
  <style>:root{--md-annotation-icon:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M22 12a10 10 0 0 1-10 10A10 10 0 0 1 2 12 10 10 0 0 1 12 2a10 10 0 0 1 10 10M6 13h8l-3.5 3.5 1.42 1.42L17.84 12l-5.92-5.92L10.5 7.5 14 11H6v2Z"/></svg>');}</style>


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
   <link href="../../../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
    html.glightbox-open { overflow: initial; height: 100%; }
    .gslide-title { margin-top: 0px; user-select: text; }
    .gslide-desc { color: #666; user-select: text; }
    .gslide-image img { background: white; }
    .gscrollbar-fixer { padding-right: 15px; }
    .gdesc-inner { font-size: 0.75rem; }
    body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
    body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
    body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}</style> <script src="../../../assets/javascripts/glightbox.min.js"></script></head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="default" data-md-color-accent="red">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#96-计算着色器" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="计算机图形学概论" class="md-header__button md-logo" aria-label="计算机图形学概论" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            计算机图形学概论
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              9.6 计算着色器
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
      <div class="md-header__option">
  <div class="md-select">
    
    <button class="md-header__button md-icon" aria-label="选择当前语言">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m12.87 15.07-2.54-2.51.03-.03A17.52 17.52 0 0 0 14.07 6H17V4h-7V2H8v2H1v2h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04M18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12m-2.62 7 1.62-4.33L19.12 17h-3.24Z"/></svg>
    </button>
    <div class="md-select__inner">
      <ul class="md-select__list">
        
          <li class="md-select__item">
            <a href="/graphicsbook-zh-cn/en/" hreflang="en" class="md-select__link">
              English
            </a>
          </li>
        
          <li class="md-select__item">
            <a href="/graphicsbook-zh-cn/cn/" hreflang="cn" class="md-select__link">
              中文
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</div>
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/hellowac/graphicsbook-zh-cn" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    graphicsbook
  </div>
</a>
      </div>
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../" class="md-tabs__link">
        
  
    
  
  首页

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../preface/" class="md-tabs__link">
        
  
    
  
  前言

      </a>
    </li>
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c1/" class="md-tabs__link">
          
  
    
  
  1.简介

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c2/" class="md-tabs__link">
          
  
    
  
  2.二维图形

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c3/" class="md-tabs__link">
          
  
    
  
  3.几何

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c4/" class="md-tabs__link">
          
  
    
  
  4.灯光和材质

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c5/" class="md-tabs__link">
          
  
    
  
  5.three.js

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c6/" class="md-tabs__link">
          
  
    
  
  6.WebGL

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c7/" class="md-tabs__link">
          
  
    
  
  7.WebGL 3D

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c8/" class="md-tabs__link">
          
  
    
  
  8.高阶3D

        </a>
      </li>
    
  

      
        
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../" class="md-tabs__link">
          
  
    
  
  9.WEBGPU

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../a1/" class="md-tabs__link">
          
  
    
  
  附录A

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../a2/" class="md-tabs__link">
          
  
    
  
  附录B

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../a3/" class="md-tabs__link">
          
  
    
  
  附录C

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../source/" class="md-tabs__link">
          
  
    
  
  附录D

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../glossary/" class="md-tabs__link">
          
  
    
  
  术语表

        </a>
      </li>
    
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../.." class="md-tabs__link">
        
  
    
  
  关于

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="计算机图形学概论" class="md-nav__button md-logo" aria-label="计算机图形学概论" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    计算机图形学概论
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/hellowac/graphicsbook-zh-cn" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    graphicsbook
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    首页
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../preface/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    前言
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c1/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    1.简介
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_3" id="__nav_3_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            1.简介
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 1 节 绘画与绘图
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 2 节：三维(3D)图形的要素
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 3 节：硬件与软件
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c2/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    2.二维图形
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_4" id="__nav_4_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            2.二维图形
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第1节: 像素、坐标和颜色
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第2节: 形状
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第3节: 变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第4节: 分层建模
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第5节: Java 绘制2D
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第6节: HTML Canvas图形
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第7节: SVG：一种场景描述语言
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c3/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    3.几何
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_5" id="__nav_5_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            3.几何
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.1 OpenGL 1.1 中的形状和颜色
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.2 3D 坐标和变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.3 投影与观看
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.4 多边形网格和 glDrawArrays
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.5 部分线性代数基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.6 使用 GLUT 和 JOGL
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c4/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    4.灯光和材质
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_6" id="__nav_6_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6">
            <span class="md-nav__icon md-icon"></span>
            4.灯光和材质
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.1 照明简介
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.2 OpenGL 1.1 中的光和材质
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.3 图像纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.4 灯光、相机、动作
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c5/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    5.three.js
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_7" id="__nav_7_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7">
            <span class="md-nav__icon md-icon"></span>
            5.three.js
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.1 Three.js 基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.2 构建对象
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.3 其他功能
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c6/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    6.WebGL
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_8" id="__nav_8_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8">
            <span class="md-nav__icon md-icon"></span>
            6.WebGL
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.1 可编程流水线
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.2 第一个例子
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.3 GLSL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.4 图像纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.5 实现 2D 变换
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c7/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    7.WebGL 3D
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_9" id="__nav_9_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9">
            <span class="md-nav__icon md-icon"></span>
            7.WebGL 3D
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.1 3D变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.2 照明和材质
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.3 纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.4 帧缓冲区
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.5 WebGL 扩展
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c8/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    8.高阶3D
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_10" id="__nav_10_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_10_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10">
            <span class="md-nav__icon md-icon"></span>
            8.高阶3D
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c8/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8.1 光线追踪
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c8/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8.2 路径追踪
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_11" checked>
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    9.WEBGPU
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_11" id="__nav_11_label" tabindex="">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_11_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_11">
            <span class="md-nav__icon md-icon"></span>
            9.WEBGPU
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.1 WebGPU 基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.2 实例和索引
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.3 WGSL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.4 WebGPU 中的 3D 图形
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.5 纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    9.6 计算着色器
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    9.6 计算着色器
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#961-工作组和调度" class="md-nav__link">
    <span class="md-ellipsis">
      9.6.1 工作组和调度
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#962-计算着色" class="md-nav__link">
    <span class="md-ellipsis">
      9.6.2 计算着色
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#963-模拟" class="md-nav__link">
    <span class="md-ellipsis">
      9.6.3 模拟
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#964-检索输出" class="md-nav__link">
    <span class="md-ellipsis">
      9.6.4 检索输出
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.7 细节
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_12" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../a1/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    附录A
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_12" id="__nav_12_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_12_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_12">
            <span class="md-nav__icon md-icon"></span>
            附录A
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a1/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    A.1 Java 编程语言
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a1/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    A.2 C 编程语言
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a1/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    A.3 JavaScript 编程语言
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a1/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    A.4 JavaScript Promise 和异步函数
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_13" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../a2/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    附录B
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_13" id="__nav_13_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_13_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_13">
            <span class="md-nav__icon md-icon"></span>
            附录B
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a2/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    B.1 节 Blender 基础知识
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a2/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    B.2 节 Blender 建模
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a2/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    B.3 节 Blender 动画
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a2/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    B.4 节 有关光和材料的更多信息
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_14" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../a3/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    附录C
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_14" id="__nav_14_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_14_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_14">
            <span class="md-nav__icon md-icon"></span>
            附录C
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a3/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C.1 节 Gimp：2D 绘画程序
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_15" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../source/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    附录D
  </span>
  

            </a>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_15_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_15">
            <span class="md-nav__icon md-icon"></span>
            附录D
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_16" >
        
          
          <label class="md-nav__link" for="__nav_16" id="__nav_16_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    术语表
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_16_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_16">
            <span class="md-nav__icon md-icon"></span>
            术语表
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../glossary/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    术语表
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    关于
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#961-工作组和调度" class="md-nav__link">
    <span class="md-ellipsis">
      9.6.1 工作组和调度
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#962-计算着色" class="md-nav__link">
    <span class="md-ellipsis">
      9.6.2 计算着色
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#963-模拟" class="md-nav__link">
    <span class="md-ellipsis">
      9.6.3 模拟
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#964-检索输出" class="md-nav__link">
    <span class="md-ellipsis">
      9.6.4 检索输出
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="96-计算着色器">9.6 <abbr title="GPU 管线中的一个阶段，它只进行纯粹的计算工作，而不是直接参与图形渲染。">计算着色器</abbr><a class="headerlink" href="#96-计算着色器" title="Permanent link">&para;</a></h1>
<p><strong>Compute Shaders</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="1:2"><input checked="checked" id="__tabbed_1_1" name="__tabbed_1" type="radio" /><input id="__tabbed_1_2" name="__tabbed_1" type="radio" /><div class="tabbed-labels"><label for="__tabbed_1_1">中文</label><label for="__tabbed_1_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p><abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 和 <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> 之间的一个主要区别是增加了计算着色器。计算着色器执行的是一种纯粹的计算任务，它不是图像渲染任务的直接部分（尽管它产生的结果可以用于后续的渲染）。虽然顶点和片段着色器在渲染管线中使用，但计算着色器只能在另一种类型的管线中使用，称为计算管线。本节讨论了如何创建和使用计算着色器和计算管线。</p>
</div>
<div class="tabbed-block">
<p>One of the major differences between <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> and <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> is the addition of compute shaders. A <abbr title="A stage in a GPU pipeline that does purely computational work, rather than participating directly in graphical rendering.">compute shader</abbr> performs a purely computational task that is not directly a part of an image <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> task (although it can produce results that will be used later for <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr>). While <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> and fragment shaders are used in a render <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>, compute shaders can only be used in another type of <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>, called a compute <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>. This section discusses how to create and use compute shaders and compute pipelines.</p>
</div>
</div>
</div>
<h2 id="961-工作组和调度">9.6.1 工作组和调度<a class="headerlink" href="#961-工作组和调度" title="Permanent link">&para;</a></h2>
<p><strong>Workgroups and Dispatches</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="2:2"><input checked="checked" id="__tabbed_2_1" name="__tabbed_2" type="radio" /><input id="__tabbed_2_2" name="__tabbed_2" type="radio" /><div class="tabbed-labels"><label for="__tabbed_2_1">中文</label><label for="__tabbed_2_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>在图像渲染中，<code>draw()</code> 或 <code>drawIndexed()</code> 函数在渲染通道编码器中被用来启动渲染管线的处理过程。这个处理过程涉及多次调用顶点着色器入口点函数，然后多次调用片段着色器入口点。对于计算管线，使用计算通道编码器，并通过调用 <code>dispatchWorkgroups()</code> 函数来启动处理。我将在下一个子节中讨论 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 和 <abbr title="WebGPU 着色器语言，是编写 WebGPU 使用的着色器的编程语言。">WGSL</abbr> 代码，但在此之前，你需要对工作组以及调度它们的基本概念有所了解。</p>
<p>计算着色器执行的工作被认为是一维、二维或三维的。这是一种基于被处理数据结构的工作组织方式。与图像相关的工作很可能是二维的。处理数组的工作可能是一维的。因此，计算着色器的调用在逻辑上被安排在一个一维、二维或三维的网格中。每个调用都有一个“全局调用 ID”，由一个、两个或三个整数组成，表示其在网格中的位置。</p>
<p>事情变得复杂的地方在于，调用被分成更小的组，称为工作组。同一工作组中的调用可以更紧密地协同工作。例如，有一个工作组地址空间，包含同一工作组中的调用共享的数据，但对其他工作组的调用不可见。工作组中的调用也按照与整体工作相同的维度排列在一个网格中。每个调用都有一个“本地调用 ID”，表示其在工作组中的位置。工作组本身有一个大小，由一个、两个或三个整数组成，表示其在每个维度的大小。所有工作组的大小都是相同的。二维工作的调用可以这样想象：</p>
<p><a class="glightbox" href="../../../en/c9/gpu-workgroups.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c9/gpu-workgroups.png" /></a></p>
<p>小黄方格是计算着色器的单独调用。工作组大小为 (4,4)，所以每个工作组由一个 4x4 的网格组成。调用的本地调用 ID 是一个介于 0 到 3 之间的数字对。工作组以 4x3 的网格形式组织。全局调用 ID 是一个 (x,y) 对，其中 x 的范围是 0 到 15，y 的范围是 0 到 11。</p>
<p>工作的调用结构由两件事决定：<abbr title="WebGPU 着色器语言，是编写 WebGPU 使用的着色器的编程语言。">WGSL</abbr> 源代码中指定的单个工作组的大小，以及在 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 端的 <code>dispatchWorkgroups()</code> 调用中指定的整体工作网格每个维度的工作组数量。对于图中所示的例子，工作组大小为 (4,4)，工作将通过调用 <code>dispatchWorkgroups(4,3)</code> 来创建。</p>
<p>工作组内的调用次数限制为 256。允许小至单个调用的工作组。然而，通常建议在大多数情况下将 64 作为合理的工作组大小，我在大多数示例中使用这个值。</p>
<p>（你可能会想知道为什么工作组应该存在。这与 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 的物理结构有关。典型 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 中的处理单元被物理上分成小组。小组中的处理器不是独立的；它们都运行相同的代码，并共享一些它们可以快速访问的本地内存。使用小于 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 上处理器小组物理大小的 <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> 工作组大小可能会导致小组中的一些处理器无事可做。通过利用 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 的物理结构，可以优化某些程序的性能。然而，我怀疑这种优化真的需要针对特定的 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 结构进行调整。对于旨在在多个平台上运行的 <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> 程序，我不确定可以进行多少优化。无论如何，这种优化超出了我的专业范围，我的示例中没有以重大方式使用工作组。）</p>
</div>
<div class="tabbed-block">
<p>For image <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr>, the <code>draw()</code> or <code>drawIndexed()</code> function is used in a render pass encoder to start processing of a render <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>. The processing involves multiple invocations of the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> entry-point function and then multiple invocations of the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> entry-point. For a compute <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>, a compute pass encoder is used, and processing is started with a call to the function <code>dispatchWorkgroups()</code>. I will discuss the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> and <abbr title="WebGPU 着色器语言，是编写 WebGPU 使用的着色器的编程语言。">WGSL</abbr> code in the next subsection, but before that, you need to have some basic understanding of workgroups and what it means to dispatch them.</p>
<p>The job performed by a <abbr title="A stage in a GPU pipeline that does purely computational work, rather than participating directly in graphical rendering.">compute shader</abbr> is thought of as one-, two-, or three-dimensional. This is a way to organize the work, based on the structure of the data that is processed. A job that works with an image is likely to be two-dimensional. A job that processes an array is likely to be one-dimensional. So, the invocations of a <abbr title="A stage in a GPU pipeline that does purely computational work, rather than participating directly in graphical rendering.">compute shader</abbr> are arranged logically in a one-, two-, or three-dimension grid. Each invocation has a "global invocation ID," consisting of one, two, or three integers that give its position in the grid.</p>
<p>To complicate things, the invocations are broken into smaller groups called workgroups. Invocations in the same workgroup can work more closely together. For example, there is a workgroup address space that contains data shared by invocations in the same workgroup but not visible to invocations in other workgroups. The invocations in a workgroup are arranged in a grid with the same dimension as the overall job. Every invocation has a "local invocation ID" that gives its position in its workgroup. The workgroup as a whole has a size, consisting of one, two, or three integers giving its size in each dimension. All workgroups in a job have the same size. The invocations for a 2D job can be visualized something like this:</p>
<p><a class="glightbox" href="../../../en/c9/gpu-workgroups.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c9/gpu-workgroups.png" /></a></p>
<p>The tiny yellow squares are individual invocations of the <abbr title="A stage in a GPU pipeline that does purely computational work, rather than participating directly in graphical rendering.">compute shader</abbr>. The workgroup size is (4,4), so each workgroup consists of a 4-by-4 grid. The local invocation ID of an invocation is a pair of numbers in the range 0 to 3. The workgroups are organized in a 4-by-3 grid. The global invocation ID is a pair (x,y) where x is in the range 0 to 15 and y is the range 0 to 11.</p>
<p>The structure of the invocations for a job is determined by two things: The size of an individual workgroup is specified in the <abbr title="WebGPU 着色器语言，是编写 WebGPU 使用的着色器的编程语言。">WGSL</abbr> source code for the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>, and the number of workgroups in each dimension of the overall job grid is specified in the call to dispatchWorkgroups() on the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side. For the example shown in the illustration, the workgroup size is (4,4), and the job would be created with a call to dispatchWorkgroups(4,3).</p>
<p>The number of invocations in a workgroup is limited to 256. Workgroups as small as a single invocation are allowed. However, 64 is recommended as a reasonable workgroup size in most cases, and I use that value in most of my examples.</p>
<p>(You might wonder why workgroups should exist at all. It has to do with the physical structure of GPUs. The processors in a typical <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> are physically divided into groups. Processors in a group are not independent; they all run the same code, and they share some local memory that they can access very quickly. It is possible that using a <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> workgroup size that is less than the physical size of processor groups on the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> might leave some processors in a group with nothing to do. The performance of some programs can be optimized by making use of the physical structure of a <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>. However, I suspect that that optimization really needs to be tuned to a particular <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> structure. For a <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> program that is designed to run on multiple platforms, I'm not sure how much optimization can be done. In any case, such optimization is beyond my expertise, and none of my examples use workgroups in a significant way.)</p>
</div>
</div>
</div>
<h2 id="962-计算着色">9.6.2 计算着色<a class="headerlink" href="#962-计算着色" title="Permanent link">&para;</a></h2>
<p><strong>Compute Shaders</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="3:2"><input checked="checked" id="__tabbed_3_1" name="__tabbed_3" type="radio" /><input id="__tabbed_3_2" name="__tabbed_3" type="radio" /><div class="tabbed-labels"><label for="__tabbed_3_1">中文</label><label for="__tabbed_3_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>我的首个计算着色器示例，<a href="../../../en/source/webgpu/first_compute_shader.html">webgpu/first_compute_shader.html</a>，是之前程序的修改版，之前的程序展示了在画布中移动并从边缘反弹的彩色圆盘。在之前的程序中，圆盘的位置在 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 端更新，然后写入 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 上的缓冲区。新版本将计算移动到 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 上运行的计算着色器中。这提高了效率，因为 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 可以并行计算，并且新值不需要复制到 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>。</p>
<p>使用计算管线的工作方式与使用渲染管线类似：为着色器创建 <abbr title="WebGPU 着色器语言，是编写 WebGPU 使用的着色器的编程语言。">WGSL</abbr> 源代码；创建一个计算管线来处理着色器，并创建管线使用的绑定组和资源；使用命令编码器和计算通道编码器来组装运行管线所需的命令；将命令提交到 <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> 设备队列。</p>
<p>在 <abbr title="WebGPU 着色器语言，是编写 WebGPU 使用的着色器的编程语言。">WGSL</abbr> 源代码中，计算着色器的入口点函数用 @compute 注解标记（与顶点着色器入口点用 @<abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> 注解的方式相同）。计算着色器入口点还需要另一个注解来指定工作组大小。例如，注解 @workgroup_size(16,8) 指定了一个二维工作组，大小在 x 方向上为 16，在 y 方向上为 8。</p>
<p>计算着色器入口点函数有几个内置值作为参数。最有用的是 @builtin(global_invocation_id)，它作为 vec3u 提供当前调用的全局调用 ID。对于一维任务，向量的 y 和 z 分量将是 1；对于二维问题，z 分量将是 1。就 <abbr title="WebGPU 着色器语言，是编写 WebGPU 使用的着色器的编程语言。">WGSL</abbr> 而言，所有问题都是三维的，缺失维度的大小设置为 1。这里，例如，是第一个示例程序入口点函数的开始：</p>
<div class="highlight"><pre><span></span><code><span class="err">@</span><span class="nx">compute</span><span class="w"> </span><span class="err">@</span><span class="nx">workgroup_size</span><span class="p">(</span><span class="mf">64</span><span class="p">)</span>
<span class="nx">fn</span><span class="w"> </span><span class="nx">main</span><span class="p">(</span><span class="w"> </span><span class="err">@</span><span class="nx">builtin</span><span class="p">(</span><span class="nx">global_invocation_id</span><span class="p">)</span><span class="w"> </span><span class="nx">global_id</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">vec3u</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="p">.</span>
</code></pre></div>
<p>计算着色器的其他内置值包括：</p>
<ul>
<li>@builtin(local_invocation_id) — 当前调用在其工作组中的本地调用 ID。</li>
<li>@builtin(num_workgroups) — 每个方向上的工作组数量。这些值只是启动当前作业的 dispatchWorkgroups() 调用的参数。</li>
<li>@builtin(workgroup_id) — 当前调用所在的工作组在工作组网格中的位置。</li>
</ul>
<p>所有这些的类型都是 vec3u，缺失维度的值设置为 1。</p>
<p>计算着色器可以通过绑定组从 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 端获取输入。没有像顶点缓冲区那样为计算着色器入口点函数提供参数值的东西，因此唯一的参数将是内置值。该函数也没有返回类型。计算着色器通过写入存储缓冲区或存储纹理（它们是绑定组的一部分）来产生输出。</p>
<p>在示例程序中，动画的数据包括移动圆盘的位置和速度。计算着色器在动画帧之间运行以更新位置。当圆盘从边缘反弹时，它会反转方向，这种情况下圆盘的速度也会改变。位置和速度的 x 和 y 分量需要更新。两个分量的计算相同。计算着色器的一个调用的任务是更新一个圆盘在 x 或 y 方向上的位置和速度。如果有 N 个圆盘，我们需要 2*N 个着色器调用。</p>
<p>位置和速度存储在两个存储缓冲区中，在着色器程序中由类型为 <code>array&lt;32&gt;</code> 的变量表示。初始值由程序的 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 端写入缓冲区。之后，缓冲区完全在 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 端使用。另一个存储缓冲区保存了一个包含三个浮点数的数组，提供计算所需的其他数据：圆盘的数量、圆盘的半径和自上次更新以来的时间变化。着色器变量声明为：</p>
<div class="highlight"><pre><span></span><code><span class="err">@</span><span class="nx">group</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="err">@</span><span class="nx">binding</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="kd">var</span><span class="o">&lt;</span><span class="nx">storage</span><span class="p">,</span><span class="nx">read_write</span><span class="o">&gt;</span><span class="w"> </span><span class="nx">diskOffsets</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">array</span><span class="o">&lt;</span><span class="nx">f32</span><span class="o">&gt;</span><span class="p">;</span>
<span class="err">@</span><span class="nx">group</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="err">@</span><span class="nx">binding</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="kd">var</span><span class="o">&lt;</span><span class="nx">storage</span><span class="p">,</span><span class="nx">read_write</span><span class="o">&gt;</span><span class="w"> </span><span class="nx">diskVelocities</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">array</span><span class="o">&lt;</span><span class="nx">f32</span><span class="o">&gt;</span><span class="p">;</span>
<span class="err">@</span><span class="nx">group</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="err">@</span><span class="nx">binding</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span><span class="w"> </span><span class="kd">var</span><span class="o">&lt;</span><span class="nx">storage</span><span class="o">&gt;</span><span class="w"> </span><span class="nx">params</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">array</span><span class="o">&lt;</span><span class="nx">f32</span><span class="p">,</span><span class="mf">3</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>
<p>由于内容将被更新，前两个数组需要 read_write 访问权限。要调用着色器，将需要一个管线和一个绑定组。计算着色器的管线描述符相当简单。它有一个 layout <abbr title="图形对象的属性，例如颜色。图像可以通过其包含的几何形状以及它们的属性来指定。">属性</abbr>，以及一个 compute 属性来指定着色器模块和着色器入口点函数。管线本身是使用 device.createComputePipeline() 函数创建的。以下是示例程序如何创建计算管线和将附加到管线的绑定组：</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span><span class="w"> </span><span class="nx">createComputePipelineConfig</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">pipelineDescriptor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">compute</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">module</span><span class="o">:</span><span class="w"> </span><span class="kt">computeShader</span><span class="p">,</span>
<span class="w">            </span><span class="nx">entryPoint</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;main&quot;</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="nx">layout</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;auto&quot;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="nx">computePipeline</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createComputePipeline</span><span class="p">(</span><span class="nx">pipelineDescriptor</span><span class="p">);</span>

<span class="w">    </span><span class="nx">computeBindGroup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createBindGroup</span><span class="p">({</span><span class="w"> </span>
<span class="w">        </span><span class="nx">layout</span><span class="o">:</span><span class="w"> </span><span class="kt">computePipeline.getBindGroupLayout</span><span class="p">(</span><span class="mf">0</span><span class="p">),</span>
<span class="w">        </span><span class="nx">entries</span><span class="o">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">            </span><span class="p">{</span><span class="w">    </span><span class="c1">// 圆盘的位置。</span>
<span class="w">                </span><span class="nx">binding</span><span class="o">:</span><span class="w"> </span><span class="kt">0</span><span class="p">,</span>
<span class="w">                </span><span class="nx">resource</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="nx">buffer</span><span class="o">:</span><span class="w"> </span><span class="kt">offsetBuffer</span><span class="p">}</span><span class="w"> </span>
<span class="w">            </span><span class="p">},</span>
<span class="w">            </span><span class="p">{</span><span class="w">    </span><span class="c1">// 圆盘的速度。</span>
<span class="w">                </span><span class="nx">binding</span><span class="o">:</span><span class="w"> </span><span class="kt">1</span><span class="p">,</span>
<span class="w">                </span><span class="nx">resource</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="nx">buffer</span><span class="o">:</span><span class="w"> </span><span class="kt">velocityBuffer</span><span class="p">}</span><span class="w"> </span>
<span class="w">            </span><span class="p">},</span>
<span class="w">            </span><span class="p">{</span><span class="w">   </span><span class="c1">// 计算所需的其他数据。</span>
<span class="w">                </span><span class="nx">binding</span><span class="o">:</span><span class="w"> </span><span class="kt">2</span><span class="p">,</span>
<span class="w">                </span><span class="nx">resource</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="nx">buffer</span><span class="o">:</span><span class="w"> </span><span class="kt">paramsBuffer</span><span class="p">}</span><span class="w"> </span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">]</span>
<span class="w">    </span><span class="p">});</span>
<span class="p">}</span>
</code></pre></div>
<p>管线由 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 函数运行，该函数在动画帧之间调用。计算通道编码器方法 <code>dispatchWorkgroups()</code> 被用来调用着色器，参数指定工作组的数量。我们需要 <code>2*DISK_COUNT</code> 个着色器调用，工作组的大小是 64，所以我们至少需要 <code>(2*DISK_COUNT)/64</code> 个工作组。由于工作组的数量必须是整数，我们需要使用 <code>Math.ceil()</code> 向上取整到整数值。</p>
<div class="highlight"><pre><span></span><code><span class="cm">/**</span>
<span class="cm"> *  使用计算通道来更新圆盘位置，基于它们的速度和自上一动画帧以来的时间变化。</span>
<span class="cm"> *  速度也可能改变。参数 dt 是时间的变化。</span>
<span class="cm"> */</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">update</span><span class="p">(</span><span class="nx">dt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="cm">/* 将时间变化写入 paramsBuffer 的第三个位置 */</span>

<span class="w">    </span><span class="nx">device</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">writeBuffer</span><span class="p">(</span><span class="nx">paramsBuffer</span><span class="p">,</span><span class="mf">8</span><span class="p">,</span><span class="ow">new</span><span class="w"> </span><span class="nb">Float32Array</span><span class="p">([</span><span class="nx">dt</span><span class="p">]));</span>

<span class="w">    </span><span class="cm">/* 编码一个计算通道来完成工作。 */</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">commandEncoder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createCommandEncoder</span><span class="p">();</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">passEncoder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">commandEncoder</span><span class="p">.</span><span class="nx">beginComputePass</span><span class="p">();</span>
<span class="w">    </span><span class="nx">passEncoder</span><span class="p">.</span><span class="nx">setPipeline</span><span class="p">(</span><span class="nx">computePipeline</span><span class="p">);</span>
<span class="w">    </span><span class="nx">passEncoder</span><span class="p">.</span><span class="nx">setBindGroup</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">computeBindGroup</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">workGroupCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Math</span><span class="p">.</span><span class="nx">ceil</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="mf">2</span><span class="o">*</span><span class="nx">DISK_COUNT</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">64</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="nx">passEncoder</span><span class="p">.</span><span class="nx">dispatchWorkgroups</span><span class="p">(</span><span class="w"> </span><span class="nx">workGroupCount</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="nx">passEncoder</span><span class="p">.</span><span class="nx">end</span><span class="p">();</span>

<span class="w">    </span><span class="cm">/* 将工作提交到 GPU 设备队列。 */</span>

<span class="w">    </span><span class="nx">device</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">submit</span><span class="p">([</span><span class="nx">commandEncoder</span><span class="p">.</span><span class="nx">finish</span><span class="p">()]);</span>
<span class="p">}</span>
</code></pre></div>
<p>如你所见，所有这些与使用渲染管线和渲染通道的工作非常相似。</p>
<hr />
<p>我的第二个计算着色器示例是 <a href="../../../en/source/webgpu/life_3.html">webgpu/life_3.html</a>，它实现了康威的生命游戏。它是 <a href="../../../en/source/webgpu/life_1.html">life_1.html</a> 的修改版，见 <a href="../s5/">9.5.5小节</a>。原始版本在显示当前代的同时，在片段着色器中计算了棋盘的新代。新版本将计算移动到计算着色器中。计算着色器版本如果有什么不同的话，实际上是<strong>效率更低</strong>的，这可以作为一个提醒，即片段着色器可以完成计算工作。</p>
<p>生命游戏本质上是一个二维问题，因为每个调用处理二维棋盘的一个单元格。工作组大小有两个组成部分，dispatchWorkgroups() 将需要两个参数。我使用 (8,8) 作为工作组大小，每个工作组有 64 个调用。</p>
<p>这个示例特别展示了计算着色器可以与纹理一起工作。棋盘的当前状态存储在一个纹理中。新状态写入第二个纹理。两个纹理都是计算管线的资源。第一个用于输入，是类型为 <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> 的资源；第二个用于输出，是类型为 storage <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> 的资源。计算着色器可以使用 <code>textureLoad()</code> 从纹理资源中读取，并可以使用 <code>textureStore()</code> 写入存储纹理资源。（有关存储纹理、<code>textureLoad()</code> 和 <code>textureStore()</code> 的信息，见 <a href="../s5/#955-纹理格式">9.5.5小节</a>。）请注意，计算着色器不能使用 <code>textureSample()</code>。</p>
<p>以下是计算着色器的源代码，省略了计算的细节：</p>
<div class="highlight"><pre><span></span><code><span class="kd">@group</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="kd">@binding</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="kd">var</span><span class="w"> </span><span class="nx">currentGen</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">texture_2d</span><span class="o">&lt;</span><span class="nx">u32</span><span class="o">&gt;</span><span class="p">;</span>
<span class="kd">@group</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="kd">@binding</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="kd">var</span><span class="w"> </span><span class="nx">nextGen</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">texture_storage_2d</span><span class="o">&lt;</span><span class="nx">r32uint</span><span class="p">,</span><span class="nx">write</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kd">@compute</span><span class="w"> </span><span class="kd">@workgroup_size</span><span class="p">(</span><span class="mf">8</span><span class="p">,</span><span class="mf">8</span><span class="p">)</span>
<span class="nx">fn</span><span class="w"> </span><span class="nx">main</span><span class="p">(</span><span class="w"> </span><span class="kd">@builtin</span><span class="p">(</span><span class="nx">global_invocation_id</span><span class="p">)</span><span class="w"> </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="kt">vec3u</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">boardSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">textureDimensions</span><span class="p">(</span><span class="nx">currentGen</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">cell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">id</span><span class="p">.</span><span class="nx">xy</span><span class="p">;</span><span class="w"> </span><span class="c1">// 正在处理的单元格的行和列。</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">cell</span><span class="p">.</span><span class="nx">x</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="nx">boardSize</span><span class="p">.</span><span class="nx">x</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">cell</span><span class="p">.</span><span class="nx">y</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="nx">boardSize</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span><span class="w">  </span><span class="c1">// 分配的单元格在棋盘外。</span>
<span class="p">}</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">alive</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">textureLoad</span><span class="p">(</span><span class="nx">currentGen</span><span class="p">,</span><span class="w"> </span><span class="nx">cell</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">).</span><span class="nx">r</span><span class="p">;</span>
<span class="w">    </span><span class="p">.</span>
<span class="w">    </span><span class="p">.</span><span class="w"> </span><span class="c1">// (计算此单元格的新 &quot;alive&quot; 值。)</span>
<span class="w">    </span><span class="p">.</span>
<span class="nx">textureStore</span><span class="p">(</span><span class="w"> </span><span class="nx">nextGen</span><span class="p">,</span><span class="w"> </span><span class="nx">cell</span><span class="p">,</span><span class="w"> </span><span class="nx">vec4u</span><span class="p">(</span><span class="nx">newAlive</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>调度工作组时，我们需要的调用数量取决于棋盘的大小，这与画布的大小相同。同样，我们必须将调用数量除以工作组大小并向上取整到整数值：</p>
<div class="highlight"><pre><span></span><code><span class="cm">/**</span>
<span class="cm"> *  计算下一代并将其复制到 currentGeneration 纹理。</span>
<span class="cm"> *  （只有在渲染着色器中使用 currentGeneration。）</span>
<span class="cm"> */</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">computeNextGeneration</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">commandEncoder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createCommandEncoder</span><span class="p">();</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">passEncoder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">commandEncoder</span><span class="p">.</span><span class="nx">beginComputePass</span><span class="p">();</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">setPipeline</span><span class="p">(</span><span class="nx">computePipeline</span><span class="p">);</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">setBindGroup</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="nx">computeBindGroup</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">workgroupCountX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Math</span><span class="p">.</span><span class="nx">ceil</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span><span class="o">/</span><span class="mf">8</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">workgroupCountY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Math</span><span class="p">.</span><span class="nx">ceil</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span><span class="o">/</span><span class="mf">8</span><span class="p">);</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">dispatchWorkgroups</span><span class="p">(</span><span class="w"> </span><span class="nx">workgroupCountX</span><span class="p">,</span><span class="w"> </span><span class="nx">workgroupCountY</span><span class="w"> </span><span class="p">);</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">end</span><span class="p">();</span>
<span class="nx">commandEncoder</span><span class="p">.</span><span class="nx">copyTextureToTexture</span><span class="p">(</span><span class="w">  </span><span class="c1">// 将结果复制到 nextGeneration。</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="nx">texture</span><span class="o">:</span><span class="w"> </span><span class="kt">nextGeneration</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="nx">texture</span><span class="o">:</span><span class="w"> </span><span class="kt">currentGeneration</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">[</span><span class="w"> </span><span class="nx">context</span><span class="p">.</span><span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span><span class="w"> </span><span class="nx">context</span><span class="p">.</span><span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span><span class="w"> </span><span class="p">]</span>
<span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">commandBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">commandEncoder</span><span class="p">.</span><span class="nx">finish</span><span class="p">();</span>
<span class="nx">device</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">submit</span><span class="p">([</span><span class="nx">commandBuffer</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div>
<p>请注意调用了一个新函数 <code>commandEncoder.copyTextureToTexture()</code>。这个函数接受三个参数，提供源纹理、目标纹理和要复制区域的大小。前两个参数是对象，有可选参数来指定 <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmap</abbr> 级别以及要复制区域的左上角或起始点。</p>
<hr />
<p>在第一个计算着色器示例中，着色器从缓冲区读取值，并将新值写回同一个缓冲区。在第二个示例中，使用了两个纹理，一个用于输入，一个用于输出。你可能会想知道为什么我们不使用一个纹理，并让着色器更新该纹理中的值。（实际上我们不能对纹理这样做，因为没有办法在同一个纹理上使用 <code>textureLoad()</code> 和 <code>textureStore()</code>，但我们可以通过使用存储缓冲区而不是纹理来存储棋盘的状态来解决这个问题。）在生命游戏中，着色器调用必须读取单元格的八个邻居的状态。问题是其他调用正在为这些邻居写新状态。如果它们将新值写入旧值存储的相同资源，就没有办法确保调用读取的是邻居的旧值而不是新值。如果我们能够强制所有读取在任何写入完成之前完成，那将很好。<abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> 有一种方法可以在单个工作组内实现那种事情，但它没有办法针对整个计算作业来实现。移动圆盘示例没有这个问题，因为每个着色器调用都处理数据数组的单个元素，并且不依赖于其他调用所写的值。</p>
</div>
<div class="tabbed-block">
<p>My first <abbr title="A stage in a GPU pipeline that does purely computational work, rather than participating directly in graphical rendering.">compute shader</abbr> example, <a href="../../../en/source/webgpu/first_compute_shader.html">webgpu/first_compute_shader.html</a>, is a modification of earlier programs that showed colored disks moving in the canvas and bouncing off the edges. In the earlier programs, the positions of the disks were updated on the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side and then written to a buffer on the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>. The new version moves that computation into a <abbr title="A stage in a GPU pipeline that does purely computational work, rather than participating directly in graphical rendering.">compute shader</abbr> that runs on the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>. This increases efficiency both because the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> parallelizes the computation and because the new values do not have be copied to the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>.</p>
<p>Working with compute pipelines is similar to working with render pipelines: Create the <abbr title="WebGPU 着色器语言，是编写 WebGPU 使用的着色器的编程语言。">WGSL</abbr> source code for the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>; create a compute <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> to process the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> and create the bind groups and resources used by the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>; use a command encoder and compute pass encoder to assemble the commands that are needed to run the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>; and submit the commands to the <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> device queue.</p>
<p>In <abbr title="WebGPU 着色器语言，是编写 WebGPU 使用的着色器的编程语言。">WGSL</abbr> source code, the entry-point function for a <abbr title="A stage in a GPU pipeline that does purely computational work, rather than participating directly in graphical rendering.">compute shader</abbr> is marked by the annotation @compute (in the same way that a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> entry-point is annotated with @<abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>). The <abbr title="A stage in a GPU pipeline that does purely computational work, rather than participating directly in graphical rendering.">compute shader</abbr> entry-point also requires another annotation to specify the workgroup size. For example, the annotation @workgroup_size(16,8) specifies a two-dimensional workgroup with size 16 in the x direction and 8 in the y direction.</p>
<p>Several builtin values are available as parameters to a <abbr title="A stage in a GPU pipeline that does purely computational work, rather than participating directly in graphical rendering.">compute shader</abbr> entry-point function. The most useful is probably @builtin(global_invocation_id), which gives the global invocation ID of the current invocation as a vec3u. For a one-dimensional task, the y and z component of the <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> will be 1; for a two-dimensional problem, the z component will be 1. As far as <abbr title="WebGPU 着色器语言，是编写 WebGPU 使用的着色器的编程语言。">WGSL</abbr> is concerned, all problems are three-dimensional, with the sizes for missing dimensions set to 1. Here, for example, is the start of the entry-point function from the first sample program:</p>
<div class="highlight"><pre><span></span><code><span class="err">@</span><span class="nx">compute</span><span class="w"> </span><span class="err">@</span><span class="nx">workgroup_size</span><span class="p">(</span><span class="mf">64</span><span class="p">)</span>
<span class="nx">fn</span><span class="w"> </span><span class="nx">main</span><span class="p">(</span><span class="w"> </span><span class="err">@</span><span class="nx">builtin</span><span class="p">(</span><span class="nx">global_invocation_id</span><span class="p">)</span><span class="w"> </span><span class="nx">global_id</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">vec3u</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="p">.</span>
</code></pre></div>
<p>Other builtins for the <abbr title="A stage in a GPU pipeline that does purely computational work, rather than participating directly in graphical rendering.">compute shader</abbr> include:</p>
<ul>
<li>@builtin(local_invocation_id) — The local invocation ID of the current invocation in its workgroup.</li>
<li>@builtin(num_workgroups) — The number of workgroups in each direction. The values are just the parameters from the call to dispatchWorkgroups() that started the current job.</li>
<li>@builtin(workgroup_id) — The position in the grid of workgroups of the workgroup that contains the current invocation.</li>
</ul>
<p>All of these are of type vec3u, with values for missing dimensions set to 1.</p>
<p>The <abbr title="A stage in a GPU pipeline that does purely computational work, rather than participating directly in graphical rendering.">compute shader</abbr> can get input from the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side in bind groups. There is nothing like a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> buffer to provide parameter values for the <abbr title="A stage in a GPU pipeline that does purely computational work, rather than participating directly in graphical rendering.">compute shader</abbr> entry point function, so the only parameters will be builtins. The function also has no return type. A <abbr title="A stage in a GPU pipeline that does purely computational work, rather than participating directly in graphical rendering.">compute shader</abbr> produces output by writing it to a <abbr title="In WebGPU, a general purpose buffer on the GPU, which can be used in compute shaders as well as in vertex and fragment shaders.">storage buffer</abbr> or storage <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> that is part of a bind group.</p>
<p>In the sample program, the data for the <abbr title="A sequence of images that, when displayed quickly one after the other, will produce the impression of continuous motion or change. The term animation also refers to the process of creating such image sequences.">animation</abbr> consists of the positions of the moving disks and their velocities. The <abbr title="A stage in a GPU pipeline that does purely computational work, rather than participating directly in graphical rendering.">compute shader</abbr> is run between frames of the <abbr title="A sequence of images that, when displayed quickly one after the other, will produce the impression of continuous motion or change. The term animation also refers to the process of creating such image sequences.">animation</abbr> to update the positions. When a disk bounces off an edge, it reverses direction, and in that case the velocity of the disk also changes. The x and y components of the positions and velocities have to be updated. The computation is the same for both components. The task for one invocation of the <abbr title="A stage in a GPU pipeline that does purely computational work, rather than participating directly in graphical rendering.">compute shader</abbr> is to update the position and velocity of one disk in either the x or y direction. If there are N disks, we need 2*N invocations of the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>.</p>
<p>The positions and velocities are stored in two storage buffers, which are represented in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program by variables of type <code>array&lt;32&gt;</code>. Initial values are written to the buffers by the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side of the program. After that, the buffers are used entirely on the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> side. An additional <abbr title="In WebGPU, a general purpose buffer on the GPU, which can be used in compute shaders as well as in vertex and fragment shaders.">storage buffer</abbr> holds an array of three floats giving other data needed for the computation: the number of disks, the radius of the disks, and the change in time since the previous update. The <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> variables are declared as</p>
<div class="highlight"><pre><span></span><code><span class="err">@</span><span class="nx">group</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="err">@</span><span class="nx">binding</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="kd">var</span><span class="o">&lt;</span><span class="nx">storage</span><span class="p">,</span><span class="nx">read_write</span><span class="o">&gt;</span><span class="w"> </span><span class="nx">diskOffsets</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">array</span><span class="o">&lt;</span><span class="nx">f32</span><span class="o">&gt;</span><span class="p">;</span>
<span class="err">@</span><span class="nx">group</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="err">@</span><span class="nx">binding</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="kd">var</span><span class="o">&lt;</span><span class="nx">storage</span><span class="p">,</span><span class="nx">read_write</span><span class="o">&gt;</span><span class="w"> </span><span class="nx">diskVelocities</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">array</span><span class="o">&lt;</span><span class="nx">f32</span><span class="o">&gt;</span><span class="p">;</span>
<span class="err">@</span><span class="nx">group</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="err">@</span><span class="nx">binding</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span><span class="w"> </span><span class="kd">var</span><span class="o">&lt;</span><span class="nx">storage</span><span class="o">&gt;</span><span class="w"> </span><span class="nx">params</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">array</span><span class="o">&lt;</span><span class="nx">f32</span><span class="p">,</span><span class="mf">3</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>
<p>The first two arrays need read_write access since their contents will be updated. To call the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>, a <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> and a bind group will be needed. The <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> descriptor for a <abbr title="A stage in a GPU pipeline that does purely computational work, rather than participating directly in graphical rendering.">compute shader</abbr> is fairly simple. It has a layout property, and a compute property to specify the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> module and <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> entry point function. The <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> itself is created with the function device.createComputePipeline(). Here is how the sample program creates the compute <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> and a bind group that will be attached to the <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>:</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span><span class="w"> </span><span class="nx">createComputePipelineConfig</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>

<span class="kd">let</span><span class="w"> </span><span class="nx">pipelineDescriptor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">compute</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">module</span><span class="o">:</span><span class="w"> </span><span class="kt">computeShader</span><span class="p">,</span>
<span class="w">        </span><span class="nx">entryPoint</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;main&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="nx">layout</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;auto&quot;</span>
<span class="p">};</span>

<span class="nx">computePipeline</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createComputePipeline</span><span class="p">(</span><span class="nx">pipelineDescriptor</span><span class="p">);</span>

<span class="nx">computeBindGroup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createBindGroup</span><span class="p">({</span><span class="w"> </span>
<span class="w">    </span><span class="nx">layout</span><span class="o">:</span><span class="w"> </span><span class="kt">computePipeline.getBindGroupLayout</span><span class="p">(</span><span class="mf">0</span><span class="p">),</span>
<span class="w">    </span><span class="nx">entries</span><span class="o">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">        </span><span class="p">{</span><span class="w">    </span><span class="c1">// For positions of the disks.</span>
<span class="w">            </span><span class="nx">binding</span><span class="o">:</span><span class="w"> </span><span class="kt">0</span><span class="p">,</span>
<span class="w">            </span><span class="nx">resource</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="nx">buffer</span><span class="o">:</span><span class="w"> </span><span class="kt">offsetBuffer</span><span class="p">}</span><span class="w"> </span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="p">{</span><span class="w">    </span><span class="c1">// For velocities of the disks.</span>
<span class="w">            </span><span class="nx">binding</span><span class="o">:</span><span class="w"> </span><span class="kt">1</span><span class="p">,</span>
<span class="w">            </span><span class="nx">resource</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="nx">buffer</span><span class="o">:</span><span class="w"> </span><span class="kt">velocityBuffer</span><span class="p">}</span><span class="w"> </span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="p">{</span><span class="w">   </span><span class="c1">// Other data for the computation.</span>
<span class="w">            </span><span class="nx">binding</span><span class="o">:</span><span class="w"> </span><span class="kt">2</span><span class="p">,</span>
<span class="w">            </span><span class="nx">resource</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="nx">buffer</span><span class="o">:</span><span class="w"> </span><span class="kt">paramsBuffer</span><span class="p">}</span><span class="w"> </span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">]</span>
<span class="p">});</span>
<span class="p">}</span>
</code></pre></div>
<p>The <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr> is run by a <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> function that is called between frames of the <abbr title="A sequence of images that, when displayed quickly one after the other, will produce the impression of continuous motion or change. The term animation also refers to the process of creating such image sequences.">animation</abbr>. The compute pass encoder method <code>dispatchWorkgroups()</code> is used to invoke the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>, with a parameter that specifies the number of workgroups. We need <code>2*DISK_COUNT invocations</code> of the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>, and the size of a workgroup is 64, so we need at least <code>(2*DISK_COUNT)/64</code> workgroups. Since the number of workgroups must be an integer, we need to round the number up to an integer value using <code>Math.ceil()</code>.</p>
<div class="highlight"><pre><span></span><code><span class="cm">/**</span>
<span class="cm"> *  Use a compute pass to update the disk positions, based on their</span>
<span class="cm"> *  velocities and the change in time since the previous animation frame.</span>
<span class="cm"> *  Velocities can also change.  The parameter, dt, is the change in time.</span>
<span class="cm"> */</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">update</span><span class="p">(</span><span class="nx">dt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="cm">/* Write the change in time to the third position in the paramsBuffer */</span>

<span class="nx">device</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">writeBuffer</span><span class="p">(</span><span class="nx">paramsBuffer</span><span class="p">,</span><span class="mf">8</span><span class="p">,</span><span class="ow">new</span><span class="w"> </span><span class="nb">Float32Array</span><span class="p">([</span><span class="nx">dt</span><span class="p">]));</span>

<span class="cm">/* Encode a compute pass that will do the work. */</span>

<span class="kd">let</span><span class="w"> </span><span class="nx">commandEncoder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createCommandEncoder</span><span class="p">();</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">passEncoder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">commandEncoder</span><span class="p">.</span><span class="nx">beginComputePass</span><span class="p">();</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">setPipeline</span><span class="p">(</span><span class="nx">computePipeline</span><span class="p">);</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">setBindGroup</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">computeBindGroup</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">workGroupCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Math</span><span class="p">.</span><span class="nx">ceil</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="mf">2</span><span class="o">*</span><span class="nx">DISK_COUNT</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">64</span><span class="w"> </span><span class="p">);</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">dispatchWorkgroups</span><span class="p">(</span><span class="w"> </span><span class="nx">workGroupCount</span><span class="w"> </span><span class="p">);</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">end</span><span class="p">();</span>

<span class="cm">/* Submit the work to the GPU device queue. */</span>

<span class="nx">device</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">submit</span><span class="p">([</span><span class="nx">commandEncoder</span><span class="p">.</span><span class="nx">finish</span><span class="p">()]);</span>
<span class="p">}</span>
</code></pre></div>
<p>As you can see, all of this is very similar to working with render pipelines and render passes.</p>
<hr />
<p>My second <abbr title="A stage in a GPU pipeline that does purely computational work, rather than participating directly in graphical rendering.">compute shader</abbr> example is <a href="../../../en/source/webgpu/life_3.html">webgpu/life_3.html</a>, which implements Conway's Game of Life. It is a modification of <a href="../../../en/source/webgpu/life_1.html">life_1.html</a> from <a href="../s5/">Subsection 9.5.5</a>. The original version computed the new generation of the board in the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr>, at the same time that it was displaying the current generation. The new version moves that computation into a <abbr title="A stage in a GPU pipeline that does purely computational work, rather than participating directly in graphical rendering.">compute shader</abbr>. The <abbr title="A stage in a GPU pipeline that does purely computational work, rather than participating directly in graphical rendering.">compute shader</abbr> version is, if anything, <strong>less</strong> efficient than the original version—which can be taken as a reminder that fragment shaders can do computational work.</p>
<p>Life is naturally a two-dimensional problem, since each invocation processes one cell of a two-dimensional board. The workgroup size has two components, and dispatchWorkgroups() will need two parameters. I use (8,8) as the workgroup size, giving 64 invocations per workgroup.</p>
<p>This example shows, in particular, that compute shaders can work with textures. The current state of the board is stored in a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. The new state is written to a second <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. Both textures are resources for the compute <abbr title="A sequence of computational stages in a GPU that are applied to incoming data to produce some result. Some of the stages can be programmable shaders, such as vertex shaders, fragment shaders, and compute shaders. In a graphics rendering pipeline, the output is the colors of the pixels in an image.">pipeline</abbr>. The first, which is used for input, is a resource of type <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>; the second, which is used for output, is a resource of type storage <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. A <abbr title="A stage in a GPU pipeline that does purely computational work, rather than participating directly in graphical rendering.">compute shader</abbr> can use <code>textureLoad()</code> to read from a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> resource, and it can use <code>textureStore()</code> to write to a storage <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> resource. (See <a href="../s5/#955-纹理格式">Subsection 9.5.5</a> for information about storage textures, <code>textureLoad()</code>, and <code>textureStore()</code>.) Note that a <abbr title="A stage in a GPU pipeline that does purely computational work, rather than participating directly in graphical rendering.">compute shader</abbr> cannot use <code>textureSample()</code>.</p>
<p>Here is the source code for the <abbr title="A stage in a GPU pipeline that does purely computational work, rather than participating directly in graphical rendering.">compute shader</abbr>, omitting the details of the computation:</p>
<div class="highlight"><pre><span></span><code><span class="kd">@group</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="kd">@binding</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="kd">var</span><span class="w"> </span><span class="nx">currentGen</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">texture_2d</span><span class="o">&lt;</span><span class="nx">u32</span><span class="o">&gt;</span><span class="p">;</span>
<span class="kd">@group</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="kd">@binding</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="kd">var</span><span class="w"> </span><span class="nx">nextGen</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">texture_storage_2d</span><span class="o">&lt;</span><span class="nx">r32uint</span><span class="p">,</span><span class="nx">write</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kd">@compute</span><span class="w"> </span><span class="kd">@workgroup_size</span><span class="p">(</span><span class="mf">8</span><span class="p">,</span><span class="mf">8</span><span class="p">)</span>
<span class="nx">fn</span><span class="w"> </span><span class="nx">main</span><span class="p">(</span><span class="w"> </span><span class="kd">@builtin</span><span class="p">(</span><span class="nx">global_invocation_id</span><span class="p">)</span><span class="w"> </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="kt">vec3u</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">boardSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">textureDimensions</span><span class="p">(</span><span class="nx">currentGen</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">cell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">id</span><span class="p">.</span><span class="nx">xy</span><span class="p">;</span><span class="w"> </span><span class="c1">// Row and column for the cell that is being processed.</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">cell</span><span class="p">.</span><span class="nx">x</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="nx">boardSize</span><span class="p">.</span><span class="nx">x</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">cell</span><span class="p">.</span><span class="nx">y</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="nx">boardSize</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span><span class="w">  </span><span class="c1">// The assigned cell is outside the board.</span>
<span class="p">}</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">alive</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">textureLoad</span><span class="p">(</span><span class="nx">currentGen</span><span class="p">,</span><span class="w"> </span><span class="nx">cell</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">).</span><span class="nx">r</span><span class="p">;</span>
<span class="w">        </span><span class="p">.</span>
<span class="w">        </span><span class="p">.</span><span class="w"> </span><span class="c1">// (Compute new &quot;alive&quot; value for this cell.)</span>
<span class="w">        </span><span class="p">.</span>
<span class="nx">textureStore</span><span class="p">(</span><span class="w"> </span><span class="nx">nextGen</span><span class="p">,</span><span class="w"> </span><span class="nx">cell</span><span class="p">,</span><span class="w"> </span><span class="nx">vec4u</span><span class="p">(</span><span class="nx">newAlive</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>When dispatching workgroups, the number of invocations that we need depends on the size of the board, which is the same as the size of the canvas. Again, we have to divide the number of invocations by the workgroup size and round up to an integer value:</p>
<div class="highlight"><pre><span></span><code><span class="cm">/**</span>
<span class="cm"> *  Compute the next generation and copy it to the currentGeneration texture.</span>
<span class="cm"> *  (Only currentGenertion is used in the render shader.)</span>
<span class="cm"> */</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">computeNextGeneration</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">commandEncoder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createCommandEncoder</span><span class="p">();</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">passEncoder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">commandEncoder</span><span class="p">.</span><span class="nx">beginComputePass</span><span class="p">();</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">setPipeline</span><span class="p">(</span><span class="nx">computePipeline</span><span class="p">);</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">setBindGroup</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="nx">computeBindGroup</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">workgroupCountX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Math</span><span class="p">.</span><span class="nx">ceil</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span><span class="o">/</span><span class="mf">8</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">workgroupCountY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Math</span><span class="p">.</span><span class="nx">ceil</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span><span class="o">/</span><span class="mf">8</span><span class="p">);</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">dispatchWorkgroups</span><span class="p">(</span><span class="w"> </span><span class="nx">workgroupCountX</span><span class="p">,</span><span class="w"> </span><span class="nx">workgroupCountY</span><span class="w"> </span><span class="p">);</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">end</span><span class="p">();</span>
<span class="nx">commandEncoder</span><span class="p">.</span><span class="nx">copyTextureToTexture</span><span class="p">(</span><span class="w">  </span><span class="c1">// Copy result to nextGeneration.</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="nx">texture</span><span class="o">:</span><span class="w"> </span><span class="kt">nextGeneration</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="nx">texture</span><span class="o">:</span><span class="w"> </span><span class="kt">currentGeneration</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">[</span><span class="w"> </span><span class="nx">context</span><span class="p">.</span><span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span><span class="w"> </span><span class="nx">context</span><span class="p">.</span><span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span><span class="w"> </span><span class="p">]</span>
<span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">commandBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">commandEncoder</span><span class="p">.</span><span class="nx">finish</span><span class="p">();</span>
<span class="nx">device</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">submit</span><span class="p">([</span><span class="nx">commandBuffer</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div>
<p>Note the call to a new function, commandEncoder.copyTextureToTexture(). This function takes three parameters, giving the source <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>, the destination <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>, and the size of the region to be copied. The first two parameters are objects, with optional parameters to specify the mipLevel and the top-left corner, or origin, of the region to be copied.</p>
<hr />
<p>In the first <abbr title="A stage in a GPU pipeline that does purely computational work, rather than participating directly in graphical rendering.">compute shader</abbr> example, the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> reads values from a buffer and writes new values back to the same buffer. In the second, two textures are used, one for input and one for output. You might wonder why we didn't use one <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> and let the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> update the values in that <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. (In fact we couldn't do that with textures, since there is no way to use <code>textureLoad()</code> and <code>textureStore()</code> on the same <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>, but we could solve that problem by using a <abbr title="In WebGPU, a general purpose buffer on the GPU, which can be used in compute shaders as well as in vertex and fragment shaders.">storage buffer</abbr> instead of a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> to hold the state of the board.) In the Life game, a <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> invocation has to read the states of the cell's eight neighbors. The problem is that other invocations are writing new states for those neighbors. If they are writing the new values to same resource where old values are stored, there is no way to ensure that an invocation reads the old values of the neighbors rather than the new values. It would be nice if we could force all of the reads to be done before any of the writes are done. <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> has a way to do that sort of thing within a single workgroup, but it has no way to do it for a compute job as a whole. The moving disk example doesn't have this problem because each invocation of the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> works on a single element of the data array and does not depend on values being written by other invocations.</p>
</div>
</div>
</div>
<h2 id="963-模拟">9.6.3 模拟<a class="headerlink" href="#963-模拟" title="Permanent link">&para;</a></h2>
<p><strong>A Simulation</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="4:2"><input checked="checked" id="__tabbed_4_1" name="__tabbed_4" type="radio" /><input id="__tabbed_4_2" name="__tabbed_4" type="radio" /><div class="tabbed-labels"><label for="__tabbed_4_1">中文</label><label for="__tabbed_4_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>计算机经常用于进行物理模拟，许多模拟都可以从 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 的并行性中受益。示例程序 <a href="../../../en/source/webgpu/diffusion.html">webgpu/diffusion.html</a> 是一个相当简单的例子，展示了可以实现什么。该程序显示了许多白色点随机移动。每个点都是一个像素。运动是一种“随机游走”：在每个时间步，粒子选择一个随机方向——上、下、左或右——并朝那个方向移动一个像素。还有黄色和青色的粒子，它们不移动。最初，在左侧有一排黄色粒子，在右侧有一排青色粒子。当一个白色粒子碰到一个黄色或青色粒子时，它会变色以匹配并停止移动。结果是在有趣的分支模式中积累了有色的粒子。这个过程很有趣。以下是一个程序的演示版本：</p>
<p><iframe src="../../../en/demos/c9/diffusion-demo.html" width="530" height="480"></iframe></p>
<p>（这个模拟的想法不是我的原创。我在很久以前读到了一个类似的模拟，尽管我不记得在哪里了。）</p>
<p>一个有趣的点是在计算着色器中使用伪随机数。<abbr title="WebGPU 着色器语言，是编写 WebGPU 使用的着色器的编程语言。">WGSL</abbr> 着色器语言中没有随机数生成器。但是，其他语言使用简单的数学公式产生伪随机数。从初始的“种子”值开始，公式产生了一系列数字。序列完全由初始种子值决定，但从统计学上看是随机的。我的程序采用了 Java 编程语言中使用的伪随机数生成器的公式。每个粒子运行自己的伪随机数生成器，从不同的种子值开始。种子值是使用 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 的 Math.random() 函数在 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 端创建的。</p>
<p>该程序使用两个存储缓冲区，一个保存有关每个粒子的信息，另一个保存画布上每个像素的颜色信息。粒子信息包括粒子的随机数生成器的当前种子值、粒子的 x 和 y 坐标以及粒子的颜色。颜色被编码为整数：1、2 或 3 分别代表白色、黄色或青色。颜色缓冲区也将颜色表示为整数代码号，增加了 0 作为背景颜色黑色的代码。</p>
<p>有两个计算着色器。对于两个着色器，每个调用处理一个粒子。第一个着色器对黄色或青色粒子什么也不做。对于白色粒子，它通过将粒子朝随机方向移动来更新粒子缓冲区的数据，除非它试图移动到包含有色粒子的像素中，然后粒子变色并不移动。着色器需要访问颜色缓冲区，以便检查白色粒子想要移动到的像素是否已经包含有色粒子。第一个着色器运行后，颜色缓冲区被清除。然后第二个计算着色器更新颜色缓冲区：对于每个粒子，它将包含粒子的像素的颜色设置为粒子的颜色。</p>
<p>该程序还有一个渲染着色器，它为每个像素调用一次。它查询颜色缓冲区以确定应该分配给像素的颜色。</p>
<p>我不会讨论这个示例的细节，但我鼓励你查看 <a href="../../../en/source/webgpu/diffusion.html">源代码</a>。</p>
</div>
<div class="tabbed-block">
<p>Computers are often used to do physical simulations, and many simulations can benefit from the parallelism of a <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>. The sample program <a href="../../../en/source/webgpu/diffusion.html">webgpu/diffusion.html</a> is a fairly simple example of what can be done. The program shows a large number of white dots moving randomly. Each dot is a <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>. The motion is a "random walk": In each time step, the particle chooses a random direction—up, down, left, or right—and moves one <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> in that direction. There are also yellow and cyan particles, which don't move. Initially, there is a line of yellow particles on the left and a line of cyan particles on the right. When a white particle hits a yellow or cyan particle, it changes color to match and stops moving. The result is a buildup of colored particles in an interesting, branching pattern. The process is interesting to watch. Here is a demo version of the program:</p>
<p><iframe src="../../../en/demos/c9/diffusion-demo.html" width="530" height="480"></iframe></p>
<p>(The idea for this simulation is not original with me. I read about a similar simulation some time ago, though I can't remember where.)</p>
<p>One point of interest is the use of pseudo-random numbers in the <abbr title="A stage in a GPU pipeline that does purely computational work, rather than participating directly in graphical rendering.">compute shader</abbr>. There is no random number generator in the <abbr title="WebGPU 着色器语言，是编写 WebGPU 使用的着色器的编程语言。">WGSL</abbr> shading language. But pseudo-random numbers are produced in other languages using simple mathematical formulas. Starting from an initial "seed" value, the formula produces a sequence of numbers. The sequence is completely determined by the initial seed value, but it looks statistically random. My program takes the formula from the pseudo-random number generator that used in the Java programming language. Each particle runs its own pseudo-random number generator, starting from different seed values. The seed values are created on the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side using <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr>'s Math.random() function.</p>
<p>The program uses two storage buffers, one holding information about each particle and one holding color information for each <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> in the canvas. Particle information includes the current seed value for the particle's random number generator, the x and y coordinates of the particle, and the particle's color. Color is encoded as an integer: 1, 2, or 3 representing white, yellow, or cyan. The <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr> also represents color as an integer code number, adding 0 as a code for black, the background color.</p>
<p>There are two compute shaders. For both shaders, each invocation processes one particle. The first <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> does nothing for a yellow or cyan particle. For a white particle, it updates data in the particle buffer by moving the particle in a random direction, except that if it tries to move into a <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> that contains a colored particle, then the particle changes color and does not move. The <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> needs access to the <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr> so that it can check whether the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> to which the white particle wants to move already contains a colored particle. After the first <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> runs, the <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr> is cleared. Then the second <abbr title="A stage in a GPU pipeline that does purely computational work, rather than participating directly in graphical rendering.">compute shader</abbr> updates the <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr>: For each particle, it sets the color of the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> that contains the particle to match the color of the particle.</p>
<p>The program also has a render <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>, which is invoked once for each <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>. It consults the <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr> to determine what color should be assigned to a <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>.</p>
<p>I will not discuss the details of this example, but I encourage you to take a look at the <a href="../../../en/source/webgpu/diffusion.html">source code</a>.</p>
</div>
</div>
</div>
<h2 id="964-检索输出">9.6.4 检索输出<a class="headerlink" href="#964-检索输出" title="Permanent link">&para;</a></h2>
<p><strong>Retrieving Output</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="5:2"><input checked="checked" id="__tabbed_5_1" name="__tabbed_5" type="radio" /><input id="__tabbed_5_2" name="__tabbed_5" type="radio" /><div class="tabbed-labels"><label for="__tabbed_5_1">中文</label><label for="__tabbed_5_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>在我到目前为止的例子中，计算着色器被用来处理数据，这些数据被渲染着色器使用。但有些任务纯粹是计算性的，没有可见组件。必须有一种方法来检索计算任务的输出，以便在程序的 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 端使用。</p>
<p>计算着色器可以将数据输出到存储缓冲区。存储缓冲区通常存储在 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 内存中，<abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 无法访问，因此我们需要一种方法将缓冲区的内容复制到 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 可以访问的内存中。解决方案是使用第二个缓冲区，其使用属性包括 MAP_READ 和 COPY_DST。这样的缓冲区通常被称为“暂存缓冲区”。<abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 可以将数据复制到暂存缓冲区，然后 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 可以“映射”该暂存缓冲区以进行读取。一旦 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 从暂存缓冲区检索了数据，它必须“取消映射”该缓冲区，因为在映射期间 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 无法访问该缓冲区。</p>
<p>示例程序 <a href="../../../en/source/webgpu/map_buffer_for_read.html">webgpu/map_buffer_for_read.html</a> 在 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 上执行一个简单的计算，输出一个浮点数数组。（这里具体的计算不重要。）该程序使用存储缓冲区和暂存缓冲区，创建方式如下：</p>
<div class="highlight"><pre><span></span><code><span class="nx">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">({</span>
<span class="w">    </span><span class="nx">size</span><span class="o">:</span><span class="w"> </span><span class="kt">4</span><span class="o">*</span><span class="nx">intervals</span><span class="p">,</span>
<span class="w">    </span><span class="nx">usage</span><span class="o">:</span><span class="w"> </span><span class="kt">GPUBufferUsage.STORAGE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">GPUBufferUsage</span><span class="p">.</span><span class="nx">COPY_SRC</span>
<span class="p">});</span>
<span class="nx">stagingBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">({</span>
<span class="w">    </span><span class="nx">size</span><span class="o">:</span><span class="w"> </span><span class="kt">4</span><span class="o">*</span><span class="nx">intervals</span><span class="p">,</span>
<span class="w">    </span><span class="nx">usage</span><span class="o">:</span><span class="w"> </span><span class="kt">GPUBufferUsage.MAP_READ</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">GPUBufferUsage</span><span class="p">.</span><span class="nx">COPY_DST</span>
<span class="p">});</span>
</code></pre></div>
<p>计算着色器输出到 buffer，然后将 buffer 复制到 stagingBuffer。您可能会想知道为什么我们不直接给存储缓冲区添加 MAP_READ 使用。但 MAP_READ 只能与 COPY_DST 结合使用。存储缓冲区旨在存储在 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 内存中；暂存缓冲区旨在存储在共享内存中。因此，通常，缓冲区不能同时是两者。</p>
<p>在将计算作业提交给 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 后，输出在作业完成后才会可用。<abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 必须等待这种情况发生，然后才能映射暂存缓冲区。这种类型的同步在 <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> 中使用承诺来处理（<a href="../../a1/s4/">第 A.4 节</a>）。暂存缓冲区使用 mapAsync() 方法进行映射，该方法返回一个承诺。当缓冲区准备好映射时，承诺解决。mapAsync() 通常使用 await 调用。例如，在示例程序中，</p>
<div class="highlight"><pre><span></span><code><span class="k">await</span><span class="w"> </span><span class="nx">stagingBuffer</span><span class="p">.</span><span class="nx">mapAsync</span><span class="p">(</span><span class="nx">GPUMapMode</span><span class="p">.</span><span class="nx">READ</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">intervals</span><span class="o">*</span><span class="mf">4</span><span class="p">);</span>
</code></pre></div>
<p>第一个参数可以是 GPUMapMode.READ 或 GPUMapMode.WRITE。另外两个参数指定要映射的缓冲区区域的起始点和大小（以字节为单位）。</p>
<p>一旦映射准备好，就可以使用暂存缓冲区方法 getMappedRange() 将映射区域的全部或部分视为 <strong><em>ArrayBuffer</em></strong>。<strong><em>ArrayBuffer</em></strong> 只是一个字节容器。在示例程序中，这些字节实际上是一个浮点数组。要将数据作为浮点数组访问，我们可以将 <strong><em>ArrayBuffer</em></strong> 包装在 <strong><em>Float32Array</em></strong> 中。示例程序这样做，然后添加数组中的数字以获得最终答案。计算的两个方面都在以下函数中完成：</p>
<div class="highlight"><pre><span></span><code><span class="k">async</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">compute</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="cm">/* 运行计算着色器，并将输出复制到暂存缓冲区。 */</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">commandEncoder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createCommandEncoder</span><span class="p">();</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">passEncoder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">commandEncoder</span><span class="p">.</span><span class="nx">beginComputePass</span><span class="p">();</span>
<span class="w">    </span><span class="nx">passEncoder</span><span class="p">.</span><span class="nx">setPipeline</span><span class="p">(</span><span class="nx">pipeline</span><span class="p">);</span>
<span class="w">    </span><span class="nx">passEncoder</span><span class="p">.</span><span class="nx">setBindGroup</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">bindGroup</span><span class="p">);</span>
<span class="w">    </span><span class="nx">passEncoder</span><span class="p">.</span><span class="nx">dispatchWorkgroups</span><span class="p">(</span><span class="w"> </span><span class="nb">Math</span><span class="p">.</span><span class="nx">ceil</span><span class="p">(</span><span class="nx">intervals</span><span class="o">/</span><span class="mf">64</span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="nx">passEncoder</span><span class="p">.</span><span class="nx">end</span><span class="p">();</span>
<span class="w">    </span><span class="nx">commandEncoder</span><span class="p">.</span><span class="nx">copyBufferToBuffer</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">stagingBuffer</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">intervals</span><span class="o">*</span><span class="mf">4</span><span class="p">);</span>
<span class="w">    </span><span class="nx">device</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">submit</span><span class="p">([</span><span class="nx">commandEncoder</span><span class="p">.</span><span class="nx">finish</span><span class="p">()]);</span>

<span class="w">    </span><span class="cm">/* 映射暂存缓冲区，将其解释为 Float32Array，并找到总和。 */</span>

<span class="w">    </span><span class="k">await</span><span class="w"> </span><span class="nx">stagingBuffer</span><span class="p">.</span><span class="nx">mapAsync</span><span class="p">(</span><span class="nx">GPUMapMode</span><span class="p">.</span><span class="nx">READ</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">intervals</span><span class="o">*</span><span class="mf">4</span><span class="p">);</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Float32Array</span><span class="p">(</span><span class="nx">stagingBuffer</span><span class="p">.</span><span class="nx">getMappedRange</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="nx">intervals</span><span class="o">*</span><span class="mf">4</span><span class="p">));</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">data</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">sum</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* 取消映射暂存缓冲区，并返回总和。 */</span>

<span class="w">    </span><span class="nx">stagingBuffer</span><span class="p">.</span><span class="nx">unmap</span><span class="p">();</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">sum</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>特别注意最后使用 <code>stagingBuffer.unmap()</code>。在 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 可以重用缓冲区之前，必须取消映射缓冲区。如果处理数据将花费非平凡的时间，最好在处理之前制作数据的副本并取消映射缓冲区。</p>
<p>也可以将缓冲区映射以进行写入，以为 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 提供输入。暂存缓冲区将使用 MAP_WRITE 和 COPY_DST 使用。<abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 将映射缓冲区以进行写入，将数据复制到映射的缓冲区中，并取消映射缓冲区。然后，它可以提交一个 <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> 作业，其中包括将数据从暂存缓冲区复制到 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 内存。我们一直在使用 <code>device.writeBuffer()</code> 将数据从 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 复制到 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 内存。该函数可以使用暂存缓冲区完成其任务（尽管它的实际工作方式不是 <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> 规范的一部分）。</p>
<hr />
<p>为了给程序增加一些趣味性，我添加了一个称为“reduce”的重要并行算法的实现。在上述讨论的计算中，数组被复制到程序的 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 端。数组在那里使用循环进行求和，这个操作对于大小为 N 的数组需要 N 步。使用 reduce，可以在 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 上以大约 log2(N) 步添加相同的数字。基本思想是将数组后半部分的每个数字与前半部分的伙伴相加。在伪代码中，对于长度为 N 的数组 A，</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">N</span><span class="o">/</span><span class="mf">2</span><span class="p">;</span><span class="w"> </span><span class="nx">index</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="nx">A</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">A</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">A</span><span class="p">[</span><span class="nx">index</span><span class="o">+</span><span class="nx">N</span><span class="o">/</span><span class="mf">2</span><span class="p">]</span>
</code></pre></div>
<p>这个循环可以被一个简单的计算着色器替换。结果是，原始数组中数字的总和等于修改后数组中前 N/2 个元素的数字总和。现在，考虑这 N/2 个元素是一个新的、更短的数组，并应用相同的过程，以便原始总和现在集中在 N/4 个元素中。继续这样做，直到原始总和集中在单个元素 A[0] 中。在这一点上，计算着色器已经被应用了 log2(N) 次。</p>
<p>现在，所有这些实际上只有在数组的大小是 2 的幂时才有效。如果任何时候你必须使用长度为奇数的数组，事情就会变得更复杂一些。然而，示例程序也处理了这种情况，你可以查看源代码了解它是如何完成的。</p>
</div>
<div class="tabbed-block">
<p>In my examples so far, the compute shaders were used to process data that was used by a render <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>. But some tasks are purely computational, with no visible component. There has to be some way to retrieve the output of a computational task so that it can be used on the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side of the program.</p>
<p>A <abbr title="A stage in a GPU pipeline that does purely computational work, rather than participating directly in graphical rendering.">compute shader</abbr> can output data to a <abbr title="In WebGPU, a general purpose buffer on the GPU, which can be used in compute shaders as well as in vertex and fragment shaders.">storage buffer</abbr>. A <abbr title="In WebGPU, a general purpose buffer on the GPU, which can be used in compute shaders as well as in vertex and fragment shaders.">storage buffer</abbr> is typically stored in <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> memory that is not accessible to <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr>, so we need a way to copy the contents of the buffer into memory that <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> can access. The solution is to use a second buffer whose usage property includes MAP_READ and COPY_DST. Such buffers are often referred to as "staging buffers." The <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> can copy data into a staging buffer, and <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> can then "map" that staging buffer for reading. Once <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> has retrieved the data from the staging buffer, it must "unmap" the buffer, because the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> cannot access the buffer while it is mapped.</p>
<p>The sample program <a href="../../../en/source/webgpu/map_buffer_for_read.html">webgpu/map_buffer_for_read.html</a> performs a simple computation on the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> that outputs an array of floating point numbers. (The specific computation is not important here.) The program uses a <abbr title="In WebGPU, a general purpose buffer on the GPU, which can be used in compute shaders as well as in vertex and fragment shaders.">storage buffer</abbr> and a staging buffer, which are created like this:</p>
<div class="highlight"><pre><span></span><code><span class="nx">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">({</span>
<span class="nx">size</span><span class="o">:</span><span class="w"> </span><span class="kt">4</span><span class="o">*</span><span class="nx">intervals</span><span class="p">,</span>
<span class="nx">usage</span><span class="o">:</span><span class="w"> </span><span class="kt">GPUBufferUsage.STORAGE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">GPUBufferUsage</span><span class="p">.</span><span class="nx">COPY_SRC</span>
<span class="p">});</span>
<span class="nx">stagingBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">({</span>
<span class="nx">size</span><span class="o">:</span><span class="w"> </span><span class="kt">4</span><span class="o">*</span><span class="nx">intervals</span><span class="p">,</span>
<span class="nx">usage</span><span class="o">:</span><span class="w"> </span><span class="kt">GPUBufferUsage.MAP_READ</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">GPUBufferUsage</span><span class="p">.</span><span class="nx">COPY_DST</span>
<span class="p">});</span>
</code></pre></div>
<p>The <abbr title="A stage in a GPU pipeline that does purely computational work, rather than participating directly in graphical rendering.">compute shader</abbr> outputs to buffer, then the buffer is copied to stagingBuffer. You might wonder why we don't just add MAP_READ usage to the <abbr title="In WebGPU, a general purpose buffer on the GPU, which can be used in compute shaders as well as in vertex and fragment shaders.">storage buffer</abbr>. But MAP_READ can only be combined with COPY_DST. Storage buffers are meant to live in <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> memory; staging buffers are meant to live in shared memory. So, in general, a buffer can't be both.</p>
<p>After the compute job is submitted to the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>, the output won't be available until the job has been completed. <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> must wait for that to happen before mapping the staging buffer. This type of synchroniztion is handled in <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> using <abbr title="在 JavaScript 编程中，一个承诺代表一个可能立即可用或将来某个时候可用的结果。程序员可以提供一个函数，如果承诺实现（即结果可用时）或承诺被拒绝（例如，如果发生某些错误）时被调用。承诺是异步的，因为处理成功或失败的函数将在某个不可预测的时间被调用。">promises</abbr> (<a href="../../a1/s4/">Section A.4</a>). A staging buffer is mapped using the method mapAsync(), which returns a promise. The promise resolves when the buffer is ready to be mapped. mapAsync() is typically called using await. For example, in the sample program,</p>
<div class="highlight"><pre><span></span><code><span class="k">await</span><span class="w"> </span><span class="nx">stagingBuffer</span><span class="p">.</span><span class="nx">mapAsync</span><span class="p">(</span><span class="nx">GPUMapMode</span><span class="p">.</span><span class="nx">READ</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">intervals</span><span class="o">*</span><span class="mf">4</span><span class="p">);</span>
</code></pre></div>
<p>The first parameter can be either GPUMapMode.READ or GPUMapMode.WRITE. The other two parameters specify the starting point and size, in bytes, of the region in the buffer to be mapped.</p>
<p>Once the mapping is ready, the staging buffer method getMappedRange() can be used to view all or part of the mapped region as an <strong><em>ArrayBuffer</em></strong>. An <strong><em>ArrayBuffer</em></strong> is just a container for bytes. In the sample program, those bytes are actually an array of floats. To access the data as an array of floats, we can wrap the <strong><em>ArrayBuffer</em></strong> in a <strong><em>Float32Array</em></strong>. The sample program does that and then addes up the numbers in the array to get a final answer. Both sides of the computation are done in the following function:</p>
<div class="highlight"><pre><span></span><code><span class="k">async</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">compute</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>

<span class="cm">/* Run the compute shader and copy the output to the staging buffer. */</span>

<span class="kd">let</span><span class="w"> </span><span class="nx">commandEncoder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">device</span><span class="p">.</span><span class="nx">createCommandEncoder</span><span class="p">();</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">passEncoder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">commandEncoder</span><span class="p">.</span><span class="nx">beginComputePass</span><span class="p">();</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">setPipeline</span><span class="p">(</span><span class="nx">pipeline</span><span class="p">);</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">setBindGroup</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">bindGroup</span><span class="p">);</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">dispatchWorkgroups</span><span class="p">(</span><span class="w"> </span><span class="nb">Math</span><span class="p">.</span><span class="nx">ceil</span><span class="p">(</span><span class="nx">intervals</span><span class="o">/</span><span class="mf">64</span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="nx">passEncoder</span><span class="p">.</span><span class="nx">end</span><span class="p">();</span>
<span class="nx">commandEncoder</span><span class="p">.</span><span class="nx">copyBufferToBuffer</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">stagingBuffer</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">intervals</span><span class="o">*</span><span class="mf">4</span><span class="p">);</span>
<span class="nx">device</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">submit</span><span class="p">([</span><span class="nx">commandEncoder</span><span class="p">.</span><span class="nx">finish</span><span class="p">()]);</span>

<span class="cm">/* Map staging buffer, interpret it as a Float32Array, and find the sum. */</span>

<span class="k">await</span><span class="w"> </span><span class="nx">stagingBuffer</span><span class="p">.</span><span class="nx">mapAsync</span><span class="p">(</span><span class="nx">GPUMapMode</span><span class="p">.</span><span class="nx">READ</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">intervals</span><span class="o">*</span><span class="mf">4</span><span class="p">);</span>

<span class="kd">let</span><span class="w"> </span><span class="nx">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Float32Array</span><span class="p">(</span><span class="nx">stagingBuffer</span><span class="p">.</span><span class="nx">getMappedRange</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="nx">intervals</span><span class="o">*</span><span class="mf">4</span><span class="p">));</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">data</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">sum</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/* Unmap the staging buffer, and return the sum. */</span>

<span class="nx">stagingBuffer</span><span class="p">.</span><span class="nx">unmap</span><span class="p">();</span>

<span class="k">return</span><span class="w"> </span><span class="nx">sum</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Note in particular the use of <code>stagingBuffer.unmap()</code> at the end. The buffer must be unmapped before it can be reused by the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>. If processing the data will take a nontrivial amount of time, it is a good idea to make a copy of the data and unmap the buffer before doing the processing.</p>
<p>It is also possible to map a buffer for writing, to provide input to the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>. The staging buffer would be created with MAP_WRITE and COPY_DST usage. <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> would map the buffer for writing, copy data into the mapped buffer, and unmap the buffer. It could then submit a <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> job that includes copying the data from the staging buffer into <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> memory. We have been using <code>device.writeBuffer()</code> to copy data from <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> into <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> memory. That function could complete its task using a staging buffer (although how it actually works is not part of the <abbr title="一种新的 JavaScript 图形 API，类似于 WebGL，但设计用于让网络程序访问现代 GPU 功能，如计算着色器。">WebGPU</abbr> specification).</p>
<hr />
<p>To add some interest to the program, I added an implementation of an important parallel algorithm called "reduce." In the computation discussed above, an array is copied to the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side of the program. The array is added up there using a loop, an operation that takes N steps for an array of size N. The same numbers can be added in the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> using reduce, with on the order of log2(N) steps. The basic idea is to add each number in the second half of the array to a partner in the first half. In pseudocode, for an array A of length N,</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">N</span><span class="o">/</span><span class="mf">2</span><span class="p">;</span><span class="w"> </span><span class="nx">index</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="nx">A</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">A</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">A</span><span class="p">[</span><span class="nx">index</span><span class="o">+</span><span class="nx">N</span><span class="o">/</span><span class="mf">2</span><span class="p">]</span>
</code></pre></div>
<p>This loop can be replaced by one application of a simple <abbr title="A stage in a GPU pipeline that does purely computational work, rather than participating directly in graphical rendering.">compute shader</abbr>. The result is that the sum of the numbers in the original array is equal to the sum of the numbers in the first N/2 elements of the modified array. Now, consider those N/2 elements to be a new, shorter array, and apply the same process, so that the original sum is now concentrated into N/4 elements. Continue like that until the original sum is concentrated into the single element A[0]. At that point, the <abbr title="A stage in a GPU pipeline that does purely computational work, rather than participating directly in graphical rendering.">compute shader</abbr> has been applied just log2(N) times.</p>
<p>Now, all this really works as stated only if the size of the array is a power of two. Things are a little more complicated if at any point you have to work with an array whose length is an odd number. However, the sample program handles that case as well, and you can look at the source code to see how its done.</p>
</div>
</div>
</div>







  
    
  
  
    
  


  <aside class="md-source-file">
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="最后更新">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1-2.1-2M12.5 7v5.2l4 2.4-1 1L11 13V7h1.5M11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2v1.8Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">2024年7月6日</span>
  </span>

    
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="创建日期">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.47 15.08 11 13V7h1.5v5.25l3.08 1.83c-.41.28-.79.62-1.11 1m-1.39 4.84c-.36.05-.71.08-1.08.08-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8c0 .37-.03.72-.08 1.08.69.1 1.33.32 1.92.64.1-.56.16-1.13.16-1.72 0-5.5-4.5-10-10-10S2 6.5 2 12s4.47 10 10 10c.59 0 1.16-.06 1.72-.16-.32-.59-.54-1.23-.64-1.92M18 15v3h-3v2h3v3h2v-3h3v-2h-3v-3h-2Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">2024年5月26日</span>
  </span>

    
    
    
  </aside>





                
              </article>
            </div>
          
          
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var tab,labels=set.querySelector(".tabbed-labels");for(tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script>

<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../../..", "features": ["content.code.copy", "content.tabs.link", "navigation.tabs", "navigation.tabs.sticky", "navigation.indexes", "navigation.top", "toc.follow", "content.tooltips"], "search": "../../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.fe8b6f2b.min.js"></script>
      
        <script src="../../../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="https://unpkg.com/mermaid@9.4.0/dist/mermaid.min.js"></script>
      
    
  <script id="init-glightbox">const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});
document$.subscribe(() => { lightbox.reload() });
</script></body>
</html>