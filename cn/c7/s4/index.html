
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="计算机图形学概论(graphicsbook)">
      
      
      
        <link rel="canonical" href="https://hellowac.github.io/graphicsbook-zh-cn/cn/c7/s4/">
      
      
        <link rel="prev" href="../s3/">
      
      
        <link rel="next" href="../s5/">
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.0, mkdocs-material-9.5.28">
    
    
      
        <title>7.4 帧缓冲区 - 计算机图形学概论</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.6543a935.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.06af60db.min.css">
      
      

  
  
  
  
  <style>:root{--md-annotation-icon:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M22 12a10 10 0 0 1-10 10A10 10 0 0 1 2 12 10 10 0 0 1 12 2a10 10 0 0 1 10 10M6 13h8l-3.5 3.5 1.42 1.42L17.84 12l-5.92-5.92L10.5 7.5 14 11H6v2Z"/></svg>');}</style>


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
   <link href="../../../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
    html.glightbox-open { overflow: initial; height: 100%; }
    .gslide-title { margin-top: 0px; user-select: text; }
    .gslide-desc { color: #666; user-select: text; }
    .gslide-image img { background: white; }
    .gscrollbar-fixer { padding-right: 15px; }
    .gdesc-inner { font-size: 0.75rem; }
    body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
    body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
    body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}</style> <script src="../../../assets/javascripts/glightbox.min.js"></script></head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="default" data-md-color-accent="red">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#74-帧缓冲区" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="计算机图形学概论" class="md-header__button md-logo" aria-label="计算机图形学概论" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            计算机图形学概论
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              7.4 帧缓冲区
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
      <div class="md-header__option">
  <div class="md-select">
    
    <button class="md-header__button md-icon" aria-label="选择当前语言">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m12.87 15.07-2.54-2.51.03-.03A17.52 17.52 0 0 0 14.07 6H17V4h-7V2H8v2H1v2h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04M18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12m-2.62 7 1.62-4.33L19.12 17h-3.24Z"/></svg>
    </button>
    <div class="md-select__inner">
      <ul class="md-select__list">
        
          <li class="md-select__item">
            <a href="/graphicsbook-zh-cn/en/" hreflang="en" class="md-select__link">
              English
            </a>
          </li>
        
          <li class="md-select__item">
            <a href="/graphicsbook-zh-cn/cn/" hreflang="cn" class="md-select__link">
              中文
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</div>
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/hellowac/graphicsbook-zh-cn" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    graphicsbook
  </div>
</a>
      </div>
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../" class="md-tabs__link">
        
  
    
  
  首页

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../preface/" class="md-tabs__link">
        
  
    
  
  前言

      </a>
    </li>
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c1/" class="md-tabs__link">
          
  
    
  
  1.简介

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c2/" class="md-tabs__link">
          
  
    
  
  2.二维图形

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c3/" class="md-tabs__link">
          
  
    
  
  3.几何

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c4/" class="md-tabs__link">
          
  
    
  
  4.灯光和材质

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c5/" class="md-tabs__link">
          
  
    
  
  5.three.js

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c6/" class="md-tabs__link">
          
  
    
  
  6.WebGL

        </a>
      </li>
    
  

      
        
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../" class="md-tabs__link">
          
  
    
  
  7.WebGL 3D

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c8/" class="md-tabs__link">
          
  
    
  
  8.高阶3D

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c9/" class="md-tabs__link">
          
  
    
  
  9.WEBGPU

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../a1/" class="md-tabs__link">
          
  
    
  
  附录A

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../a2/" class="md-tabs__link">
          
  
    
  
  附录B

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../a3/" class="md-tabs__link">
          
  
    
  
  附录C

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../source/" class="md-tabs__link">
          
  
    
  
  附录D

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../glossary/" class="md-tabs__link">
          
  
    
  
  术语表

        </a>
      </li>
    
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../.." class="md-tabs__link">
        
  
    
  
  关于

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="计算机图形学概论" class="md-nav__button md-logo" aria-label="计算机图形学概论" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    计算机图形学概论
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/hellowac/graphicsbook-zh-cn" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    graphicsbook
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    首页
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../preface/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    前言
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c1/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    1.简介
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_3" id="__nav_3_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            1.简介
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 1 节 绘画与绘图
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 2 节：三维(3D)图形的要素
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 3 节：硬件与软件
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c2/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    2.二维图形
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_4" id="__nav_4_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            2.二维图形
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第1节: 像素、坐标和颜色
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第2节: 形状
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第3节: 变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第4节: 分层建模
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第5节: Java 绘制2D
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第6节: HTML Canvas图形
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第7节: SVG：一种场景描述语言
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c3/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    3.几何
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_5" id="__nav_5_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            3.几何
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.1 OpenGL 1.1 中的形状和颜色
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.2 3D 坐标和变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.3 投影与观看
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.4 多边形网格和 glDrawArrays
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.5 部分线性代数基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.6 使用 GLUT 和 JOGL
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c4/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    4.灯光和材质
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_6" id="__nav_6_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6">
            <span class="md-nav__icon md-icon"></span>
            4.灯光和材质
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.1 照明简介
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.2 OpenGL 1.1 中的光和材质
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.3 图像纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.4 灯光、相机、动作
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c5/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    5.three.js
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_7" id="__nav_7_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7">
            <span class="md-nav__icon md-icon"></span>
            5.three.js
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.1 Three.js 基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.2 构建对象
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.3 其他功能
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c6/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    6.WebGL
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_8" id="__nav_8_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8">
            <span class="md-nav__icon md-icon"></span>
            6.WebGL
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.1 可编程流水线
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.2 第一个例子
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.3 GLSL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.4 图像纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.5 实现 2D 变换
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" checked>
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    7.WebGL 3D
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_9" id="__nav_9_label" tabindex="">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_9">
            <span class="md-nav__icon md-icon"></span>
            7.WebGL 3D
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.1 3D变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.2 照明和材质
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.3 纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    7.4 帧缓冲区
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    7.4 帧缓冲区
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#741-帧缓冲区操作" class="md-nav__link">
    <span class="md-ellipsis">
      7.4.1 帧缓冲区操作
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#742-渲染到纹理" class="md-nav__link">
    <span class="md-ellipsis">
      7.4.2 渲染到纹理
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#743-渲染缓冲区" class="md-nav__link">
    <span class="md-ellipsis">
      7.4.3 渲染缓冲区
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#744-动态立方体贴图纹理" class="md-nav__link">
    <span class="md-ellipsis">
      7.4.4 动态立方体贴图纹理
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.5 WebGL 扩展
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c8/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    8.高阶3D
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_10" id="__nav_10_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_10_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10">
            <span class="md-nav__icon md-icon"></span>
            8.高阶3D
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c8/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8.1 光线追踪
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c8/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8.2 路径追踪
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_11" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c9/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    9.WEBGPU
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_11" id="__nav_11_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_11_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_11">
            <span class="md-nav__icon md-icon"></span>
            9.WEBGPU
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.1 WebGPU 基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.2 实例和索引
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.3 WGSL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.4 WebGPU 中的 3D 图形
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.5 纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.6 计算着色器
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.7 细节
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_12" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../a1/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    附录A
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_12" id="__nav_12_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_12_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_12">
            <span class="md-nav__icon md-icon"></span>
            附录A
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a1/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    A.1 Java 编程语言
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a1/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    A.2 C 编程语言
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a1/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    A.3 JavaScript 编程语言
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a1/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    A.4 JavaScript Promise 和异步函数
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_13" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../a2/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    附录B
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_13" id="__nav_13_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_13_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_13">
            <span class="md-nav__icon md-icon"></span>
            附录B
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a2/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    B.1 节 Blender 基础知识
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a2/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    B.2 节 Blender 建模
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a2/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    B.3 节 Blender 动画
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a2/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    B.4 节 有关光和材料的更多信息
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_14" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../a3/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    附录C
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_14" id="__nav_14_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_14_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_14">
            <span class="md-nav__icon md-icon"></span>
            附录C
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a3/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C.1 节 Gimp：2D 绘画程序
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_15" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../source/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    附录D
  </span>
  

            </a>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_15_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_15">
            <span class="md-nav__icon md-icon"></span>
            附录D
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_16" >
        
          
          <label class="md-nav__link" for="__nav_16" id="__nav_16_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    术语表
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_16_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_16">
            <span class="md-nav__icon md-icon"></span>
            术语表
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../glossary/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    术语表
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    关于
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#741-帧缓冲区操作" class="md-nav__link">
    <span class="md-ellipsis">
      7.4.1 帧缓冲区操作
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#742-渲染到纹理" class="md-nav__link">
    <span class="md-ellipsis">
      7.4.2 渲染到纹理
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#743-渲染缓冲区" class="md-nav__link">
    <span class="md-ellipsis">
      7.4.3 渲染缓冲区
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#744-动态立方体贴图纹理" class="md-nav__link">
    <span class="md-ellipsis">
      7.4.4 动态立方体贴图纹理
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="74-帧缓冲区">7.4 <abbr title="在WebGL中，一个组织渲染图像缓冲区的数据结构，可能包括颜色缓冲区、深度缓冲区和模板缓冲区。WebGL图形上下文有一个用于屏幕渲染的默认帧缓冲区，并且可以为离屏渲染创建额外的帧缓冲区。">帧缓冲区</abbr><a class="headerlink" href="#74-帧缓冲区" title="Permanent link">&para;</a></h1>
<p><strong>Framebuffers</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="1:2"><input checked="checked" id="__tabbed_1_1" name="__tabbed_1" type="radio" /><input id="__tabbed_1_2" name="__tabbed_1" type="radio" /><div class="tabbed-labels"><label for="__tabbed_1_1">中文</label><label for="__tabbed_1_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>"<abbr title="在WebGL中，一个组织渲染图像缓冲区的数据结构，可能包括颜色缓冲区、深度缓冲区和模板缓冲区。WebGL图形上下文有一个用于屏幕渲染的默认帧缓冲区，并且可以为离屏渲染创建额外的帧缓冲区。">帧缓冲区</abbr>"这个术语传统上指的是内存中的一个区域，它保存了在计算机屏幕上显示的图像的颜色数据。在 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 中，一个 <strong><abbr title="在WebGL中，一个组织渲染图像缓冲区的数据结构，可能包括颜色缓冲区、深度缓冲区和模板缓冲区。WebGL图形上下文有一个用于屏幕渲染的默认帧缓冲区，并且可以为离屏渲染创建额外的帧缓冲区。">帧缓冲区</abbr></strong> 是一个数据结构，它组织了渲染图像所需的内存资源。<abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 图形上下文有一个默认的帧缓冲区，用于屏幕上出现的图像。默认帧缓冲区是由创建图形上下文的 canvas.getContext() 调用创建的。它的属性取决于传递给该函数的选项，并且在创建后不能更改。然而，可以创建额外的帧缓冲区，其属性由 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 程序控制。它们可以用于离屏渲染，并且对于某些高级渲染算法是必需的。</p>
<p>帧缓冲区可以使用颜色缓冲区来保存图像的颜色数据，使用深度缓冲区来保存每个像素的深度值，以及使用所谓的模板缓冲区（本教科书中不涉及）。这些缓冲区被称为“附加”到帧缓冲区。对于非默认帧缓冲区，<abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 程序可以随时附加和分离缓冲区。帧缓冲区不需要完整的三套缓冲区，但你需要一个颜色缓冲区、深度缓冲区或两者兼有才能使用帧缓冲区进行渲染。如果在渲染到帧缓冲区时没有启用深度测试，那么不需要深度缓冲区。一些渲染算法，如阴影映射(<a href="../../c5/s3/#533-阴影">5.3.3小节</a>)，使用一个只有深度缓冲区而没有颜色缓冲区的帧缓冲区。在 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 中，还可以将多个颜色缓冲区附加到同一个帧缓冲区，这对于某些高级算法和计算应用非常有用。（另见<a href="../s5/#754-延迟着色">7.5.4小节</a>。）</p>
<p>渲染函数 gl.drawArrays() 和 gl.drawElements() 会影响当前帧缓冲区，最初是默认帧缓冲区。当前帧缓冲区可以通过调用以下代码更改：</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">bindFramebuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAMEBUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">frameBufferObject</span><span class="p">);</span>
</code></pre></div>
<p>这个函数的第一个参数始终是 gl.FRAMEBUFFER。第二个参数可以是 null，以选择默认帧缓冲区进行绘制，或者是通过函数 gl.createFramebuffer() 创建的非默认帧缓冲区，下面将讨论这个函数。</p>
</div>
<div class="tabbed-block">
<p>The term "<abbr title="A region of memory that contains color data for a digital image. Most often refers to the memory containing the image that appears on the computer's screen.">frame buffer</abbr>" traditionally refers to the region of memory that holds the color data for the image displayed on a computer screen. In <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>, a <strong><abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr></strong> is a data structure that organizes the memory resources that are needed to render an image. A <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> graphics context has a default <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr>, which is used for the image that appears on the screen. The default <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr> is created by the call to canvas.getContext() that creates the graphics context. Its properties depend on the options that are passed to that function and cannot be changed after it is created. However, additional framebuffers can be created, with properties controlled by the <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> program. They can be used for off-screen <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr>, and they are required for certain advanced <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> algorithms.</p>
<p>A <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr> can use a <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr> to hold the color data for an image, a <abbr title="A region of memory that stores the information needed for the depth test in 3D graphics, that is, a depth value for each pixel in the image. Also called the &quot;z-buffer.&quot;">depth buffer</abbr> to hold a depth value for each <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>, and something called a stencil buffer (which is not covered in this textbook). The buffers are said to be "attached" to the <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr>. For a non-default <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr>, buffers can be attached and detached by the <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> program at any time. A <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr> doesn't need a full set of three buffers, but you need a <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr>, a <abbr title="A region of memory that stores the information needed for the depth test in 3D graphics, that is, a depth value for each pixel in the image. Also called the &quot;z-buffer.&quot;">depth buffer</abbr>, or both to be able to use the <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr> for <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr>. If the <abbr title="A solution to the hidden surface problem that involves keeping track of the depth, or distance from the viewer, of the object currently visible at each pixel in the image. When a new object is drawn at a pixel, the depth of the new object is compared to the depth of the current object to decide which one is closer to the viewer. The advantage of the depth test is that objects can be rendered in any order. A disadvantage is that only a limited range of depths can be represented in the image.">depth test</abbr> is not enabled when <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> to the <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr>, then no <abbr title="A region of memory that stores the information needed for the depth test in 3D graphics, that is, a depth value for each pixel in the image. Also called the &quot;z-buffer.&quot;">depth buffer</abbr> is needed. And some <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> algorithms, such as <abbr title="A technique for determining which parts of a scene are illuminated and which are in shadow from a given light source. The technique involves rendering the scene from the point of the view of the light source, but uses only the depth buffer from that rendering. The depth buffer is the &quot;shadow map.&quot; Along a given direction from the light source, the object that is illuminated by the light is the one that is closest to the light. The distance to that object is essentially encoded in the depth buffer. Objects at greater distance are in shadow.">shadow mapping</abbr> (<a href="../../c5/s3/#533-阴影">Subsection 5.3.3</a>) use a <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr> with a <abbr title="A region of memory that stores the information needed for the depth test in 3D graphics, that is, a depth value for each pixel in the image. Also called the &quot;z-buffer.&quot;">depth buffer</abbr> but no <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr>. In <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0, it is also possible to attach several color buffers to the same <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr>, which can be useful for certain advanced algorithms and computational applications. (Also, see <a href="../s5/#754-延迟着色">Subsection 7.5.4</a>.)</p>
<p>The <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> functions gl.drawArrays() and gl.drawElements() affect the current <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr>, which is initially the default <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr>. The current <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr> can be changed by calling</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">bindFramebuffer</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAMEBUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">frameBufferObject</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>The first parameter to this function is always gl.FRAMEBUFFER. The second parameter can be null to select the default <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr> for drawing, or it can be a non-default <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr> created by the function gl.createFramebuffer(), which will be discussed below.</p>
</div>
</div>
</div>
<h2 id="741-帧缓冲区操作">7.4.1 帧缓冲区操作<a class="headerlink" href="#741-帧缓冲区操作" title="Permanent link">&para;</a></h2>
<p><strong>Framebuffer Operations</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="2:2"><input checked="checked" id="__tabbed_2_1" name="__tabbed_2" type="radio" /><input id="__tabbed_2_2" name="__tabbed_2" type="radio" /><div class="tabbed-labels"><label for="__tabbed_2_1">中文</label><label for="__tabbed_2_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>在我们讨论使用非默认帧缓冲区的示例之前，我们先看看一些影响当前活动帧缓冲区渲染的 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 设置。我们已经看到的例子包括用于填充颜色缓冲区的清除颜色，当调用 gl.clear() 时使用，以及启用深度测试的状态。</p>
<p>另一个影响深度缓冲区使用的例子是 <strong><abbr title="在WebGL中，一个设置，控制是否在渲染期间将深度值写入深度缓冲区。当深度掩码设置为false时，深度值将被丢弃，深度缓冲区保持不变。">深度掩码</abbr></strong>，这是一个布尔值，控制是否在渲染期间向深度缓冲区写入值。（深度测试的启用状态决定是否在渲染期间 <strong>使用</strong> 深度缓冲区中的值；深度掩码决定是否向深度缓冲区 <strong>写入</strong> 新值。）可以使用以下命令关闭向深度缓冲区写入：</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">depthMask</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
</code></pre></div>
<p>通过调用 <code>gl.depthMask(true)</code> 可以重新打开写入。默认值是 true。</p>
<p>使用深度掩码的一个例子是渲染半透明几何体。当场景中的一些对象是半透明的时，应该首先渲染所有的不透明对象，然后是半透明对象。假设你先渲染了一个半透明对象，然后又渲染了一个位于半透明对象后面的不透明对象。深度测试会导致不透明对象被半透明对象隐藏。但是“半透明”意味着不透明对象应该能够通过半透明对象看到。因此，首先渲染所有不透明对象非常重要。在渲染半透明对象时，通过调用 <code>gl.depthMask(false)</code> 关闭向深度缓冲区写入也很重要。原因是一个在另一个半透明对象后面绘制的半透明对象应该能够通过前面的对象看到。但请注意，在渲染半透明对象时，深度测试仍然必须启用，因为半透明对象可能被不透明对象隐藏。此外，在渲染半透明对象时，必须启用 <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> 混合。</p>
<p>要正确渲染半透明对象，应该在渲染之前将半透明原语按从后到前的顺序排序，如画家算法 (<a href="../../c3/s1/#314-深度测试">3.1.4小节</a>) 中所述。然而，这可能难以实现，有时可以通过按任意顺序（但仍在不透明原语之后）渲染半透明原语获得可接受的结果。实际上，这在演示 <a href="../../../en/demos/c3/rotation-axis.html">c3/<abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr>-axis.html</a> 从 <a href="../../c3/s2/#322-基本-3d-变换">3.2.2小节</a> 和 <a href="../../../en/demos/c3/transform-equivalence-3d.html">c3/transform-equivalence-3d.html</a> 从 <a href="../../c3/s3/#334-模型视图转换">3.3.4小节</a> 中就是这样做的。</p>
<hr />
<p>也可以使用 <strong><abbr title="在WebGL中，一种设置，用于确定在渲染期间颜色缓冲区的哪些“通道”被写入。这些通道是颜色的RGBA组成部分：红色、绿色、蓝色和alpha。颜色掩码由四个布尔值组成，每个通道一个。一个false值会阻止对颜色缓冲区中相应颜色分量的任何更改。">颜色掩码</abbr></strong> 控制向颜色缓冲区的写入。颜色缓冲区有四个“通道”，分别对应颜色的红色、绿色、蓝色和 <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> 分量。每个通道可以单独控制。例如，你可以允许向红色和 <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> 颜色通道写入，同时阻止向绿色和蓝色通道写入。这可以通过以下命令完成：</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">colorMask</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">);</span>
</code></pre></div>
<p><code>gl.colorMask</code> 函数接受四个参数，每个颜色通道一个。true 值允许向通道写入；false 值阻止写入。在渲染期间，如果某个通道的写入被阻止，相应颜色分量的值将被忽略。</p>
<p>使用颜色掩码的一个用途是用于红蓝立体渲染 (<a href="../../c5/s3/#531-实例化网格">5.3.1小节</a>)。红蓝立体图像包含场景的两张图像，一张用于左眼，一张用于右眼。一张图像仅使用红色阴影绘制，而另一张仅使用绿色和蓝色的组合。两张图像从略微不同的视点绘制，对应于左眼和右眼的视图。因此，红蓝立体的算法形式如下：</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">clearColor</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">clear</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">COLOR_BUFFER_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">DEPTH_BUFFER_BIT</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">colorMask</span><span class="p">(</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// 仅向红色通道写入</span>
<span class="p">...</span><span class="w"> </span><span class="c1">// 设置左眼的视图</span>
<span class="p">...</span><span class="w"> </span><span class="c1">// 渲染场景</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">clear</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">DEPTH_BUFFER_BIT</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// 仅清除深度缓冲区</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">colorMask</span><span class="p">(</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="p">);</span><span class="w">  </span><span class="c1">// 向绿色和蓝色通道写入</span>
<span class="p">...</span><span class="w"> </span><span class="c1">// 设置右眼的视图</span>
<span class="p">...</span><span class="w"> </span><span class="c1">// 渲染场景</span>
</code></pre></div>
<p>设置左眼和右眼视图的一种方法是简单地围绕 y 轴旋转几度。请注意，在绘制第二张图像之前，必须清除深度缓冲区而不是颜色缓冲区，因为否则深度测试将阻止第二张图像的某些部分被写入。</p>
<hr />
<p>最后，我想更详细地看看混合（Blending）。混合指的是片段着色器中的片段颜色与颜色缓冲区中片段的当前颜色如何结合。默认情况下，假设片段通过了深度测试，是用片段颜色替换当前颜色。当启用混合时，当前颜色可以被替换为当前颜色和片段颜色的某种组合。之前，我只讨论了使用以下命令启用用于透明度的 <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> 混合：</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">enable</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">BLEND</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">blendFunc</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">SRC_ALPHA</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">ONE_MINUS_SRC_ALPHA</span><span class="p">);</span>
</code></pre></div>
<p><code>gl.blendFunc()</code> 函数决定了如何从当前颜色和片段颜色计算新颜色。在这里显示的参数下，使用 <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> 语法的公式为新颜色：</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nx">src</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">src</span><span class="p">.</span><span class="nx">a</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="nx">dest</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mf">1</span><span class="o">-</span><span class="nx">src</span><span class="p">.</span><span class="nx">a</span><span class="p">))</span>
</code></pre></div>
<p>其中 <em>src</em> 是“源”颜色（即正在写入的颜色，片段颜色），<em>dest</em> 是“目标”颜色（即当前在颜色缓冲区中的颜色，是渲染操作的目标）。<em>src.a</em> 是源颜色的 <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> 分量。<code>gl.blendFunc()</code> 的参数决定了公式中的系数 —— <em>src.a</em> 和 (1−<em>src.a</em>)。混合函数的默认系数由以下给出：</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">blendFunc</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ONE</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">ZERO</span><span class="p">);</span>
</code></pre></div>
<p>这指定了公式：</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nx">src</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="nx">dest</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span>
</code></pre></div>
<p>也就是说，新颜色等于源颜色；没有混合。</p>
<p>请注意，混合同时适用于颜色的 <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> 分量和 RGB 分量，这可能不是你想要的。当使用半透明颜色绘制时，意味着写入颜色缓冲区的颜色将有一个小于 1 的 <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> 分量。当在网页上的画布上渲染时，这将使画布本身半透明，允许画布的背景透过。（这假设 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 上下文是使用 <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> 通道创建的，这是默认设置。）为了避免这种情况，你可以使用替代命令设置混合函数：</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">blendFuncSeparate</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">SRC_ALPHA</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">ONE_MINUS_SRC_ALPHA</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">ZERO</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">ONE</span><span class="p">);</span>
</code></pre></div>
<p>两个额外的参数指定了用于公式中 <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> 分量的独立系数，而前两个参数仅用于 RGB 分量。也就是说，使用以下公式计算颜色缓冲区的新颜色：</p>
<div class="highlight"><pre><span></span><code><span class="nx">vec4</span><span class="p">((</span><span class="nx">src</span><span class="p">.</span><span class="nx">rgb</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">src</span><span class="p">.</span><span class="nx">a</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="nx">dest</span><span class="p">.</span><span class="nx">rgb</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mf">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">src</span><span class="p">.</span><span class="nx">a</span><span class="p">)),</span><span class="w"> </span><span class="nx">src</span><span class="p">.</span><span class="nx">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">dest</span><span class="p">.</span><span class="nx">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1</span><span class="p">);</span>
</code></pre></div>
<p>使用这个公式，目标（<abbr title="在OpenGL中，保存图像颜色数据的内存区域。它充当了绘制表面，用于渲染图像。">颜色缓冲区</abbr>）中的 <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> 分量保持其原始值不变。</p>
<p>由 <code>gl.blendFunc(gl.ONE,gl.ONE)</code> 设置的混合函数有时可以用于 <strong><abbr title="一种渲染算法，它多次绘制场景，并以某种方式组合结果来计算最终图像。一个简单的例子是红蓝立体图像，其中场景的左眼和右眼图像分别被渲染并组合。">多遍算法</abbr></strong>。在多遍算法中，场景被渲染多次，结果以某种方式组合以产生最终图像。（红蓝立体渲染是一个例子。）如果你想简单地将各个遍历的结果加起来，那么你可以填充颜色缓冲区为零，启用混合，并在渲染期间将混合函数设置为 (<em>gl.ONE,gl.ONE</em>)。</p>
<p>作为一个简单的例子，示例程序 <a href="../../../en/source/webgl/image-blur.html">webgl/image-blur.html</a> 使用多遍算法来实现模糊效果。示例中的场景只是一个应用到矩形的纹理图像，所以效果是模糊纹理图像。该技术涉及将场景绘制九次。在片段着色器中，颜色被除以九。混合用于将九次遍历的片段颜色相加，以便颜色缓冲区中的最终颜色是九次遍历的颜色平均值。对于九次中的八次，场景从原始位置稍微偏移，以便最终图像中像素的颜色是该像素以及原始场景中周围像素的颜色的平均值。</p>
</div>
<div class="tabbed-block">
<p>Before we get to examples of using non-default framebuffers, we look at some <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> settings that affect <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> into whichever <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr> is current. Examples that we have already seen include the clear color, which is used to fill the <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr> when gl.clear() is called, and the enabled state of the <abbr title="A solution to the hidden surface problem that involves keeping track of the depth, or distance from the viewer, of the object currently visible at each pixel in the image. When a new object is drawn at a pixel, the depth of the new object is compared to the depth of the current object to decide which one is closer to the viewer. The advantage of the depth test is that objects can be rendered in any order. A disadvantage is that only a limited range of depths can be represented in the image.">depth test</abbr>.</p>
<p>Another example that affects the use of the <abbr title="A region of memory that stores the information needed for the depth test in 3D graphics, that is, a depth value for each pixel in the image. Also called the &quot;z-buffer.&quot;">depth buffer</abbr> is the <strong><abbr title="In WebGL, a setting that controls whether depth values are written to the depth buffer during rendering. When the depth mask is set to false, the depth value is discarded and the depth buffer is unchanged.">depth mask</abbr></strong>, a boolean value that controls whether values are written to the <abbr title="A region of memory that stores the information needed for the depth test in 3D graphics, that is, a depth value for each pixel in the image. Also called the &quot;z-buffer.&quot;">depth buffer</abbr> during <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr>. (The enabled state of the <abbr title="A solution to the hidden surface problem that involves keeping track of the depth, or distance from the viewer, of the object currently visible at each pixel in the image. When a new object is drawn at a pixel, the depth of the new object is compared to the depth of the current object to decide which one is closer to the viewer. The advantage of the depth test is that objects can be rendered in any order. A disadvantage is that only a limited range of depths can be represented in the image.">depth test</abbr> determines whether values from the <abbr title="A region of memory that stores the information needed for the depth test in 3D graphics, that is, a depth value for each pixel in the image. Also called the &quot;z-buffer.&quot;">depth buffer</abbr> are <strong>used</strong> during <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr>; the <abbr title="In WebGL, a setting that controls whether depth values are written to the depth buffer during rendering. When the depth mask is set to false, the depth value is discarded and the depth buffer is unchanged.">depth mask</abbr> determines whether new values are <strong>written</strong> to the <abbr title="A region of memory that stores the information needed for the depth test in 3D graphics, that is, a depth value for each pixel in the image. Also called the &quot;z-buffer.&quot;">depth buffer</abbr>.) Writing to the <abbr title="A region of memory that stores the information needed for the depth test in 3D graphics, that is, a depth value for each pixel in the image. Also called the &quot;z-buffer.&quot;">depth buffer</abbr> can be turned off with the command</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">depthMask</span><span class="p">(</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>and can be turned back on by calling <em>gl.depthMask(true)</em>. The default value is true.</p>
<p>One example of using the <abbr title="In WebGL, a setting that controls whether depth values are written to the depth buffer during rendering. When the depth mask is set to false, the depth value is discarded and the depth buffer is unchanged.">depth mask</abbr> is for <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> translucent geometry. When some of the objects in a scene are translucent, then all of the opaque objects should be rendered first, followed by the translucent objects. Suppose that you rendered a translucent object, and then rendered an opaque object that lies behind the translucent object. The <abbr title="A solution to the hidden surface problem that involves keeping track of the depth, or distance from the viewer, of the object currently visible at each pixel in the image. When a new object is drawn at a pixel, the depth of the new object is compared to the depth of the current object to decide which one is closer to the viewer. The advantage of the depth test is that objects can be rendered in any order. A disadvantage is that only a limited range of depths can be represented in the image.">depth test</abbr> would cause the opaque object to be hidden by the translucent object. But "translucent" means that the opaque object should be visible through the translucent object. So it's important to render all the opaque objects first. And it's important to turn off writing to the <abbr title="A region of memory that stores the information needed for the depth test in 3D graphics, that is, a depth value for each pixel in the image. Also called the &quot;z-buffer.&quot;">depth buffer</abbr>, by calling <em>gl.depthMask(false)</em>, while <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> the translucent objects. The reason is that a translucent object that is drawn behind another translucent object should be visible through the front object. Note, however, that the <abbr title="A solution to the hidden surface problem that involves keeping track of the depth, or distance from the viewer, of the object currently visible at each pixel in the image. When a new object is drawn at a pixel, the depth of the new object is compared to the depth of the current object to decide which one is closer to the viewer. The advantage of the depth test is that objects can be rendered in any order. A disadvantage is that only a limited range of depths can be represented in the image.">depth test</abbr> must still be enabled while the translucent objects are being rendered, since a translucent object can be hidden by an opaque object. Also, <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> blending must be on while <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> the translucent objects.</p>
<p>For fully correct <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> of translucent objects, the translucent primitives should be sorted into back-to-front order before <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr>, as in the <abbr title="A solution to the hidden surface algorithm that involves drawing the objects in a scene in order from back to front, that is, in decreasing order of distance from the viewer. A disadvantage is that the order is usually not well-defined unless some objects are decomposed into smaller sub-objects. Another issue is that the order of drawing has to change when objects move or when the point of view changes.">painter's algorithm</abbr> (<a href="../../c3/s1/#314--深度测试">Subsection 3.1.4</a>). However, that can be difficult to implement, and acceptable results can sometimes be obtained by <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> the translucent primitives in arbitrary order (but still after the opaque primitives). In fact that was done in the demos <a href="../../../en/demos/c3/rotation-axis.html">c3/<abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr>-axis.html</a> from <a href="../../c3/s2/#322-基本-3d-变换">Subsection 3.2.2</a> and <a href="../../../en/demos/c3/transform-equivalence-3d.html">c3/transform-equivalence-3d.html</a> from <a href="../../c3/s3/#334-模型视图转换">Subsection 3.3.4</a>.</p>
<hr />
<p>It is also possible to control writing to the <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr>, using the <strong><abbr title="In WebGL, a setting that determines which &quot;channels&quot; in the color buffer are written during rendering. The channels are the RGBA color components red, green, blue, and alpha. A color mask consists of four boolean values, one for each channel. A false value prevents any change from being made to the corresponding color component in the color buffer.">color mask</abbr></strong>. The <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr> has four "channels" corresponding to the red, green, blue, and <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> components of the color. Each channel can be controlled separately. You could, for example, allow writing to the red and <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> color channels, while blocking writing to the green and blue channels. That would be done with the command</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">colorMask</span><span class="p">(</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>The <strong>colorMask</strong> function takes four parameters, one for each color channel. A true value allows writing to the channel; a <em>false</em> value blocks writing. When writing is blocked for a channel during <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr>, the value of the corresponding <abbr title="One of the numbers used in a color model to specify a color. For example, in the RGB color model, a color is specified by three color components representing the amounts of red, green, and blue in the color.">color component</abbr> is simply ignored.</p>
<p>One use of the <abbr title="In WebGL, a setting that determines which &quot;channels&quot; in the color buffer are written during rendering. The channels are the RGBA color components red, green, blue, and alpha. A color mask consists of four boolean values, one for each channel. A false value prevents any change from being made to the corresponding color component in the color buffer.">color mask</abbr> is for <abbr title="A technique for combining stereographic images of a scene, one for the left eye and one for the right eye, into a single image. Typically, the image for the left eye is drawn using only shades of red, and the image for the right eye contains only blue and green color components. The 3D effect can be seen by viewing the combined image through red/cyan glasses, which allow each eye to see only the image that is intended for that eye.">anaglyph stereo</abbr> <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> (<a href="../../c5/s3/#531-实例化网格">Subsection 5.3.1</a>). An <abbr title="A technique for combining stereographic images of a scene, one for the left eye and one for the right eye, into a single image. Typically, the image for the left eye is drawn using only shades of red, and the image for the right eye contains only blue and green color components. The 3D effect can be seen by viewing the combined image through red/cyan glasses, which allow each eye to see only the image that is intended for that eye.">anaglyph stereo</abbr> image contains two images of the scene, one intended for the left eye and one for the right eye. One image is drawn using only shades of red, while the other uses only combinations of green and blue. The two images are drawn from slightly different viewpoints, corresponding to the views from the left and the right eye. So the algorithm for <abbr title="A technique for combining stereographic images of a scene, one for the left eye and one for the right eye, into a single image. Typically, the image for the left eye is drawn using only shades of red, and the image for the right eye contains only blue and green color components. The 3D effect can be seen by viewing the combined image through red/cyan glasses, which allow each eye to see only the image that is intended for that eye.">anaglyph stereo</abbr> has the form</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">clearColor</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">clear</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">COLOR_BUFFER_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">DEPTH_BUFFER_BIT</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">colorMask</span><span class="p">(</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// write to red channel only</span>
<span class="p">...</span><span class="w"> </span><span class="c1">// set up view from left eye</span>
<span class="p">...</span><span class="w"> </span><span class="c1">// render the scene</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">clear</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">DEPTH_BUFFER_BIT</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// clear only the depth buffer</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">colorMask</span><span class="p">(</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="p">);</span><span class="w">  </span><span class="c1">// write to green and blue channels</span>
<span class="p">...</span><span class="w"> </span><span class="c1">// set up view from right eye</span>
<span class="p">...</span><span class="w"> </span><span class="c1">// render the scene</span>
</code></pre></div>
<p>One way to set up the views from the left and right eyes is simply to rotate the view by a few degrees about the y-axis. Note that the <abbr title="A region of memory that stores the information needed for the depth test in 3D graphics, that is, a depth value for each pixel in the image. Also called the &quot;z-buffer.&quot;">depth buffer</abbr>, but not the <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr>, must be cleared before drawing the second image, since otherwise the <abbr title="A solution to the hidden surface problem that involves keeping track of the depth, or distance from the viewer, of the object currently visible at each pixel in the image. When a new object is drawn at a pixel, the depth of the new object is compared to the depth of the current object to decide which one is closer to the viewer. The advantage of the depth test is that objects can be rendered in any order. A disadvantage is that only a limited range of depths can be represented in the image.">depth test</abbr> would prevent some parts of the second image from being written.</p>
<hr />
<p>Finally, I would like to look at blending in more detail. Blending refers to how the fragment color from the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> is combined with the current color of the fragment in the <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr>. The default, assuming that the fragment passes the <abbr title="A solution to the hidden surface problem that involves keeping track of the depth, or distance from the viewer, of the object currently visible at each pixel in the image. When a new object is drawn at a pixel, the depth of the new object is compared to the depth of the current object to decide which one is closer to the viewer. The advantage of the depth test is that objects can be rendered in any order. A disadvantage is that only a limited range of depths can be represented in the image.">depth test</abbr>, is to replace the current color with the fragment color. When blending is enabled, the current color can be replaced with some combination of the current color and the fragment color. Previously, I have only discussed turning on <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> blending for transparency with the commands</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">enable</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">BLEND</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">blendFunc</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">SRC_ALPHA</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">ONE_MINUS_SRC_ALPHA</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>The function <em>gl.blendFunc()</em> determines how the new color is computed from the current color and the fragment color. With the parameters shown here, the formula for the new color, using <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> syntax, is</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nx">src</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">src</span><span class="p">.</span><span class="nx">a</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="nx">dest</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mf">1</span><span class="o">-</span><span class="nx">src</span><span class="p">.</span><span class="nx">a</span><span class="p">))</span>
</code></pre></div>
<p>where <em>src</em> is the "source" color (that is, the color that is being written, the fragment color) and <em>dest</em> is the "destination" color (that is, the color currently in the <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr>, which is the destination of the <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> operation). And <em>src.a</em> is the <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> component of the source color. The parameters to <em>gl.blendFunc()</em> determine the coefficients— <em>src.a</em> and (1−<em>src.a</em>)—in the formula. The default coefficients for the blend function are given by</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">blendFunc</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">ONE</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">ZERO</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>which specifies the formula</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nx">src</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="nx">dest</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span>
</code></pre></div>
<p>That is, the new color is equal to the source color; there is no blending.</p>
<p>Note that blending applies to the <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> component as well as the RGB components of the color, which is probably not what you want. When drawing with a translucent color, it means that the color that is written to the <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr> will have an <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> component less than 1. When <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> to a canvas on a web page, this will make the canvas itself translucent, allowing the background of the canvas to show through. (This assumes that the <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> context was created with an <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> channel, which is the default.) To avoid that, you can set the blend function with the alternative command</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">blendFuncSeparate</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">SRC_ALPHA</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">ONE_MINUS_SRC_ALPHA</span><span class="p">,</span><span class="w"> </span>
<span class="w">                                                    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">ZERO</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">ONE</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>The two extra parameters specify separate coefficients to be used for the <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> component in the formula, while the first two parameters are used only for the RGB components. That is, the new color for the <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr> is computed using the formula</p>
<div class="highlight"><pre><span></span><code><span class="nx">vec4</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="nx">src</span><span class="p">.</span><span class="nx">rgb</span><span class="o">*</span><span class="nx">src</span><span class="p">.</span><span class="nx">a</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="nx">dest</span><span class="p">.</span><span class="nx">rgb</span><span class="o">*</span><span class="p">(</span><span class="mf">1</span><span class="o">-</span><span class="nx">src</span><span class="p">.</span><span class="nx">a</span><span class="p">)),</span><span class="w"> </span><span class="nx">src</span><span class="p">.</span><span class="nx">a</span><span class="o">*</span><span class="mf">0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">dest</span><span class="p">.</span><span class="nx">a</span><span class="o">*</span><span class="mf">1</span><span class="w">  </span><span class="p">);</span>
</code></pre></div>
<p>With this formula, the <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> component in the destination (the <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr>) remains the same as its original value.</p>
<p>The blend function set by <em>gl.blendFunc(gl.ONE,gl.ONE)</em> can sometimes be used in <strong>multi-pass algorithms</strong>. In a <abbr title="A rendering algorithm that draws a scene several times and combines the results somehow to compute the final image. A simple example is anaglyph stereo, in which a left-eye and right-eye image of the scene are rendered separately and combined.">multi-pass algorithm</abbr>, a scene is rendered several times, and the results are combined somehow to produce the final image. (Anaglyph stereo <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> is an example.) If you simply want to add up the results of the various passes, then you can fill the <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr> with zeros, enable blending, and set the blend function to (<em>gl.ONE,gl.ONE</em>) during <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr>.</p>
<p>As a simple example, the sample program <a href="../../../en/source/webgl/image-blur.html">webgl/image-blur.html</a> uses a <abbr title="A rendering algorithm that draws a scene several times and combines the results somehow to compute the final image. A simple example is anaglyph stereo, in which a left-eye and right-eye image of the scene are rendered separately and combined.">multi-pass algorithm</abbr> to implement blurring. The scene in the example is just a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image applied to a rectangle, so the effect is to blur the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image. The technique involves drawing the scene nine times. In the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr>, the color is divided by nine. Blending is used to add the fragment colors from the nine passes, so that the final color in the <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr> is the average of the colors from the nine passes. For eight of the nine passes, the scene is offset slightly from its original position, so that the color of a <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> in the final image is the average of the colors of that <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> and the surrounding <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr> from the original scene.</p>
</div>
</div>
</div>
<h2 id="742-渲染到纹理">7.4.2 <abbr title="一种技术，将渲染操作的输出直接写入纹理。在WebGL中，通过将纹理附加为帧缓冲区的缓冲区之一，可以实现渲染到纹理。">渲染到纹理</abbr><a class="headerlink" href="#742-渲染到纹理" title="Permanent link">&para;</a></h2>
<p><strong>Render To Texture</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="3:2"><input checked="checked" id="__tabbed_3_1" name="__tabbed_3" type="radio" /><input id="__tabbed_3_2" name="__tabbed_3" type="radio" /><div class="tabbed-labels"><label for="__tabbed_3_1">中文</label><label for="__tabbed_3_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>前一节适用于任何帧缓冲区。但我们还没有使用过非默认的帧缓冲区。我们现在转向那个话题。</p>
<p>非默认帧缓冲区的一个用途是直接将内容渲染到纹理中。也就是说，纹理图像所占的内存可以附加到帧缓冲区作为其颜色缓冲区，以便渲染操作将它们的输出发送到纹理图像中。这种技术被称为<strong><abbr title="一种技术，将渲染操作的输出直接写入纹理。在WebGL中，通过将纹理附加为帧缓冲区的缓冲区之一，可以实现渲染到纹理。">渲染到纹理</abbr></strong>，在示例程序 <a href="../../../en/source/webgl/render-to-texture.html">webgl/<abbr title="A technique in which the output of a rendering operation is written directly to a texture. In WebGL, render-to-texture can be implemented by attaching the texture as one of the buffers in a framebuffer.">render-to-texture</abbr>.html</a> 中使用了此技术。</p>
<p>通常在加载图像到纹理时分配纹理内存，使用的函数是 <em>gl.texImage2D</em> 或 <em>gl.copyTexImage2D</em>。（见 <a href="../../c6/s4/#64-图像纹理">第6.4节</a>。）然而，有一个版本的 <em>gl.texImage2D</em> 可以用来在不加载图像到该内存的情况下分配内存。以下是一个示例，来自示例程序：</p>
<div class="highlight"><pre><span></span><code><span class="nx">texture</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createTexture</span><span class="p">();</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bindTexture</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">texture</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">texImage2D</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span><span class="w"> </span><span class="mf">512</span><span class="p">,</span><span class="w"> </span><span class="mf">512</span><span class="p">,</span><span class="w"> </span>
<span class="w">                            </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">UNSIGNED_BYTE</span><span class="p">,</span><span class="w"> </span><span class="kc">null</span><span class="p">);</span>
</code></pre></div>
<p>最后一行的 <em>null</em> 参数告诉 <em>gl.texImage2D</em> 分配新内存，而不加载现有的图像数据来填充该内存。相反，新内存用零填充。<em>gl.texImage2D</em> 的第一个参数是纹理目标。对于普通纹理，目标是 <em>gl.TEXTURE_2D</em>，但其他值用于处理立方体贴图。第四和第五个参数指定图像的高度和宽度；它们应该是2的幂。其他参数通常具有这里显示的值；它们的含义与 <a href="../../c6/s4/#643-更多制作纹理的方法">6.4.3小节</a> 中讨论的 <em>gl.texImage2D</em> 版本相同。请注意，必须首先创建并绑定纹理对象；<em>gl.texImage2D</em> 适用于当前绑定到活动纹理单元的纹理。（在 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 中，也可以使用 <a href="../../c6/s4/#646-webgl-20-中的纹理">6.4.6小节</a> 中讨论的 <em>gl.texStorage2D()</em> 函数来完成相同的操作。）</p>
<p>要将纹理附加到帧缓冲区，你需要创建一个帧缓冲区对象，并通过绑定使其成为当前帧缓冲区。例如，</p>
<div class="highlight"><pre><span></span><code><span class="nx">framebuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createFramebuffer</span><span class="p">();</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bindFramebuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAMEBUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">framebuffer</span><span class="p">);</span>
</code></pre></div>
<p>然后可以使用 <em>gl.framebufferTexture2D</em> 函数将纹理附加到帧缓冲区：</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">framebufferTexture2D</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAMEBUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">COLOR_ATTACHMENT0</span><span class="p">,</span><span class="w"> </span>
<span class="w">                                                </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">texture</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>第一个参数始终是 <em>gl.FRAMEBUFFER</em>。第二个参数表示正在附加颜色缓冲区。<em>gl.COLOR_ATTACHMENT0</em> 中的最后一个字符是零，这允许有多个颜色缓冲区附加到帧缓冲区（尽管在标准 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 中，只允许一个颜色缓冲区）。第三个参数与 <em>gl.texImage2D</em> 中使用的相同的纹理目标，第四个是纹理对象。最后一个参数是 <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmap</abbr> 级别；它通常是零，这意味着渲染到纹理图像本身，而不是其 <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmap</abbr> 图像之一。</p>
<p>有了这个设置，你准备好绑定帧缓冲区并绘制到纹理了。绘制纹理后，调用</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">bindFramebuffer</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAMEBUFFER</span><span class="p">,</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>以重新开始绘制到默认帧缓冲区。此时，纹理已准备好在后续的渲染操作中使用。纹理对象可以绑定到纹理单元，并且在着色器程序中可以使用 <em>sampler2D</em> 变量从纹理中读取。</p>
<p>你很可能会在绘制到纹理和绘制到屏幕上使用不同的着色器程序。回想一下，函数 <em>gl.useProgram()</em> 用于指定着色器程序。</p>
<p>在 <a href="../../../en/source/webgl/render-to-texture.html">示例程序</a> 中，纹理可以动画化。在动画过程中，每个动画帧都会将新图像绘制到纹理中。纹理图像是 2D 的，所以在渲染它时禁用了深度测试。这意味着帧缓冲区不需要深度缓冲区。示例程序中的渲染函数大致形式如下</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span><span class="w"> </span><span class="nx">draw</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="cm">/* 将 2D 图像绘制到附加到帧缓冲区的纹理中。 */</span>

<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">bindFramebuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAMEBUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">framebuffer</span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">useProgram</span><span class="p">(</span><span class="nx">prog_texture</span><span class="p">);</span><span class="w">  </span><span class="c1">// 用于纹理的着色器程序</span>

<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">clearColor</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">clear</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">COLOR_BUFFER_BIT</span><span class="p">);</span><span class="w">  </span><span class="c1">// 将纹理清除为白色</span>

<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">enable</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">BLEND</span><span class="p">);</span><span class="w">  </span><span class="c1">// 在绘制 2D 图像时使用透明度。    </span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">disable</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">DEPTH_TEST</span><span class="p">);</span><span class="w"> </span><span class="c1">// 帧缓冲区甚至没有深度缓冲区！</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">viewport</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">512</span><span class="p">,</span><span class="mf">512</span><span class="p">);</span><span class="w">  </span><span class="c1">// 视口不会自动设置！</span>

<span class="w">    </span><span class="p">.</span>
<span class="w">    </span><span class="p">.</span><span class="w">  </span><span class="c1">// 绘制每个帧都会变化的纹理图像</span>
<span class="w">    </span><span class="p">.</span>

<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">disable</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">BLEND</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 现在使用纹理绘制主场景，它是 3D 的。 */</span>

<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">bindFramebuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAMEBUFFER</span><span class="p">,</span><span class="w"> </span><span class="kc">null</span><span class="p">);</span><span class="w"> </span><span class="c1">// 绘制到默认帧缓冲区。</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">useProgram</span><span class="p">(</span><span class="nx">prog</span><span class="p">);</span><span class="w">  </span><span class="c1">// 用于屏幕上图像的着色器程序</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">clearColor</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">clear</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">COLOR_BUFFER_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">DEPTH_BUFFER_BIT</span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">enable</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">DEPTH_TEST</span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">viewport</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span><span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span><span class="p">);</span><span class="w">  </span><span class="c1">// 重置视口！</span>

<span class="w">    </span><span class="p">.</span>
<span class="w">    </span><span class="p">.</span><span class="w">   </span><span class="c1">// 绘制场景</span>
<span class="w">    </span><span class="p">.</span>

<span class="p">}</span>
</code></pre></div>
<p>请注意，当绘制到非默认帧缓冲区时，必须手动设置视口。然后在绘制屏幕上的图像时，必须重置视口以匹配渲染屏幕上图像的画布大小。我还应该指出，此程序中只使用了一个纹理对象，所以它可以在初始化期间一次性绑定。在这种情况下，在 <em>draw()</em> 函数中不需要调用 <em>gl.bindTexture()</em>。</p>
<p>这个示例可以不使用帧缓冲区来实现，就像 <a href="../../c4/s3/#435-从内存加载纹理">4.3.6小节</a> 中的示例那样。在那个示例中，纹理图像被绘制到默认帧缓冲区，然后复制到纹理对象。然而，本节中的版本更有效，因为它不需要在渲染图像后复制图像。</p>
</div>
<div class="tabbed-block">
<p>The previous subsection applies to any <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr>. But we haven't yet used a non-default <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr>. We turn to that topic now.</p>
<p>One use for a non-default <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr> is to render directly into a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. That is, the memory occupied by a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image can be attached to the <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr> as its <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr>, so that <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> operations will send their output to the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image. This technique, which is called <strong><abbr title="A technique in which the output of a rendering operation is written directly to a texture. In WebGL, render-to-texture can be implemented by attaching the texture as one of the buffers in a framebuffer.">render-to-texture</abbr></strong>, is used in the sample program <a href="../../../en/source/webgl/render-to-texture.html">webgl/<abbr title="A technique in which the output of a rendering operation is written directly to a texture. In WebGL, render-to-texture can be implemented by attaching the texture as one of the buffers in a framebuffer.">render-to-texture</abbr>.html</a>.</p>
<p>Texture memory is normally allocated when an image is loaded into the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> using the function <em>gl.texImage2D</em> or <em>gl.copyTexImage2D</em>. (See <a href="../../c6/s4/#64-图像纹理">Section 6.4</a>.) However, there is a version of <em>gl.texImage2D</em> that can be used to allocate memory without loading an image into that memory. Here is an example, from the sample program:</p>
<div class="highlight"><pre><span></span><code><span class="nx">texture</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createTexture</span><span class="p">();</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bindTexture</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">texture</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">texImage2D</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span><span class="w"> </span><span class="mf">512</span><span class="p">,</span><span class="w"> </span><span class="mf">512</span><span class="p">,</span><span class="w"> </span>
<span class="w">                            </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">UNSIGNED_BYTE</span><span class="p">,</span><span class="w"> </span><span class="kc">null</span><span class="p">);</span>
</code></pre></div>
<p>It is the <em>null</em> parameter at the end of the last line that tells <em>gl.texImage2D</em> to allocate new memory without loading existing image data to fill that memory. Instead, the new memory is filled with zeros. The first parameter to <em>gl.texImage2D</em> is the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> target. The target is <em>gl.TEXTURE_2D</em> for normal textures, but other values are used for working with cubemap textures. The fourth and fifth parameters specify the height and width of the image; they should be powers of two. The other parameters usually have the values shown here; their meanings are the same as for the version of <em>gl.texImage2D</em> discussed in <a href="../../c6/s4/#643-更多制作纹理的方法">Subsection 6.4.3</a>. Note that the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object must first be created and bound; <em>gl.texImage2D</em> applies to the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> that is currently bound to the active <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> unit. (In <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0, the same thing can also be accomplished using the <em>gl.texStorage2D()</em> function discussed in <a href="../../c6/s4/#646-webgl-20-中的纹理">Subsection 6.4.6</a>.)</p>
<p>To attach the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> to a <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr>, you need to create a <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr> object and make that object the current <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr> by binding it. For example,</p>
<div class="highlight"><pre><span></span><code><span class="nx">framebuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createFramebuffer</span><span class="p">();</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bindFramebuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAMEBUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">framebuffer</span><span class="p">);</span>
</code></pre></div>
<p>Then the function <em>gl.framebufferTexture2D</em> can be used to attach the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> to the <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr>:</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">framebufferTexture2D</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAMEBUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">COLOR_ATTACHMENT0</span><span class="p">,</span><span class="w"> </span>
<span class="w">                                                </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">texture</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>The first parameter is always <em>gl.FRAMEBUFFER</em>. The second parameter says a <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr> is being attached. The last character in <em>gl.COLOR_ATTACHMENT0</em> is a zero, which allows the possibility of having more than one <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr> attached to a <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr> (although in standard <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0, only one <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr> is allowed). The third parameter is the same <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> target that was used in <em>gl.texImage2D</em>, and the fourth is the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object. The last parameter is the <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmap</abbr> level; it will usually be zero, which means <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> to the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image itself rather than to one of its <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmap</abbr> images.</p>
<p>With this setup, you are ready to bind the <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr> and draw to the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. After drawing the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>, call</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">bindFramebuffer</span><span class="p">(</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAMEBUFFER</span><span class="p">,</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>to start drawing again to the default <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr>. At that point, the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> is ready for use in subsequent <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> operations. The <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object can be bound to a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> unit, and a <em>sampler2D</em> variable can be used in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program to read from the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>.</p>
<p>You are very likely to use different <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> programs for drawing to the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> and drawing to the screen. Recall that the function <em>gl.useProgram()</em> is used to specify the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program.</p>
<p>In the <a href="../../../en/source/webgl/render-to-texture.html">sample program</a>, the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> can be animated. During the <abbr title="A sequence of images that, when displayed quickly one after the other, will produce the impression of continuous motion or change. The term animation also refers to the process of creating such image sequences.">animation</abbr>, a new image is drawn to the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> for each frame of the <abbr title="A sequence of images that, when displayed quickly one after the other, will produce the impression of continuous motion or change. The term animation also refers to the process of creating such image sequences.">animation</abbr>. The <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image is 2D, so the <abbr title="A solution to the hidden surface problem that involves keeping track of the depth, or distance from the viewer, of the object currently visible at each pixel in the image. When a new object is drawn at a pixel, the depth of the new object is compared to the depth of the current object to decide which one is closer to the viewer. The advantage of the depth test is that objects can be rendered in any order. A disadvantage is that only a limited range of depths can be represented in the image.">depth test</abbr> is disabled while <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> it. This means that the <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr> doesn't need a <abbr title="A region of memory that stores the information needed for the depth test in 3D graphics, that is, a depth value for each pixel in the image. Also called the &quot;z-buffer.&quot;">depth buffer</abbr>. In outline form, the <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> function in the sample program has the form</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span><span class="w"> </span><span class="nx">draw</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="cm">/* Draw the 2D image into a texture attached to a framebuffer. */</span>

<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">bindFramebuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAMEBUFFER</span><span class="p">,</span><span class="nx">framebuffer</span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">useProgram</span><span class="p">(</span><span class="nx">prog_texture</span><span class="p">);</span><span class="w">  </span><span class="c1">// shader program for the texture</span>

<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">clearColor</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">clear</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">COLOR_BUFFER_BIT</span><span class="p">);</span><span class="w">  </span><span class="c1">// clear the texture to white</span>

<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">enable</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">BLEND</span><span class="p">);</span><span class="w">  </span><span class="c1">// Use transparency while drawing 2D image.    </span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">disable</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">DEPTH_TEST</span><span class="p">);</span><span class="w"> </span><span class="c1">// framebuffer doesn&#39;t even have a depth buffer!</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">viewport</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">512</span><span class="p">,</span><span class="mf">512</span><span class="p">);</span><span class="w">  </span><span class="c1">// Viewport is not set automatically!</span>

<span class="w">    </span><span class="p">.</span>
<span class="w">    </span><span class="p">.</span><span class="w">  </span><span class="c1">// draw the texture image, which changes in each frame</span>
<span class="w">    </span><span class="p">.</span>

<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">disable</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">BLEND</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/*  Now draw the main scene, which is 3D, using the texture. */</span>

<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">bindFramebuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAMEBUFFER</span><span class="p">,</span><span class="kc">null</span><span class="p">);</span><span class="w"> </span><span class="c1">// Draw to default framebuffer.</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">useProgram</span><span class="p">(</span><span class="nx">prog</span><span class="p">);</span><span class="w">  </span><span class="c1">// shader program for the on-screen image</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">clearColor</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">clear</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">COLOR_BUFFER_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">DEPTH_BUFFER_BIT</span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">enable</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">DEPTH_TEST</span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">viewport</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span><span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span><span class="p">);</span><span class="w">  </span><span class="c1">// Reset the viewport!</span>

<span class="w">    </span><span class="p">.</span>
<span class="w">    </span><span class="p">.</span><span class="w">   </span><span class="c1">// draw the scene</span>
<span class="w">    </span><span class="p">.</span>

<span class="p">}</span>
</code></pre></div>
<p>Note that the <abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr> has to be set by hand when drawing to a non-default <abbr title="A region of memory that contains color data for a digital image. Most often refers to the memory containing the image that appears on the computer's screen.">frame buffer</abbr>. It then has to be reset when drawing the on-screen image to match the size of the canvas where the on-screen image is rendered. I should also note that only one <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object is used in this program, so it can be bound once and for all during initialization. In this case, it is not necessary to call <em>gl.bindTexture()</em> in the <em>draw()</em> function.</p>
<p>This example could be implemented without using a <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr>, as was done for the example in <a href="../../c4/s3/#435-从内存加载纹理">Subsection 4.3.6</a>. In that example, the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image was drawn to the default <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr>, then copied to the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object. However, the version in this section is more efficient because it does not need to copy the image after <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> it.</p>
</div>
</div>
</div>
<h2 id="743-渲染缓冲区">7.4.3 <abbr title="在WebGL中，一种缓冲区（即内存区域），可以附加到帧缓冲区用作颜色缓冲区、深度缓冲区或模板缓冲区。">渲染缓冲区</abbr><a class="headerlink" href="#743-渲染缓冲区" title="Permanent link">&para;</a></h2>
<p><strong>Renderbuffers</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="4:2"><input checked="checked" id="__tabbed_4_1" name="__tabbed_4" type="radio" /><input id="__tabbed_4_2" name="__tabbed_4" type="radio" /><div class="tabbed-labels"><label for="__tabbed_4_1">中文</label><label for="__tabbed_4_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>通常使用纹理对象的内存作为帧缓冲区的颜色缓冲区是很方便的。然而，有时更适合为缓冲区创建单独的内存，与任何纹理无关。对于深度缓冲区来说，这是典型情况。在这种情况下，可以创建一个 <strong><abbr title="In WebGL, a buffer (that is, a region of memory) that can be attached to a framebuffer for use as a color buffer, depth buffer, or stencil buffer.">renderbuffer</abbr></strong> 来作为内存。Renderbuffer 代表可以附加到帧缓冲区的内存，用作颜色缓冲区、深度缓冲区或模板缓冲区。要使用它，你需要创建 <abbr title="In WebGL, a buffer (that is, a region of memory) that can be attached to a framebuffer for use as a color buffer, depth buffer, or stencil buffer.">renderbuffer</abbr> 并为它分配内存。内存是通过函数 <em>gl.renderbufferStorage()</em> 分配的。在分配内存之前，必须通过调用 <em>gl.bindRenderbuffer()</em> 绑定 <abbr title="In WebGL, a buffer (that is, a region of memory) that can be attached to a framebuffer for use as a color buffer, depth buffer, or stencil buffer.">renderbuffer</abbr>。以下是一个创建用作深度缓冲区的 <abbr title="In WebGL, a buffer (that is, a region of memory) that can be attached to a framebuffer for use as a color buffer, depth buffer, or stencil buffer.">renderbuffer</abbr> 的示例：</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">depthBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createRenderbuffer</span><span class="p">();</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bindRenderbuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">RENDERBUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">depthBuffer</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">renderbufferStorage</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">RENDERBUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">DEPTH_COMPONENT16</span><span class="p">,</span><span class="w"> </span><span class="mf">512</span><span class="p">,</span><span class="w"> </span><span class="mf">512</span><span class="p">);</span>
</code></pre></div>
<p><em>gl.bindRenderbuffer</em> 和 <em>gl.renderbufferStorage</em> 的第一个参数都必须是 <em>gl.RENDERBUFFER</em>。<em>gl.renderbufferStorage</em> 的第二个参数指定了 <abbr title="In WebGL, a buffer (that is, a region of memory) that can be attached to a framebuffer for use as a color buffer, depth buffer, or stencil buffer.">renderbuffer</abbr> 的用途。值 gl.DEPTH_COMPONENT16 是每个像素16位的深度缓冲区。（在 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 中，16位是唯一的选项。）对于包含 RGBA 颜色的彩色缓冲区，每个像素有四个八位值，第二个参数将是 gl.RGBA8。其他值也是可能的，例如 <em>gl.RGB565</em>，它使用每个像素16位，红色通道5位，绿色通道6位，蓝色通道5位。对于模板缓冲区，值将是 gl.STENCIL_INDEX8。<em>gl.renderbufferStorage</em> 的最后两个参数是缓冲区的宽度和高度。</p>
<p>函数 <em>gl.framebufferRenderbuffer()</em> 用于将 <abbr title="In WebGL, a buffer (that is, a region of memory) that can be attached to a framebuffer for use as a color buffer, depth buffer, or stencil buffer.">renderbuffer</abbr> 附加为帧缓冲区中的一个缓冲区。它的形式如下：</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">framebufferRenderbuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAMEBUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">DEPTH_ATTACHMENT</span><span class="p">,</span><span class="w"> </span>
<span class="w">                                        </span><span class="nx">gl</span><span class="p">.</span><span class="nx">RENDERBUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">renderbuffer</span><span class="p">);</span>
</code></pre></div>
<p>在此函数调用之前，必须通过调用 <em>gl.bindFramebuffer</em> 绑定帧缓冲区。gl.framebufferRenderbuffer 的第一个和第三个参数必须如上所示。最后一个参数是 <abbr title="In WebGL, a buffer (that is, a region of memory) that can be attached to a framebuffer for use as a color buffer, depth buffer, or stencil buffer.">renderbuffer</abbr>。第二个参数指定了 <abbr title="In WebGL, a buffer (that is, a region of memory) that can be attached to a framebuffer for use as a color buffer, depth buffer, or stencil buffer.">renderbuffer</abbr> 的用途。它可以是，例如，<em>gl.COLOR_ATTACHMENT0</em>，<em>gl.DEPTH_ATTACHMENT</em> 或 <em>gl.STENCIL_ATTACHMENT</em>。</p>
</div>
<div class="tabbed-block">
<p>It is often convenient to use memory from a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object as the <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr> for a <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr>. However, sometimes its more appropriate to create separate memory for the buffer, not associated with any <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. For the <abbr title="A region of memory that stores the information needed for the depth test in 3D graphics, that is, a depth value for each pixel in the image. Also called the &quot;z-buffer.&quot;">depth buffer</abbr>, that is the typical case. For such cases, the memory can be created as a <strong><abbr title="In WebGL, a buffer (that is, a region of memory) that can be attached to a framebuffer for use as a color buffer, depth buffer, or stencil buffer.">renderbuffer</abbr></strong>. A <abbr title="In WebGL, a buffer (that is, a region of memory) that can be attached to a framebuffer for use as a color buffer, depth buffer, or stencil buffer.">renderbuffer</abbr> represents memory that can be attached to a <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr> for use as a <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr>, <abbr title="A region of memory that stores the information needed for the depth test in 3D graphics, that is, a depth value for each pixel in the image. Also called the &quot;z-buffer.&quot;">depth buffer</abbr>, or stencil buffer. To use one, you need to create the <abbr title="In WebGL, a buffer (that is, a region of memory) that can be attached to a framebuffer for use as a color buffer, depth buffer, or stencil buffer.">renderbuffer</abbr> and allocate memory for it. Memory is allocated using the function <em>gl.renderbufferStorage()</em>. The <abbr title="In WebGL, a buffer (that is, a region of memory) that can be attached to a framebuffer for use as a color buffer, depth buffer, or stencil buffer.">renderbuffer</abbr> must be bound by calling <em>gl.bindRenderbuffer()</em> before allocating the memory. Here is an example that creates a <abbr title="In WebGL, a buffer (that is, a region of memory) that can be attached to a framebuffer for use as a color buffer, depth buffer, or stencil buffer.">renderbuffer</abbr> for use as a <abbr title="A region of memory that stores the information needed for the depth test in 3D graphics, that is, a depth value for each pixel in the image. Also called the &quot;z-buffer.&quot;">depth buffer</abbr>:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">depthBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createRenderbuffer</span><span class="p">();</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bindRenderbuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">RENDERBUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">depthBuffer</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">renderbufferStorage</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">RENDERBUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">DEPTH_COMPONENT16</span><span class="p">,</span><span class="w"> </span><span class="mf">512</span><span class="p">,</span><span class="w"> </span><span class="mf">512</span><span class="p">);</span>
</code></pre></div>
<p>The first parameter to both <em>gl.bindRenderbuffer</em> and <em>gl.renderbufferStorage</em> must be <em>gl.RENDERBUFFER</em>. The second parameter to <em>gl.renderbufferStorage</em> specifies how the <abbr title="In WebGL, a buffer (that is, a region of memory) that can be attached to a framebuffer for use as a color buffer, depth buffer, or stencil buffer.">renderbuffer</abbr> will be used. The value gl.DEPTH_COMPONENT16 is for a <abbr title="A region of memory that stores the information needed for the depth test in 3D graphics, that is, a depth value for each pixel in the image. Also called the &quot;z-buffer.&quot;">depth buffer</abbr> with 16 bits for each <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>. (Sixteen bits is the only option in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0.) For a <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr> holding RGBA colors with four eight-bit values per <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>, the second parameter would be gl.RGBA8. Other values are possible, such as <em>gl.RGB565</em>, which uses 16 bits per <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> with 5 bits for the red color channel, 6 bits for green, and 5 bits for blue. For a stencil buffer, the value would be gl.STENCIL_INDEX8. The last two parameters to <em>gl.renderbufferStorage</em> are the width and height of the buffer.</p>
<p>The function <em>gl.framebufferRenderbuffer()</em> is used to attach a renderbufffer to be used as one of the buffers in a <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr>. It takes the form</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">framebufferRenderbuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAMEBUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">DEPTH_ATTACHMENT</span><span class="p">,</span><span class="w"> </span>
<span class="w">                                        </span><span class="nx">gl</span><span class="p">.</span><span class="nx">RENDERBUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">renderbuffer</span><span class="p">);</span>
</code></pre></div>
<p>The <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr> must be bound by calling <em>gl.bindFramebuffer</em> before this function is called. The first and third parameters to gl.framebufferRenderbuffer must be as shown. The last parameter is the <abbr title="In WebGL, a buffer (that is, a region of memory) that can be attached to a framebuffer for use as a color buffer, depth buffer, or stencil buffer.">renderbuffer</abbr>. The second parameter specifies how the <abbr title="In WebGL, a buffer (that is, a region of memory) that can be attached to a framebuffer for use as a color buffer, depth buffer, or stencil buffer.">renderbuffer</abbr> will be used. It can be, for example, <em>gl.COLOR_ATTACHMENT0</em>, <em>gl.DEPTH_ATTACHMENT</em>, or <em>gl.STENCIL_ATTACHMENT</em>.</p>
</div>
</div>
</div>
<h2 id="744-动态立方体贴图纹理">7.4.4 动态立方体贴图纹理<a class="headerlink" href="#744-动态立方体贴图纹理" title="Permanent link">&para;</a></h2>
<p><strong>Dynamic Cubemap Textures</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="5:2"><input checked="checked" id="__tabbed_5_1" name="__tabbed_5" type="radio" /><input id="__tabbed_5_2" name="__tabbed_5" type="radio" /><div class="tabbed-labels"><label for="__tabbed_5_1">中文</label><label for="__tabbed_5_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>要将 3D 场景渲染到帧缓冲区，我们需要一个颜色缓冲区和一个深度缓冲区。示例程序 <a href="../../../en/source/webgl/cube-camera.html">webgl/cube-<abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>.html</a> 展示了这个过程。此示例对立方体贴图纹理使用渲染到纹理技术。然后，立方体贴图纹理被用作反射表面上的环境贴图。除了环境贴图，程序还使用另一个立方体贴图作为天空盒。（见 <a href="../../c6/s3/#635-函数定义">6.3.5小节</a>。）以下是程序中的图像：</p>
<p><a class="glightbox" href="../../../en/c7/dynamic-cubemap.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c7/dynamic-cubemap.png" /></a></p>
<p>在这种情况下，环境包括背景天空盒，还包括几个不属于天空盒纹理的彩色立方体。图像中心的反射球体反射了立方体以及天空盒，这意味着环境贴图纹理不能与天空盒纹理相同——它必须包括立方体。此外，场景可以动画化，立方体可以移动。球体上的反射必须随着立方体的移动而变化。这意味着环境贴图纹理必须在每一帧重新创建。为此，我们可以使用帧缓冲区将立方体贴图纹理渲染。</p>
<p>立方体贴图由六幅图像组成，分别对应于 x、y 和 z 轴的正负方向。每个图像与不同的纹理目标相关联（类似于 <em>gl.TEXTURE_2D</em>）。要渲染立方体贴图，我们需要为所有六个面分配存储空间。以下是示例程序中的代码：</p>
<div class="highlight"><pre><span></span><code><span class="nx">cubemapTargets</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w">  </span>
<span class="w">    </span><span class="c1">// 为了方便起见，将纹理目标存储在数组中 </span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_POSITIVE_X</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_NEGATIVE_X</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_POSITIVE_Y</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_NEGATIVE_Y</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_POSITIVE_Z</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_NEGATIVE_Z</span><span class="w"> </span>
<span class="p">];</span>

<span class="nx">dynamicCubemap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createTexture</span><span class="p">();</span><span class="w"> </span><span class="c1">// 创建纹理对象。</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bindTexture</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP</span><span class="p">,</span><span class="w"> </span><span class="nx">dynamicCubemap</span><span class="p">);</span><span class="w">  </span><span class="c1">// 将其绑定为立方体贴图</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">6</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">texImage2D</span><span class="p">(</span><span class="nx">cubemapTargets</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span><span class="w"> </span><span class="mf">512</span><span class="p">,</span><span class="w"> </span><span class="mf">512</span><span class="p">,</span><span class="w"> </span>
<span class="w">                                </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">UNSIGNED_BYTE</span><span class="p">,</span><span class="w"> </span><span class="kc">null</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>我们还需要创建一个帧缓冲区，以及一个用作深度缓冲区的 <abbr title="In WebGL, a buffer (that is, a region of memory) that can be attached to a framebuffer for use as a color buffer, depth buffer, or stencil buffer.">renderbuffer</abbr>，并需要将深度缓冲区附加到帧缓冲区。可以使用同一个帧缓冲区来渲染纹理的所有六幅图像，根据需要更改帧缓冲区的颜色缓冲区附件。要将六幅立方体贴图图像之一附加为颜色缓冲区，我们只需在调用 <em>gl.framebufferTexture2D()</em> 时指定相应的立方体贴图纹理目标。例如，以下命令</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">framebufferTexture2D</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAMEBUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">COLOR_ATTACHMENT0</span><span class="p">,</span><span class="w"> </span>
<span class="w">                        </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_NEGATIVE_Z</span><span class="p">,</span><span class="w"> </span><span class="nx">dynamicCubemap</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">);</span>
</code></pre></div>
<p>将纹理对象 <em>dynamicCubemap</em> 的负 z 图像附加为当前绑定帧缓冲区的颜色缓冲区。</p>
<p>六幅纹理图像渲染完成后，立方体贴图纹理就准备好使用了。除了渲染了六个 3D 图像而不是一个 2D 图像之外，这与本节前面环境贴图的渲染到纹理示例非常相似。</p>
<hr />
<p>要渲染立方体贴图所需的六个场景图像，我们需要考虑如何为反射物体制作环境贴图。我们希望获得围绕该物体的环境图像。可以通过将相机放置在物体中心来制作这些图像。基本思想是将相机指向正负坐标轴的六个方向，并在每个方向上拍摄一张照片，但要正确处理细节却很棘手。（请注意，当我们将结果应用到表面上的某一点时，我们只能获得正确反射的近似值。对于表面上某点的几何正确反射，我们需要从那个点的视角来看，而不是从物体中心的视角来看，但我们不能现实地为表面上的每个点制作不同的环境贴图。只要场景中的其他物体不太靠近反射表面，近似效果看起来就会不错。）</p>
<p>“<abbr title="在三维计算机图形中，将投影和观察变换组合成一个抽象，模拟物理相机或眼睛。">相机</abbr>”实际上意味着投影变换和观察变换。投影需要一个九十度的视野，以覆盖立方体的一面，其纵横比将是1，因为立方体的面是正方形。我们可以使用如下的 <em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em> 命令来制作投影矩阵：</p>
<div class="highlight"><pre><span></span><code><span class="nx">mat4</span><span class="p">.</span><span class="nx">projection</span><span class="p">(</span><span class="nx">projection</span><span class="p">,</span><span class="w"> </span><span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="o">/</span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">100</span><span class="p">);</span>
</code></pre></div>
<p>这里的最后两个参数，近裁剪面和远裁剪面的距离，应该选择以包含场景中的所有物体。如果我们不应用观察变换，相机将位于原点，指向负z轴方向。如果反射物体位于原点，就像示例程序中那样，我们可以使用没有观察变换的相机来拍摄立方体贴图的负z图像。</p>
<p>但是，由于图像存储为立方体贴图的方式的细节，我们发现我们需要应用一个变换。让我们看看立方体贴图的图像布局：</p>
<p><a class="glightbox" href="../../../en/c7/cubemap-layout.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c7/cubemap-layout.png" /></a></p>
<p>立方体的六个面以黑色显示，好像立方体的面已经被打开并铺平了。每个面都标有相应的坐标轴方向。正负y面的副本以灰色显示，以展示这些面如何连接到负z面。我们为立方体贴图制作的图像必须像布局中的面一样拼接在一起。然而，布局中的面是从立方体的<strong>外部</strong>观看的，而相机将从立方体的<strong>内部</strong>拍摄照片。要获得正确的视图，我们需要水平翻转相机拍摄的照片。经过一些尝试，我发现我还需要垂直翻转它，也许是因为网络图像相对于OpenGL约定是倒置存储的。我们可以通过(−1,−1,1)的缩放变换来实现两次翻转。综合起来，制作立方体贴图的负z图像的代码是：</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">bindFramebuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAMEBUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">framebuffer</span><span class="p">);</span><span class="w"> </span><span class="c1">// 绘制到离屏缓冲区。</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">viewport</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">512</span><span class="p">,</span><span class="mf">512</span><span class="p">);</span><span class="w">  </span><span class="c1">// 匹配纹理图像的大小。</span>

<span class="err">/* 设置虚拟相机的投影和模型视图矩阵</span>

<span class="nx">mat4</span><span class="p">.</span><span class="nx">perspective</span><span class="p">(</span><span class="nx">projection</span><span class="p">,</span><span class="w"> </span><span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="o">/</span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">100</span><span class="p">);</span>
<span class="nx">mat4</span><span class="p">.</span><span class="nx">identity</span><span class="p">(</span><span class="nx">modelview</span><span class="p">);</span>
<span class="nx">mat4</span><span class="p">.</span><span class="nx">scale</span><span class="p">(</span><span class="nx">modelview</span><span class="p">,</span><span class="nx">modelview</span><span class="p">,[</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">]);</span>

<span class="err">/* 将立方体贴图的负z图像附加为帧缓冲区的颜色缓冲区，</span>
<span class="nx">并通过渲染图像</span><span class="err">“</span><span class="nx">拍照</span><span class="err">”。</span>

<span class="nx">gl</span><span class="p">.</span><span class="nx">framebufferTexture2D</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAMEBUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">COLOR_ATTACHMENT0</span><span class="p">,</span><span class="w"> </span>
<span class="w">                        </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_NEGATIVE_Z</span><span class="p">,</span><span class="w"> </span><span class="nx">dynamicCubemap</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">);</span>
<span class="nx">renderSkyboxAndCubes</span><span class="p">();</span>
</code></pre></div>
<p>最后一行的函数渲染场景，除了中心的反射物体本身，并负责将投影和模型视图矩阵发送到着色器程序。</p>
<p>对于其他五幅图像，我们需要在拍照前将相机指向不同的方向。这可以通过向观察变换添加适当的旋转来完成。例如，对于正x图像，我们需要围绕y轴旋转相机−90度。作为观察变换，我们需要命令：</p>
<div class="highlight"><pre><span></span><code><span class="nx">mat4</span><span class="p">.</span><span class="nx">rotateY</span><span class="p">(</span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="o">/</span><span class="mf">2</span><span class="p">);</span>
</code></pre></div>
<p>可能更容易将其视为一个建模变换，将立方体的正x面旋转到相机前方的视野中。</p>
<p>在 <a href="../../../en/source/webgl/cube-camera.html">示例程序</a> 中，六个立方体贴图图像是在函数 <em>createDynamicCubemap()</em> 中创建的。阅读该函数的源代码以获取全部细节。</p>
<p>这个动态立方体贴图程序是一个很好的例子，因为它使用了我们所涵盖的许多概念和技术。花一点时间思考这个示例程序中发生的一切，以及它们是如何实现的。（您可能还会注意到茶壶没有反射<strong>它自己</strong>的任何部分。）</p>
<p><iframe src="../../../en/demos/c7/cube-camera-demo.html" width="550" height="565"></iframe></p>
</div>
<div class="tabbed-block">
<p>To render a 3D scene to a <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr>, we need both a <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr> and a <abbr title="A region of memory that stores the information needed for the depth test in 3D graphics, that is, a depth value for each pixel in the image. Also called the &quot;z-buffer.&quot;">depth buffer</abbr>. An example can be found in the sample program <a href="../../../en/source/webgl/cube-camera.html">webgl/cube-<abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>.html</a>. This example uses <abbr title="A technique in which the output of a rendering operation is written directly to a texture. In WebGL, render-to-texture can be implemented by attaching the texture as one of the buffers in a framebuffer.">render-to-texture</abbr> for a <abbr title="A texture made up of six images, one for each of the directions positive x, negative x, positive y, negative y, positive z, and negative z. The images are intended to include everything that can be seen from a given point. Cubemap textures are used for environment mapping and skyboxes.">cubemap texture</abbr>. The <abbr title="A texture made up of six images, one for each of the directions positive x, negative x, positive y, negative y, positive z, and negative z. The images are intended to include everything that can be seen from a given point. Cubemap textures are used for environment mapping and skyboxes.">cubemap texture</abbr> is then used as an environment map on a reflective surface. In addition to the environment map, the program uses another <abbr title="A texture made up of six images, one for each of the directions positive x, negative x, positive y, negative y, positive z, and negative z. The images are intended to include everything that can be seen from a given point. Cubemap textures are used for environment mapping and skyboxes.">cubemap texture</abbr> for a <abbr title="一个围绕场景的大立方体，用图像纹理，形成该场景所有方向的背景。">skybox</abbr>. (See <a href="../../c6/s3/#635-函数定义">Subsection 6.3.5</a>.) Here's an image from the program:</p>
<p><a class="glightbox" href="../../../en/c7/dynamic-cubemap.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c7/dynamic-cubemap.png" /></a></p>
<p>The environment in this case includes the background <abbr title="一个围绕场景的大立方体，用图像纹理，形成该场景所有方向的背景。">skybox</abbr>, but also includes several colored cubes that are not part of the <abbr title="一个围绕场景的大立方体，用图像纹理，形成该场景所有方向的背景。">skybox</abbr> <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. The reflective sphere in the center of the image reflects the cubes as well as the <abbr title="一个围绕场景的大立方体，用图像纹理，形成该场景所有方向的背景。">skybox</abbr>, which means that the environment map <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> can't be the same as the <abbr title="一个围绕场景的大立方体，用图像纹理，形成该场景所有方向的背景。">skybox</abbr> <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>—it has to include the cubes. Furthermore, the scene can be animated and the cubes can move. The reflection in the sphere has to change as the cubes move. This means that the environment map <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> has to be recreated in each frame. For that, we can use a <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr> to render to the <abbr title="A texture made up of six images, one for each of the directions positive x, negative x, positive y, negative y, positive z, and negative z. The images are intended to include everything that can be seen from a given point. Cubemap textures are used for environment mapping and skyboxes.">cubemap texture</abbr>.</p>
<p>A <abbr title="A texture made up of six images, one for each of the directions positive x, negative x, positive y, negative y, positive z, and negative z. The images are intended to include everything that can be seen from a given point. Cubemap textures are used for environment mapping and skyboxes.">cubemap texture</abbr> consists of six images, one each for the positive and negative direction of the x, y, and z axes. Each image is associated with a different <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> target (similar to <em>gl.TEXTURE_2D</em>). To render a cubemap, we need to allocate storage for all six sides. Here's the code from the sample program:</p>
<div class="highlight"><pre><span></span><code><span class="nx">cubemapTargets</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w">  </span>
<span class="w">        </span><span class="c1">// store texture targets in an array for convenience </span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_POSITIVE_X</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_NEGATIVE_X</span><span class="p">,</span><span class="w"> </span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_POSITIVE_Y</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_NEGATIVE_Y</span><span class="p">,</span><span class="w"> </span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_POSITIVE_Z</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_NEGATIVE_Z</span><span class="w"> </span>
<span class="p">];</span>

<span class="nx">dynamicCubemap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createTexture</span><span class="p">();</span><span class="w"> </span><span class="c1">// Create the texture object.</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bindTexture</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP</span><span class="p">,</span><span class="w"> </span><span class="nx">dynamicCubemap</span><span class="p">);</span><span class="w">  </span><span class="c1">// bind it as a cubemap</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">6</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">texImage2D</span><span class="p">(</span><span class="nx">cubemapTargets</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span><span class="w"> </span><span class="mf">512</span><span class="p">,</span><span class="w"> </span><span class="mf">512</span><span class="p">,</span><span class="w"> </span>
<span class="w">                                    </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">UNSIGNED_BYTE</span><span class="p">,</span><span class="w"> </span><span class="kc">null</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>We also need to create a <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr>, as well as a <abbr title="In WebGL, a buffer (that is, a region of memory) that can be attached to a framebuffer for use as a color buffer, depth buffer, or stencil buffer.">renderbuffer</abbr> for use as a <abbr title="A region of memory that stores the information needed for the depth test in 3D graphics, that is, a depth value for each pixel in the image. Also called the &quot;z-buffer.&quot;">depth buffer</abbr>, and we need to attach the <abbr title="A region of memory that stores the information needed for the depth test in 3D graphics, that is, a depth value for each pixel in the image. Also called the &quot;z-buffer.&quot;">depth buffer</abbr> to the <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr>. The same <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr> can be used to render all six images for the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>, changing the <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr> attachment of the <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr> as needed. To attach one of the six cubemap images as the <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr>, we just specify the corresponding <abbr title="A texture made up of six images, one for each of the directions positive x, negative x, positive y, negative y, positive z, and negative z. The images are intended to include everything that can be seen from a given point. Cubemap textures are used for environment mapping and skyboxes.">cubemap texture</abbr> target in the call to <em>gl.framebufferTexture2D()</em>. For example, the command</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">framebufferTexture2D</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAMEBUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">COLOR_ATTACHMENT0</span><span class="p">,</span><span class="w"> </span>
<span class="w">                        </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_NEGATIVE_Z</span><span class="p">,</span><span class="w"> </span><span class="nx">dynamicCubemap</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">);</span>
</code></pre></div>
<p>attaches the negative z image from the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object <em>dynamicCubemap</em> to be used as the <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr> in the currently bound <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr>.</p>
<p>After the six <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> images have been rendered, the <abbr title="A texture made up of six images, one for each of the directions positive x, negative x, positive y, negative y, positive z, and negative z. The images are intended to include everything that can be seen from a given point. Cubemap textures are used for environment mapping and skyboxes.">cubemap texture</abbr> is ready to be used. Aside from the fact that six 3D images are rendered instead of one 2D image, this is all very similar to the <abbr title="A technique in which the output of a rendering operation is written directly to a texture. In WebGL, render-to-texture can be implemented by attaching the texture as one of the buffers in a framebuffer.">render-to-texture</abbr> example from earlier in this section.</p>
<hr />
<p>The question remains of how to render the six images of the scene that are needed for the <abbr title="A texture made up of six images, one for each of the directions positive x, negative x, positive y, negative y, positive z, and negative z. The images are intended to include everything that can be seen from a given point. Cubemap textures are used for environment mapping and skyboxes.">cubemap texture</abbr>. To make an environment map for a reflective object, we want images of the environment that surrounds that object. The images can be made with a <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> placed at the center of the object. The basic idea is to point the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> in the six directions of the positive and negative coordinate axes and snap a picture in each direction, but it's tricky to get the details correct. (And note that when we apply the result to a point on the surface, we will only have an approximation of the correct reflection. For a geometrically correct reflection at the point, we would need the view from that very point, not the view from the center of the object, but we can't realistically make a different environment map for each point on the surface. The approximation will look OK as long as other objects in the scene are not too close to the reflective surface.)</p>
<p>A "<abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>" really means a <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> transformation and a <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transformation. The <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> needs a ninety-degree field of view, to cover one side of the cube, and its <abbr title="The ratio of the width, w, of a rectangle to the height, h, of the rectangle, expressed either as a ratio **w:h** or as a fraction** w/h**.">aspect ratio</abbr> will be 1, since the sides of the cube are squares. We can make the <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> with a <em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em> command such as</p>
<div class="highlight"><pre><span></span><code><span class="nx">mat4</span><span class="p">.</span><span class="nx">projection</span><span class="p">(</span><span class="w"> </span><span class="nx">projection</span><span class="p">,</span><span class="w"> </span><span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="o">/</span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">100</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>where the last two parameters, the near and far clipping distances, should be chosen to include all the objects in the scene. If we apply no <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transformation, the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> will be at the origin, pointing in the direction of the negative z-axis. If the reflective object is at the origin, as it is in the sample program, we can use the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> with no <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transformation to take the negative-z image for the <abbr title="A texture made up of six images, one for each of the directions positive x, negative x, positive y, negative y, positive z, and negative z. The images are intended to include everything that can be seen from a given point. Cubemap textures are used for environment mapping and skyboxes.">cubemap texture</abbr>.</p>
<p>But, because of the details of how the images must be stored for cubemap textures, it turns out that we need to apply one transformation. Let's look at the layout of images for a <abbr title="A texture made up of six images, one for each of the directions positive x, negative x, positive y, negative y, positive z, and negative z. The images are intended to include everything that can be seen from a given point. Cubemap textures are used for environment mapping and skyboxes.">cubemap texture</abbr>:</p>
<p><a class="glightbox" href="../../../en/c7/cubemap-layout.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c7/cubemap-layout.png" /></a></p>
<p>The six sides of the cube are shown in black, as if the sides of the cube have been opened up and laid out flat. Each side is marked with the corresponding coordinate axis direction. Duplicate copies of the plus and minus y sides are shown in gray, to show how those sides attach to the negative z side. The images that we make for the cubemap must fit together in the same way as the sides in this layout. However, the sides in the layout are viewed from the <strong>outside</strong> of the cube, while the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> will be taking a picture from the <strong>inside</strong> of the cube. To get the correct view, we need to flip the picture from the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> horizontally. After some experimentation, I found that I also need to flip it vertically, perhaps because web images are stored upside down with respect to the <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> convention. We can do both flips with a <abbr title="A geometric transform that multiplies each coordinate of a point by a number called the scaling factor. Scaling increases or decreases the size of an object, but also moves its points closer to or farther from the origin. Scaling can be uniform—the same in every direction—or non-uniform—with a different scaling factor in each coordinate direction. A negative scaling factor can be used to apply a reflection.">scaling</abbr> transformation by (−1,−1,1). Putting this together, the code for making the cubemap's negative z image is</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">bindFramebuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAMEBUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">framebuffer</span><span class="p">);</span><span class="w"> </span><span class="c1">// Draw to offscreen buffer.</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">viewport</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">512</span><span class="p">,</span><span class="mf">512</span><span class="p">);</span><span class="w">  </span><span class="c1">// Match size of the texture images.</span>

<span class="cm">/* Set up projection and modelview matrices for the virtual camera</span>

<span class="cm">mat4.perspective(projection, Math.PI/2, 1, 1, 100);</span>
<span class="cm">mat4.identity(modelview);</span>
<span class="cm">mat4.scale(modelview,modelview,[-1,-1,1]);</span>

<span class="cm">/* Attach the cubemap negative z image as the color buffer in the framebuffer,</span>
<span class="cm">and &quot;take the picture&quot; by rendering the image. */</span>

<span class="nx">gl</span><span class="p">.</span><span class="nx">framebufferTexture2D</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAMEBUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">COLOR_ATTACHMENT0</span><span class="p">,</span><span class="w"> </span>
<span class="w">                        </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_CUBE_MAP_NEGATIVE_Z</span><span class="p">,</span><span class="w"> </span><span class="nx">dynamicCubemap</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">);</span>
<span class="nx">renderSkyboxAndCubes</span><span class="p">();</span>
</code></pre></div>
<p>The function in the last line renders the scene, except for the central reflective object itself, and is responsible for sending the <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> and modelview matrices to the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> programs.</p>
<p>For the other five images, we need to aim the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> in a different direction before taking the picture. That can be done by adding an appropriate <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> to the <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transformation. For example, for the positive x image, we need to rotate the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> by −90 degrees about the y-axis. As a <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transform, we need the command</p>
<div class="highlight"><pre><span></span><code><span class="nx">mat4</span><span class="p">.</span><span class="nx">rotateY</span><span class="p">(</span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="o">/</span><span class="mf">2</span><span class="p">);</span>
</code></pre></div>
<p>It might be easier to think of this as a <abbr title="A transformation that is applied to an object to map that object into the world coordinate system or into the object coordinate system for a more complex, hierarchical object.">modeling transformation</abbr> that rotates the positive x side of the cube into view in front of the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>.</p>
<p>In the <a href="../../../en/source/webgl/cube-camera.html">sample program</a>, the six cubemap images are created in the function <em>createDynamicCubemap()</em>. Read the source code of that function for the full details.</p>
<p>This dynamic cubemap program is a nice example, since it makes use of so many of the concepts and techniques that we have covered. Take a minute to think about everything that is going on in this demo version of the sample program, and how it was all implemented. (You might also notice that the teapot does not reflect any part of <strong>itself</strong>.)</p>
<p><iframe src="../../../en/demos/c7/cube-camera-demo.html" width="550" height="565"></iframe></p>
</div>
</div>
</div>







  
    
  
  
    
  


  <aside class="md-source-file">
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="最后更新">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1-2.1-2M12.5 7v5.2l4 2.4-1 1L11 13V7h1.5M11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2v1.8Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">2024年6月19日</span>
  </span>

    
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="创建日期">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.47 15.08 11 13V7h1.5v5.25l3.08 1.83c-.41.28-.79.62-1.11 1m-1.39 4.84c-.36.05-.71.08-1.08.08-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8c0 .37-.03.72-.08 1.08.69.1 1.33.32 1.92.64.1-.56.16-1.13.16-1.72 0-5.5-4.5-10-10-10S2 6.5 2 12s4.47 10 10 10c.59 0 1.16-.06 1.72-.16-.32-.59-.54-1.23-.64-1.92M18 15v3h-3v2h3v3h2v-3h3v-2h-3v-3h-2Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">2024年5月26日</span>
  </span>

    
    
    
  </aside>





                
              </article>
            </div>
          
          
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var tab,labels=set.querySelector(".tabbed-labels");for(tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script>

<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../../..", "features": ["content.code.copy", "content.tabs.link", "navigation.tabs", "navigation.tabs.sticky", "navigation.indexes", "navigation.top", "toc.follow", "content.tooltips"], "search": "../../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.fe8b6f2b.min.js"></script>
      
        <script src="../../../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="https://unpkg.com/mermaid@9.4.0/dist/mermaid.min.js"></script>
      
    
  <script id="init-glightbox">const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});
document$.subscribe(() => { lightbox.reload() });
</script></body>
</html>