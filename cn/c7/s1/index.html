
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="计算机图形学概论(graphicsbook)">
      
      
      
        <link rel="canonical" href="https://hellowac.github.io/graphicsbook-zh-cn/cn/c7/s1/">
      
      
        <link rel="prev" href="../">
      
      
        <link rel="next" href="../s2/">
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.5.18">
    
    
      
        <title>7.1 3D变换 - 计算机图形学概论</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.66ac8b77.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.06af60db.min.css">
      
      

  
  
  
  
  <style>:root{--md-annotation-icon:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M22 12a10 10 0 0 1-10 10A10 10 0 0 1 2 12 10 10 0 0 1 12 2a10 10 0 0 1 10 10M6 13h8l-3.5 3.5 1.42 1.42L17.84 12l-5.92-5.92L10.5 7.5 14 11H6v2Z"/></svg>');}</style>


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
   <link href="../../../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
        html.glightbox-open { overflow: initial; height: 100%; }
        .gslide-title { margin-top: 0px; user-select: text; }
        .gslide-desc { color: #666; user-select: text; }
        .gslide-image img { background: white; }
        
            .gscrollbar-fixer { padding-right: 15px; }
            .gdesc-inner { font-size: 0.75rem; }
            body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
            body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
            body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}
            </style> <script src="../../../assets/javascripts/glightbox.min.js"></script></head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="default" data-md-color-accent="red">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#71-3d变换" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="计算机图形学概论" class="md-header__button md-logo" aria-label="计算机图形学概论" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            计算机图形学概论
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              7.1 3D变换
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
      <div class="md-header__option">
  <div class="md-select">
    
    <button class="md-header__button md-icon" aria-label="选择当前语言">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m12.87 15.07-2.54-2.51.03-.03A17.52 17.52 0 0 0 14.07 6H17V4h-7V2H8v2H1v2h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04M18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12m-2.62 7 1.62-4.33L19.12 17h-3.24Z"/></svg>
    </button>
    <div class="md-select__inner">
      <ul class="md-select__list">
        
          <li class="md-select__item">
            <a href="/graphicsbook-zh-cn/en/" hreflang="en" class="md-select__link">
              English
            </a>
          </li>
        
          <li class="md-select__item">
            <a href="/graphicsbook-zh-cn/cn/" hreflang="cn" class="md-select__link">
              中文
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</div>
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/hellowac/graphicsbook-zh-cn" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    graphicsbook
  </div>
</a>
      </div>
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../" class="md-tabs__link">
        
  
    
  
  首页

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../preface/" class="md-tabs__link">
        
  
    
  
  前言

      </a>
    </li>
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c1/" class="md-tabs__link">
          
  
    
  
  1.简介

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c2/" class="md-tabs__link">
          
  
    
  
  2.二维图形

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c3/" class="md-tabs__link">
          
  
    
  
  3.几何

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c4/" class="md-tabs__link">
          
  
    
  
  4.灯光和材质

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c5/" class="md-tabs__link">
          
  
    
  
  5.three.js

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c6/" class="md-tabs__link">
          
  
    
  
  6.WebGL

        </a>
      </li>
    
  

      
        
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../" class="md-tabs__link">
          
  
    
  
  7.WebGL 3D

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c8/" class="md-tabs__link">
          
  
    
  
  8.高阶3D

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c9/" class="md-tabs__link">
          
  
    
  
  9.WEBGPU

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../a1/" class="md-tabs__link">
          
  
    
  
  附录

        </a>
      </li>
    
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../.." class="md-tabs__link">
        
  
    
  
  关于

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="计算机图形学概论" class="md-nav__button md-logo" aria-label="计算机图形学概论" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    计算机图形学概论
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/hellowac/graphicsbook-zh-cn" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    graphicsbook
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    首页
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../preface/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    前言
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c1/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    1.简介
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_3" id="__nav_3_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            1.简介
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 1 节 绘画与绘图
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 2 节：三维(3D)图形的要素
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 3 节：硬件与软件
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c2/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    2.二维图形
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_4" id="__nav_4_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            2.二维图形
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第1节: 像素、坐标和颜色
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第2节: 形状
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第3节: 变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第4节: 分层建模
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第5节: Java 绘制2D
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第6节: HTML Canvas图形
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第7节: SVG：一种场景描述语言
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c3/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    3.几何
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_5" id="__nav_5_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            3.几何
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.1 OpenGL 1.1 中的形状和颜色
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.2 3D 坐标和变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.3 投影与观看
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.4 多边形网格和 glDrawArrays
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.5 部分线性代数基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.6 使用 GLUT 和 JOGL
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c4/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    4.灯光和材质
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_6" id="__nav_6_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6">
            <span class="md-nav__icon md-icon"></span>
            4.灯光和材质
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.1 照明简介
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.2 OpenGL 1.1 中的光和材质
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.3 图像纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.4 灯光、相机、动作
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c5/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    5.three.js
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_7" id="__nav_7_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7">
            <span class="md-nav__icon md-icon"></span>
            5.three.js
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.1 Three.js 基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.2 构建对象
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.3 其他功能
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c6/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    6.WebGL
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_8" id="__nav_8_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8">
            <span class="md-nav__icon md-icon"></span>
            6.WebGL
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.1 可编程流水线
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.2 第一个例子
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.3 GLSL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.4 图像纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.5 实现 2D 变换
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" checked>
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    7.WebGL 3D
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_9" id="__nav_9_label" tabindex="">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_9">
            <span class="md-nav__icon md-icon"></span>
            7.WebGL 3D
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    7.1 3D变换
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    7.1 3D变换
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#711-关于着色器脚本" class="md-nav__link">
    <span class="md-ellipsis">
      7.1.1 关于着色器脚本
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#712-glmatrix简介" class="md-nav__link">
    <span class="md-ellipsis">
      7.1.2 glMatrix简介
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#713-变换坐标" class="md-nav__link">
    <span class="md-ellipsis">
      7.1.3 变换坐标
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#714-变换法线" class="md-nav__link">
    <span class="md-ellipsis">
      7.1.4 变换法线
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#715-鼠标旋转" class="md-nav__link">
    <span class="md-ellipsis">
      7.1.5 鼠标旋转
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.2 照明和材质
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.3 纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.4 帧缓冲区
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.5 WebGL 扩展
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c8/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    8.高阶3D
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_10" id="__nav_10_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_10_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10">
            <span class="md-nav__icon md-icon"></span>
            8.高阶3D
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c8/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8.1 光线追踪
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c8/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8.2 路径追踪
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_11" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c9/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    9.WEBGPU
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_11" id="__nav_11_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_11_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_11">
            <span class="md-nav__icon md-icon"></span>
            9.WEBGPU
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.1 WebGPU 基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.2 实例和索引
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.3 WGSL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.4 WebGPU 中的 3D 图形
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.5 纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.6 计算着色器
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.7 细节
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_12" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../a1/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    附录
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_12" id="__nav_12_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_12_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_12">
            <span class="md-nav__icon md-icon"></span>
            附录
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a2/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Blender 3D建模
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a3/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Gimp和Inkscape
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../source/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    示例程序源代码
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../glossary/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    术语表
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    关于
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#711-关于着色器脚本" class="md-nav__link">
    <span class="md-ellipsis">
      7.1.1 关于着色器脚本
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#712-glmatrix简介" class="md-nav__link">
    <span class="md-ellipsis">
      7.1.2 glMatrix简介
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#713-变换坐标" class="md-nav__link">
    <span class="md-ellipsis">
      7.1.3 变换坐标
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#714-变换法线" class="md-nav__link">
    <span class="md-ellipsis">
      7.1.4 变换法线
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#715-鼠标旋转" class="md-nav__link">
    <span class="md-ellipsis">
      7.1.5 鼠标旋转
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="71-3d变换">7.1 3D变换<a class="headerlink" href="#71-3d变换" title="Permanent link">&para;</a></h1>
<p><strong>Transformations in 3D</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="1:2"><input checked="checked" id="__tabbed_1_1" name="__tabbed_1" type="radio" /><input id="__tabbed_1_2" name="__tabbed_1" type="radio" /><div class="tabbed-labels"><label for="__tabbed_1_1">中文</label><label for="__tabbed_1_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>我们已经在<a href="../../c6/">第六章</a>中看到了如何使用WebGL绘制基本图形，以及如何实现2D变换。在3D中绘制基本图形与2D相同，唯一的区别是每个顶点有三个坐标而不是两个。3D中的变换与2D类似，但随着第三维度的增加，复杂性有了显著的提升。本节将涵盖WebGL中3D图形的几何方面。在<a href="../s2/">下一节</a>中，我们将转向照明和材质的问题。</p>
</div>
<div class="tabbed-block">
<p>We have already seen in <a href="../../c6/">Chapter 6</a> how to draw primitives using <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>, and how to implement 2D transformations. Drawing primitives is the same in 3D, except that there are three coordinates per <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> instead of two. Transformations in 3D are also similar to 2D, but for transformations the increase in complexity that comes with the third dimension is substantial. This section covers the geometric side of 3D graphics with <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>. In the <a href="../s2/">next section</a>, we will move on to the question of <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> and materials.</p>
</div>
</div>
</div>
<h2 id="711-关于着色器脚本">7.1.1 关于着色器脚本<a class="headerlink" href="#711-关于着色器脚本" title="Permanent link">&para;</a></h2>
<p><strong>About Shader Scripts</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="2:2"><input checked="checked" id="__tabbed_2_1" name="__tabbed_2" type="radio" /><input id="__tabbed_2_2" name="__tabbed_2" type="radio" /><div class="tabbed-labels"><label for="__tabbed_2_1">中文</label><label for="__tabbed_2_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>但在我们开始更认真地使用WebGL之前，有一个更好的方法来在网页上包含着色器源代码会很不错。到目前为止，我通过连接一堆JavaScript字符串字面量来创建源代码字符串，每个代码行一个。那种格式很难阅读，也很难编辑。至少还有两种常用的技术。一种是将GLSL着色器源代码放在<code>&lt;script&gt;</code>元素内。以下是一个顶点着色器的示例：</p>
<div class="highlight"><pre><span></span><code><span class="p">&lt;</span><span class="nt">script</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;x-shader/x-vertex&quot;</span> <span class="na">id</span><span class="o">=</span><span class="s">&quot;vshader&quot;</span><span class="p">&gt;</span>
<span class="w">    </span><span class="nx">attribute</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">a_coords</span><span class="p">;</span>
<span class="w">    </span><span class="nx">uniform</span><span class="w"> </span><span class="nx">mat4</span><span class="w"> </span><span class="nx">modelviewProjection</span><span class="p">;</span>
<span class="w">    </span><span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="nx">a_coords</span><span class="p">,</span><span class="mf">1.0</span><span class="p">);</span>
<span class="w">        </span><span class="nx">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">modelviewProjection</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">coords</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</code></pre></div>
<p>这依赖于一个事实，即网络浏览器不会识别<code>&lt;script&gt;</code>元素中列出的类型，因此它不会尝试执行脚本。然而，它确实会将<code>&lt;script&gt;</code>元素的内容存储在表示网页的DOM数据结构中。内容可以使用标准DOM API作为字符串检索。我不会解释使用的API函数，但以下是一个函数，它以脚本元素的<em>id</em>作为参数，并返回一个包含元素内部文本的字符串：</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span><span class="w"> </span><span class="nx">getTextContent</span><span class="p">(</span><span class="w"> </span><span class="nx">elementID</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">element</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="nx">elementID</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">element</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nx">node</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">nodeType</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">3</span><span class="p">)</span><span class="w"> </span><span class="c1">// 这是一个文本节点</span>
<span class="w">            </span><span class="nx">str</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">node</span><span class="p">.</span><span class="nx">textContent</span><span class="p">;</span>
<span class="w">        </span><span class="nx">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">node</span><span class="p">.</span><span class="nx">nextSibling</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">str</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>示例程序<a href="../../../en/source/webgl/glmatrix-cube-unlit.html">webgl/glmatrix-cube-unlit.html</a>使用了这种技术。另一个想法是将源代码定义为JavaScript模板字符串。（见<a href="../a3/s3.md">小节A.3.1</a>）。模板字符串被包含在单引号字符之间，并且可以跨越多行。（"引号"也被称为"反引号"）。模板字符串只是在ES6中作为JavaScript的一部分引入的。它们可以包含JavaScript表达式的值，但这里我们不需要那种能力。以下是如何将上述着色器定义为模板字符串的方式：</p>
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">vertexShaderSource</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sb">`</span>
<span class="sb">attribute vec3 a_coords;</span>
<span class="sb">uniform mat4 modelviewProjection;</span>
<span class="sb">void main() {</span>
<span class="sb">    vec4 coords = vec4(a_coords,1.0);</span>
<span class="sb">    gl_Position = modelviewProjection * coords;</span>
<span class="sb">}`</span><span class="p">;</span>
</code></pre></div>
<p>这种技术在本章的许多示例程序中使用。请注意，如果你将GLSL ES 3.00着色器定义为模板字符串，你应该确保在打开引号后立即包括所需的第一行，#version 3.00 es，因为那行不能由空行前导。</p>
</div>
<div class="tabbed-block">
<p>But before we begin working more seriously with <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>, it will be nice to have a better way to include <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> source code on a web page. Up until now, I have created the source code strings by concatenating a bunch of <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> string literals, one for each line of code. That format is hard to read and very hard to edit. There are at least two other techniques that are often used. One is to put the <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> source code inside <code>&lt;script&gt;</code> elements. Here is an example for a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>:</p>
<div class="highlight"><pre><span></span><code><span class="p">&lt;</span><span class="nt">script</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;x-shader/x-vertex&quot;</span> <span class="na">id</span><span class="o">=</span><span class="s">&quot;vshader&quot;</span><span class="p">&gt;</span>
<span class="w">    </span><span class="nx">attribute</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">a_coords</span><span class="p">;</span>
<span class="w">    </span><span class="nx">uniform</span><span class="w"> </span><span class="nx">mat4</span><span class="w"> </span><span class="nx">modelviewProjection</span><span class="p">;</span>
<span class="w">    </span><span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="nx">a_coords</span><span class="p">,</span><span class="mf">1.0</span><span class="p">);</span>
<span class="w">        </span><span class="nx">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">modelviewProjection</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">coords</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</code></pre></div>
<p>This relies on the fact that a web browser will not recognize the type listed in the <code>&lt;script&gt;</code> element, so it will not try to execute the script. However, it does store the content of the <code>&lt;script&gt;</code> element in the <abbr title="Document Object Model. A specification for representing a web page (and other kinds of structured document) as a tree-like data structure. Can also refer to the data structure itself, as in &quot;the DOM for this web page.&quot; A web page can be modified dynamically by manipulating its DOM, using the JavaScript programming language.">DOM</abbr> data structure that represents the web page. The content can be retrieved as a string using the standard <abbr title="Document Object Model. A specification for representing a web page (and other kinds of structured document) as a tree-like data structure. Can also refer to the data structure itself, as in &quot;the DOM for this web page.&quot; A web page can be modified dynamically by manipulating its DOM, using the JavaScript programming language.">DOM</abbr> <abbr title="Application Programming Interface. A collection of related classes, functions, constants, etc., for performing some task. An API is an &quot;interface&quot; in the sense that it can be used without understanding how its functionality is actually implemented.">API</abbr>. I won't explain the <abbr title="Application Programming Interface. A collection of related classes, functions, constants, etc., for performing some task. An API is an &quot;interface&quot; in the sense that it can be used without understanding how its functionality is actually implemented.">API</abbr> functions that are used, but here is a function that takes the <em>id</em> of the script element as its parameter and returns a string containing the text from inside the element:</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span><span class="w"> </span><span class="nx">getTextContent</span><span class="p">(</span><span class="w"> </span><span class="nx">elementID</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">element</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="nx">elementID</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">element</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nx">node</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">nodeType</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">3</span><span class="p">)</span><span class="w"> </span><span class="c1">// this is a text node</span>
<span class="w">            </span><span class="nx">str</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">node</span><span class="p">.</span><span class="nx">textContent</span><span class="p">;</span>
<span class="w">        </span><span class="nx">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">node</span><span class="p">.</span><span class="nx">nextSibling</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">str</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>The sample program <a href="../../../en/source/webgl/glmatrix-cube-unlit.html">webgl/glmatrix-cube-unlit.html</a> uses this technique. The other idea is to define the source code as a <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> template string. (See <a href="../a3/s3.md">Subsection A.3.1</a>). A template string is enclosed between single backquote characters and can span multiple lines. (The "backquote" is also called a "backtick.") Template strings were only introduced into <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> as part of <abbr title="A version of JavaScript implemented by almost all modern web browsers. More formally known as ECMAScript 6 or ECMAScript 2015. ES6 introduced a large number of new features.">ES6</abbr>. They can include the values of <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> expressions, but we don't need that capability here. Here is how the above <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> could be defined as a template string:</p>
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">vertexShaderSource</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sb">`</span>
<span class="sb">attribute vec3 a_coords;</span>
<span class="sb">uniform mat4 modelviewProjection;</span>
<span class="sb">void main() {</span>
<span class="sb">    vec4 coords = vec4(a_coords,1.0);</span>
<span class="sb">    gl_Position = modelviewProjection * coords;</span>
<span class="sb">}`</span><span class="p">;</span>
</code></pre></div>
<p>This technique is used in many of the sample programs in this chapter. Note that if you define a <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 3.00 <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> as a template string, you should be sure to include the required first line, #version 3.00 es, immediately after the opening backquote, since that line cannot be preceded by a blank line.</p>
</div>
</div>
</div>
<h2 id="712-glmatrix简介">7.1.2 glMatrix简介<a class="headerlink" href="#712-glmatrix简介" title="Permanent link">&para;</a></h2>
<p><strong>Introducing <abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="3:2"><input checked="checked" id="__tabbed_3_1" name="__tabbed_3" type="radio" /><input id="__tabbed_3_2" name="__tabbed_3" type="radio" /><div class="tabbed-labels"><label for="__tabbed_3_1">中文</label><label for="__tabbed_3_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>变换对于计算机图形学至关重要。<abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> API没有提供任何用于处理变换的函数。在<a href="../../c6/s5/">第6.5节</a>中，我们使用了一个简单的JavaScript类来表示2D的建模变换。在三维空间中，情况会变得更加复杂。对于使用WebGL的3D图形，JavaScript端通常需要创建模型视图变换和投影变换，并且必须在没有WebGL帮助的情况下对模型视图矩阵应用旋转、缩放和平移。如果有JavaScript库来完成这项工作，那么事情会容易得多。一个常用的库是<strong><em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em></strong>，这是由Brandon Jones和Colin MacKenzie IV编写的用于向量和矩阵数学的免费JavaScript库。它可在<a href="https://glmatrix.net">https://glmatrix.net</a>获取。这本教科书使用的是2015年的2.3版本，尽管有更新的版本可用。根据其许可证，此文件可以自由使用和分发。我的程序使用脚本gl-<abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>-min.js。你可以在这本书的网站下载的源文件夹中找到一份副本。这个文件是一个“压缩”的JavaScript文件，不打算供人类阅读。（你也可以阅读2.2版本的完整源代码，包括注释，以人类可读的形式，在文件<a href="../../../en/source/webgl/gl-matrix.js">webgl/gl-<abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>.js</a>中找到，更多信息可以在glmatrix网站上找到。）</p>
<p><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr> API可以通过像下面这样的脚本元素在网页上使用：</p>
<div class="highlight"><pre><span></span><code><span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&quot;gl-matrix-min.js&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</code></pre></div>
<p>这假定<em>gl-<abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>-min.js</em>与网页在同一目录中。</p>
<p>glMatrix库定义了它所谓的“类”<strong><em>vec2</em></strong>、<strong><em>vec3</em></strong>和<strong><em>vec4</em></strong>，用于处理2、3和4个数字的向量。它定义了<strong><em>mat3</em></strong>用于处理3x3矩阵，以及<strong><em>mat4</em></strong>用于4x4矩阵。这些名称不应与同名的GLSL类型混淆；<em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em>完全在JavaScript端。然而，<em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em>的<strong><em>mat4</em></strong>可以传递给着色器程序以指定GLSL <em>mat4</em>的值，其他向量和矩阵类型也是如此。</p>
<p>每个<em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em>类定义了一组用于处理向量和矩阵的函数。实际上，尽管文档使用“类”这个术语，<em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em>并不是面向对象的。它的类实际上只是JavaScript对象，它类中的函数在Java中将被称为静态方法。在<em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em>中，向量和矩阵被表示为数组，类如<strong><em>vec4</em></strong>和<strong><em>mat4</em></strong>中的函数仅操作这些数组。没有类型为<strong><em>vec4</em></strong>或<strong><em>mat4</em></strong>的对象，只有长度分别为4或16的数组。数组可以是普通的JavaScript数组，也可以是类型为<strong><em>Float32Array</em></strong>的类型化数组。如果让<em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em>为你创建数组，它们将是Float32Arrays，但所有<em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em>函数将与这两种数组一起工作。例如，如果<em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em>文档说一个参数应该是<strong><em>vec3</em></strong>类型，那么传递一个<strong><em>Float32Array</em></strong>或一个包含三个数字的常规JavaScript数组作为该参数的值是可以的。</p>
<p>请注意，任何一种数组也可以在诸如<em>gl.uniform3fv()</em>和<em>gl.uniformMatrix4fv()</em>等WebGL函数中使用。<em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em>旨在与这些函数一起工作。例如，在<em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em>中的一个<strong><em>mat4</em></strong>是一个长度为16的数组，以列主序格式保存4x4矩阵的元素，这与<em>gl.uniformMatrix4fv</em>使用的格式相同。</p>
<hr />
<p>每个<em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em>类都有一个<em>create()</em>函数，用于创建一个具有适当长度的数组，并用默认值填充。例如，</p>
<div class="highlight"><pre><span></span><code><span class="nx">transform</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">mat4</span><span class="p">.</span><span class="nx">create</span><span class="p">();</span>
</code></pre></div>
<p>将<em>transform</em>设置为一个新的长度为16的<strong><em>Float32Array</em></strong>，初始化为表示单位矩阵。类似地，</p>
<div class="highlight"><pre><span></span><code><span class="nx">vector</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec3</span><span class="p">.</span><span class="nx">create</span><span class="p">();</span>
</code></pre></div>
<p>创建一个长度为3、填充了零的<strong><em>Float32Array</em></strong>。每个类还有一个<em>clone(x)</em>函数，用于创建其参数x的副本。例如：</p>
<div class="highlight"><pre><span></span><code><span class="nx">saveTransform</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">mat4</span><span class="p">.</span><span class="nx">clone</span><span class="p">(</span><span class="nx">modelview</span><span class="p">);</span>
</code></pre></div>
<p>大多数其他函数不创建新数组。相反，它们修改它们第一个参数的内容。例如，<em>mat4.multiply(A,B,C)</em>将修改A，使其包含B和C的矩阵乘积。每个参数必须是已经存在的<strong><em>mat4</em></strong>（即长度为16的数组）。一些数组可以是相同的。例如，<em>mat4.multiply(A,A,B)</em>的作用是将A乘以B，并将A修改为包含答案。</p>
<p>有函数用于将矩阵乘以标准变换，如缩放和旋转。例如，如果A和B是<strong><em>mat4s</em></strong>，v是一个<strong><em>vec3</em></strong>，那么<em>mat4.translate(A,B,v)</em>使A等于B和表示由向量<em>v</em>平移的矩阵的乘积。在实践中，我们将主要在表示<em>modelview</em>变换的矩阵上使用这样的操作。所以，假设我们有一个名为<em>modelview</em>的<strong><em>mat4</em></strong>，它保存当前的<em>modelview</em>变换。要通过向量<em>[dx,dy,dz]</em>应用平移，我们可以这样说</p>
<div class="highlight"><pre><span></span><code><span class="nx">mat4</span><span class="p">.</span><span class="nx">translate</span><span class="p">(</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="nx">dx</span><span class="p">,</span><span class="nx">dy</span><span class="p">,</span><span class="nx">dz</span><span class="p">]</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>这等同于在OpenGL中调用<em>glTranslatef(dx,dy,dz)</em>。也就是说，如果我们在这个语句之后绘制一些几何体，使用modelview作为<em>modelview</em>变换，那么几何体首先会被平移[dx,dy,dz]，然后会被<em>modelview</em>的先前值变换。注意在这个命令中使用向量来指定平移，而不是三个单独的参数；这是glMatrix的典型用法。要应用缩放变换，缩放因子为<em>sx</em>、<em>sy</em>和<em>sz</em>，使用</p>
<div class="highlight"><pre><span></span><code><span class="nx">mat4</span><span class="p">.</span><span class="nx">scale</span><span class="p">(</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="nx">sx</span><span class="p">,</span><span class="nx">sy</span><span class="p">,</span><span class="nx">sz</span><span class="p">]</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>对于旋转，<em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em>有四个函数，包括三个用于围绕<em>x</em>、<em>y</em>或<em>z</em>轴旋转的常见情况。第四个旋转函数指定旋转轴为从(0,0,0)到点<em>(dx,dy,dz)</em>的线。这等同于<em>glRotatef(angle,dx,dy,dz)</em>。不幸的是，这些函数中的旋转角度是以弧度而不是度指定的：</p>
<div class="highlight"><pre><span></span><code><span class="nx">mat4</span><span class="p">.</span><span class="nx">rotateX</span><span class="p">(</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">radians</span><span class="w"> </span><span class="p">);</span>
<span class="nx">mat4</span><span class="p">.</span><span class="nx">rotateY</span><span class="p">(</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">radians</span><span class="w"> </span><span class="p">);</span>
<span class="nx">mat4</span><span class="p">.</span><span class="nx">rotateZ</span><span class="p">(</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">radians</span><span class="w"> </span><span class="p">);</span>
<span class="nx">mat4</span><span class="p">.</span><span class="nx">rotate</span><span class="p">(</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">radians</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="nx">dx</span><span class="p">,</span><span class="nx">dy</span><span class="p">,</span><span class="nx">dz</span><span class="p">]</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>这些函数允许我们进行所有基本的建模和查看变换，这对3D图形是必需的。为了进行层次化图形，我们还需要在遍历场景图时保存和恢复变换。为此，我们需要一个栈。我们可以使用一个常规的JavaScript数组，它已经有<em>push</em>和<em>pop</em>操作。所以，我们可以创建一个空数组作为栈：</p>
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">matrixStack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[];</span>
</code></pre></div>
<p>然后，我们可以通过说</p>
<div class="highlight"><pre><span></span><code><span class="nx">matrixStack</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="w"> </span><span class="nx">mat4</span><span class="p">.</span><span class="nx">clone</span><span class="p">(</span><span class="nx">modelview</span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>将当前modelview矩阵的副本推到栈上，并且我们可以用</p>
<div class="highlight"><pre><span></span><code><span class="nx">modelview</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">matrixStack</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
</code></pre></div>
<p>从栈中移除一个矩阵，并将其设置为当前的modelview矩阵。</p>
<p>这些操作等同于OpenGL中的<em>glPushMatrix()</em>和<em>glPopMatrix()</em>。</p>
<hr />
<p>模型视图变换的起点通常是观察变换。在OpenGL中，经常使用函数<em>gluLookAt</em>来设置观察变换（见<a href="../../c3/s3/#334-模型视图转换">3.3.4小节</a>）。glMatrix库有一个“lookAt”函数来做同样的事情：</p>
<div class="highlight"><pre><span></span><code><span class="nx">mat4</span><span class="p">.</span><span class="nx">lookAt</span><span class="p">(</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="nx">eyex</span><span class="p">,</span><span class="nx">eyey</span><span class="p">,</span><span class="nx">eyez</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="nx">refx</span><span class="p">,</span><span class="nx">refy</span><span class="p">,</span><span class="nx">refz</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="nx">upx</span><span class="p">,</span><span class="nx">upy</span><span class="p">,</span><span class="nx">upz</span><span class="p">]</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>注意，这个函数使用三个<strong><em>vec3's</em></strong>代替<em>gluLookAt</em>中的九个独立参数，并且它将结果放在它的第一个参数中，而不是全局变量中。这个函数调用实际上等同于两个OpenGL命令：</p>
<div class="highlight"><pre><span></span><code><span class="nx">glLoadIdentity</span><span class="p">();</span>
<span class="nx">gluLookAt</span><span class="p">(</span><span class="w"> </span><span class="nx">eyex</span><span class="p">,</span><span class="nx">eyey</span><span class="p">,</span><span class="nx">eyez</span><span class="p">,</span><span class="nx">refx</span><span class="p">,</span><span class="nx">refy</span><span class="p">,</span><span class="nx">refz</span><span class="p">,</span><span class="nx">upx</span><span class="p">,</span><span class="nx">upy</span><span class="p">,</span><span class="nx">upz</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>所以，你不需要在调用<em>mat4.lookAt</em>之前将<em>modelview</em>设置为单位矩阵，就像你通常在OpenGL中做的那样。然而，你必须在使用<em>mat4.lookAt</em>之前创建<em>modelview</em><abbr title="数字的矩形数组。矩阵可以表示为二维数组，数字按行和列排列。一个N×N矩阵表示从N维空间到自身的线性变换。">矩阵</abbr>，比如通过调用</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">modelview</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">mat4</span><span class="p">.</span><span class="nx">create</span><span class="p">();</span>
</code></pre></div>
<p>如果你想将现有的<strong><em>mat4</em></strong>设置为单位矩阵，你可以使用<em>mat4.identity</em>函数。例如，</p>
<div class="highlight"><pre><span></span><code><span class="nx">mat4</span><span class="p">.</span><span class="nx">identity</span><span class="p">(</span><span class="w"> </span><span class="nx">modelview</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>如果你想从基本的缩放、旋转和平移变换中组合出视图变换，你可以使用这个作为起点。</p>
<p>类似地，<em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em>有设置投影变换的函数。它有等同于<em>glOrtho</em>、<em>glFrustum</em>和<em>gluPerspective</em>的函数（见3.3.3小节），只是<em>mat4.perspective</em>中的视场角度是以弧度而不是度给出的：</p>
<div class="highlight"><pre><span></span><code><span class="nx">mat4</span><span class="p">.</span><span class="nx">ortho</span><span class="p">(</span><span class="w"> </span><span class="nx">projection</span><span class="p">,</span><span class="w"> </span><span class="nx">left</span><span class="p">,</span><span class="w"> </span><span class="nx">right</span><span class="p">,</span><span class="w"> </span><span class="nx">bottom</span><span class="p">,</span><span class="w"> </span><span class="nx">top</span><span class="p">,</span><span class="w"> </span><span class="nx">near</span><span class="p">,</span><span class="w"> </span><span class="nx">far</span><span class="w"> </span><span class="p">);</span>

<span class="nx">mat4</span><span class="p">.</span><span class="nx">frustum</span><span class="p">(</span><span class="w"> </span><span class="nx">projection</span><span class="p">,</span><span class="w"> </span><span class="nx">left</span><span class="p">,</span><span class="w"> </span><span class="nx">right</span><span class="p">,</span><span class="w"> </span><span class="nx">bottom</span><span class="p">,</span><span class="w"> </span><span class="nx">top</span><span class="p">,</span><span class="w"> </span><span class="nx">near</span><span class="p">,</span><span class="w"> </span><span class="nx">far</span><span class="w"> </span><span class="p">);</span>

<span class="nx">mat4</span><span class="p">.</span><span class="nx">perspective</span><span class="p">(</span><span class="w"> </span><span class="nx">projection</span><span class="p">,</span><span class="w"> </span><span class="nx">fovyInRadians</span><span class="p">,</span><span class="w"> </span><span class="nx">aspect</span><span class="p">,</span><span class="w"> </span><span class="nx">near</span><span class="p">,</span><span class="w"> </span><span class="nx">far</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>和模型视图变换一样，你不需要在调用这些函数之前用单位矩阵加载<em><abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr></em>，但你必须将<em><abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr></em>创建为一个<strong><em>mat4</em></strong>（或长度为16的数组）。</p>
</div>
<div class="tabbed-block">
<p>Transformations are essential to computer graphics. The <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> <abbr title="Application Programming Interface. A collection of related classes, functions, constants, etc., for performing some task. An API is an &quot;interface&quot; in the sense that it can be used without understanding how its functionality is actually implemented.">API</abbr> does not provide any functions for working with transformations. In <a href="../../c6/s5/">Section 6.5</a>, we used a simple <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> class to represent modeling transformations in 2D. Things get more complex in three dimensions. For 3D graphics with <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>, the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side will usually have to create both a modelview transform and a <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> transform, and it will have to apply <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr>, <abbr title="A geometric transform that multiplies each coordinate of a point by a number called the scaling factor. Scaling increases or decreases the size of an object, but also moves its points closer to or farther from the origin. Scaling can be uniform—the same in every direction—or non-uniform—with a different scaling factor in each coordinate direction. A negative scaling factor can be used to apply a reflection.">scaling</abbr>, and <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr> to the modelview <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>, all without help from <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>. Doing so is much easier if you have a <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> library to do the work. One commonly used library is <strong><em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em></strong>, a free <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> library for <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> and <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> math written by Brandon Jones and Colin MacKenzie IV. It is available from <a href="https://glmatrix.net">https://glmatrix.net</a>. This textbook uses Version 2.3 of the library, from 2015, although newer versions are available. According to its license, this file can be freely used and distributed. My programs use the script gl-<abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>-min.js. You can find a copy in the source folder in the web site download of this book. This file is a "minified" <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> file, which is not meant to be human-readable. (You can also read the full source for version 2.2, in human-readable form including comments, in the file <a href="../../../en/source/webgl/gl-matrix.js">webgl/gl-<abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>.js</a>, and more information can be found on the glmatrix web site.)</p>
<p>The <abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr> <abbr title="Application Programming Interface. A collection of related classes, functions, constants, etc., for performing some task. An API is an &quot;interface&quot; in the sense that it can be used without understanding how its functionality is actually implemented.">API</abbr> can be made available for use on a web page with a script element such as</p>
<div class="highlight"><pre><span></span><code><span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&quot;gl-matrix-min.js&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</code></pre></div>
<p>This assumes that <em>gl-<abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>-min.js</em> is in the same directory as the web page.</p>
<p>The <em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em> library defines what it calls "classes" named <strong><em>vec2</em></strong>, <strong><em>vec3</em></strong>, and <strong><em>vec4</em></strong> for working with vectors of 2, 3, and 4 numbers. It defines <strong><em>mat3</em></strong> for working with 3-by-3 matrices and <strong><em>mat4</em></strong> for 4-by-4 matrices. The names should not be confused with the <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> types of the same names; <em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em> in entirely on the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side. However, a <em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em> <strong><em>mat4</em></strong> can be passed to a <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program to specify the value of a <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> <em>mat4</em>, and similarly for the other <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> and <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> types.</p>
<p>Each <em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em> class defines a set of functions for working with vectors and matrices. In fact, however, although the documentation uses the term "class," <em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em> is not object-oriented. Its classes are really just <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> objects, and the functions in its classes are what would be called static methods in Java. Vectors and matrices are represented in <em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em> as arrays, and the functions in classes like <strong><em>vec4</em></strong> and <strong><em>mat4</em></strong> simply operate on those arrays. There are no objects of type <strong><em>vec4</em></strong> or <strong><em>mat4</em></strong> as such, just arrays of length 4 or 16 respectively. The arrays can be either ordinary <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> arrays or typed arrays of type <strong><em>Float32Array</em></strong>. If you let <em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em> create the arrays for you, they will be Float32Arrays, but all <em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em> functions will work with either kind of array. For example, if the <em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em> documentation says that a parameter should be of type <strong><em>vec3</em></strong>, it is OK to pass either a <strong><em>Float32Array</em></strong> or a regular <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> array of three numbers as the value of that parameter.</p>
<p>Note that it is also the case that either kind of array can be used in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> functions such as <em>gl.uniform3fv()</em> and <em>gl.uniformMatrix4fv()</em>. <em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em> is designed to work with those functions. For example, a <strong><em>mat4</em></strong> in <em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em> is an array of length 16 that holds the elements of a 4-by-4 array in <abbr title="Column-by-column ordering of the elements of a two-dimensional matrix; that is, an ordering that starts with the elements in the first column, followed by the elements in the second column, and so on. Column-major order is used for matrices in OpenGL and GLSL.">column-major order</abbr>, the same format that is used by <em>gl.uniformMatrix4fv</em>.</p>
<hr />
<p>Each <em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em> class has a <em>create()</em> function which creates an array of the appropriate length and fills it with default values. For example,</p>
<div class="highlight"><pre><span></span><code><span class="nx">transform</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">mat4</span><span class="p">.</span><span class="nx">create</span><span class="p">();</span>
</code></pre></div>
<p>sets <em>transform</em> to be a new <strong><em>Float32Array</em></strong> of length 16, initialized to represent the <abbr title="The n-by-n identity matrix is an n-by-n matrix which has ones on the diagonal and zeros elsewhere. Multiplication of any matrix B by the identity matrix, in either order, leaves B unchanged. Multiplication of an n-dimensional vector by the n-by-n identity matrix leaves the vector unchanged; that is, the identity matrix is the matrix for the identity transformation.">identity matrix</abbr>. Similarly,</p>
<div class="highlight"><pre><span></span><code><span class="nx">vector</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec3</span><span class="p">.</span><span class="nx">create</span><span class="p">();</span>
</code></pre></div>
<p>creates a <strong><em>Float32Array</em></strong> of length 3, filled with zeros. Each class also has a function <em>clone(x)</em> that creates a copy of its parameter x. For example:</p>
<div class="highlight"><pre><span></span><code><span class="nx">saveTransform</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">mat4</span><span class="p">.</span><span class="nx">clone</span><span class="p">(</span><span class="nx">modelview</span><span class="p">);</span>
</code></pre></div>
<p>Most other functions do <strong>not</strong> create new arrays. Instead, they modify the contents of their first parameter. For example, <em>mat4.multiply(A,B,C)</em> will modify A so that it holds the <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> product of B and C. Each parameter must be a <strong><em>mat4</em></strong> (that is, an array of length 16) that already exists. It is OK for some of the arrays to be the same. For example, <em>mat4.multiply(A,A,B)</em> has the effect of multiplying A times B and modifying A so that it contains the answer.</p>
<p>There are functions for multiplying a <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> by standard transformations such as <abbr title="A geometric transform that multiplies each coordinate of a point by a number called the scaling factor. Scaling increases or decreases the size of an object, but also moves its points closer to or farther from the origin. Scaling can be uniform—the same in every direction—or non-uniform—with a different scaling factor in each coordinate direction. A negative scaling factor can be used to apply a reflection.">scaling</abbr> and <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr>. For example if A and B are <strong><em>mat4s</em></strong> and v is a <strong><em>vec3</em></strong>, then <em>mat4.translate(A,B,v)</em> makes A equal to the product of B and the <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> that represents <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr> by the <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> <em>v</em>. In practice, we will use such operations mostly on a <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> that represents the <em>modelview</em> transformation. So, suppose that we have a <strong><em>mat4</em></strong> named <em>modelview</em> that holds the current <em>modelview</em> transform. To apply a <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr> by a <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> <em>[dx,dy,dz]</em>, we can say</p>
<div class="highlight"><pre><span></span><code><span class="nx">mat4</span><span class="p">.</span><span class="nx">translate</span><span class="p">(</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="nx">dx</span><span class="p">,</span><span class="nx">dy</span><span class="p">,</span><span class="nx">dz</span><span class="p">]</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>This is equivalent to calling <em>glTranslatef(dx,dy,dz)</em> in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr>. That is, if we draw some geometry after this statement, using modelview as the <em>modelview</em> transformation, then the geometry will first be translated by [dx,dy,dz] and then will be transformed by whatever was the previous value of <em>modelview</em>. Note the use of a <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> to specify the <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr> in this command, rather than three separate parameters; this is typical of <abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr>. To apply a <abbr title="A geometric transform that multiplies each coordinate of a point by a number called the scaling factor. Scaling increases or decreases the size of an object, but also moves its points closer to or farther from the origin. Scaling can be uniform—the same in every direction—or non-uniform—with a different scaling factor in each coordinate direction. A negative scaling factor can be used to apply a reflection.">scaling</abbr> transformation with scale factors <em>sx</em>, <em>sy</em>, and <em>sz</em>, use</p>
<div class="highlight"><pre><span></span><code><span class="nx">mat4</span><span class="p">.</span><span class="nx">scale</span><span class="p">(</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="nx">sx</span><span class="p">,</span><span class="nx">sy</span><span class="p">,</span><span class="nx">sz</span><span class="p">]</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>For <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr>, <em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em> has four functions, including three for the common cases of <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> about the <em>x</em>, <em>y</em>, or <em>z</em> axis. The fourth <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> function specifies the <abbr title="Rotation in 3D space is rotation about a line, which is called the axis of rotation. The axis of rotation remains fixed, while everything else moves in circles around the axis.">axis of rotation</abbr> as the line from (0,0,0) to a point <em>(dx,dy,dz)</em>. This is equivalent to <em>glRotatef(angle,dx,dy,dz)</em> Unfortunately, the angle of <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> in these functions is specified in radians rather than in degrees:</p>
<div class="highlight"><pre><span></span><code><span class="nx">mat4</span><span class="p">.</span><span class="nx">rotateX</span><span class="p">(</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">radians</span><span class="w"> </span><span class="p">);</span>
<span class="nx">mat4</span><span class="p">.</span><span class="nx">rotateY</span><span class="p">(</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">radians</span><span class="w"> </span><span class="p">);</span>
<span class="nx">mat4</span><span class="p">.</span><span class="nx">rotateZ</span><span class="p">(</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">radians</span><span class="w"> </span><span class="p">);</span>
<span class="nx">mat4</span><span class="p">.</span><span class="nx">rotate</span><span class="p">(</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">radians</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="nx">dx</span><span class="p">,</span><span class="nx">dy</span><span class="p">,</span><span class="nx">dz</span><span class="p">]</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>These functions allow us to do all the basic modeling and <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transformations that we need for 3D graphics. To do hierarchical graphics, we also need to save and restore the transformation as we traverse the <abbr title="A data structure that represents the objects in a scene, together with attributes of the objects and the modeling transformations that are applied to the objects. An image of the scene is created by traversing the scene graph data structure. A scene graph might exist only conceptually, or it might be an actual data structure in a program.">scene graph</abbr>. For that, we need a <abbr title="A data structure with the operations push() and pop(). Pushing an item onto a stack just adds that item to the stack. Popping from the stack will remove and return the item that was most recently pushed onto the stack.">stack</abbr>. We can use a regular <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> array, which already has <em>push</em> and <em>pop</em> operations. So, we can create the <abbr title="A data structure with the operations push() and pop(). Pushing an item onto a stack just adds that item to the stack. Popping from the stack will remove and return the item that was most recently pushed onto the stack.">stack</abbr> as an empty array:</p>
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">matrixStack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[];</span>
</code></pre></div>
<p>We can then push a copy of the current modelview <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> onto the <abbr title="A data structure with the operations push() and pop(). Pushing an item onto a stack just adds that item to the stack. Popping from the stack will remove and return the item that was most recently pushed onto the stack.">stack</abbr> by saying</p>
<div class="highlight"><pre><span></span><code><span class="nx">matrixStack</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="w"> </span><span class="nx">mat4</span><span class="p">.</span><span class="nx">clone</span><span class="p">(</span><span class="nx">modelview</span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>and we can remove a <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> from the <abbr title="A data structure with the operations push() and pop(). Pushing an item onto a stack just adds that item to the stack. Popping from the stack will remove and return the item that was most recently pushed onto the stack.">stack</abbr> and set it to be the current modelview <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> with</p>
<div class="highlight"><pre><span></span><code><span class="nx">modelview</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">matrixStack</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
</code></pre></div>
<p>These operations are equivalent to <em>glPushMatrix()</em> and <em>glPopMatrix()</em> in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr>.</p>
<hr />
<p>The starting point for the modelview transform is usually a <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transform. In <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr>, the function <em>gluLookAt</em> is often used to set up the <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transformation (<a href="../../c3/s3/#334-模型视图转换">Subsection 3.3.4</a>). The <abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr> library has a "lookAt" function to do the same thing:</p>
<div class="highlight"><pre><span></span><code><span class="nx">mat4</span><span class="p">.</span><span class="nx">lookAt</span><span class="p">(</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="nx">eyex</span><span class="p">,</span><span class="nx">eyey</span><span class="p">,</span><span class="nx">eyez</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="nx">refx</span><span class="p">,</span><span class="nx">refy</span><span class="p">,</span><span class="nx">refz</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="nx">upx</span><span class="p">,</span><span class="nx">upy</span><span class="p">,</span><span class="nx">upz</span><span class="p">]</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>Note that this function uses three <strong><em>vec3's</em></strong> in place of the nine separate parameters in <em>gluLookAt</em>, and it places the result in its first parameter instead of in a global variable. This function call is actually equivalent to the two <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> commands</p>
<div class="highlight"><pre><span></span><code><span class="nx">glLoadIdentity</span><span class="p">();</span>
<span class="nx">gluLookAt</span><span class="p">(</span><span class="w"> </span><span class="nx">eyex</span><span class="p">,</span><span class="nx">eyey</span><span class="p">,</span><span class="nx">eyez</span><span class="p">,</span><span class="nx">refx</span><span class="p">,</span><span class="nx">refy</span><span class="p">,</span><span class="nx">refz</span><span class="p">,</span><span class="nx">upx</span><span class="p">,</span><span class="nx">upy</span><span class="p">,</span><span class="nx">upz</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>So, you don't have to set <em>modelview</em> equal to the <abbr title="The n-by-n identity matrix is an n-by-n matrix which has ones on the diagonal and zeros elsewhere. Multiplication of any matrix B by the identity matrix, in either order, leaves B unchanged. Multiplication of an n-dimensional vector by the n-by-n identity matrix leaves the vector unchanged; that is, the identity matrix is the matrix for the identity transformation.">identity matrix</abbr> before calling <em>mat4.lookAt</em>, as you would usually do in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr>. However, you do have to create the <em>modelview</em> <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> at some point before using <em>mat4.lookAt</em>, such as by calling</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">modelview</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">mat4</span><span class="p">.</span><span class="nx">create</span><span class="p">();</span>
</code></pre></div>
<p>If you do want to set an existing <strong><em>mat4</em></strong> to the <abbr title="The n-by-n identity matrix is an n-by-n matrix which has ones on the diagonal and zeros elsewhere. Multiplication of any matrix B by the identity matrix, in either order, leaves B unchanged. Multiplication of an n-dimensional vector by the n-by-n identity matrix leaves the vector unchanged; that is, the identity matrix is the matrix for the identity transformation.">identity matrix</abbr>, you can do so with the <em>mat4.identity</em> function. For example,</p>
<div class="highlight"><pre><span></span><code><span class="nx">mat4</span><span class="p">.</span><span class="nx">identity</span><span class="p">(</span><span class="w"> </span><span class="nx">modelview</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>You could use this as a starting point if you wanted to compose the view transformation out of basic scale, rotate, and translate transformations.</p>
<p>Similarly, <em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em> has functions for setting up <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> transformations. It has functions equivalent to <em>glOrtho</em>, <em>glFrustum</em>, and <em>gluPerspective</em> (<a href="../../c3/s3/#333-投影变换">Subsection 3.3.3</a>), except that the field-of-view angle in <em>mat4.perspective</em> is given in radians rather than degrees:</p>
<div class="highlight"><pre><span></span><code><span class="nx">mat4</span><span class="p">.</span><span class="nx">ortho</span><span class="p">(</span><span class="w"> </span><span class="nx">projection</span><span class="p">,</span><span class="w"> </span><span class="nx">left</span><span class="p">,</span><span class="w"> </span><span class="nx">right</span><span class="p">,</span><span class="w"> </span><span class="nx">bottom</span><span class="p">,</span><span class="w"> </span><span class="nx">top</span><span class="p">,</span><span class="w"> </span><span class="nx">near</span><span class="p">,</span><span class="w"> </span><span class="nx">far</span><span class="w"> </span><span class="p">);</span>

<span class="nx">mat4</span><span class="p">.</span><span class="nx">frustum</span><span class="p">(</span><span class="w"> </span><span class="nx">projection</span><span class="p">,</span><span class="w"> </span><span class="nx">left</span><span class="p">,</span><span class="w"> </span><span class="nx">right</span><span class="p">,</span><span class="w"> </span><span class="nx">bottom</span><span class="p">,</span><span class="w"> </span><span class="nx">top</span><span class="p">,</span><span class="w"> </span><span class="nx">near</span><span class="p">,</span><span class="w"> </span><span class="nx">far</span><span class="w"> </span><span class="p">);</span>

<span class="nx">mat4</span><span class="p">.</span><span class="nx">perspective</span><span class="p">(</span><span class="w"> </span><span class="nx">projection</span><span class="p">,</span><span class="w"> </span><span class="nx">fovyInRadians</span><span class="p">,</span><span class="w"> </span><span class="nx">aspect</span><span class="p">,</span><span class="w"> </span><span class="nx">near</span><span class="p">,</span><span class="w"> </span><span class="nx">far</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>As with the <abbr title="In OpenGL 1.1, a transform that combines the modeling transform with the viewing transform. That is, it is the composition of the transformation from object coordinates to world coordinates and the transformation from world coordinates to eye coordinates. Because of the equivalence between modeling and viewing transformations, world coordinates are not really meaningful for OpenGL, and only the combined transformation is tracked.">modelview transformation</abbr>, you do not need to load <em><abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr></em> with the identity before calling one of these functions, but you must create <em><abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr></em> as a <strong><em>mat4</em></strong> (or an array of length 16).</p>
</div>
</div>
</div>
<h2 id="713-变换坐标">7.1.3 变换坐标<a class="headerlink" href="#713-变换坐标" title="Permanent link">&para;</a></h2>
<p><strong>Transforming Coordinates</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="4:2"><input checked="checked" id="__tabbed_4_1" name="__tabbed_4" type="radio" /><input id="__tabbed_4_2" name="__tabbed_4" type="radio" /><div class="tabbed-labels"><label for="__tabbed_4_1">中文</label><label for="__tabbed_4_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>当然，创建投影和模型视图变换的目的是为了在绘制基本图形时使用它们来变换坐标。在WebGL中，变换通常在顶点着色器中完成。一个基本图形的坐标以对象坐标指定。它们乘以模型视图变换以将它们转换为眼睛坐标，然后乘以投影矩阵以将它们转换为实际用于绘制基本图形的最终裁剪坐标。或者，模型视图和投影矩阵可以相乘，得到一个表示组合变换的矩阵；然后可以直接将对象坐标乘以该矩阵，直接转换为裁剪坐标。</p>
<p>在着色器程序中，坐标变换通常表示为GLSL uniform变量，类型为<strong><em>mat4</em></strong>。着色器程序可以使用单独的投影和模型视图矩阵或组合矩阵（或两者兼有）。有时，由于某些光照计算是在眼睛坐标中完成的，因此可能需要单独的模型视图变换矩阵，但这里有一个使用组合矩阵的最小GLSL ES 1.00顶点着色器：</p>
<div class="highlight"><pre><span></span><code><span class="nx">attribute</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">a_coords</span><span class="p">;</span><span class="w">           </span><span class="c1">// 顶点的(x,y,z)对象坐标。</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">mat4</span><span class="w"> </span><span class="nx">modelviewProjection</span><span class="p">;</span><span class="w">  </span><span class="c1">// 组合变换矩阵。</span>
<span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="nx">a_coords</span><span class="p">,</span><span class="mf">1.0</span><span class="p">);</span><span class="w">   </span><span class="c1">// 为w坐标添加1.0。</span>
<span class="w">    </span><span class="nx">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">modelviewProjection</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">coords</span><span class="p">;</span><span class="w">  </span><span class="c1">// 变换坐标。</span>
<span class="p">}</span>
</code></pre></div>
<p>这个着色器来自示例程序<a href="../../../en/source/webgl/glmatrix-cube-unlit.html">webgl/glmatrix-cube-unlit.html</a>。该程序允许用户查看一个彩色立方体，只使用基本颜色而不应用光照。用户可以选择正交投影或透视投影，并可以使用键盘旋转立方体。旋转是作为围绕x、y和z轴的单独旋转组成的建模变换应用的。在JavaScript方面的变换矩阵，程序使用glMatrix库中的<strong><em>mat4</em></strong>类来表示投影、模型视图和组合变换矩阵：</p>
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">projection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">mat4</span><span class="p">.</span><span class="nx">create</span><span class="p">();</span><span class="w">  </span><span class="c1">// 投影矩阵</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">modelview</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">mat4</span><span class="p">.</span><span class="nx">create</span><span class="p">();</span><span class="w">   </span><span class="c1">// 模型视图矩阵</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">modelviewProjection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">mat4</span><span class="p">.</span><span class="nx">create</span><span class="p">();</span><span class="w">  </span><span class="c1">// 组合矩阵</span>
</code></pre></div>
<p>（这些变量可以是<em>const</em>，因为相同的矩阵对象将在整个程序中使用，尽管对象中的数字会改变。）只有<em>modelviewProjection</em>对应于着色器变量。在初始化期间使用</p>
<div class="highlight"><pre><span></span><code><span class="nx">u_modelviewProjection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getUniformLocation</span><span class="p">(</span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;modelviewProjection&quot;</span><span class="p">);</span>
</code></pre></div>
<p>获取该变量在着色器程序中的位置。变换矩阵在<em>draw()</em>函数中计算，使用<em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em> <strong><em>mat4</em></strong>类的函数。在绘制组成立方体的基本图形之前，使用<em>gl.uniformMatrix4fv</em>将<em>modelviewProjection</em>的值发送到着色器程序。这里是执行此操作的代码：</p>
<div class="highlight"><pre><span></span><code><span class="cm">/* 设置投影以表示投影变换 */</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;persproj&quot;</span><span class="p">).</span><span class="nx">checked</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">mat4</span><span class="p">.</span><span class="nx">perspective</span><span class="p">(</span><span class="nx">projection</span><span class="p">,</span><span class="w"> </span><span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="o">/</span><span class="mf">5</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">4</span><span class="p">,</span><span class="w"> </span><span class="mf">8</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">mat4</span><span class="p">.</span><span class="nx">ortho</span><span class="p">(</span><span class="nx">projection</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">4</span><span class="p">,</span><span class="w"> </span><span class="mf">8</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* 设置modelview以表示观察变换。 */</span>

<span class="nx">mat4</span><span class="p">.</span><span class="nx">lookAt</span><span class="p">(</span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mf">2</span><span class="p">,</span><span class="mf">2</span><span class="p">,</span><span class="mf">6</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">]);</span>

<span class="cm">/* 将建模变换应用于modelview。 */</span>

<span class="nx">mat4</span><span class="p">.</span><span class="nx">rotateX</span><span class="p">(</span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">rotateX</span><span class="p">);</span>
<span class="nx">mat4</span><span class="p">.</span><span class="nx">rotateY</span><span class="p">(</span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">rotateY</span><span class="p">);</span>
<span class="nx">mat4</span><span class="p">.</span><span class="nx">rotateZ</span><span class="p">(</span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">rotateZ</span><span class="p">);</span>

<span class="cm">/* 将投影矩阵乘以模型视图矩阵得到组合变换矩阵，并将该矩阵发送到着色器程序。 */</span>

<span class="nx">mat4</span><span class="p">.</span><span class="nx">multiply</span><span class="p">(</span><span class="w"> </span><span class="nx">modelviewProjection</span><span class="p">,</span><span class="w"> </span><span class="nx">projection</span><span class="p">,</span><span class="w"> </span><span class="nx">modelview</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">uniformMatrix4fv</span><span class="p">(</span><span class="nx">u_modelviewProjection</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="nx">modelviewProjection</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>如果着色器程序中使用了单独的模型视图和投影矩阵，那么模型视图矩阵可以应用于将对象坐标转换为眼睛坐标，然后投影可以应用于眼睛坐标来计算<em>gl_Position</em>。这里有一个执行此操作的最小顶点着色器：</p>
<div class="highlight"><pre><span></span><code><span class="nx">attribute</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">a_coords</span><span class="p">;</span><span class="w">  </span><span class="c1">// 顶点的(x,y,z)对象坐标。</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">mat4</span><span class="w"> </span><span class="nx">modelview</span><span class="p">;</span><span class="w">   </span><span class="c1">// 模型视图变换。</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">mat4</span><span class="w"> </span><span class="nx">projection</span><span class="p">;</span><span class="w">  </span><span class="c1">// 投影变换。</span>
<span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="nx">a_coords</span><span class="p">,</span><span class="mf">1.0</span><span class="p">);</span><span class="w">      </span><span class="c1">// 为w坐标添加1.0。</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">eyeCoords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">modelview</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">coords</span><span class="p">;</span><span class="w">   </span><span class="c1">// 应用模型视图变换。</span>
<span class="w">    </span><span class="nx">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">projection</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">eyeCoords</span><span class="p">;</span><span class="w">  </span><span class="c1">// 应用投影变换。</span>
<span class="p">}</span>
</code></pre></div>
</div>
<div class="tabbed-block">
<p>Of course, the point of making a <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> and a <abbr title="In OpenGL 1.1, a transform that combines the modeling transform with the viewing transform. That is, it is the composition of the transformation from object coordinates to world coordinates and the transformation from world coordinates to eye coordinates. Because of the equivalence between modeling and viewing transformations, world coordinates are not really meaningful for OpenGL, and only the combined transformation is tracked.">modelview transformation</abbr> is to use them to transform coordinates while drawing primitives. In <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>, the transformation is usually done in the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>. The coordinates for a primitive are specified in <abbr title="The coordinate system in which the coordinates for points in an object are originally specified, before they are transformed by any modeling or other transform that will be applied to the object.">object coordinates</abbr>. They are multiplied by the <abbr title="In OpenGL 1.1, a transform that combines the modeling transform with the viewing transform. That is, it is the composition of the transformation from object coordinates to world coordinates and the transformation from world coordinates to eye coordinates. Because of the equivalence between modeling and viewing transformations, world coordinates are not really meaningful for OpenGL, and only the combined transformation is tracked.">modelview transformation</abbr> to covert them into <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr> and then by the <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> to covert them to the final <abbr title="The default coordinate system in OpenGL. The projection transform maps the 3D scene to clip coordinates. The rendered image will show the contents of the cube in the clip coordinate system that contains x, y, and z values in the range from -1 to 1; anything outside that range is &quot;clipped&quot; away.">clip coordinates</abbr> that are actually used for drawing the primitive. Alternatively, the modelview and <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> matrices can be multiplied together to get a <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> that represents the combined transformation; <abbr title="The coordinate system in which the coordinates for points in an object are originally specified, before they are transformed by any modeling or other transform that will be applied to the object.">object coordinates</abbr> can then be multiplied by that <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> to transform them directly into <abbr title="The default coordinate system in OpenGL. The projection transform maps the 3D scene to clip coordinates. The rendered image will show the contents of the cube in the clip coordinate system that contains x, y, and z values in the range from -1 to 1; anything outside that range is &quot;clipped&quot; away.">clip coordinates</abbr>.</p>
<p>In the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program, coordinate transforms are usually represented as <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> uniform variables of type <strong><em>mat4</em></strong>. The <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program can use either separate <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> and modelview matrices or a combined <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> (or both). Sometimes, a separate modelview transform <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> is required, because certain <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> calculations are done in <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr>, but here is a minimal <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 1.00 <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> that uses a combined <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>:</p>
<div class="highlight"><pre><span></span><code><span class="nx">attribute</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">a_coords</span><span class="p">;</span><span class="w">           </span><span class="c1">// (x,y,z) object coordinates of vertex.</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">mat4</span><span class="w"> </span><span class="nx">modelviewProjection</span><span class="p">;</span><span class="w">  </span><span class="c1">// Combined transformation matrix.</span>
<span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="nx">a_coords</span><span class="p">,</span><span class="mf">1.0</span><span class="p">);</span><span class="w">   </span><span class="c1">// Add 1.0 for the w-coordinate.</span>
<span class="w">    </span><span class="nx">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">modelviewProjection</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">coords</span><span class="p">;</span><span class="w">  </span><span class="c1">// Transform the coordinates.</span>
<span class="p">}</span>
</code></pre></div>
<p>This <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> is from the sample program <a href="../../../en/source/webgl/glmatrix-cube-unlit.html">webgl/glmatrix-cube-unlit.html</a>. That program lets the user view a colored cube, using just basic color with no <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> applied. The user can select either an orthographic or a <abbr title="A projection from 3D to 2D that projects objects along lines radiating out from a viewpoint. A perspective projection attempts to simulate realistic viewing. A perspective projection preserves perspective; that is, objects that are farther from the viewpoint are smaller in the projection. In OpenGL 1.1, the view volume for a perspective projection is a frustum, or truncated pyramid.">perspective projection</abbr> and can rotate the cube using the keyboard. The <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> is applied as a <abbr title="A transformation that is applied to an object to map that object into the world coordinate system or into the object coordinate system for a more complex, hierarchical object.">modeling transformation</abbr> consisting of separate rotations about the x-, y-, and z-axes. For transformation matrices on the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side, the program uses the <strong><em>mat4</em></strong> class from the <abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr> library to represent the <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr>, modelview, and combined transformation matrices:</p>
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">projection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">mat4</span><span class="p">.</span><span class="nx">create</span><span class="p">();</span><span class="w">  </span><span class="c1">// projection matrix</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">modelview</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">mat4</span><span class="p">.</span><span class="nx">create</span><span class="p">();</span><span class="w">   </span><span class="c1">// modelview matrix</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">modelviewProjection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">mat4</span><span class="p">.</span><span class="nx">create</span><span class="p">();</span><span class="w">  </span><span class="c1">// combined matrix</span>
</code></pre></div>
<p>(These variables can be <em>const</em> since the same <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> objects will be used throughout the program, even though the numbers in the objects will change.) Only <em>modelviewProjection</em> corresponds to a <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> variable. The location of that variable in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program is obtained during initialization using</p>
<div class="highlight"><pre><span></span><code><span class="nx">u_modelviewProjection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getUniformLocation</span><span class="p">(</span><span class="nx">prog</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;modelviewProjection&quot;</span><span class="p">);</span>
</code></pre></div>
<p>The transformation matrices are computed in the <em>draw()</em> function, using functions from the <em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em> <strong><em>mat4</em></strong> class. The value for <em>modelviewProjection</em> is sent to the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program using <em>gl.uniformMatrix4fv</em> before the primitives that make up the cube are drawn. Here is the code that does it:</p>
<div class="highlight"><pre><span></span><code><span class="cm">/* Set the value of projection to represent the projection transformation */</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;persproj&quot;</span><span class="p">).</span><span class="nx">checked</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">mat4</span><span class="p">.</span><span class="nx">perspective</span><span class="p">(</span><span class="nx">projection</span><span class="p">,</span><span class="w"> </span><span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="o">/</span><span class="mf">5</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">4</span><span class="p">,</span><span class="w"> </span><span class="mf">8</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">mat4</span><span class="p">.</span><span class="nx">ortho</span><span class="p">(</span><span class="nx">projection</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">4</span><span class="p">,</span><span class="w"> </span><span class="mf">8</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Set the value of modelview to represent the viewing transform. */</span>

<span class="nx">mat4</span><span class="p">.</span><span class="nx">lookAt</span><span class="p">(</span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mf">2</span><span class="p">,</span><span class="mf">2</span><span class="p">,</span><span class="mf">6</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">]);</span>

<span class="cm">/* Apply the modeling transformation to modelview. */</span>

<span class="nx">mat4</span><span class="p">.</span><span class="nx">rotateX</span><span class="p">(</span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">rotateX</span><span class="p">);</span>
<span class="nx">mat4</span><span class="p">.</span><span class="nx">rotateY</span><span class="p">(</span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">rotateY</span><span class="p">);</span>
<span class="nx">mat4</span><span class="p">.</span><span class="nx">rotateZ</span><span class="p">(</span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">rotateZ</span><span class="p">);</span>

<span class="cm">/* Multiply the projection matrix times the modelview matrix to give the</span>
<span class="cm">combined transformation matrix, and send that to the shader program. */</span>

<span class="nx">mat4</span><span class="p">.</span><span class="nx">multiply</span><span class="p">(</span><span class="w"> </span><span class="nx">modelviewProjection</span><span class="p">,</span><span class="w"> </span><span class="nx">projection</span><span class="p">,</span><span class="w"> </span><span class="nx">modelview</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">uniformMatrix4fv</span><span class="p">(</span><span class="nx">u_modelviewProjection</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="nx">modelviewProjection</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>If separate modelview and <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> matrices are used in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program, then the modelview <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> can be applied to transform <abbr title="The coordinate system in which the coordinates for points in an object are originally specified, before they are transformed by any modeling or other transform that will be applied to the object.">object coordinates</abbr> to <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr>, and the <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> can then be applied to the <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr> to compute <em>gl_Position</em>. Here is a minimal <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> that does that:</p>
<div class="highlight"><pre><span></span><code><span class="nx">attribute</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">a_coords</span><span class="p">;</span><span class="w">  </span><span class="c1">// (x,y,z) object coordinates of vertex.</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">mat4</span><span class="w"> </span><span class="nx">modelview</span><span class="p">;</span><span class="w">   </span><span class="c1">// Modelview transformation.</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">mat4</span><span class="w"> </span><span class="nx">projection</span><span class="p">;</span><span class="w">  </span><span class="c1">// Projection transformation</span>
<span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="nx">a_coords</span><span class="p">,</span><span class="mf">1.0</span><span class="p">);</span><span class="w">      </span><span class="c1">// Add 1.0 for w-coordinate.</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">eyeCoords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">modelview</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">coords</span><span class="p">;</span><span class="w">   </span><span class="c1">// Apply modelview transform.</span>
<span class="w">    </span><span class="nx">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">projection</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">eyeCoords</span><span class="p">;</span><span class="w">  </span><span class="c1">// Apply projection transform.</span>
<span class="p">}</span>
</code></pre></div>
</div>
</div>
</div>
<h2 id="714-变换法线">7.1.4 变换法线<a class="headerlink" href="#714-变换法线" title="Permanent link">&para;</a></h2>
<p><strong>Transforming Normals</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="5:2"><input checked="checked" id="__tabbed_5_1" name="__tabbed_5" type="radio" /><input id="__tabbed_5_2" name="__tabbed_5" type="radio" /><div class="tabbed-labels"><label for="__tabbed_5_1">中文</label><label for="__tabbed_5_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>法向量对于光照计算至关重要（见<a href="../../c4/s1/#413-法向量">4.1.3小节</a>）。当一个表面以某种方式变换时，似乎该表面的法向量也会改变。然而，如果变换是平移，情况并非如此。法向量指示表面朝向的方向。平移表面不会改变表面朝向的方向，因此法向量保持不变。记住，向量没有位置，只有长度和方向。所以甚至谈论移动或平移向量都没有意义。</p>
<p>你的第一个猜测可能是法向量应该通过变换的旋转/缩放部分来变换。猜测正确的变换由3x3矩阵表示，该矩阵是通过从4x4坐标变换矩阵中丢弃右列和底行获得的。（右列表示变换的平移部分，底行之所以存在，是因为在矩阵中实现平移需要使用齐次坐标来表示向量。法向量在不考虑平移的情况下不使用齐次坐标。）但这在所有情况下都不可能是正确的。例如，考虑一个剪切变换。正如这个插图所示，如果对象的法向量与对象一样经受相同的剪切变换，得到的向量将不会与对象垂直：</p>
<p><a class="glightbox" href="../../../en/c7/normal-transform.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c7/normal-transform.png" /></a></p>
<p>尽管如此，仍然可以从坐标变换矩阵中获得法向量的正确变换矩阵。事实证明，你需要丢弃第四行和第四列，然后取一个叫做“逆转置”的东西，这个3x3矩阵的结果是已知的。你不需要知道这意味着什么或为什么它有效。glMatrix库会为你计算它。你需要的函数是<em>normalFromMat4</em>，它在<strong><em>mat3</em></strong>类中定义：</p>
<div class="highlight"><pre><span></span><code><span class="nx">mat3</span><span class="p">.</span><span class="nx">normalFromMat4</span><span class="p">(</span><span class="w"> </span><span class="nx">normalMatrix</span><span class="p">,</span><span class="w"> </span><span class="nx">coordinateMatrix</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>在这个函数调用中，<em>coordinateMatrix</em>是表示应用于坐标的变换的<strong><em>mat4</em></strong>，normalMatrix是一个已经存在的<strong><em>mat3</em></strong>。这个函数计算<em>coordinateMatrix</em>的旋转/缩放部分的逆转置，并将答案放在<em>normalMatrix</em>中。由于我们需要法向量进行光照计算，而光照计算是在眼睛坐标中完成的，我们通常感兴趣的坐标变换是模型视图变换。</p>
<p>法向量应该发送到着色器程序中，在那里需要它来变换法向量，以便在光照计算中使用。光照需要单位法向量，即长度为一的法向量。法向量矩阵通常不保留它应用的向量的长度，因此将需要规范化变换后的向量。GLSL有内置函数用于规范化向量。实现光照的顶点着色器可能采用以下形式：</p>
<div class="highlight"><pre><span></span><code><span class="nx">attribute</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">a_coords</span><span class="p">;</span><span class="w">   </span><span class="c1">// 未变换的对象坐标。</span>
<span class="nx">attribute</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">normal</span><span class="p">;</span><span class="w">     </span><span class="c1">// 法向量。</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">mat4</span><span class="w"> </span><span class="nx">projection</span><span class="p">;</span><span class="w">   </span><span class="c1">// 投影变换矩阵。</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">mat4</span><span class="w"> </span><span class="nx">modelview</span><span class="p">;</span><span class="w">    </span><span class="c1">// 模型视图变换矩阵。</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">mat3</span><span class="w"> </span><span class="nx">normalMatrix</span><span class="p">;</span><span class="w"> </span><span class="c1">// 法向量的变换矩阵。</span>
<span class="p">.</span>
<span class="p">.</span><span class="w">  </span><span class="c1">// 定义光和材质属性的变量。</span>
<span class="p">.</span>
<span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="nx">a_coords</span><span class="p">,</span><span class="mf">1.0</span><span class="p">);</span><span class="w">  </span><span class="c1">// 为w坐标添加1.0。</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">eyeCoords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">modelview</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">coords</span><span class="p">;</span><span class="w">  </span><span class="c1">// 变换到眼睛坐标。</span>
<span class="w">    </span><span class="nx">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">projection</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">eyeCoords</span><span class="p">;</span><span class="w">  </span><span class="c1">// 变换到裁剪坐标。</span>
<span class="w">    </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">transformedNormal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">normalMatrix</span><span class="o">*</span><span class="nx">normal</span><span class="p">;</span><span class="w">  </span><span class="c1">// 变换法向量。</span>
<span class="w">    </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">unitNormal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">normalize</span><span class="p">(</span><span class="nx">transformedNormal</span><span class="p">);</span><span class="w">  </span><span class="c1">// 规范化。</span>
<span class="w">    </span><span class="p">.</span>
<span class="w">    </span><span class="p">.</span><span class="w">  </span><span class="c1">// 使用eyeCoords, unitNormal和光和材质属性</span>
<span class="w">    </span><span class="p">.</span><span class="w">  </span><span class="c1">// 计算顶点的颜色。</span>
<span class="w">    </span><span class="p">.</span>
<span class="p">}</span>
</code></pre></div>
<p>我们将在<a href="../s2/">下一节</a>中看几个具体的例子。</p>
<p>我会注意到GLSL ES 3.00（但不是GLSL ES 1.00）有内置函数用于计算矩阵的逆和转置，这使得在着色器中计算法向量矩阵相对容易。然而，在JavaScript方面一次性计算矩阵可能仍然比在每个顶点着色器的执行中计算它更有效率。</p>
</div>
<div class="tabbed-block">
<p>Normal vectors are essential for <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> calculations (<a href="../../c4/s1/#413-法向量">Subsection 4.1.3</a>). When a surface is transformed in some way, it seems that the normal vectors to that surface will also change. However, that is not true if the transformation is a <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr>. A <abbr title="A normal vector to a surface at a point on that surface is a vector that is perpendicular to the surface at that point. Normal vectors to curves are defined similarly. Normal vectors are important for lighting calculations.">normal vector</abbr> tells what direction a surface is facing. Translating the surface does not change the direction in which the surface is facing, so the <abbr title="A normal vector to a surface at a point on that surface is a vector that is perpendicular to the surface at that point. Normal vectors to curves are defined similarly. Normal vectors are important for lighting calculations.">normal vector</abbr> remains the same. Remember that a <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> doesn't have a position, just a length and a direction. So it doesn't even make sense to talk about moving or translating a <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr>.</p>
<p>Your first guess might be that the <abbr title="A normal vector to a surface at a point on that surface is a vector that is perpendicular to the surface at that point. Normal vectors to curves are defined similarly. Normal vectors are important for lighting calculations.">normal vector</abbr> should be transformed by just the <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr>/<abbr title="A geometric transform that multiplies each coordinate of a point by a number called the scaling factor. Scaling increases or decreases the size of an object, but also moves its points closer to or farther from the origin. Scaling can be uniform—the same in every direction—or non-uniform—with a different scaling factor in each coordinate direction. A negative scaling factor can be used to apply a reflection.">scaling</abbr> part of the transformation. The guess is that the correct transformation is represented by the 3-by-3 <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> that is obtained by dropping the right column and the bottom row from the 4-by-4 coordinate transformation <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>. (The right column represents the <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr> part of the transformation, and the bottom row is only there because implementing <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr> in a <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> requires the use of <abbr title="A way of representing n-dimensional vectors as (n+1)-dimensional vectors where two (n+1) vectors represent the same n-dimensional vector if they differ by a scalar multiple. In 3D, for example, if w is not zero, then the homogeneous coordinates (x,y,z,w) are equivalent to homogeneous coordinates (x/w,y/w,z/w,1), since they differ by multiplication by the scalar w. Both sets of coordinates represent the 3D vector (x/w,y/w,z/w)">homogeneous coordinates</abbr> to represent vectors. Normal vectors, where <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr> is not an issue, do not use <abbr title="A way of representing n-dimensional vectors as (n+1)-dimensional vectors where two (n+1) vectors represent the same n-dimensional vector if they differ by a scalar multiple. In 3D, for example, if w is not zero, then the homogeneous coordinates (x,y,z,w) are equivalent to homogeneous coordinates (x/w,y/w,z/w,1), since they differ by multiplication by the scalar w. Both sets of coordinates represent the 3D vector (x/w,y/w,z/w)">homogeneous coordinates</abbr>.) But that can't be correct in all cases. Consider, for example, a <abbr title="A shear transformation in 2D leaves some line, L, fixed, and lines perpendicular to L are &quot;tilted&quot; relative to L by the same angle. Another description is that a line parallel to L is mapped to itself, but is moved by an amount proportional to its distance from L. In 3D, a shear transformation leaves some plane, P, fixed, and it maps a plane parallel to P to itself, but moved by an amount proportional to its distance from P.">shear transform</abbr>. As this illustration shows, if the normal vectors to an object are subjected to the same shear transformation as the object, the resulting vectors will not be perpendicular to the object:</p>
<p><a class="glightbox" href="../../../en/c7/normal-transform.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c7/normal-transform.png" /></a></p>
<p>Nevertheless, it is possible to get the correct transformation <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> for normal vectors from the coordinate transformation <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>. It turns out that you need to drop the fourth row and the fourth column and then take something called the "inverse transpose" of the resulting 3-by-3 <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>. You don't need to know what that means or why it works. The <em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em> library will compute it for you. The function that you need is <em>normalFromMat4</em>, and it is defined in the <strong><em>mat3</em></strong> class:</p>
<div class="highlight"><pre><span></span><code><span class="nx">mat3</span><span class="p">.</span><span class="nx">normalFromMat4</span><span class="p">(</span><span class="w"> </span><span class="nx">normalMatrix</span><span class="p">,</span><span class="w"> </span><span class="nx">coordinateMatrix</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>In this function call, <em>coordinateMatrix</em> is the <strong><em>mat4</em></strong> that represents the transformation that is applied to coordinates, and normalMatrix is a <strong><em>mat3</em></strong> that already exists. This function computes the inverse transpose of the <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr>/scale part of <em>coordinateMatrix</em> and places the answer in <em>normalMatrix</em>. Since we need normal vectors for <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> calculations, and <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> calculations are done in <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr>, the coordinate transformation that we are interested in is usually the modelview transform.</p>
<p>The normal <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> should be sent to the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program, where it is needed to transform normal vectors for use in <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> calculations. Lighting requires <abbr title="A normal vector of length one; that is, a unit vector that is perpendicular to a curve or surface at a given point on the curve or surface.">unit normal</abbr> vectors, that is, normal vectors of length one. The normal <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> does not in general preserve the <abbr title="A vector is defined by its length and its direction, so length is a fundamental property. When a vector is represented as an arrow, its length is just the length of that arrow. For a 2D vector given by coordinates (x,y), the length is the square root of `x*x+y*y`. For a 3D vector given as (x,y,z), the length is the square root of `x*x+y*y+z*z`.">length of a vector</abbr> to which it is applied, so it will be necessary to <abbr title="将非零向量除以其长度得到的单位向量的结果，即长度为一的向量。注意，“归一化向量”和“法向量”是两个无关的术语！">normalize</abbr> the transformed <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr>. <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> has a built-in function for normalizing vectors. A <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> that implements <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> might take the form:</p>
<div class="highlight"><pre><span></span><code><span class="nx">attribute</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">a_coords</span><span class="p">;</span><span class="w">   </span><span class="c1">// Untransformed object coordinates.</span>
<span class="nx">attribute</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">normal</span><span class="p">;</span><span class="w">     </span><span class="c1">// Normal vector.</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">mat4</span><span class="w"> </span><span class="nx">projection</span><span class="p">;</span><span class="w">   </span><span class="c1">// Projection transformation matrix.</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">mat4</span><span class="w"> </span><span class="nx">modelview</span><span class="p">;</span><span class="w">    </span><span class="c1">// Modelview transformation matrix.</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">mat3</span><span class="w"> </span><span class="nx">normalMatrix</span><span class="p">;</span><span class="w"> </span><span class="c1">// Transform matrix for normal vectors.</span>
<span class="p">.</span>
<span class="p">.</span><span class="w">  </span><span class="c1">// Variables to define light and material properties.</span>
<span class="p">.</span>
<span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="nx">a_coords</span><span class="p">,</span><span class="mf">1.0</span><span class="p">);</span><span class="w">  </span><span class="c1">// Add a 1.0 for the w-coordinate.</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">eyeCoords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">modelview</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">coords</span><span class="p">;</span><span class="w">  </span><span class="c1">// Transform to eye coordinates.</span>
<span class="w">    </span><span class="nx">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">projection</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">eyeCoords</span><span class="p">;</span><span class="w">  </span><span class="c1">// Transform to clip coordinates.</span>
<span class="w">    </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">transformedNormal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">normalMatrix</span><span class="o">*</span><span class="nx">normal</span><span class="p">;</span><span class="w">  </span><span class="c1">// Transform normal vector.</span>
<span class="w">    </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">unitNormal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">normalize</span><span class="p">(</span><span class="nx">transformedNormal</span><span class="p">);</span><span class="w">  </span><span class="c1">// Normalize.</span>
<span class="w">    </span><span class="p">.</span>
<span class="w">    </span><span class="p">.</span><span class="w">  </span><span class="c1">// Use eyeCoords, unitNormal, and light and material</span>
<span class="w">    </span><span class="p">.</span><span class="w">  </span><span class="c1">// properties to compute a color for the vertex.</span>
<span class="w">    </span><span class="p">.</span>
<span class="p">}</span>
</code></pre></div>
<p>We will look at several specific examples in the <a href="../s2/">next section</a>.</p>
<p>I will note that <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 3.00 (but not <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 1.00) has built-in functions for computing the inverse and the transpose of a <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>, making it fairly easy to compute the normal <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>. However, it might still be more efficient to compute the <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> once on the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side, rather than computing it in every execution of the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>.</p>
</div>
</div>
</div>
<h2 id="715-鼠标旋转">7.1.5 鼠标旋转<a class="headerlink" href="#715-鼠标旋转" title="Permanent link">&para;</a></h2>
<p><strong>Rotation by Mouse</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="6:2"><input checked="checked" id="__tabbed_6_1" name="__tabbed_6" type="radio" /><input id="__tabbed_6_2" name="__tabbed_6" type="radio" /><div class="tabbed-labels"><label for="__tabbed_6_1">中文</label><label for="__tabbed_6_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>计算机图形学在有用户交互时变得更有趣。通过让用户旋转场景，从不同方向查看，3D体验得到了极大的增强。<a href="../../../en/source/webgl/glmatrix-cube-unlit.html">未照明的立方体</a>示例允许用户使用键盘旋转场景。但是使用鼠标进行旋转可以给用户提供更好的控制。我编写了两个JavaScript类，<strong><em>SimpleRotator</em></strong>和<strong><em>TrackballRotator</em></strong>，来实现两种不同的鼠标旋转风格。</p>
<p><strong><em>SimpleRotator</em></strong>类在文件<a href="../../../en/source/webgl/simple-rotator.js">webgl/simple-rotator.js</a>中定义。要在网页上使用它，你需要在一个<code>&lt;script&gt;</code>标签中包含该文件，并且你需要创建一个类型为<strong><em>SimpleRotator</em></strong>的对象：</p>
<div class="highlight"><pre><span></span><code><span class="nx">rotator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">SimpleRotator</span><span class="p">(</span><span class="w"> </span><span class="nx">canvas</span><span class="p">,</span><span class="w"> </span><span class="nx">callback</span><span class="p">,</span><span class="w"> </span><span class="nx">viewDistance</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>第一个参数必须是一个DOM <code>&lt;canvas&gt;</code>元素。它应该是WebGL渲染场景的画布。<strong><em>SimpleRotator</em></strong>构造函数为画布添加了一个鼠标事件的监听器；它还处理触摸屏上的触摸事件。构造函数的第二个参数是可选的。如果它被定义，它必须是一个函数。每次旋转变化时，都会调用该函数，不带任何参数。通常，回调函数是渲染画布中图像的函数。第三个参数也是可选的。如果定义了，它必须是一个非负数。它给出了观察者从旋转中心的距离。默认值是零，这对于正交投影可能没问题，但通常不正确。</p>
<p><strong><em>SimpleRotator</em></strong>跟踪一个随着用户旋转场景而变化的观察变换。最重要的函数是<em>rotator.getViewMatrix()</em>。这个函数返回一个包含16个数字的数组，代表列主序的观察变换矩阵。这个矩阵可以直接使用<em>gl.uniformMatrix4fv</em>发送到着色器程序，或者可以作为模型视图矩阵的初始值与<em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em>库的函数一起使用。</p>
<p>示例程序<a href="../../../en/source/webgl/cube-with-simple-rotator.html">webgl/cube-with-simple-rotator.html</a>是使用<strong><em>SimpleRotator</em></strong>的一个例子。该程序使用由glMatrix函数定义的透视投影</p>
<div class="highlight"><pre><span></span><code><span class="nx">mat4</span><span class="p">.</span><span class="nx">perspective</span><span class="p">(</span><span class="nx">projection</span><span class="p">,</span><span class="w"> </span><span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="o">/</span><span class="mf">8</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">8</span><span class="p">,</span><span class="w"> </span><span class="mf">12</span><span class="p">);</span>
</code></pre></div>
<p>旋转器的<em>viewDistance</em>必须在投影中的<em>near</em>和<em>far</em>距离之间。这里，<em>near</em>是8，<em>far</em>是12，<em>viewDistance</em>可以设置为10。旋转器是在初始化期间使用语句创建的</p>
<div class="highlight"><pre><span></span><code><span class="nx">rotator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">SimpleRotator</span><span class="p">(</span><span class="nx">canvas</span><span class="p">,</span><span class="w"> </span><span class="nx">draw</span><span class="p">,</span><span class="w"> </span><span class="mf">10</span><span class="p">);</span>
</code></pre></div>
<p>在<em>draw()</em>函数中，在绘制场景之前，从旋转器获取观察变换。这个程序中没有建模变换，所以视图矩阵也是模型视图矩阵。使用glMatrix函数将该矩阵与投影矩阵相乘，并将组合变换矩阵发送到着色器程序：</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">modelview</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">rotator</span><span class="p">.</span><span class="nx">getViewMatrix</span><span class="p">();</span>

<span class="nx">mat4</span><span class="p">.</span><span class="nx">multiply</span><span class="p">(</span><span class="w"> </span><span class="nx">modelviewProjection</span><span class="p">,</span><span class="w"> </span><span class="nx">projection</span><span class="p">,</span><span class="w"> </span><span class="nx">modelview</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">uniformMatrix4fv</span><span class="p">(</span><span class="nx">u_modelviewProjection</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="nx">modelviewProjection</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>如果你只是想在自己的程序中使用<strong><em>SimpleRotator</em></strong>，你只需要知道这些。我还编写了一个替代的旋转器类<strong><em>TrackballRotator</em></strong>，它在JavaScript文件<a href="../../../en/source/webgl/trackball-rotator.js">webgl/trackball-rotator.js</a>中定义。<strong><em>TrackballRotator</em></strong>可以像<strong><em>SimpleRotator</em></strong>一样使用。主要的区别在于<strong><em>TrackballRotator</em></strong>允许完全自由的旋转，而<strong><em>SimpleRotator</em></strong>有一个约束，即y轴在图像中始终保持垂直。</p>
<p>示例程序<a href="../../../en/source/webgl/cube-with-trackball-rotator.html">webgl/cube-with-trackball-rotator.html</a>使用了一个TrackballRotator，但除此之外与<strong><em>SimpleRotator</em></strong>示例相同。以下演示让你尝试两种类型的旋转器。左侧的立方体使用了<strong><em>SimpleRotator</em></strong>，右侧使用了TrackballRotator：</p>
<p><iframe src="../../../en/demos/c7/rotators.html" width="660" height="380"></iframe></p>
<p>默认情况下，无论原点是否在图像中心，任何类型的旋转器的旋转中心都是原点。然而，你可以通过调用<em><abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr>.setRotationCenter([a,b,c])</em>来改变旋转中心为点<em>(a,b,c)</em>。参数必须是一个包含三个数字的数组。通常，<em>(a,b,c)</em>将是图像中心显示的点（在<em>gluLookAt</em>中将是视图参考点）。</p>
<hr />
<p>你不需要理解实现旋转器所使用的数学。实际上，<strong><em>TrackballRotator</em></strong> 使用了一些我在这里不想解释的高级技术。然而，<strong><em>SimpleRotator</em></strong> 比较简单，了解它的工作原理是很好的。所以，我将解释<strong><em>SimpleRotator</em></strong> 的视图变换是如何计算的。实际上，考虑整体场景上的相应建模变换会更容易（回想一下建模和视图的等价性<a href="../../c3/s3/#334-模型视图转换">3.3.4小节</a>）。</p>
<p>建模变换包括绕y轴的旋转，然后是绕x轴的旋转。旋转的大小随着用户拖动鼠标而变化。左右移动控制绕y轴的旋转，而上下移动控制绕x轴的旋转。绕x轴的旋转被限制在-85到85度的范围内。注意，绕y轴的旋转，然后绕x轴的旋转，在投影到屏幕上时，总是使y轴指向垂直方向。</p>
<p>假设旋转中心是<em>(tx,ty,tz)</em>而不是(0,0,0)。为了实现这一点，在进行旋转之前，我们需要平移场景，将点<em>(tx,ty,tz)</em>移动到原点。我们可以通过<em>(-tx,-ty,-tz)</em>进行平移来实现。然后，在进行旋转之后，我们需要将原点平移回点<em>(tx,ty,tz)</em>。</p>
<p>最后，如果<em>viewDistance</em>不为零，我们需要将场景推离观察者<em>viewDistance</em>单位。我们可以通过<em>(0,0,-viewDistance)</em>进行平移来实现。如果<em>d</em>是视图距离，<em>ry</em>是绕y轴的旋转，rx是绕x轴的旋转，那么我们需要对场景应用的建模变换序列如下：</p>
<ol>
<li>将视图中心移动到原点：<abbr title="一种几何变换，它将点的每个坐标添加给定的平移量。平移用于移动对象而不改变其大小或方向。">平移</abbr><em>(-tx,-ty,-tz)</em>。</li>
<li>绕y轴旋转ry弧度的场景。</li>
<li>绕x轴旋转rx弧度的场景。</li>
<li>将原点移回视图中心：<abbr title="一种几何变换，它将点的每个坐标添加给定的平移量。平移用于移动对象而不改变其大小或方向。">平移</abbr><em>(tx,ty,tz)</em>。</li>
<li>将场景远离观察者：<abbr title="一种几何变换，它将点的每个坐标添加给定的平移量。平移用于移动对象而不改变其大小或方向。">平移</abbr><em>(0,0,-d)</em>。</li>
</ol>
<p>请记住，建模变换是按照与代码中发生的顺序相反的顺序应用于对象的，视图矩阵可以通过以下<em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em>命令创建：</p>
<div class="highlight"><pre><span></span><code><span class="nx">viewmatrix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">mat4</span><span class="p">.</span><span class="nx">create</span><span class="p">();</span>
<span class="nx">mat4</span><span class="p">.</span><span class="nx">translate</span><span class="p">(</span><span class="nx">viewmatrix</span><span class="p">,</span><span class="w"> </span><span class="nx">viewmatrix</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="o">-</span><span class="nx">d</span><span class="p">]);</span>
<span class="nx">mat4</span><span class="p">.</span><span class="nx">translate</span><span class="p">(</span><span class="nx">viewmatrix</span><span class="p">,</span><span class="w"> </span><span class="nx">viewmatrix</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="nx">tx</span><span class="p">,</span><span class="nx">ty</span><span class="p">,</span><span class="nx">tz</span><span class="p">]);</span>
<span class="nx">mat4</span><span class="p">.</span><span class="nx">rotateX</span><span class="p">(</span><span class="nx">viewmatrix</span><span class="p">,</span><span class="w"> </span><span class="nx">viewmatrix</span><span class="p">,</span><span class="w"> </span><span class="nx">rx</span><span class="p">);</span>
<span class="nx">mat4</span><span class="p">.</span><span class="nx">rotateY</span><span class="p">(</span><span class="nx">viewmatrix</span><span class="p">,</span><span class="w"> </span><span class="nx">viewmatrix</span><span class="p">,</span><span class="w"> </span><span class="nx">ry</span><span class="p">);</span>
<span class="nx">mat4</span><span class="p">.</span><span class="nx">translate</span><span class="p">(</span><span class="nx">viewmatrix</span><span class="p">,</span><span class="w"> </span><span class="nx">viewmatrix</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">-</span><span class="nx">tx</span><span class="p">,</span><span class="o">-</span><span class="nx">ty</span><span class="p">,</span><span class="o">-</span><span class="nx">tz</span><span class="p">]);</span>
</code></pre></div>
<p>实际上，在我的代码中，我直接根据各个变换的矩阵创建视图矩阵。旋转和平移的4x4矩阵在<a href="../../c3/s5/#352-矩阵和变换">3.5.2小节</a>中给出。一个<strong><em>SimpleRotator</em></strong>的视图矩阵是五个平移和旋转矩阵的矩阵乘积：</p>
<p><a class="glightbox" href="../../../en/c7/matrices-for-simple-rotator.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c7/matrices-for-simple-rotator.png" /></a></p>
<p>实际上，实现乘法并不太难。如果你好奇，可以看看JavaScript文件<a href="../../../en/source/webgl/simple-rotator.js">webgl/simple-rotator.js</a>。</p>
</div>
<div class="tabbed-block">
<p>Computer graphics is a lot more interesting when there is user interaction. The 3D experience is enhanced considerably just by letting the user rotate the scene, to view it from various directions. The <a href="../../../en/source/webgl/glmatrix-cube-unlit.html">unlit cube</a> example lets the user rotate the scene using the keyboard. But using the mouse for <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> gives the user much better control. I have written two <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> classes, <strong><em>SimpleRotator</em></strong> and <strong><em>TrackballRotator</em></strong>, to implement two different styles of <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr>-by-mouse.</p>
<p>The <strong><em>SimpleRotator</em></strong> class is defined in the file <a href="../../../en/source/webgl/simple-rotator.js">webgl/simple-rotator.js</a>. To use it on a web page, you need to include that file in a <code>&lt;script&gt;</code> tag, and you need to create an object of type <strong><em>SimpleRotator</em></strong>:</p>
<div class="highlight"><pre><span></span><code><span class="nx">rotator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">SimpleRotator</span><span class="p">(</span><span class="w"> </span><span class="nx">canvas</span><span class="p">,</span><span class="w"> </span><span class="nx">callback</span><span class="p">,</span><span class="w"> </span><span class="nx">viewDistance</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>The first parameter must be a <abbr title="Document Object Model. A specification for representing a web page (and other kinds of structured document) as a tree-like data structure. Can also refer to the data structure itself, as in &quot;the DOM for this web page.&quot; A web page can be modified dynamically by manipulating its DOM, using the JavaScript programming language.">DOM</abbr> <code>&lt;canvas&gt;</code> element. It should be the canvas where <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> renders the scene. The <strong><em>SimpleRotator</em></strong> <abbr title="In object-oriented programming, a subroutine that is used to create objects. A constructor for a class creates and initializes objects belonging to that class.">constructor</abbr> adds a listener for mouse events to the canvas; it also handles touch events on a touchscreen. The second parameter to the <abbr title="In object-oriented programming, a subroutine that is used to create objects. A constructor for a class creates and initializes objects belonging to that class.">constructor</abbr> is optional. If it is defined, it must be a function. The function is called, with no parameters, each time the <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> changes. Typically, the callback function is the function that renders the image in the canvas. The third parameter is also optional. If defined, it must be a non-negative number. It gives the distance of the viewer from the center of <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr>. The default value is zero, which can be OK for an <abbr title="A projection from 3D to 2D that simply discards the z-coordinate. It projects objects along lines that are orthogonal (perpendicular) to the xy-plane. In OpenGL 1.1, the view volume for an orthographic projection is a rectangular solid.">orthographic projection</abbr> but is usually not correct.</p>
<p>A <strong><em>SimpleRotator</em></strong> keeps track of a <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transformation that changes as the user rotates the scene. The most important function is <em>rotator.getViewMatrix()</em>. This function returns an array of 16 numbers representing the <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> for the <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transformation in <abbr title="Column-by-column ordering of the elements of a two-dimensional matrix; that is, an ordering that starts with the elements in the first column, followed by the elements in the second column, and so on. Column-major order is used for matrices in OpenGL and GLSL.">column-major order</abbr>. The <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> can be sent directly to the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program using <em>gl.uniformMatrix4fv</em>, or it can be used with functions from the <em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em> library as the initial value of the modelview <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>.</p>
<p>The sample program <a href="../../../en/source/webgl/cube-with-simple-rotator.html">webgl/cube-with-simple-rotator.html</a> is an example of using a <strong><em>SimpleRotator</em></strong>. The program uses a <abbr title="A projection from 3D to 2D that projects objects along lines radiating out from a viewpoint. A perspective projection attempts to simulate realistic viewing. A perspective projection preserves perspective; that is, objects that are farther from the viewpoint are smaller in the projection. In OpenGL 1.1, the view volume for a perspective projection is a frustum, or truncated pyramid.">perspective projection</abbr> defined by the <abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr> function</p>
<div class="highlight"><pre><span></span><code><span class="nx">mat4</span><span class="p">.</span><span class="nx">perspective</span><span class="p">(</span><span class="nx">projection</span><span class="p">,</span><span class="w"> </span><span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="o">/</span><span class="mf">8</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">8</span><span class="p">,</span><span class="w"> </span><span class="mf">12</span><span class="p">);</span>
</code></pre></div>
<p>The <em>viewDistance</em> for the rotator has to be between the <em>near</em> and <em>far</em> distances in the <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr>. Here, <em>near</em> is 8 and <em>far</em> is 12, and the <em>viewDistance</em> can be set to 10. The rotator is created during initialization using the statement</p>
<div class="highlight"><pre><span></span><code><span class="nx">rotator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">SimpleRotator</span><span class="p">(</span><span class="nx">canvas</span><span class="p">,</span><span class="w"> </span><span class="nx">draw</span><span class="p">,</span><span class="w"> </span><span class="mf">10</span><span class="p">);</span>
</code></pre></div>
<p>In the <em>draw()</em> function, the <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transformation is obtained from the rotator before drawing the scene. There is no <abbr title="A transformation that is applied to an object to map that object into the world coordinate system or into the object coordinate system for a more complex, hierarchical object.">modeling transformation</abbr> in this program, so the view <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> is also the modelview <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>. That <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> is multiplied by the <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> using a <abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr> function, and the combined transformation <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> is sent to the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">modelview</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">rotator</span><span class="p">.</span><span class="nx">getViewMatrix</span><span class="p">();</span>

<span class="nx">mat4</span><span class="p">.</span><span class="nx">multiply</span><span class="p">(</span><span class="w"> </span><span class="nx">modelviewProjection</span><span class="p">,</span><span class="w"> </span><span class="nx">projection</span><span class="p">,</span><span class="w"> </span><span class="nx">modelview</span><span class="w"> </span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">uniformMatrix4fv</span><span class="p">(</span><span class="nx">u_modelviewProjection</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="nx">modelviewProjection</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>That's really all that you need to know if you just want to use <strong><em>SimpleRotator</em></strong> in your own programs. I have also written an alternative rotator class, <strong><em>TrackballRotator</em></strong>, which is defined in the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> file <a href="../../../en/source/webgl/trackball-rotator.js">webgl/trackball-rotator.js</a>. A <strong><em>TrackballRotator</em></strong> can be used in the same way as a <strong><em>SimpleRotator</em></strong>. The main difference is that a <strong><em>TrackballRotator</em></strong> allows completely free <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> while a <strong><em>SimpleRotator</em></strong> has the constraint that the y-axis will always remain vertical in the image.</p>
<p>The sample program <a href="../../../en/source/webgl/cube-with-trackball-rotator.html">webgl/cube-with-trackball-rotator.html</a> uses a TrackballRotator, but is otherwise identical to the <strong><em>SimpleRotator</em></strong> example. The following demo lets you try out both types of rotator. A <strong><em>SimpleRotator</em></strong> is used for the cube on the left, and a TrackballRotator is used on the right:</p>
<p><iframe src="../../../en/demos/c7/rotators.html" width="660" height="380"></iframe></p>
<p>By default, the center of <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> for either type of rotator is the origin, even if the origin is not at the center of the image. However, you can change the center of <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> to be the point <em>(a,b,c)</em> by calling <em><abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr>.setRotationCenter([a,b,c])</em>. The parameter must be an array of three numbers. Typically, <em>(a,b,c)</em> would be the point displayed at the center of the image (the point that would be the view reference point in <em>gluLookAt</em>).</p>
<hr />
<p>You don't need to understand the mathematics that is used to implement a rotator. In fact, <strong><em>TrackballRotator</em></strong> uses some advanced techniques that I don't want to explain here. However, <strong><em>SimpleRotator</em></strong> is, well, more simple, and it's nice to know how it works. So, I will explain how the view transformation is computed for a <strong><em>SimpleRotator</em></strong>. Actually, it will be easier to think in terms of the corresponding <abbr title="A transformation that is applied to an object to map that object into the world coordinate system or into the object coordinate system for a more complex, hierarchical object.">modeling transformation</abbr> on the scene as a whole. (Recall the equivalence between modeling and <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> (<a href="../../c3/s3/#334-模型视图转换">Subsection 3.3.4</a>).)</p>
<p>The <abbr title="A transformation that is applied to an object to map that object into the world coordinate system or into the object coordinate system for a more complex, hierarchical object.">modeling transformation</abbr> includes a <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> about the y-axis followed by a <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> about the x-axis. The sizes of the rotations change as the user drags the mouse. Left/right motion controls the <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> about the y-axis, while up/down motion controls the <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> about the x-axis. The <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> about the x-axis is restricted to lie in the range −85 to 85 degrees. Note that a <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> about the y-axis followed by a <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> about the x-axis always leaves the y-axis pointing in a vertical direction when <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projected</abbr> onto the screen.</p>
<p>Suppose the center of <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> is <em>(tx,ty,tz)</em> instead of (0,0,0). To implement that, before doing the rotations, we need to translate the scene to move the point <em>(tx,ty,tz)</em> to the origin. We can do that with a <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr> by <em>(-tx,-ty,-tz)</em>. Then, after doing the <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr>, we need to translate the origin back to the point <em>(tx,ty,tz)</em>.</p>
<p>Finally, if the <em>viewDistance</em> is not zero, we need to push the scene <em>viewDistance</em> units away from the viewer. We can do that with a <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr> by <em>(0,0,-viewDistance)</em>. If <em>d</em> is the view distance, <em>ry</em> is the <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> about the y-axis, and rx is the <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> about the x-axis, then the sequence of modeling transformations that we need to apply to the scene is as follows:</p>
<ol>
<li>Move the view center to the origin: Translate by (-tx,-ty,-tz).</li>
<li>Rotate the scene by ry radians about the y-axis.</li>
<li>Rotate the scene by rx radians about the x-axis.</li>
<li>Move the origin back to view center: Translate by (tx,ty,tz).</li>
<li>Move the scene away from the viewer: Translate by (0,0,-d).</li>
</ol>
<p>Keeping in mind that modeling transformations are applied to objects in the opposite of the order in which they occur in the code, the view <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> could be created by the following <em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em> commands:</p>
<div class="highlight"><pre><span></span><code><span class="nx">viewmatrix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">mat4</span><span class="p">.</span><span class="nx">create</span><span class="p">();</span>
<span class="nx">mat4</span><span class="p">.</span><span class="nx">translate</span><span class="p">(</span><span class="nx">viewmatrix</span><span class="p">,</span><span class="w"> </span><span class="nx">viewmatrix</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="o">-</span><span class="nx">d</span><span class="p">]);</span>
<span class="nx">mat4</span><span class="p">.</span><span class="nx">translate</span><span class="p">(</span><span class="nx">viewmatrix</span><span class="p">,</span><span class="w"> </span><span class="nx">viewmatrix</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="nx">tx</span><span class="p">,</span><span class="nx">ty</span><span class="p">,</span><span class="nx">tz</span><span class="p">]);</span>
<span class="nx">mat4</span><span class="p">.</span><span class="nx">rotateX</span><span class="p">(</span><span class="nx">viewmatrix</span><span class="p">,</span><span class="w"> </span><span class="nx">viewmatrix</span><span class="p">,</span><span class="w"> </span><span class="nx">rx</span><span class="p">);</span>
<span class="nx">mat4</span><span class="p">.</span><span class="nx">rotateY</span><span class="p">(</span><span class="nx">viewmatrix</span><span class="p">,</span><span class="w"> </span><span class="nx">viewmatrix</span><span class="p">,</span><span class="w"> </span><span class="nx">ry</span><span class="p">);</span>
<span class="nx">mat4</span><span class="p">.</span><span class="nx">translate</span><span class="p">(</span><span class="nx">viewmatrix</span><span class="p">,</span><span class="w"> </span><span class="nx">viewmatrix</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">-</span><span class="nx">tx</span><span class="p">,</span><span class="o">-</span><span class="nx">ty</span><span class="p">,</span><span class="o">-</span><span class="nx">tz</span><span class="p">]);</span>
</code></pre></div>
<p>In fact, in my code, I create the view <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> directly, based on the matrices for the individual transformations. The 4-by-4 matrices for <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> and <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr> are given in <a href="../../c3/s5/#352-矩阵和变换">Subsection 3.5.2</a>. The view <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> for a <strong><em>SimpleRotator</em></strong> is the <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> product of five <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr> and <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> matrices:</p>
<p><a class="glightbox" href="../../../en/c7/matrices-for-simple-rotator.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c7/matrices-for-simple-rotator.png" /></a></p>
<p>It's actually not too difficult to implement the multiplication. See the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> file, <a href="../../../en/source/webgl/simple-rotator.js">webgl/simple-rotator.js</a>, if you are curious.</p>
</div>
</div>
</div>







  
    
  
  
    
  


  <aside class="md-source-file">
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="最后更新">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1-2.1-2M12.5 7v5.2l4 2.4-1 1L11 13V7h1.5M11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2v1.8Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">2024年6月15日</span>
  </span>

    
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="创建日期">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.47 15.08 11 13V7h1.5v5.25l3.08 1.83c-.41.28-.79.62-1.11 1m-1.39 4.84c-.36.05-.71.08-1.08.08-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8c0 .37-.03.72-.08 1.08.69.1 1.33.32 1.92.64.1-.56.16-1.13.16-1.72 0-5.5-4.5-10-10-10S2 6.5 2 12s4.47 10 10 10c.59 0 1.16-.06 1.72-.16-.32-.59-.54-1.23-.64-1.92M18 15v3h-3v2h3v3h2v-3h3v-2h-3v-3h-2Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">2024年5月26日</span>
  </span>

    
    
    
  </aside>





                
              </article>
            </div>
          
          
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var tab,labels=set.querySelector(".tabbed-labels");for(tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script>

<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../../..", "features": ["content.code.copy", "content.tabs.link", "navigation.tabs", "navigation.tabs.sticky", "navigation.indexes", "navigation.top", "toc.follow", "content.tooltips"], "search": "../../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.3220b9d7.min.js"></script>
      
        <script src="../../../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="https://unpkg.com/mermaid@9.4.0/dist/mermaid.min.js"></script>
      
    
  <script>document$.subscribe(() => {const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});})</script></body>
</html>