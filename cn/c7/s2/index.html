
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="计算机图形学概论(graphicsbook)">
      
      
      
        <link rel="canonical" href="https://hellowac.github.io/graphicsbook-zh-cn/cn/c7/s2/">
      
      
        <link rel="prev" href="../s1/">
      
      
        <link rel="next" href="../s3/">
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.5.18">
    
    
      
        <title>7.2 照明和材质 - 计算机图形学概论</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.66ac8b77.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.06af60db.min.css">
      
      

  
  
  
  
  <style>:root{--md-annotation-icon:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M22 12a10 10 0 0 1-10 10A10 10 0 0 1 2 12 10 10 0 0 1 12 2a10 10 0 0 1 10 10M6 13h8l-3.5 3.5 1.42 1.42L17.84 12l-5.92-5.92L10.5 7.5 14 11H6v2Z"/></svg>');}</style>


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
   <link href="../../../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
        html.glightbox-open { overflow: initial; height: 100%; }
        .gslide-title { margin-top: 0px; user-select: text; }
        .gslide-desc { color: #666; user-select: text; }
        .gslide-image img { background: white; }
        
            .gscrollbar-fixer { padding-right: 15px; }
            .gdesc-inner { font-size: 0.75rem; }
            body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
            body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
            body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}
            </style> <script src="../../../assets/javascripts/glightbox.min.js"></script></head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="default" data-md-color-accent="red">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#72-照明和材质" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="计算机图形学概论" class="md-header__button md-logo" aria-label="计算机图形学概论" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            计算机图形学概论
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              7.2 照明和材质
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
      <div class="md-header__option">
  <div class="md-select">
    
    <button class="md-header__button md-icon" aria-label="选择当前语言">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m12.87 15.07-2.54-2.51.03-.03A17.52 17.52 0 0 0 14.07 6H17V4h-7V2H8v2H1v2h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04M18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12m-2.62 7 1.62-4.33L19.12 17h-3.24Z"/></svg>
    </button>
    <div class="md-select__inner">
      <ul class="md-select__list">
        
          <li class="md-select__item">
            <a href="/graphicsbook-zh-cn/en/" hreflang="en" class="md-select__link">
              English
            </a>
          </li>
        
          <li class="md-select__item">
            <a href="/graphicsbook-zh-cn/cn/" hreflang="cn" class="md-select__link">
              中文
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</div>
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/hellowac/graphicsbook-zh-cn" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    graphicsbook
  </div>
</a>
      </div>
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../" class="md-tabs__link">
        
  
    
  
  首页

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../preface/" class="md-tabs__link">
        
  
    
  
  前言

      </a>
    </li>
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c1/" class="md-tabs__link">
          
  
    
  
  1.简介

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c2/" class="md-tabs__link">
          
  
    
  
  2.二维图形

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c3/" class="md-tabs__link">
          
  
    
  
  3.几何

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c4/" class="md-tabs__link">
          
  
    
  
  4.灯光和材质

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c5/" class="md-tabs__link">
          
  
    
  
  5.three.js

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c6/" class="md-tabs__link">
          
  
    
  
  6.WebGL

        </a>
      </li>
    
  

      
        
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../" class="md-tabs__link">
          
  
    
  
  7.WebGL 3D

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c8/" class="md-tabs__link">
          
  
    
  
  8.高阶3D

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c9/" class="md-tabs__link">
          
  
    
  
  9.WEBGPU

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../a1/" class="md-tabs__link">
          
  
    
  
  附录

        </a>
      </li>
    
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../.." class="md-tabs__link">
        
  
    
  
  关于

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="计算机图形学概论" class="md-nav__button md-logo" aria-label="计算机图形学概论" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    计算机图形学概论
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/hellowac/graphicsbook-zh-cn" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    graphicsbook
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    首页
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../preface/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    前言
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c1/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    1.简介
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_3" id="__nav_3_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            1.简介
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 1 节 绘画与绘图
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 2 节：三维(3D)图形的要素
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 3 节：硬件与软件
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c2/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    2.二维图形
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_4" id="__nav_4_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            2.二维图形
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第1节: 像素、坐标和颜色
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第2节: 形状
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第3节: 变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第4节: 分层建模
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第5节: Java 绘制2D
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第6节: HTML Canvas图形
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第7节: SVG：一种场景描述语言
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c3/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    3.几何
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_5" id="__nav_5_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            3.几何
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.1 OpenGL 1.1 中的形状和颜色
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.2 3D 坐标和变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.3 投影与观看
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.4 多边形网格和 glDrawArrays
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.5 部分线性代数基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.6 使用 GLUT 和 JOGL
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c4/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    4.灯光和材质
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_6" id="__nav_6_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6">
            <span class="md-nav__icon md-icon"></span>
            4.灯光和材质
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.1 照明简介
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.2 OpenGL 1.1 中的光和材质
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.3 图像纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.4 灯光、相机、动作
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c5/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    5.three.js
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_7" id="__nav_7_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7">
            <span class="md-nav__icon md-icon"></span>
            5.three.js
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.1 Three.js 基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.2 构建对象
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.3 其他功能
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c6/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    6.WebGL
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_8" id="__nav_8_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8">
            <span class="md-nav__icon md-icon"></span>
            6.WebGL
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.1 可编程流水线
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.2 第一个例子
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.3 GLSL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.4 图像纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.5 实现 2D 变换
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" checked>
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    7.WebGL 3D
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_9" id="__nav_9_label" tabindex="">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_9">
            <span class="md-nav__icon md-icon"></span>
            7.WebGL 3D
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.1 3D变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    7.2 照明和材质
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    7.2 照明和材质
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#721-最小照明" class="md-nav__link">
    <span class="md-ellipsis">
      7.2.1 最小照明
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#722-镜面反射和-phong-着色" class="md-nav__link">
    <span class="md-ellipsis">
      7.2.2 镜面反射和 Phong 着色
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#723-增加复杂性" class="md-nav__link">
    <span class="md-ellipsis">
      7.2.3 增加复杂性
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#724-两侧照明" class="md-nav__link">
    <span class="md-ellipsis">
      7.2.4 两侧照明
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#725-移动灯" class="md-nav__link">
    <span class="md-ellipsis">
      7.2.5 移动灯
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#726-聚光灯" class="md-nav__link">
    <span class="md-ellipsis">
      7.2.6 聚光灯
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#727-光衰减" class="md-nav__link">
    <span class="md-ellipsis">
      7.2.7 光衰减
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#728-磁盘世界2" class="md-nav__link">
    <span class="md-ellipsis">
      7.2.8 磁盘世界2
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.3 纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.4 帧缓冲区
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.5 WebGL 扩展
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c8/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    8.高阶3D
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_10" id="__nav_10_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_10_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10">
            <span class="md-nav__icon md-icon"></span>
            8.高阶3D
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c8/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8.1 光线追踪
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c8/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8.2 路径追踪
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_11" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c9/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    9.WEBGPU
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_11" id="__nav_11_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_11_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_11">
            <span class="md-nav__icon md-icon"></span>
            9.WEBGPU
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.1 WebGPU 基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.2 实例和索引
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.3 WGSL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.4 WebGPU 中的 3D 图形
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.5 纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.6 计算着色器
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.7 细节
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_12" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../a1/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    附录
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_12" id="__nav_12_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_12_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_12">
            <span class="md-nav__icon md-icon"></span>
            附录
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a2/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Blender 3D建模
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a3/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Gimp和Inkscape
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../source/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    示例程序源代码
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../glossary/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    术语表
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    关于
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#721-最小照明" class="md-nav__link">
    <span class="md-ellipsis">
      7.2.1 最小照明
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#722-镜面反射和-phong-着色" class="md-nav__link">
    <span class="md-ellipsis">
      7.2.2 镜面反射和 Phong 着色
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#723-增加复杂性" class="md-nav__link">
    <span class="md-ellipsis">
      7.2.3 增加复杂性
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#724-两侧照明" class="md-nav__link">
    <span class="md-ellipsis">
      7.2.4 两侧照明
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#725-移动灯" class="md-nav__link">
    <span class="md-ellipsis">
      7.2.5 移动灯
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#726-聚光灯" class="md-nav__link">
    <span class="md-ellipsis">
      7.2.6 聚光灯
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#727-光衰减" class="md-nav__link">
    <span class="md-ellipsis">
      7.2.7 光衰减
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#728-磁盘世界2" class="md-nav__link">
    <span class="md-ellipsis">
      7.2.8 磁盘世界2
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="72-照明和材质">7.2 照明和材质<a class="headerlink" href="#72-照明和材质" title="Permanent link">&para;</a></h1>
<p><strong>Lighting and Material</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="1:2"><input checked="checked" id="__tabbed_1_1" name="__tabbed_1" type="radio" /><input id="__tabbed_1_2" name="__tabbed_1" type="radio" /><div class="tabbed-labels"><label for="__tabbed_1_1">中文</label><label for="__tabbed_1_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>在本节中，我们将讨论WebGL中的光照和材质问题。我们将继续使用在<a href="../../c4/s1/">第4.1节</a>和<a href="../../c4/s2/">第4.2节</a>中介绍的基本OpenGL模型，但现在我们负责在自己的GLSL着色器程序中实现光照方程。这意味着需要更加注意实现细节。这也意味着我们可以为特定应用程序选择实现光照方程的哪些部分。</p>
<p>光照方程的目标是计算表面上某点的颜色。方程的输入包括表面的材质属性和照亮表面的光源属性。光线击中表面的角度起着重要作用。该角度可以从光源的方向和表面法线向量计算得出。镜面反射的计算还使用到观察者的方向和反射光线的方向。在<a href="../../c4/s1/#414-opengl-11-光照方程">4.1.4小节</a>的光照图中展示了用于计算的四个向量：</p>
<p><a class="glightbox" href="../../../en/c7/light-equation.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c7/light-equation.png" /></a></p>
<p>向量L、N、R和V应该是单位向量。回想一下，单位向量具有这样的属性：两个单位向量之间角度的余弦值由这两个向量的点积给出。</p>
<p>光照方程还涉及环境光和自发光颜色，这些颜色不依赖于图中显示的方向向量。</p>
<p>在我们通过使用光照模型的各个方面的一些示例时，你应该牢记这个大局。</p>
</div>
<div class="tabbed-block">
<p>In this section, we turn to the question of <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> and <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>. We will continue to use the basic <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> model that was covered in <a href="../../c4/s1/">Section 4.1</a> and <a href="../../c4/s2/">Section 4.2</a>, but now we are responsible for implementing the <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> equation in our own <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> programs. That means being more aware of the implementation details. It also means that we can pick and choose which parts of the <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> equation we will implement for a given application.</p>
<p>The goal of the <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> equation is to compute a color for a point on a surface. The inputs to the equation include the <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> properties of the surface and the properties of light sources that illuminate the surface. The angle at which the light hits the surface plays an important role. The angle can be computed from the direction to the light source and the <abbr title="A normal vector to a surface at a point on that surface is a vector that is perpendicular to the surface at that point. Normal vectors to curves are defined similarly. Normal vectors are important for lighting calculations.">normal vector</abbr> to the surface. Computation of <abbr title="Mirror-like reflection of light rays from a surface. A ray of light is reflected as a ray in the direction that makes the angle of reflection equal to the angle of incidence. A specular reflection can only be seen by a viewer whose position lies on the path of the reflected ray.">specular reflection</abbr> also uses the direction to the viewer and the direction of the reflected ray. The four vectors that are used in the computation are shown in this <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> diagram from <a href="../../c4/s1/#414-opengl-11-光照方程">Subsection 4.1.4</a>:</p>
<p><a class="glightbox" href="../../../en/c7/light-equation.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c7/light-equation.png" /></a></p>
<p>The vectors L, N, R, and V should be unit vectors. Recall that unit vectors have the property that the cosine of the angle between two unit vectors is given by the <abbr title="The dot product of two vectors is the sum of the products of corresponding coordinates. For 3D vectors `v=(x,y,z)` and `w=(a,b,c)`, the dot product of v and w is `x*a+y*b+z*c`. The dot product is equal to the cosine of the angle between the vectors, divided by the product of their lengths.">dot product</abbr> of the two vectors.</p>
<p>The <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> equation also involves ambient and <abbr title="A material property that represents color that is intrinsic to a surface, rather than coming from light from other sources that is reflected by the surface. Emission color can make the object look like it is glowing, but it does not illuminate other objects. Emission color is often called &quot;emissive color.&quot;">emission color</abbr>, which do not depend the direction vectors shown in the diagram.</p>
<p>You should keep this big picture in mind as we work through some examples that use various aspects of the <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> model.</p>
</div>
</div>
</div>
<h2 id="721-最小照明">7.2.1 最小照明<a class="headerlink" href="#721-最小照明" title="Permanent link">&para;</a></h2>
<p><strong>Minimal Lighting</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="2:2"><input checked="checked" id="__tabbed_2_1" name="__tabbed_2" type="radio" /><input id="__tabbed_2_2" name="__tabbed_2" type="radio" /><div class="tabbed-labels"><label for="__tabbed_2_1">中文</label><label for="__tabbed_2_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>即使是非常简单的光照也能让3D图形看起来更加逼真。对于最小化的光照，我有时会使用我所说的“视点光”，这是一种从观察者方向照射进场景的白光。在最简单的情况下，可以使用方向光。在眼睛坐标系中，方向视点光沿着负z轴方向照射。指向光源的光方向向量（上图中的<em>L</em>）是(0,0,1)。</p>
<p>为了保持简单，我们只考虑漫反射。在这种情况下，从表面反射的光的颜色是表面漫反射材质颜色、光的颜色以及光击中表面角度的余弦值的乘积。红色、绿色和蓝色颜色分量的乘积分别计算。我们假设光是白色的，所以在公式中光的颜色是1。材质颜色可能来自JavaScript端作为uniform或attribute变量。</p>
<p>光击中表面角度的余弦值由法线向量N与光方向向量<em>L</em>的点积给出。在眼睛坐标系中，<em>L</em>是(0,0,1)。<abbr title="两个向量的点积是对应坐标的乘积之和。对于三维向量 v=(x,y,z) 和 w=(a,b,c)，v 和 w 的点积是 x*a+y*b+z*c。点积等于两个向量之间的夹角的余弦，除以它们的长度的乘积。">点积</abbr><em>N·L</em>或<em>N·(0,0,1)</em>因此仅仅是<em>N.z</em>，即<em>N</em>的z分量。然而，这假设N也是以眼睛坐标系给出的。法线向量通常来自JavaScript端，并且以对象坐标系表示。在用于光照计算之前，它必须转换到眼睛坐标系。如在<a href="../s1/#714-变换法线">7.1.4小节</a>中讨论的，要做到这一点我们需要一个从模型视图矩阵派生的法线变换矩阵。由于法线向量必须是长度为一的，计算N的GLSL代码可能是这样的：</p>
<div class="highlight"><pre><span></span><code><span class="nx">vec3</span><span class="w"> </span><span class="nx">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">normalize</span><span class="p">(</span><span class="nx">normalMatrix</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">normal</span><span class="p">);</span>
</code></pre></div>
<p>其中<em>normal</em>是对象坐标系中的原始法线向量，<em>normalMatrix</em>是法线变换矩阵，<em><abbr title="将非零向量除以其长度得到的单位向量的结果，即长度为一的向量。注意，“归一化向量”和“法向量”是两个无关的术语！">normalize</abbr></em>是一个内置的GLSL函数，它返回一个长度为一且与其参数指向同一方向的向量。</p>
<p>还有一个复杂情况：<abbr title="两个向量的点积是对应坐标的乘积之和。对于三维向量 v=(x,y,z) 和 w=(a,b,c)，v 和 w 的点积是 x*a+y*b+z*c。点积等于两个向量之间的夹角的余弦，除以它们的长度的乘积。">点积</abbr><em>N·L</em>可能是负数，这意味着法线向量指向光源的相反方向（在这种情况下是指向屏幕内部）。通常，这意味着表面不被照亮。在视点光的情况下，我们知道每个可见表面都是被照亮的，这意味着我们正在看表面的“背面”（或者指定了错误的法线）。假设我们希望以相同的方式处理表面的两侧。背面的正确法线向量是正面法线向量的负数，正确的点积是(−N)·L。我们可以通过简单地使用<em>abs(N·L)</em>来处理这两种情况。对于<em>L = (0,0,1)</em>，那就是<em>abs(N.z)</em>。如果<em>color</em>是一个给出表面漫反射颜色的<em>vec3</em>，可见颜色可以这样计算：</p>
<div class="highlight"><pre><span></span><code><span class="nx">vec3</span><span class="w"> </span><span class="nx">visibleColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">abs</span><span class="p">(</span><span class="nx">N</span><span class="p">.</span><span class="nx">z</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">color</span><span class="p">;</span>
</code></pre></div>
<p>如果<em>color</em>是一个给出RGBA颜色的<em>vec4</em>，只有RGB分量应该乘以点积：</p>
<div class="highlight"><pre><span></span><code><span class="nx">vec4</span><span class="w"> </span><span class="nx">visibleColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="nx">abs</span><span class="p">(</span><span class="nx">N</span><span class="p">.</span><span class="nx">z</span><span class="p">)</span><span class="o">*</span><span class="nx">color</span><span class="p">.</span><span class="nx">rgb</span><span class="p">,</span><span class="w"> </span><span class="nx">color</span><span class="p">.</span><span class="nx">a</span><span class="p">);</span>
</code></pre></div>
<p>示例程序<a href="../../../en/source/webgl/cube-with-basic-lighting.html">webgl/cube-with-basic-<abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr>.html</a>实现了这个最小化光照模型。光照计算在顶点着色器中完成。场景的一部分没有使用光照绘制，顶点着色器有一个uniform <em>bool</em>变量来指定是否应用光照。这是该程序的顶点着色器源代码：</p>
<div class="highlight"><pre><span></span><code><span class="nx">attribute</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">a_coords</span><span class="p">;</span><span class="w">            </span><span class="c1">// 顶点的对象坐标。</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">mat4</span><span class="w"> </span><span class="nx">modelviewProjection</span><span class="p">;</span><span class="w">   </span><span class="c1">// 组合变换矩阵。</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">bool</span><span class="w"> </span><span class="nx">lit</span><span class="p">;</span><span class="w">            </span><span class="c1">// 是否应用光照？</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">normal</span><span class="p">;</span><span class="w">         </span><span class="c1">// 法线向量（在对象坐标中）。</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">mat3</span><span class="w"> </span><span class="nx">normalMatrix</span><span class="p">;</span><span class="w">   </span><span class="c1">// 法线向量的变换矩阵。</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">color</span><span class="p">;</span><span class="w">          </span><span class="c1">// 基本（漫反射）颜色。</span>
<span class="nx">varying</span><span class="w"> </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">v_color</span><span class="p">;</span><span class="w">        </span><span class="c1">// 发送到片段着色器的颜色。</span>
<span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="nx">a_coords</span><span class="p">,</span><span class="mf">1.0</span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">modelviewProjection</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">coords</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">lit</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">normalize</span><span class="p">(</span><span class="nx">normalMatrix</span><span class="o">*</span><span class="nx">normal</span><span class="p">);</span><span class="w"> </span><span class="c1">// 变换后的单位法线。</span>
<span class="w">        </span><span class="kr">float</span><span class="w"> </span><span class="nx">dotProduct</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">abs</span><span class="p">(</span><span class="nx">N</span><span class="p">.</span><span class="nx">z</span><span class="p">);</span>
<span class="w">        </span><span class="nx">v_color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="nx">dotProduct</span><span class="o">*</span><span class="nx">color</span><span class="p">.</span><span class="nx">rgb</span><span class="p">,</span><span class="w"> </span><span class="nx">color</span><span class="p">.</span><span class="nx">a</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">v_color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">color</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>向这个模型添加环境光很容易，使用uniform变量来指定环境光级别。自发光颜色也很容易添加。</p>
<p>这个例子中使用的方向光在技术上只适用于正交投影，尽管它通常也会为透视投影提供可接受的结果。但透视投影的正确视点光是在(0,0,0)处的点光源——眼睛坐标中“眼睛”的位置。点光源比方向光稍微复杂一些。</p>
<p>请记住，光照计算是在眼睛坐标系中完成的。指向光源的向量<em>L</em>可以这样计算：</p>
<div class="highlight"><pre><span></span><code><span class="nx">vec3</span><span class="w"> </span><span class="nx">L</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">normalize</span><span class="p">(</span><span class="nx">lightPosition</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">eyeCoords</span><span class="p">.</span><span class="nx">xyz</span><span class="p">);</span>
</code></pre></div>
<p>其中<em>lightPosition</em>是一个<em>vec3</em>，表示光源在眼睛坐标系中的位置，而eyeCoords是一个<em>vec4</em>，表示表面点在眼睛坐标系中的位置。对于视点光，<em>lightPosition</em>是<em>(0,0,0)</em>，<em>L</em>可以简单地计算为<em><abbr title="将非零向量除以其长度得到的单位向量的结果，即长度为一的向量。注意，“归一化向量”和“法向量”是两个无关的术语！">normalize</abbr>(-eyeCoords.xyz)</em>。表面点的眼睛坐标必须通过将模型视图矩阵应用于该点的对象坐标来计算。这意味着着色器程序需要知道模型视图矩阵；仅仅知道组合的模型视图和投影矩阵是不够的。上面显示的顶点着色器可以修改为使用位于(0,0,0)的点光源，如下所示：</p>
<div class="highlight"><pre><span></span><code><span class="nx">attribute</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">a_coords</span><span class="p">;</span><span class="w">      </span><span class="c1">// 顶点的对象坐标。</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">mat4</span><span class="w"> </span><span class="nx">modelview</span><span class="p">;</span><span class="w">       </span><span class="c1">// 模型视图变换矩阵。</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">mat4</span><span class="w"> </span><span class="nx">projection</span><span class="p">;</span><span class="w">      </span><span class="c1">// 投影变换矩阵。</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">bool</span><span class="w"> </span><span class="nx">lit</span><span class="p">;</span><span class="w">             </span><span class="c1">// 是否应用光照？</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">normal</span><span class="p">;</span><span class="w">          </span><span class="c1">// 法线向量（在对象坐标中）。</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">mat3</span><span class="w"> </span><span class="nx">normalMatrix</span><span class="p">;</span><span class="w">    </span><span class="c1">// 法线向量的变换矩阵。</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">color</span><span class="p">;</span><span class="w">           </span><span class="c1">// 基本（漫反射）颜色。</span>
<span class="nx">varying</span><span class="w"> </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">v_color</span><span class="p">;</span><span class="w">         </span><span class="c1">// 发送到片段着色器的颜色。</span>
<span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="nx">a_coords</span><span class="p">,</span><span class="mf">1.0</span><span class="p">);</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">eyeCoords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">modelview</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">coords</span><span class="p">;</span>
<span class="w">    </span><span class="nx">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">projection</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">eyeCoords</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">lit</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">L</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">normalize</span><span class="p">(</span><span class="o">-</span><span class="nx">eyeCoords</span><span class="p">.</span><span class="nx">xyz</span><span class="p">);</span><span class="w"> </span><span class="c1">// 指向光源。</span>
<span class="w">        </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">normalize</span><span class="p">(</span><span class="nx">normalMatrix</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">normal</span><span class="p">);</span><span class="w"> </span><span class="c1">// 变换后的单位法线。</span>
<span class="w">        </span><span class="kr">float</span><span class="w"> </span><span class="nx">dotProduct</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">abs</span><span class="p">(</span><span class="nx">dot</span><span class="p">(</span><span class="nx">N</span><span class="p">,</span><span class="w"> </span><span class="nx">L</span><span class="p">));</span>
<span class="w">        </span><span class="nx">v_color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="nx">dotProduct</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">color</span><span class="p">.</span><span class="nx">rgb</span><span class="p">,</span><span class="w"> </span><span class="nx">color</span><span class="p">.</span><span class="nx">a</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">v_color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">color</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>（注意，然而，在某些情况下，将光照计算移到片段着色器可能会更好，我们很快就会看到。）</p>
</div>
<div class="tabbed-block">
<p>Even very simple <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> can make 3D graphics look more realistic. For minimal <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr>, I sometimes use what I call a "viewpoint light," a white light that shines from the direction of the viewer into the scene. In the simplest case, a <abbr title="A light source whose light rays are parallel, all arriving from the same direction. Can be considered to be a light source at an effectively infinite distance. Also called a &quot;sun,&quot; since the Sun is an example of a directional light source.">directional light</abbr> can be used. In <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr>, a directional viewpoint light shines in the direction of the negative z-axis. The light direction <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> (<em>L</em> in the above diagram), which points towards the light source, is (0,0,1).</p>
<p>To keep things minimal, let's consider <abbr title="Reflection of incident light in all directions from a surface, so that diffuse illumination of a surface is visible to all viewers, independent of the viewer's position.">diffuse reflection</abbr> only. In that case, the color of the light reflected from a surface is the product of the diffuse <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> color of the surface, the color of the light, and the cosine of the angle at which the light hits the surface. The product is computed separately for the red, green, and blue components of the color. We are assuming that the light is white, so the light color is 1 in the formula. The <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> color will probably come from the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side as a uniform or <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> variable.</p>
<p>The cosine of the angle at which the light hits the surface is given by the <abbr title="The dot product of two vectors is the sum of the products of corresponding coordinates. For 3D vectors `v=(x,y,z)` and `w=(a,b,c)`, the dot product of v and w is `x*a+y*b+z*c`. The dot product is equal to the cosine of the angle between the vectors, divided by the product of their lengths.">dot product</abbr> of the <abbr title="A normal vector to a surface at a point on that surface is a vector that is perpendicular to the surface at that point. Normal vectors to curves are defined similarly. Normal vectors are important for lighting calculations.">normal vector</abbr> N with the light direction <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> <em>L</em>. In <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr>, <em>L</em> is (0,0,1). The <abbr title="The dot product of two vectors is the sum of the products of corresponding coordinates. For 3D vectors `v=(x,y,z)` and `w=(a,b,c)`, the dot product of v and w is `x*a+y*b+z*c`. The dot product is equal to the cosine of the angle between the vectors, divided by the product of their lengths.">dot product</abbr>, <em>N·L</em> or <em>N·(0,0,1)</em>, is therefore simply <em>N.z</em>, the z-component of <em>N</em>. However, this assumes that N is also given in <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr>. The <abbr title="A normal vector to a surface at a point on that surface is a vector that is perpendicular to the surface at that point. Normal vectors to curves are defined similarly. Normal vectors are important for lighting calculations.">normal vector</abbr> will ordinarily come from the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side and will be expressed in <abbr title="The coordinate system in which the coordinates for points in an object are originally specified, before they are transformed by any modeling or other transform that will be applied to the object.">object coordinates</abbr>. Before it is used in <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> calculations, it must be transformed to the eye <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr>. As discussed in <a href="../s1/#714-变换法线">Subsection 7.1.4</a>, to do that we need a normal transformation <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> that is derived from the modelview <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>. Since the <abbr title="A normal vector to a surface at a point on that surface is a vector that is perpendicular to the surface at that point. Normal vectors to curves are defined similarly. Normal vectors are important for lighting calculations.">normal vector</abbr> must be of length one, the <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> code for computing N would be something like</p>
<div class="highlight"><pre><span></span><code><span class="nx">vec3</span><span class="w"> </span><span class="nx">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">normalize</span><span class="p">(</span><span class="w"> </span><span class="nx">normalMatrix</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">normal</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>where <em>normal</em> is the original <abbr title="A normal vector to a surface at a point on that surface is a vector that is perpendicular to the surface at that point. Normal vectors to curves are defined similarly. Normal vectors are important for lighting calculations.">normal vector</abbr> in <abbr title="The coordinate system in which the coordinates for points in an object are originally specified, before they are transformed by any modeling or other transform that will be applied to the object.">object coordinates</abbr>, <em>normalMatrix</em> is the normal transformation <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>, and <em><abbr title="将非零向量除以其长度得到的单位向量的结果，即长度为一的向量。注意，“归一化向量”和“法向量”是两个无关的术语！">normalize</abbr></em> is a built-in <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> function that returns a <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> of length one pointing in the same direction as its parameter.</p>
<p>There is one more complication: The <abbr title="The dot product of two vectors is the sum of the products of corresponding coordinates. For 3D vectors `v=(x,y,z)` and `w=(a,b,c)`, the dot product of v and w is `x*a+y*b+z*c`. The dot product is equal to the cosine of the angle between the vectors, divided by the product of their lengths.">dot product</abbr> <em>N·L</em> can be negative, which would mean that the <abbr title="A normal vector to a surface at a point on that surface is a vector that is perpendicular to the surface at that point. Normal vectors to curves are defined similarly. Normal vectors are important for lighting calculations.">normal vector</abbr> points away from the light source (into the screen in this case). Ordinarily, that would mean that the light does not illuminate the surface. In the case of a viewpoint light, where we know that every visible surface is illuminated, it means that we are looking at the "back side" of the surface (or that incorrect normals were specified). Let's assume that we want to treat the two sides of the surface the same. The correct <abbr title="A normal vector to a surface at a point on that surface is a vector that is perpendicular to the surface at that point. Normal vectors to curves are defined similarly. Normal vectors are important for lighting calculations.">normal vector</abbr> for the back side is the negative of the <abbr title="A normal vector to a surface at a point on that surface is a vector that is perpendicular to the surface at that point. Normal vectors to curves are defined similarly. Normal vectors are important for lighting calculations.">normal vector</abbr> for the front side, and the correct <abbr title="The dot product of two vectors is the sum of the products of corresponding coordinates. For 3D vectors `v=(x,y,z)` and `w=(a,b,c)`, the dot product of v and w is `x*a+y*b+z*c`. The dot product is equal to the cosine of the angle between the vectors, divided by the product of their lengths.">dot product</abbr> is (−N)·L. We can handle both cases if we simply use <em>abs(N·L)</em>. For <em>L = (0,0,1)</em>, that would be <em>abs(N.z)</em>. If <em>color</em> is a <em>vec3</em> giving the <abbr title="A material property that represents the proportion of incident light that is reflected diffusely from a surface.">diffuse color</abbr> of the surface, the visible color can be computed as</p>
<div class="highlight"><pre><span></span><code><span class="nx">vec3</span><span class="w"> </span><span class="nx">visibleColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">abs</span><span class="p">(</span><span class="nx">N</span><span class="p">.</span><span class="nx">z</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">color</span><span class="p">;</span>
</code></pre></div>
<p>If <em>color</em> is instead a <em>vec4</em> giving an <abbr title="An RGB color—specified by red, green, and blue component values—together with an alpha component. The alpha component is most often take to specify the degree of transparency of the color, with a maximal alpha value giving a fully opaque color.">RGBA color</abbr>, only the RGB components should be multiplied by the <abbr title="The dot product of two vectors is the sum of the products of corresponding coordinates. For 3D vectors `v=(x,y,z)` and `w=(a,b,c)`, the dot product of v and w is `x*a+y*b+z*c`. The dot product is equal to the cosine of the angle between the vectors, divided by the product of their lengths.">dot product</abbr>:</p>
<div class="highlight"><pre><span></span><code><span class="nx">vec4</span><span class="w"> </span><span class="nx">visibleColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="w"> </span><span class="nx">abs</span><span class="p">(</span><span class="nx">N</span><span class="p">.</span><span class="nx">z</span><span class="p">)</span><span class="o">*</span><span class="nx">color</span><span class="p">.</span><span class="nx">rgb</span><span class="p">,</span><span class="w"> </span><span class="nx">color</span><span class="p">.</span><span class="nx">a</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>The sample program <a href="../../../en/source/webgl/cube-with-basic-lighting.html">webgl/cube-with-basic-<abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr>.html</a> implements this minimal <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> model. The <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> calculations are done in the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>. Part of the scene is drawn without <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr>, and the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> has a uniform <em>bool</em> variable to specify whether <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> should be applied. Here is the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> source code from that program:</p>
<div class="highlight"><pre><span></span><code><span class="nx">attribute</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">a_coords</span><span class="p">;</span><span class="w">            </span><span class="c1">// Object coordinates for the vertex.</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">mat4</span><span class="w"> </span><span class="nx">modelviewProjection</span><span class="p">;</span><span class="w">   </span><span class="c1">// Combined transformation matrix.</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">bool</span><span class="w"> </span><span class="nx">lit</span><span class="p">;</span><span class="w">            </span><span class="c1">// Should lighting be applied?</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">normal</span><span class="p">;</span><span class="w">         </span><span class="c1">// Normal vector (in object coordinates).</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">mat3</span><span class="w"> </span><span class="nx">normalMatrix</span><span class="p">;</span><span class="w">   </span><span class="c1">// Transformation matrix for normal vectors.</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">color</span><span class="p">;</span><span class="w">          </span><span class="c1">// Basic (diffuse) color.</span>
<span class="nx">varying</span><span class="w"> </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">v_color</span><span class="p">;</span><span class="w">        </span><span class="c1">// Color to be sent to fragment shader.</span>
<span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="nx">a_coords</span><span class="p">,</span><span class="mf">1.0</span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">modelviewProjection</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">coords</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">lit</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">normalize</span><span class="p">(</span><span class="nx">normalMatrix</span><span class="o">*</span><span class="nx">normal</span><span class="p">);</span><span class="w"> </span><span class="c1">// Transformed unit normal.</span>
<span class="w">        </span><span class="kr">float</span><span class="w"> </span><span class="nx">dotProduct</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">abs</span><span class="p">(</span><span class="nx">N</span><span class="p">.</span><span class="nx">z</span><span class="p">);</span>
<span class="w">        </span><span class="nx">v_color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="w"> </span><span class="nx">dotProduct</span><span class="o">*</span><span class="nx">color</span><span class="p">.</span><span class="nx">rgb</span><span class="p">,</span><span class="w"> </span><span class="nx">color</span><span class="p">.</span><span class="nx">a</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">v_color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">color</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>It would be easy to add <abbr title="Directionless light that exists in an environment but does not seem to come from a particular source in the environment. An approximation for light that has been reflected so many times that its original source can't be identified. Ambient light illuminates all objects in a scene equally.">ambient light</abbr> to this model, using a <abbr title="Variables that represent input to a shader program in a programmable graphics pipeline. A uniform variable has the same value at every vertex and at every pixel of a primitive.">uniform variable</abbr> to specify the <abbr title="Directionless light that exists in an environment but does not seem to come from a particular source in the environment. An approximation for light that has been reflected so many times that its original source can't be identified. Ambient light illuminates all objects in a scene equally.">ambient light</abbr> level. Emission color is also easy.</p>
<p>The <abbr title="A light source whose light rays are parallel, all arriving from the same direction. Can be considered to be a light source at an effectively infinite distance. Also called a &quot;sun,&quot; since the Sun is an example of a directional light source.">directional light</abbr> used in this example is technically only correct for an <abbr title="A projection from 3D to 2D that simply discards the z-coordinate. It projects objects along lines that are orthogonal (perpendicular) to the xy-plane. In OpenGL 1.1, the view volume for an orthographic projection is a rectangular solid.">orthographic projection</abbr>, although it will also generally give acceptable results for a <abbr title="A projection from 3D to 2D that projects objects along lines radiating out from a viewpoint. A perspective projection attempts to simulate realistic viewing. A perspective projection preserves perspective; that is, objects that are farther from the viewpoint are smaller in the projection. In OpenGL 1.1, the view volume for a perspective projection is a frustum, or truncated pyramid.">perspective projection</abbr>. But the correct viewpoint light for a <abbr title="A projection from 3D to 2D that projects objects along lines radiating out from a viewpoint. A perspective projection attempts to simulate realistic viewing. A perspective projection preserves perspective; that is, objects that are farther from the viewpoint are smaller in the projection. In OpenGL 1.1, the view volume for a perspective projection is a frustum, or truncated pyramid.">perspective projection</abbr> is a <abbr title="A light source whose light rays emanate from a single point. Also called a &quot;lamp,&quot; since a lamp approximates a point source of light. Also called a positional light.">point light</abbr> at (0,0,0)—the position of the "eye" in <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr>. A <abbr title="A light source whose light rays emanate from a single point. Also called a &quot;lamp,&quot; since a lamp approximates a point source of light. Also called a positional light.">point light</abbr> is a little more difficult than a <abbr title="A light source whose light rays are parallel, all arriving from the same direction. Can be considered to be a light source at an effectively infinite distance. Also called a &quot;sun,&quot; since the Sun is an example of a directional light source.">directional light</abbr>.</p>
<p>Remember that <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> calculations are done in <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr>. The <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> <em>L</em> that points from the surface to the light can be computed as</p>
<div class="highlight"><pre><span></span><code><span class="nx">vec3</span><span class="w"> </span><span class="nx">L</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">normalize</span><span class="p">(</span><span class="w"> </span><span class="nx">lightPosition</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">eyeCoords</span><span class="p">.</span><span class="nx">xyz</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>where <em>lightPosition</em> is a <em>vec3</em> that gives the position of the light in <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr>, and eyeCoords is a <em>vec4</em> giving the position of the surface point in <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr>. For a viewpoint light, the <em>lightPosition</em> is <em>(0,0,0)</em>, and <em>L</em> can be computed simply as <em><abbr title="将非零向量除以其长度得到的单位向量的结果，即长度为一的向量。注意，“归一化向量”和“法向量”是两个无关的术语！">normalize</abbr>(−eyeCoords.xyz)</em>. The <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr> for the surface point must be computed by applying the modelview <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> to the <abbr title="The coordinate system in which the coordinates for points in an object are originally specified, before they are transformed by any modeling or other transform that will be applied to the object.">object coordinates</abbr> for that point. This means that the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program needs to know the modelview <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>; it's not sufficient to know the combined modelview and <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>. The <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> shown above can modified to use a <abbr title="A light source whose light rays emanate from a single point. Also called a &quot;lamp,&quot; since a lamp approximates a point source of light. Also called a positional light.">point light</abbr> at (0,0,0) as follows:</p>
<div class="highlight"><pre><span></span><code><span class="nx">attribute</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">a_coords</span><span class="p">;</span><span class="w">      </span><span class="c1">// Object coordinates for the vertex.</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">mat4</span><span class="w"> </span><span class="nx">modelview</span><span class="p">;</span><span class="w">       </span><span class="c1">// Modelview transformation matrix</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">mat4</span><span class="w"> </span><span class="nx">projection</span><span class="p">;</span><span class="w">      </span><span class="c1">// Projection transformation matrix.</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">bool</span><span class="w"> </span><span class="nx">lit</span><span class="p">;</span><span class="w">             </span><span class="c1">// Should lighting be applied?</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">normal</span><span class="p">;</span><span class="w">          </span><span class="c1">// Normal vector (in object coordinates).</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">mat3</span><span class="w"> </span><span class="nx">normalMatrix</span><span class="p">;</span><span class="w">    </span><span class="c1">// Transformation matrix for normal vectors.</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">color</span><span class="p">;</span><span class="w">           </span><span class="c1">// Basic (diffuse) color.</span>
<span class="nx">varying</span><span class="w"> </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">v_color</span><span class="p">;</span><span class="w">         </span><span class="c1">// Color to be sent to fragment shader.</span>
<span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="nx">a_coords</span><span class="p">,</span><span class="mf">1.0</span><span class="p">);</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">eyeCoords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">modelview</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">coords</span><span class="p">;</span>
<span class="w">    </span><span class="nx">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">projection</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">eyeCoords</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">lit</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">L</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">normalize</span><span class="p">(</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">eyeCoords</span><span class="p">.</span><span class="nx">xyz</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// Points to light.</span>
<span class="w">        </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">normalize</span><span class="p">(</span><span class="nx">normalMatrix</span><span class="o">*</span><span class="nx">normal</span><span class="p">);</span><span class="w"> </span><span class="c1">// Transformed unit normal.</span>
<span class="w">        </span><span class="kr">float</span><span class="w"> </span><span class="nx">dotProduct</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">abs</span><span class="p">(</span><span class="w"> </span><span class="nx">dot</span><span class="p">(</span><span class="nx">N</span><span class="p">,</span><span class="nx">L</span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="nx">v_color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="w"> </span><span class="nx">dotProduct</span><span class="o">*</span><span class="nx">color</span><span class="p">.</span><span class="nx">rgb</span><span class="p">,</span><span class="w"> </span><span class="nx">color</span><span class="p">.</span><span class="nx">a</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">v_color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">color</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>(Note, however, that in some situations, it can be better to move the <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> calculations to the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr>, as we will soon see.)</p>
</div>
</div>
</div>
<h2 id="722-镜面反射和-phong-着色">7.2.2 镜面反射和 Phong 着色<a class="headerlink" href="#722-镜面反射和-phong-着色" title="Permanent link">&para;</a></h2>
<p><strong>Specular Reflection and Phong Shading</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="3:2"><input checked="checked" id="__tabbed_3_1" name="__tabbed_3" type="radio" /><input id="__tabbed_3_2" name="__tabbed_3" type="radio" /><div class="tabbed-labels"><label for="__tabbed_3_1">中文</label><label for="__tabbed_3_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>要在我们的基本光照模型中添加镜面光，我们需要处理光照图中的向量<em>R</em>和<em>V</em>。在完美的镜面反射中，只有当<em>R</em>等于<em>V</em>时，观察者才能看到镜面高光，这非常不可能。但在我们使用的光照方程中，镜面反射的量取决于点积<em>R·V</em>，这代表了<em>R</em>和<em>V</em>之间角度的余弦值。镜面反射对可见颜色的贡献公式是：</p>
<div class="arithmatex">\[ (R \cdot V)^s \times \text{specularMaterialColor} \times \text{lightIntensity} \]</div>
<p>其中s是镜面指数（在OpenGL中称为“<abbr title="决定镜面高光大小和清晰度的材质属性。也被称为&quot;镜面指数&quot;，因为它在照明计算中的使用方式。在OpenGL中，光泽度是一个在0到128范围内的数字。">光泽度</abbr>”的材料属性）。如果<em>R·V</em>大于零，则该公式才有效；否则，镜面贡献为零。</p>
<p>单位向量R可以从L和N计算得出。（一些三角学显示R由<em>2</em>(N·L)<em>N − L</em>给出。）GLSL有一个内置函数<em>reflect(I,N)</em>，用于计算向量<em>I</em>通过单位法线向量<em>N</em>的反射；然而，<em>reflect(L,N)</em>的值是−R而不是<em>R</em>。（GLSL假设一个指向从光源指向表面的光方向向量，而我的L向量则相反。）</p>
<p><abbr title="长度为一的向量。">单位向量</abbr><em>V</em>从表面指向观察者的位置。请记住，我们在眼睛坐标系中进行计算。对于正交投影，观察者本质上在无限远处，V可以取为(0,0,1)。对于透视投影，观察者在眼睛坐标系中的点(0,0,0)，<em>V</em>由<em><abbr title="将非零向量除以其长度得到的单位向量的结果，即长度为一的向量。注意，“归一化向量”和“法向量”是两个无关的术语！">normalize</abbr>(−eyeCoords)</em>给出，其中<em>eyeCoords</em>包含眼睛坐标系中表面点的xyz坐标。将所有这些结合起来，并假设我们已经拥有N和L，计算颜色的GLSL代码形式如下：</p>
<div class="highlight"><pre><span></span><code><span class="nx">R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="nx">reflect</span><span class="p">(</span><span class="nx">L</span><span class="p">,</span><span class="nx">N</span><span class="p">);</span>
<span class="nx">V</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">normalize</span><span class="p">(</span><span class="o">-</span><span class="nx">eyeCoords</span><span class="p">.</span><span class="nx">xyz</span><span class="p">);</span><span class="w">  </span><span class="c1">// （假设为透视投影。）</span>
<span class="nx">vec3</span><span class="w"> </span><span class="nx">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">dot</span><span class="p">(</span><span class="nx">L</span><span class="p">,</span><span class="nx">N</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">diffuseMaterialColor</span><span class="p">.</span><span class="nx">rgb</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">diffuseLightColor</span><span class="p">;</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">dot</span><span class="p">(</span><span class="nx">R</span><span class="p">,</span><span class="nx">V</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">color</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="nx">pow</span><span class="p">(</span><span class="nx">dot</span><span class="p">(</span><span class="nx">R</span><span class="p">,</span><span class="nx">V</span><span class="p">),</span><span class="w"> </span><span class="nx">specularExponent</span><span class="p">)</span><span class="w"> </span><span class="o">*</span>
<span class="w">                        </span><span class="nx">specularMaterialColor</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">specularLightColor</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>示例程序<a href="../../../en/source/webgl/basic-specular-lighting.html">webgl/basic-specular-<abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr>.html</a>实现了具有漫反射和镜面反射的光照。对于这个绘制曲面的程序，法线向量作为顶点属性给出，而不是作为uniform变量。为了增加光照的灵活性，光的位置被指定为uniform变量而不是常量。遵循OpenGL的惯例，<em>lightPosition</em>是一个<em>vec4</em>。对于方向光，w坐标是0，光的眼睛坐标是<em>lightPosition.xyz</em>。如果w坐标非零，光是点光源，其眼睛坐标是<em>lightPosition.xyz/lightPosition.w</em>。（通过lightPosition.w的除法是齐次坐标的惯例，但实际上，lightPosition.w通常要么是零要么是一。）该程序允许不同的漫反射和镜面材料颜色，但光总是白色的，漫反射强度为0.8，镜面强度为0.4。你应该能够理解顶点着色器中的所有代码：</p>
<div class="highlight"><pre><span></span><code><span class="nx">attribute</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">a_coords</span><span class="p">;</span>
<span class="nx">attribute</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">a_normal</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">mat4</span><span class="w"> </span><span class="nx">modelview</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">mat4</span><span class="w"> </span><span class="nx">projection</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">mat3</span><span class="w"> </span><span class="nx">normalMatrix</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">lightPosition</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">diffuseColor</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">specularColor</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="kr">float</span><span class="w"> </span><span class="nx">specularExponent</span><span class="p">;</span>
<span class="nx">varying</span><span class="w"> </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">v_color</span><span class="p">;</span>
<span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="nx">a_coords</span><span class="p">,</span><span class="mf">1.0</span><span class="p">);</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">eyeCoords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">modelview</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">coords</span><span class="p">;</span>
<span class="w">    </span><span class="nx">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">projection</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">eyeCoords</span><span class="p">;</span>
<span class="w">    </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">N</span><span class="p">,</span><span class="w"> </span><span class="nx">L</span><span class="p">,</span><span class="w"> </span><span class="nx">R</span><span class="p">,</span><span class="w"> </span><span class="nx">V</span><span class="p">;</span><span class="w">  </span><span class="c1">// 光照方程的向量。</span>
<span class="w">    </span><span class="nx">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">normalize</span><span class="p">(</span><span class="nx">normalMatrix</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">a_normal</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">lightPosition</span><span class="p">.</span><span class="nx">w</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 方向光。</span>
<span class="w">        </span><span class="nx">L</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">normalize</span><span class="p">(</span><span class="nx">lightPosition</span><span class="p">.</span><span class="nx">xyz</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 点光源。</span>
<span class="w">        </span><span class="nx">L</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">normalize</span><span class="p">((</span><span class="nx">lightPosition</span><span class="p">.</span><span class="nx">xyz</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nx">lightPosition</span><span class="p">.</span><span class="nx">w</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">eyeCoords</span><span class="p">.</span><span class="nx">xyz</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="nx">reflect</span><span class="p">(</span><span class="nx">L</span><span class="p">,</span><span class="w"> </span><span class="nx">N</span><span class="p">);</span>
<span class="w">    </span><span class="nx">V</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">normalize</span><span class="p">(</span><span class="o">-</span><span class="nx">eyeCoords</span><span class="p">.</span><span class="nx">xyz</span><span class="p">);</span><span class="w">  </span><span class="c1">// （假设为透视投影。）</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">dot</span><span class="p">(</span><span class="nx">L</span><span class="p">,</span><span class="w"> </span><span class="nx">N</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">v_color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">);</span><span class="w">  </span><span class="c1">// 顶点没有被照亮。</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.8</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">dot</span><span class="p">(</span><span class="nx">L</span><span class="p">,</span><span class="w"> </span><span class="nx">N</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">diffuseColor</span><span class="p">.</span><span class="nx">rgb</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">dot</span><span class="p">(</span><span class="nx">R</span><span class="p">,</span><span class="w"> </span><span class="nx">V</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">color</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mf">0.4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">pow</span><span class="p">(</span><span class="nx">dot</span><span class="p">(</span><span class="nx">R</span><span class="p">,</span><span class="w"> </span><span class="nx">V</span><span class="p">),</span><span class="w"> </span><span class="nx">specularExponent</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">specularColor</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="nx">v_color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="nx">color</span><span class="p">,</span><span class="w"> </span><span class="nx">diffuseColor</span><span class="p">.</span><span class="nx">a</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>片段着色器只是将<em>v_color</em>的值赋给<em>gl_FragColor</em>。</p>
<hr />
<p>这种方法模仿了OpenGL 1.1，在顶点着色器中进行光照计算。这有时被称为<strong><abbr title="仅在原语的顶点处进行光照计算，并通过插值结果来获取内部像素的颜色。逐顶点光照是传统OpenGL的标准。没有镜面反射的逐顶点光照是Lambert着色。">逐顶点光照</abbr></strong>。它类似于<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>中的Lambert着色，只是Lambert着色只使用漫反射。但有许多情况下逐顶点光照不能给出好的结果。我们在<a href="../../c5/s1/#515-灯光">5.1.5小节</a>中看到，对于聚光灯来说，它可能会给出非常糟糕的结果。除非原语非常小，否则它也倾向于产生不好的镜面高光。</p>
<p>如果光源相对于原语的位置非常接近，与原语的大小相比，光在顶点处与原语形成的角度可能与光在原语内部某点的角度关系很小：</p>
<p><a class="glightbox" href="../../../en/c7/close-light.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c7/close-light.png" /></a></p>
<p>由于光照严重依赖角度，逐顶点光照在这种情况下不会给出好的结果。为了获得更好的结果，我们可以进行<strong><abbr title="在原语的每个像素上进行光照计算，这在大多数情况下比逐顶点光照得到更好的结果。Phong着色使用逐像素光照，法线向量由顶点插值得到。">逐像素光照</abbr></strong>。也就是说，我们可以将顶点着色器中的光照计算移动到片段着色器中。</p>
<p>要进行逐像素光照，必须将顶点着色器中可用的某些数据通过变化变量传递给片段着色器。这包括例如表面点的对象坐标或眼睛坐标。如果漫反射颜色是属性而不是uniform变量，也可能适用。当然，uniform变量可以直接被片段着色器访问。光属性通常uniform，材料属性也可能是。</p>
<p>然后，当然还有法线向量，它们对光照至关重要。尽管法线向量有时可以是uniform变量，但它们通常是属性。逐像素光照通常使用插值的法线向量，通过变化变量传递给片段着色器。（Phong着色只是使用插值法线的逐像素光照。）插值法线向量通常只是几何正确法线的一个近似，但通常足够好，可以给出好的结果。另一个问题是，即使顶点着色器中的法线向量是单位向量，插值的法线向量也不一定是单位向量。因此，在片段着色器中标准化插值的法线向量很重要。顶点着色器中的原始法线向量也应该标准化，以便插值正常工作。</p>
<p>示例程序<a href="../../../en/source/webgl/basic-specular-lighting-Phong.html">webgl/basic-specular-<abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr>-Phong.html</a>使用逐像素光照。我强烈建议你阅读该程序中的着色器源代码。除了光照计算已经移动到片段着色器之外，它与之前的示例程序完全相同。</p>
<p>这个演示允许你并排查看使用逐顶点光照绘制的对象和使用逐像素光照绘制的相同对象。它使用与两个示例程序相同的着色器程序。有关更多信息，请参见演示中的帮助文本：</p>
<p><iframe src="../../../en/demos/c7/per-pixel-vs-per-vertex.html" width="660" height="520"></iframe></p>
<p>示例程序<a href="../../../en/source/webgl/basic-specular-lighting-Phong-webgl2.html">webgl/basic-specular-<abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr>-Phong-webgl2.html</a>是将原始的WebGL 1.0 Phong光照程序移植到WebGL 2.0的版本。它展示了在GLSL ES 3.00中着色器程序的样子。变化很小。属性变量变为"in"变量，变化变量在顶点着色器中变为"out"变量，在片段着色器中变为"in"变量，内置片段着色器变量gl_FragColor被自定义的"out"变量替换。JavaScript端根本不需要更改，但作为一个例子，它已经被修改为使用顶点数组对象来组织程序中可以绘制的各种对象的数据。</p>
</div>
<div class="tabbed-block">
<p>To add specular <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> to our basic <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> model, we need to work with the vectors <em>R</em> and <em>V</em> in the <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> diagram. In perfect <abbr title="Mirror-like reflection of light rays from a surface. A ray of light is reflected as a ray in the direction that makes the angle of reflection equal to the angle of incidence. A specular reflection can only be seen by a viewer whose position lies on the path of the reflected ray.">specular reflection</abbr>, the viewer sees a <abbr title="Illumination of a surface produced by specular reflection. A specular highlight is seen at points on the surface where the angle from the surface to the viewer is approximately equal to the angle from the surface to a light source.">specular highlight</abbr> only if <em>R</em> is equal to <em>V</em>, which is very unlikely. But in the <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> equation that we are using, the amount of <abbr title="Mirror-like reflection of light rays from a surface. A ray of light is reflected as a ray in the direction that makes the angle of reflection equal to the angle of incidence. A specular reflection can only be seen by a viewer whose position lies on the path of the reflected ray.">specular reflection</abbr> depends on the <abbr title="The dot product of two vectors is the sum of the products of corresponding coordinates. For 3D vectors `v=(x,y,z)` and `w=(a,b,c)`, the dot product of v and w is `x*a+y*b+z*c`. The dot product is equal to the cosine of the angle between the vectors, divided by the product of their lengths.">dot product</abbr> <em>R·V</em>, which represents the cosine of the angle between <em>R</em> and <em>V</em>. The formula for the contribution of <abbr title="Mirror-like reflection of light rays from a surface. A ray of light is reflected as a ray in the direction that makes the angle of reflection equal to the angle of incidence. A specular reflection can only be seen by a viewer whose position lies on the path of the reflected ray.">specular reflection</abbr> to the visible color is</p>
<div class="highlight"><pre><span></span><code>(R·V)&lt;sup&gt;s&lt;/sup&gt; * specularMaterialColor * lightIntensity
</code></pre></div>
<p>where s is the <abbr title="A material property that determines the size and sharpness of specular highlights. Called &quot;shininess&quot; in OpenGL.">specular exponent</abbr> (the <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> property called "<abbr title="A material property that determines the size and sharpness of specular highlights. Also called the &quot;specular exponent&quot; because of the way it is used in lighting calculations. In OpenGL, shininess is a number in the range 0 to 128.">shininess</abbr>" in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr>). The formula is only valid if R·V is greater than zero; otherwise, the specular contribution is zero.</p>
<p>The <abbr title="A vector of length one.">unit vector</abbr> R can be computed from L and N. (Some trigonometry shows that R is given by <em>2*(N·L)*N − L</em>.) <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> has a built-in function <em>reflect(I,N)</em> that computes the reflection of a <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> <em>I</em> through a unit <abbr title="A normal vector to a surface at a point on that surface is a vector that is perpendicular to the surface at that point. Normal vectors to curves are defined similarly. Normal vectors are important for lighting calculations.">normal vector</abbr> <em>N</em>; however, the value of <em>reflect(L,N)</em> is −R rather than <em>R</em>. (<abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> assumes a light direction <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> that points from the light toward the surface, while my L <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> does the reverse.)</p>
<p>The <abbr title="A vector of length one.">unit vector</abbr> <em>V</em> points from the surface towards the position of the viewer. Remember that we are doing the calculations in <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr>. For an <abbr title="A projection from 3D to 2D that simply discards the z-coordinate. It projects objects along lines that are orthogonal (perpendicular) to the xy-plane. In OpenGL 1.1, the view volume for an orthographic projection is a rectangular solid.">orthographic projection</abbr>, the viewer is essentially at infinite distance, and V can be taken to be (0,0,1). For a <abbr title="A projection from 3D to 2D that projects objects along lines radiating out from a viewpoint. A perspective projection attempts to simulate realistic viewing. A perspective projection preserves perspective; that is, objects that are farther from the viewpoint are smaller in the projection. In OpenGL 1.1, the view volume for a perspective projection is a frustum, or truncated pyramid.">perspective projection</abbr>, the viewer is at the point (0,0,0) in <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr>, and <em>V</em> is given by <em><abbr title="将非零向量除以其长度得到的单位向量的结果，即长度为一的向量。注意，“归一化向量”和“法向量”是两个无关的术语！">normalize</abbr>(−eyeCoords)</em> where <em>eyeCoords</em> contains the xyz coordinates of the surface point in the eye <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr>. Putting all this together, and assuming that we already have N and L, the <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> code for computing the color takes the form:</p>
<div class="highlight"><pre><span></span><code><span class="nx">R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="nx">reflect</span><span class="p">(</span><span class="nx">L</span><span class="p">,</span><span class="nx">N</span><span class="p">);</span>
<span class="nx">V</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">normalize</span><span class="p">(</span><span class="w"> </span><span class="o">-</span><span class="nx">eyeCoords</span><span class="p">.</span><span class="nx">xyz</span><span class="w"> </span><span class="p">);</span><span class="w">  </span><span class="c1">// (Assumes a perspective projection.)</span>
<span class="nx">vec3</span><span class="w"> </span><span class="nx">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">dot</span><span class="p">(</span><span class="nx">L</span><span class="p">,</span><span class="nx">N</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="nx">diffuseMaterialColor</span><span class="p">.</span><span class="nx">rgb</span><span class="o">*</span><span class="w"> </span><span class="nx">diffuseLightColor</span><span class="p">;</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">dot</span><span class="p">(</span><span class="nx">R</span><span class="p">,</span><span class="nx">V</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">color</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="nx">pow</span><span class="p">(</span><span class="nx">dot</span><span class="p">(</span><span class="nx">R</span><span class="p">,</span><span class="nx">V</span><span class="p">),</span><span class="nx">specularExponent</span><span class="p">)</span><span class="w"> </span><span class="o">*</span>
<span class="w">                        </span><span class="nx">specularMaterialColor</span><span class="o">*</span><span class="w"> </span><span class="nx">specularLightColor</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>The sample program <a href="../../../en/source/webgl/basic-specular-lighting.html">webgl/basic-specular-<abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr>.html</a> implements <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> with diffuse and <abbr title="Mirror-like reflection of light rays from a surface. A ray of light is reflected as a ray in the direction that makes the angle of reflection equal to the angle of incidence. A specular reflection can only be seen by a viewer whose position lies on the path of the reflected ray.">specular reflection</abbr>. For this program, which draws curved surfaces, normal vectors are given as a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> rather than a <abbr title="Variables that represent input to a shader program in a programmable graphics pipeline. A uniform variable has the same value at every vertex and at every pixel of a primitive.">uniform variable</abbr>. To add some flexibility to the <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr>, the light position is specified as a <abbr title="Variables that represent input to a shader program in a programmable graphics pipeline. A uniform variable has the same value at every vertex and at every pixel of a primitive.">uniform variable</abbr> rather than a constant. Following the <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> convention, <em>lightPosition</em> is a <em>vec4</em>. For a <abbr title="A light source whose light rays are parallel, all arriving from the same direction. Can be considered to be a light source at an effectively infinite distance. Also called a &quot;sun,&quot; since the Sun is an example of a directional light source.">directional light</abbr>, the w-coordinate is 0, and the <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr> of the light are <em>lightPosition.xyz</em>. If the w-coordinate is non-zero, the light is a <abbr title="A light source whose light rays emanate from a single point. Also called a &quot;lamp,&quot; since a lamp approximates a point source of light. Also called a positional light.">point light</abbr>, and its <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr> are <em>lightPosition.xyz/lightPosition.w</em>. (The division by lightPosition.w is the convention for <abbr title="A way of representing n-dimensional vectors as (n+1)-dimensional vectors where two (n+1) vectors represent the same n-dimensional vector if they differ by a scalar multiple. In 3D, for example, if w is not zero, then the homogeneous coordinates (x,y,z,w) are equivalent to homogeneous coordinates (x/w,y/w,z/w,1), since they differ by multiplication by the scalar w. Both sets of coordinates represent the 3D vector (x/w,y/w,z/w)">homogeneous coordinates</abbr>, but in practice, lightPosition.w will usually be either zero or one.) The program allows for different diffuse and specular <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> colors, but the light is always white, with diffuse intensity 0.8 and specular intensity 0.4. You should be able to understand all of the code in the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>:</p>
<div class="highlight"><pre><span></span><code><span class="nx">attribute</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">a_coords</span><span class="p">;</span>
<span class="nx">attribute</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">a_normal</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">mat4</span><span class="w"> </span><span class="nx">modelview</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">mat4</span><span class="w"> </span><span class="nx">projection</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">mat3</span><span class="w"> </span><span class="nx">normalMatrix</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">lightPosition</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">diffuseColor</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">specularColor</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="kr">float</span><span class="w"> </span><span class="nx">specularExponent</span><span class="p">;</span>
<span class="nx">varying</span><span class="w"> </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">v_color</span><span class="p">;</span>
<span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="nx">a_coords</span><span class="p">,</span><span class="mf">1.0</span><span class="p">);</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">eyeCoords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">modelview</span><span class="w"> </span><span class="o">*</span><span class="nx">coords</span><span class="p">;</span>
<span class="w">    </span><span class="nx">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">projection</span><span class="o">*</span><span class="w"> </span><span class="nx">eyeCoords</span><span class="p">;</span>
<span class="w">    </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">N</span><span class="p">,</span><span class="w"> </span><span class="nx">L</span><span class="p">,</span><span class="w"> </span><span class="nx">R</span><span class="p">,</span><span class="w"> </span><span class="nx">V</span><span class="p">;</span><span class="w">  </span><span class="c1">// Vectors for lighting equation.</span>
<span class="w">    </span><span class="nx">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">normalize</span><span class="p">(</span><span class="w"> </span><span class="nx">normalMatrix</span><span class="o">*</span><span class="nx">a_normal</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="nx">lightPosition</span><span class="p">.</span><span class="nx">w</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Directional light.</span>
<span class="w">        </span><span class="nx">L</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">normalize</span><span class="p">(</span><span class="w"> </span><span class="nx">lightPosition</span><span class="p">.</span><span class="nx">xyz</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Point light.</span>
<span class="w">        </span><span class="nx">L</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">normalize</span><span class="p">(</span><span class="w"> </span><span class="nx">lightPosition</span><span class="p">.</span><span class="nx">xyz</span><span class="o">/</span><span class="nx">lightPosition</span><span class="p">.</span><span class="nx">w</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">eyeCoords</span><span class="p">.</span><span class="nx">xyz</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="nx">reflect</span><span class="p">(</span><span class="nx">L</span><span class="p">,</span><span class="nx">N</span><span class="p">);</span>
<span class="w">    </span><span class="nx">V</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">normalize</span><span class="p">(</span><span class="w"> </span><span class="o">-</span><span class="nx">eyeCoords</span><span class="p">.</span><span class="nx">xyz</span><span class="p">);</span><span class="w">  </span><span class="c1">// (Assumes a perspective projection.)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="nx">dot</span><span class="p">(</span><span class="nx">L</span><span class="p">,</span><span class="nx">N</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">v_color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">);</span><span class="w">  </span><span class="c1">// The vertex is not illuminated.</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.8</span><span class="o">*</span><span class="w"> </span><span class="nx">dot</span><span class="p">(</span><span class="nx">L</span><span class="p">,</span><span class="nx">N</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="nx">diffuseColor</span><span class="p">.</span><span class="nx">rgb</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">dot</span><span class="p">(</span><span class="nx">R</span><span class="p">,</span><span class="nx">V</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">color</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mf">0.4</span><span class="o">*</span><span class="w"> </span><span class="nx">pow</span><span class="p">(</span><span class="nx">dot</span><span class="p">(</span><span class="nx">R</span><span class="p">,</span><span class="nx">V</span><span class="p">),</span><span class="nx">specularExponent</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">specularColor</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="nx">v_color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="nx">color</span><span class="p">,</span><span class="w"> </span><span class="nx">diffuseColor</span><span class="p">.</span><span class="nx">a</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>The <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> just assigns the value of <em>v_color</em> to <em>gl_FragColor</em>.</p>
<hr />
<p>This approach imitates <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1 in that it does <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> calculations in the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>. This is sometimes called <strong>per-<abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr></strong>. It is similar to <abbr title="A technique for computing pixel colors on a primitive using a lighting equation that takes into account ambient and diffuse reflection. In Lambert shading, the lighting equation is applied only at the vertices of the primitive. Color values for pixels in the primitive are calculated by interpolating the values that were computed for the vertices. Lambert shading is named after Johann Lambert, who developed the theory on which it is based in the eighteenth century.">Lambert shading</abbr> in <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>, except that <abbr title="A technique for computing pixel colors on a primitive using a lighting equation that takes into account ambient and diffuse reflection. In Lambert shading, the lighting equation is applied only at the vertices of the primitive. Color values for pixels in the primitive are calculated by interpolating the values that were computed for the vertices. Lambert shading is named after Johann Lambert, who developed the theory on which it is based in the eighteenth century.">Lambert shading</abbr> only uses <abbr title="Reflection of incident light in all directions from a surface, so that diffuse illumination of a surface is visible to all viewers, independent of the viewer's position.">diffuse reflection</abbr>. But there are many cases where per-<abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> does not give good results. We saw in <a href="../../c5/s1/#515-灯光">Subsection 5.1.5</a> that it can give very bad results for spotlights. It also tends to produce bad specular highlights, unless the primitives are very small.</p>
<p>If a light source is close to a primitive, compared to the size of the primitive, the angles that the light makes with the primitive at the vertices can have very little relationship to the angle of the light at an interior point of the primitive:</p>
<p><a class="glightbox" href="../../../en/c7/close-light.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c7/close-light.png" /></a></p>
<p>Since <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> depends heavily on the angles, per-<abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> will not give a good result in this case. To get better results, we can do <strong>per-<abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr></strong>. That is, we can move the <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> calculations from the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> into the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr>.</p>
<p>To do per-<abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr>, certain data that is available in the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> must be passed to the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> in varying variables. This includes, for example, either <abbr title="The coordinate system in which the coordinates for points in an object are originally specified, before they are transformed by any modeling or other transform that will be applied to the object.">object coordinates</abbr> or <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr> for the surface point. The same might apply to properties such as <abbr title="A material property that represents the proportion of incident light that is reflected diffusely from a surface.">diffuse color</abbr>, if they are <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr> rather then uniform variables. Of course, uniform variables are directly accessible to the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr>. Light properties will generally be uniforms, and <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> properties might well be.</p>
<p>And then, of course, there are the normal vectors, which are so essential for <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr>. Although normal vectors can sometimes be uniform variables, they are usually <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr>. Per-<abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> generally uses interpolated normal vectors, passed to the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> in a <abbr title="A variable that is used to communicate values from the vertex shader to the fragment shader in the WebGL or OpenGL ES 2.0 graphics pipeline. A varying variable is assigned a value in the vertex shader. The value of the variable in the fragment shader for a pixel in the primitive is obtained by interpolating the values from the vertices of the primitive. (In newer versions of GLSL, which support additional shader stages, the term &quot;varying variable&quot; is replaced by the more general terms &quot;in variable&quot; and &quot;out variable,&quot; which refer to variables that are used for input to or output from a shader.)">varying variable</abbr>. (<abbr title="A technique for computing pixel colors on a primitive using a lighting equation that takes into account ambient, diffuse, and specular reflection. In Phong shading, the lighting equation is applied at each pixel. Normal vectors are specified only at the vertices of the primitive. The normal vector that is used in the lighting equation at a pixel is obtained by interpolating the normal vectors for the vertices. Phong shading is named after Bui Tuong Phong, who developed the theory in the 1970s.">Phong shading</abbr> is just per-<abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> using interpolated normals.) An interpolated <abbr title="A normal vector to a surface at a point on that surface is a vector that is perpendicular to the surface at that point. Normal vectors to curves are defined similarly. Normal vectors are important for lighting calculations.">normal vector</abbr> is in general only an approximation for the geometrically correct normal, but it's usually good enough to give good results. Another issue is that interpolated normals are not necessarily unit vectors, even if the normals in the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> are unit vectors. So, it's important to <abbr title="将非零向量除以其长度得到的单位向量的结果，即长度为一的向量。注意，“归一化向量”和“法向量”是两个无关的术语！">normalize</abbr> the interpolated normal vectors in the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr>. The original normal vectors in the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> should also be normalized, for the <abbr title="Given values for some quantity at certain reference points, computing a value for that quantity at other points by some kind of averaging applied to the values at the reference points.">interpolation</abbr> to work properly.</p>
<p>The sample program <a href="../../../en/source/webgl/basic-specular-lighting-Phong.html">webgl/basic-specular-<abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr>-Phong.html</a> uses per-<abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr>. I urge you to read the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> source code in that program. Aside from the fact that <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> calculations have been moved to the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr>, it is identical to the previous sample program.</p>
<p>This demo lets you view objects drawn using per-<abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> side-by-side with identical objects drawn using per-<abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr>. It uses the same <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> programs as the two sample programs. See the help text in the demo for more information:</p>
<p><iframe src="../../../en/demos/c7/per-pixel-vs-per-vertex.html" width="660" height="520"></iframe></p>
<p>The sample program <a href="../../../en/source/webgl/basic-specular-lighting-Phong-webgl2.html">webgl/basic-specular-<abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr>-Phong-webgl2.html</a> is a port of the original <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 Phong <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> program to <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0. It shows what the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program looks like in <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 3.00. The changes are minimal. Attribute variables become "in" variables, varying variables become "out" variables in the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> and "in" variables in the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr>, and the built-in <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> variable gl_FragColor is replaced with a custom "out" variable. The <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side would not have to be changed at all, but as an example, it has been modified to use <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> array objects to organize the data for the various objects that can be drawn in the in program.</p>
</div>
</div>
</div>
<h2 id="723-增加复杂性">7.2.3 增加复杂性<a class="headerlink" href="#723-增加复杂性" title="Permanent link">&para;</a></h2>
<p><strong>Adding Complexity</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="4:2"><input checked="checked" id="__tabbed_4_1" name="__tabbed_4" type="radio" /><input id="__tabbed_4_2" name="__tabbed_4" type="radio" /><div class="tabbed-labels"><label for="__tabbed_4_1">中文</label><label for="__tabbed_4_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>我们的着色器程序正在变得更加复杂。随着我们增加对多个光源、额外的光属性、双面光照、纹理等特性的支持，使用数据结构和函数来帮助管理复杂性将是有用的。<abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> 数据结构在 <a href="../../c6/s3/#632-数据结构">6.3.2小节</a> 中介绍，函数定义在 <a href="../../c6/s3/#635-函数定义">6.3.5小节</a> 中介绍。让我们简要看看它们如何被用来处理光和材质。</p>
<p>定义一个结构体来保存光的属性是有意义的。这些属性通常至少包括光的位置和颜色。根据应用和使用的光照模型的细节，可以添加其他属性。例如，为了能够打开和关闭光源，可以添加一个<em>bool</em>变量来表示光是否启用：</p>
<div class="highlight"><pre><span></span><code><span class="nx">struct</span><span class="w"> </span><span class="nx">LightProperties</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">bool</span><span class="w"> </span><span class="nx">enabled</span><span class="p">;</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">position</span><span class="p">;</span>
<span class="w">    </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">color</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>然后，可以用<em>LightProperties</em>类型的变量来表示光。它很可能是一个<em>uniform</em>变量，以便可以在 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 端指定其值。通常，会有多个光源，由数组表示；例如，允许最多四个光源：</p>
<div class="highlight"><pre><span></span><code><span class="nx">uniform</span><span class="w"> </span><span class="nx">LightProperties</span><span class="w"> </span><span class="nx">lights</span><span class="p">[</span><span class="mf">4</span><span class="p">];</span>
</code></pre></div>
<p>材质属性也可以表示为<em>struct</em>。同样，细节会因应用而异。例如，为了允许漫反射和镜面颜色：</p>
<div class="highlight"><pre><span></span><code><span class="nx">struct</span><span class="w"> </span><span class="nx">MaterialProperties</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">diffuseColor</span><span class="p">;</span>
<span class="w">    </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">specularColor</span><span class="p">;</span>
<span class="w">    </span><span class="kr">float</span><span class="w"> </span><span class="nx">specularExponent</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>有了这些数据类型，我们可以编写一个函数来帮助进行光照计算。下面的函数计算一个光源对表面上某点颜色的贡献。（其中一些参数可以是着色器程序中的全局变量。）</p>
<div class="highlight"><pre><span></span><code><span class="nx">vec3</span><span class="w"> </span><span class="nx">lightingEquation</span><span class="p">(</span><span class="nx">LightProperties</span><span class="w"> </span><span class="nx">light</span><span class="p">,</span><span class="w">       </span>
<span class="w">                        </span><span class="nx">MaterialProperties</span><span class="w"> </span><span class="nx">material</span><span class="p">,</span><span class="w"> </span>
<span class="w">                        </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">eyeCoords</span><span class="p">,</span><span class="w"> </span><span class="c1">// 点的眼睛坐标。</span>
<span class="w">                        </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">N</span><span class="p">,</span><span class="w"> </span><span class="c1">// 表面的法线向量。</span>
<span class="w">                        </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">V</span><span class="w">  </span><span class="c1">// 指向观察者的方向。</span>
<span class="w">                    </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">L</span><span class="p">,</span><span class="w"> </span><span class="nx">R</span><span class="p">;</span><span class="w"> </span><span class="c1">// 光的方向和反射光的方向。</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">light</span><span class="p">.</span><span class="nx">position</span><span class="p">.</span><span class="nx">w</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 方向光</span>
<span class="w">        </span><span class="nx">L</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">normalize</span><span class="p">(</span><span class="nx">light</span><span class="p">.</span><span class="nx">position</span><span class="p">.</span><span class="nx">xyz</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 点光源</span>
<span class="w">        </span><span class="nx">L</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">normalize</span><span class="p">((</span><span class="nx">light</span><span class="p">.</span><span class="nx">position</span><span class="p">.</span><span class="nx">xyz</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nx">light</span><span class="p">.</span><span class="nx">position</span><span class="p">.</span><span class="nx">w</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">eyeCoords</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">dot</span><span class="p">(</span><span class="nx">L</span><span class="p">,</span><span class="w"> </span><span class="nx">N</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 光没有照亮表面</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">reflection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">dot</span><span class="p">(</span><span class="nx">L</span><span class="p">,</span><span class="w"> </span><span class="nx">N</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">light</span><span class="p">.</span><span class="nx">color</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">material</span><span class="p">.</span><span class="nx">diffuseColor</span><span class="p">;</span>
<span class="w">    </span><span class="nx">R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="nx">reflect</span><span class="p">(</span><span class="nx">L</span><span class="p">,</span><span class="w"> </span><span class="nx">N</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">dot</span><span class="p">(</span><span class="nx">R</span><span class="p">,</span><span class="w"> </span><span class="nx">V</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 光线反射向观察者</span>
<span class="w">        </span><span class="kr">float</span><span class="w"> </span><span class="nx">factor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">pow</span><span class="p">(</span><span class="nx">dot</span><span class="p">(</span><span class="nx">R</span><span class="p">,</span><span class="w"> </span><span class="nx">V</span><span class="p">),</span><span class="w"> </span><span class="nx">material</span><span class="p">.</span><span class="nx">specularExponent</span><span class="p">);</span>
<span class="w">        </span><span class="nx">reflection</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">factor</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">material</span><span class="p">.</span><span class="nx">specularColor</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">light</span><span class="p">.</span><span class="nx">color</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">reflection</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>然后，假设有四个光源，光照方程的完整计算可能看起来像这样：</p>
<div class="highlight"><pre><span></span><code><span class="nx">vec3</span><span class="w"> </span><span class="nx">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span><span class="w">  </span><span class="c1">// 从黑色（所有颜色分量为零）开始。</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kr">int</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">4</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// 添加第 i 个光源的贡献。</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">lights</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">enabled</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 只有启用的光才能贡献颜色。</span>
<span class="w">        </span><span class="nx">color</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">lightingEquation</span><span class="p">(</span><span class="nx">lights</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span><span class="w"> </span><span class="nx">material</span><span class="p">,</span>
<span class="w">                                    </span><span class="nx">eyeCoords</span><span class="p">,</span><span class="w"> </span><span class="nx">normal</span><span class="p">,</span><span class="w"> </span><span class="nx">viewDirection</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
</div>
<div class="tabbed-block">
<p>Our <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> programs are getting more complex. As we add support for multiple lights, additional light properties, two-sided <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr>, textures, and other features, it will be useful to use data structures and functions to help manage the complexity. <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> data structures were introduced in <a href="../../c6/s3/#632-数据结构">Subsection 6.3.2</a>, and function definitions in <a href="../../c6/s3/#635-函数定义">Subsection 6.3.5</a>. Let's look briefly at how they can be used to work with light and <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr>.</p>
<p>It makes sense to define a struct to hold the properties of a light. The properties will usually include, at a minimum, the position and color of the light. Other properties can be added, depending on the application and the details of the <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> model that are used. For example, to make it possible to turn lights on and off, a <em>bool</em> variable might be added to say whether the light is enabled:</p>
<div class="highlight"><pre><span></span><code><span class="nx">struct</span><span class="w"> </span><span class="nx">LightProperties</span><span class="w"> </span><span class="p">{</span>
<span class="nx">bool</span><span class="w"> </span><span class="nx">enabled</span><span class="p">;</span>
<span class="nx">vec4</span><span class="w"> </span><span class="nx">position</span><span class="p">;</span>
<span class="nx">vec3</span><span class="w"> </span><span class="nx">color</span><span class="p">;</span><span class="w"> </span>
<span class="p">};</span>
</code></pre></div>
<p>A light can then be represented as a variable of type <em>LightProperties</em>. It will likely be a <em>uniform</em> variable so that its value can be specified on the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side. Often, there will be multiple lights, represented by an array; for example, to allow for up to four lights:</p>
<div class="highlight"><pre><span></span><code><span class="nx">uniform</span><span class="w"> </span><span class="nx">LightProperties</span><span class="w"> </span><span class="nx">lights</span><span class="p">[</span><span class="mf">4</span><span class="p">];</span>
</code></pre></div>
<p>Material properties can also be represented as a <em>struct</em>. Again, the details will vary from one application to another. For example, to allow for diffuse and <abbr title="A material property that represents the proportion of incident light that is reflected specularly by a surface.">specular color</abbr>:</p>
<div class="highlight"><pre><span></span><code><span class="nx">struct</span><span class="w"> </span><span class="nx">MaterialProperties</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">diffuseColor</span><span class="p">;</span>
<span class="w">    </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">specularColor</span><span class="p">;</span>
<span class="w">    </span><span class="kr">float</span><span class="w"> </span><span class="nx">specularExponent</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>With these data types in hand, we can write a function to help with the <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> calculation. The following function computes the contribution of one light to the color of a point on a surface. (Some of the parameters could be global variables in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program instead.)</p>
<div class="highlight"><pre><span></span><code><span class="nx">vec3</span><span class="w"> </span><span class="nx">lightingEquation</span><span class="p">(</span><span class="w"> </span><span class="nx">LightProperties</span><span class="w"> </span><span class="nx">light</span><span class="p">,</span><span class="w">       </span>
<span class="w">                            </span><span class="nx">MaterialProperties</span><span class="w"> </span><span class="nx">material</span><span class="p">,</span><span class="w"> </span>
<span class="w">                            </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">eyeCoords</span><span class="p">,</span><span class="w"> </span><span class="c1">// Eye coordinates for the point.</span>
<span class="w">                            </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">N</span><span class="p">,</span><span class="w"> </span><span class="c1">// Normal vector to the surface.</span>
<span class="w">                            </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">V</span><span class="w">  </span><span class="c1">// Direction to viewer.</span>
<span class="w">                        </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">L</span><span class="p">,</span><span class="w"> </span><span class="nx">R</span><span class="p">;</span><span class="w"> </span><span class="c1">// Light direction and reflected light direction.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="nx">light</span><span class="p">.</span><span class="nx">position</span><span class="p">.</span><span class="nx">w</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// directional light</span>
<span class="w">        </span><span class="nx">L</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">normalize</span><span class="p">(</span><span class="w"> </span><span class="nx">light</span><span class="p">.</span><span class="nx">position</span><span class="p">.</span><span class="nx">xyz</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// point light</span>
<span class="w">        </span><span class="nx">L</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">normalize</span><span class="p">(</span><span class="w"> </span><span class="nx">light</span><span class="p">.</span><span class="nx">position</span><span class="p">.</span><span class="nx">xyz</span><span class="o">/</span><span class="nx">light</span><span class="p">.</span><span class="nx">position</span><span class="p">.</span><span class="nx">w</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">eyeCoords</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">dot</span><span class="p">(</span><span class="nx">L</span><span class="p">,</span><span class="nx">N</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// light does not illuminate the surface</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span><span class="w"> </span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">reflection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">dot</span><span class="p">(</span><span class="nx">L</span><span class="p">,</span><span class="nx">N</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">light</span><span class="p">.</span><span class="nx">color</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">material</span><span class="p">.</span><span class="nx">diffuseColor</span><span class="p">;</span>
<span class="w">    </span><span class="nx">R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="nx">reflect</span><span class="p">(</span><span class="nx">L</span><span class="p">,</span><span class="nx">N</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">dot</span><span class="p">(</span><span class="nx">R</span><span class="p">,</span><span class="nx">V</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// ray is reflected toward the viewer</span>
<span class="w">        </span><span class="kr">float</span><span class="w"> </span><span class="nx">factor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">pow</span><span class="p">(</span><span class="nx">dot</span><span class="p">(</span><span class="nx">R</span><span class="p">,</span><span class="nx">V</span><span class="p">),</span><span class="nx">material</span><span class="p">.</span><span class="nx">specularExponent</span><span class="p">);</span>
<span class="w">        </span><span class="nx">reflection</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">factor</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">material</span><span class="p">.</span><span class="nx">specularColor</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">light</span><span class="p">.</span><span class="nx">color</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">reflection</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Then, assuming that there are four lights, the full calculation of the <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> equation might look like this:</p>
<div class="highlight"><pre><span></span><code><span class="nx">vec3</span><span class="w"> </span><span class="nx">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span><span class="w">  </span><span class="c1">// Start with black (all color components zero).</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kr">int</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">4</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// Add in the contribution from light i.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">lights</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">enabled</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Light can only contribute color if enabled.</span>
<span class="w">        </span><span class="nx">color</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">lightingEquation</span><span class="p">(</span><span class="w"> </span><span class="nx">lights</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span><span class="w"> </span><span class="nx">material</span><span class="p">,</span>
<span class="w">                                        </span><span class="nx">eyeCoords</span><span class="p">,</span><span class="w"> </span><span class="nx">normal</span><span class="p">,</span><span class="w"> </span><span class="nx">viewDirection</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
</div>
</div>
</div>
<h2 id="724-两侧照明">7.2.4 两侧照明<a class="headerlink" href="#724-两侧照明" title="Permanent link">&para;</a></h2>
<p><strong>Two-sided Lighting</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="5:2"><input checked="checked" id="__tabbed_5_1" name="__tabbed_5" type="radio" /><input id="__tabbed_5_2" name="__tabbed_5" type="radio" /><div class="tabbed-labels"><label for="__tabbed_5_1">中文</label><label for="__tabbed_5_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>示例程序 <a href="../../../en/source/webgl/parametric-function-grapher.html">webgl/parametric-function-grapher.html</a> 使用了类似于我们刚刚看到的 <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> 数据结构。它还引入了一些新特性。该程序绘制了一个参数曲面的图形。曲面上点的 <em>(x,y,z)</em> 坐标由两个变量 <em>u</em> 和 <em>v</em> 的函数给出。用户可以输入这些函数的定义。有一个视点光，但为了提供更均匀的照明，额外添加了两个光源。该图形被视为有两个面，分别被涂成黄色和蓝色。程序可以选择性地在表面上显示网格线。这是默认曲面的样子，带有网格线：</p>
<p><a class="glightbox" href="../../../en/c7/parametric-function-webgl.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c7/parametric-function-webgl.png" /></a></p>
<p>这是一个双面光照的例子 (<a href="../../c4/s2/#424-全局光照属性">4.2.4小节</a>)。我们需要两种材料，一种用于绘制面向外的多边形的前材料，一种用于绘制面向内的多边形的后材料。此外，在绘制背面时，我们必须反转法线向量的方向，因为法线向量被假定为指向前面。</p>
<p>但是当着色器程序执行光照计算时，它如何知道它正在绘制前面还是后面呢？这些信息来自着色器程序外部：片段着色器有一个内置的布尔变量名为 <em>gl_FrontFacing</em>，如果着色器正在处理多边形的前面，则在调用片段着色器之前，该变量的值被设置为 <em>true</em>。当进行逐像素光照时，片段着色器可以检查这个变量的值，以决定在光照方程中使用前材料还是后材料。示例程序有两个 uniform 变量来表示这两种材料。它有三种光源。法线向量和点的眼睛坐标是变化变量。法线变换矩阵也在片段着色器中应用：</p>
<div class="highlight"><pre><span></span><code><span class="nx">uniform</span><span class="w"> </span><span class="nx">MaterialProperties</span><span class="w"> </span><span class="nx">frontMaterial</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">MaterialProperties</span><span class="w"> </span><span class="nx">backMaterial</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">LightProperties</span><span class="w"> </span><span class="nx">lights</span><span class="p">[</span><span class="mf">3</span><span class="p">];</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">mat3</span><span class="w"> </span><span class="nx">normalMatrix</span><span class="p">;</span>
<span class="nx">varying</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">v_normal</span><span class="p">;</span>
<span class="nx">varying</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">v_eyeCoords</span><span class="p">;</span>
</code></pre></div>
<p>使用这些变量和上面显示的 lightingEquation 函数计算片段的颜色：</p>
<div class="highlight"><pre><span></span><code><span class="nx">vec3</span><span class="w"> </span><span class="nx">normal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">normalize</span><span class="p">(</span><span class="nx">normalMatrix</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">v_normal</span><span class="p">);</span>
<span class="nx">vec3</span><span class="w"> </span><span class="nx">viewDirection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">normalize</span><span class="p">(</span><span class="o">-</span><span class="nx">v_eyeCoords</span><span class="p">);</span>
<span class="nx">vec3</span><span class="w"> </span><span class="nx">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kr">int</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">3</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">lights</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">enabled</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">gl_FrontFacing</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// 计算前面的颜色。</span>
<span class="w">            </span><span class="nx">color</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">lightingEquation</span><span class="p">(</span><span class="nx">lights</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span><span class="w"> </span><span class="nx">frontMaterial</span><span class="p">,</span><span class="w"> </span><span class="nx">v_eyeCoords</span><span class="p">,</span>
<span class="w">                                        </span><span class="nx">normal</span><span class="p">,</span><span class="w"> </span><span class="nx">viewDirection</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// 计算后面的颜色。</span>
<span class="w">            </span><span class="nx">color</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">lightingEquation</span><span class="p">(</span><span class="nx">lights</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span><span class="w"> </span><span class="nx">backMaterial</span><span class="p">,</span><span class="w"> </span><span class="nx">v_eyeCoords</span><span class="p">,</span>
<span class="w">                                        </span><span class="o">-</span><span class="nx">normal</span><span class="p">,</span><span class="w"> </span><span class="nx">viewDirection</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="nx">gl_FragColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="nx">color</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
</code></pre></div>
<p>注意，在对 <em>lightEquation</em> 的第二次调用中，法线向量被给出为 <em>-normal</em>。负号用于在背面使用时反转法线向量的方向。</p>
<p>如果你想在进行逐顶点光照时使用双面光照，你必须处理 <em>gl_FrontFacing</em> 在顶点着色器中不可用的事实。一个选择是在顶点着色器中计算前颜色和后颜色，并将两个值作为变化变量传递给片段着色器。然后片段着色器可以基于 <em>gl_FrontFacing</em> 的值决定使用哪种颜色。</p>
<hr />
<p><abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 中有一些设置与双面光照有关。通常，<abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 根据一个规则来确定三角形的正面，即当正面被观察时，顶点按逆时针顺序列出。<abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 命令 <em>gl.frontFace(gl.CW)</em> 反转了这个规则，使得当正面被观察时，顶点按顺时针顺序列出。命令 <em>gl.frontFace(gl.CCW)</em> 恢复了默认规则。</p>
<p>在某些情况下，你可以确定没有背面是可见的。当对象是封闭表面且从外部观察，所有三角形都朝向外部时，就会发生这种情况。在这种情况下，绘制背面是浪费努力的，因为你可以放心它们会被前面隐藏。<abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 命令 <em>gl.enable(gl.CULL_FACE)</em> 告诉 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 根据三角形是面向正面还是背面来决定是否绘制它们。命令 <em>gl.cullFace(gl.BACK)</em> 和 <em>gl.cullFace(gl.FRONT)</em> 确定在启用 CULL_FACE 时是丢弃背面还是正面的三角形；默认是丢弃背面的三角形。</p>
<hr />
<p>示例程序可以在表面上显示一组网格线。正如我们之前在 <a href="../../c3/s4/#341-索引面集">3.4.1小节</a> 的末尾和 <a href="../../c5/s1/#514-物体几何形状材料">5.1.4小节</a> 中看到的那样，绘制两个完全相同深度的对象可能会导致深度测试问题。<abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 使用多边形偏移来解决这个问题。<abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 中也有相同的解决方案。多边形偏移可以通过以下命令开启：</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">enable</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">POLYGON_OFFSET_FILL</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">polygonOffset</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">);</span>
</code></pre></div>
<p>并可以通过以下命令关闭：</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">disable</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">POLYGON_OFFSET_FILL</span><span class="p">);</span>
</code></pre></div>
<p>在示例程序中，在绘制图形时启用了多边形偏移，在绘制网格线时关闭了多边形偏移。</p>
</div>
<div class="tabbed-block">
<p>The sample program <a href="../../../en/source/webgl/parametric-function-grapher.html">webgl/parametric-function-grapher.html</a> uses <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> data structures similar to the ones we have just been looking at. It also introduces a few new features. The program draws the graph of a parametric surface. The <em>(x,y,z)</em> coordinates of points on the surface are given by functions of two variables <em>u</em> and <em>v</em>. The definitions of the functions can be input by the user. There is a viewpoint light, but two extra lights have been added in an attempt to provide more even illumination. The graph is considered to have two sides, which are colored yellow and blue. The program can, optionally, show grid lines on the surface. Here's what the default surface looks like, with grid lines:</p>
<p><a class="glightbox" href="../../../en/c7/parametric-function-webgl.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c7/parametric-function-webgl.png" /></a></p>
<p>This is an example of two-sided <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> (<a href="../../c4/s2/#424-全局光照属性">Subsection 4.2.4</a>). We need two materials, a front <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> for drawing front-facing polygons and a back <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> for drawing back-facing polygons. Furthermore, when drawing a <abbr title="One of the two sides of a polygon in 3D. A polygon has two sides. One is taken to be the front face, and the other is the back face. In OpenGL, the difference is determined by the order in which the vertices of the polygon are enumerated. The default is that, seen from the back, the vertices are enumerated in clockwise order around the polygon.">back face</abbr>, we have to reverse the direction of the <abbr title="A normal vector to a surface at a point on that surface is a vector that is perpendicular to the surface at that point. Normal vectors to curves are defined similarly. Normal vectors are important for lighting calculations.">normal vector</abbr>, since normal vectors are assumed to point out of the <abbr title="One of the two sides of a polygon in 3D. A polygon has two sides. One is taken to be the front face, and the other is the back face. In OpenGL, the difference is determined by the order in which the vertices of the polygon are enumerated. The default is that, seen from the front, the vertices are enumerated in counterclockwise order around the polygon.">front face</abbr>.</p>
<p>But when the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program does <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> calculations, how does it know whether it's drawing a <abbr title="One of the two sides of a polygon in 3D. A polygon has two sides. One is taken to be the front face, and the other is the back face. In OpenGL, the difference is determined by the order in which the vertices of the polygon are enumerated. The default is that, seen from the front, the vertices are enumerated in counterclockwise order around the polygon.">front face</abbr> or a <abbr title="One of the two sides of a polygon in 3D. A polygon has two sides. One is taken to be the front face, and the other is the back face. In OpenGL, the difference is determined by the order in which the vertices of the polygon are enumerated. The default is that, seen from the back, the vertices are enumerated in clockwise order around the polygon.">back face</abbr>? That information comes from outside the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program: The <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> has a built-in boolean variable named <em>gl_FrontFacing</em> whose value is set to <em>true</em> before the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> is called, if the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> is working on the <abbr title="One of the two sides of a polygon in 3D. A polygon has two sides. One is taken to be the front face, and the other is the back face. In OpenGL, the difference is determined by the order in which the vertices of the polygon are enumerated. The default is that, seen from the front, the vertices are enumerated in counterclockwise order around the polygon.">front face</abbr> of a <abbr title="A multi-sided shape lying in a plane and specified by a list of points, called its vertices, and made up of the line segments from each point in the list to the next point in the list, plus a line segment from the last point in the list to the first point. All the points are required to lie in the same plane. Sometimes the term &quot;polygon&quot; includes the interior of the shape as well as its boundary.">polygon</abbr>. When doing per-<abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr>, the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> can check the value of this variable to decide whether to use the front <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> or the back <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> in the <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> equation. The sample program has two uniform variables to represent the two materials. It has three lights. The normal vectors and <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr> of the point are varying variables. And the normal transformation <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> is also applied in the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr>:</p>
<div class="highlight"><pre><span></span><code><span class="nx">uniform</span><span class="w"> </span><span class="nx">MaterialProperties</span><span class="w"> </span><span class="nx">frontMaterial</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">MaterialProperties</span><span class="w"> </span><span class="nx">backMaterial</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">LightProperties</span><span class="w"> </span><span class="nx">lights</span><span class="p">[</span><span class="mf">3</span><span class="p">];</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">mat3</span><span class="w"> </span><span class="nx">normalMatrix</span><span class="p">;</span>
<span class="nx">varying</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">v_normal</span><span class="p">;</span>
<span class="nx">varying</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">v_eyeCoords</span><span class="p">;</span>
</code></pre></div>
<p>A color for the fragment is computed using these variables and the lightingEquation function shown above:</p>
<div class="highlight"><pre><span></span><code><span class="nx">vec3</span><span class="w"> </span><span class="nx">normal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">normalize</span><span class="p">(</span><span class="w"> </span><span class="nx">normalMatrix</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">v_normal</span><span class="w"> </span><span class="p">);</span>
<span class="nx">vec3</span><span class="w"> </span><span class="nx">viewDirection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">normalize</span><span class="p">(</span><span class="w"> </span><span class="o">-</span><span class="nx">v_eyeCoords</span><span class="p">);</span>
<span class="nx">vec3</span><span class="w"> </span><span class="nx">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kr">int</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">3</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">lights</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">enabled</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">gl_FrontFacing</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// Computing color for a front face.</span>
<span class="w">            </span><span class="nx">color</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">lightingEquation</span><span class="p">(</span><span class="w"> </span><span class="nx">lights</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span><span class="w"> </span><span class="nx">frontMaterial</span><span class="p">,</span><span class="w"> </span><span class="nx">v_eyeCoords</span><span class="p">,</span>
<span class="w">                                            </span><span class="nx">normal</span><span class="p">,</span><span class="w"> </span><span class="nx">viewDirection</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// Computing color for a back face.</span>
<span class="w">            </span><span class="nx">color</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">lightingEquation</span><span class="p">(</span><span class="w"> </span><span class="nx">lights</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span><span class="w"> </span><span class="nx">backMaterial</span><span class="p">,</span><span class="w"> </span><span class="nx">v_eyeCoords</span><span class="p">,</span>
<span class="w">                                            </span><span class="o">-</span><span class="nx">normal</span><span class="p">,</span><span class="w"> </span><span class="nx">viewDirection</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="nx">gl_FragColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="nx">color</span><span class="p">,</span><span class="mf">1.0</span><span class="p">);</span>
</code></pre></div>
<p>Note that in the second call to <em>lightEquation</em>, the <abbr title="A normal vector to a surface at a point on that surface is a vector that is perpendicular to the surface at that point. Normal vectors to curves are defined similarly. Normal vectors are important for lighting calculations.">normal vector</abbr> is given as <em>−normal</em>. The negative sign reverses the direction of the <abbr title="A normal vector to a surface at a point on that surface is a vector that is perpendicular to the surface at that point. Normal vectors to curves are defined similarly. Normal vectors are important for lighting calculations.">normal vector</abbr> for use on a <abbr title="One of the two sides of a polygon in 3D. A polygon has two sides. One is taken to be the front face, and the other is the back face. In OpenGL, the difference is determined by the order in which the vertices of the polygon are enumerated. The default is that, seen from the back, the vertices are enumerated in clockwise order around the polygon.">back face</abbr>.</p>
<p>If you want to use two-sided <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> when doing per-<abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr>, you have to deal with the fact that <em>gl_FrontFacing</em> is not available in the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>. One option is to compute both a front color and a back color in the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> and pass both values to the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> as varying variables. The <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> can then decide which color to use, based on the value of <em>gl_FrontFacing</em>.</p>
<hr />
<p>There are a few <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> settings related to two-sided <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr>. Ordinarily, <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> determines the <abbr title="One of the two sides of a polygon in 3D. A polygon has two sides. One is taken to be the front face, and the other is the back face. In OpenGL, the difference is determined by the order in which the vertices of the polygon are enumerated. The default is that, seen from the front, the vertices are enumerated in counterclockwise order around the polygon.">front face</abbr> of a triangle according to the rule that when the <abbr title="One of the two sides of a polygon in 3D. A polygon has two sides. One is taken to be the front face, and the other is the back face. In OpenGL, the difference is determined by the order in which the vertices of the polygon are enumerated. The default is that, seen from the front, the vertices are enumerated in counterclockwise order around the polygon.">front face</abbr> is viewed, vertices are listed in counterclockwise order around the triangle. The <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> command <em>gl.frontFace(gl.CW)</em> reverses the rule, so that vertices are listed in clockwise order when the <abbr title="One of the two sides of a polygon in 3D. A polygon has two sides. One is taken to be the front face, and the other is the back face. In OpenGL, the difference is determined by the order in which the vertices of the polygon are enumerated. The default is that, seen from the front, the vertices are enumerated in counterclockwise order around the polygon.">front face</abbr> is viewed. The command <em>gl.frontFace(gl.CCW)</em> restores the default rule.</p>
<p>In some cases, you can be sure that no back faces are visible. This will happen when the objects are closed surfaces seen from the outside, and all the triangles face towards the outside. In such cases, it is wasted effort to draw back faces, since you can be sure that they will be hidden by front faces. The <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> command <em>gl.enable(gl.CULL_FACE)</em> tells <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> to discard triangles without drawing them, based on whether they are front-facing or back-facing. The commands <em>gl.cullFace(gl.BACK)</em> and <em>gl.cullFace(gl.FRONT)</em> determine whether it is back-facing or front-facing triangles that are discarded when CULL_FACE is enabled; the default is to discard back-facing triangles.</p>
<hr />
<p>The sample program can display a set of grid lines on the surface. As always, drawing two objects at exactly the same depth can cause a problem with the <abbr title="A solution to the hidden surface problem that involves keeping track of the depth, or distance from the viewer, of the object currently visible at each pixel in the image. When a new object is drawn at a pixel, the depth of the new object is compared to the depth of the current object to decide which one is closer to the viewer. The advantage of the depth test is that objects can be rendered in any order. A disadvantage is that only a limited range of depths can be represented in the image.">depth test</abbr>. As we have already seen at the end of <a href="../../c3/s4/#341-索引面集">Subsection 3.4.1</a> and in <a href="../../c5/s1/#514-物体几何形状材料">Subsection 5.1.4</a>, <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> uses <abbr title="A multi-sided shape lying in a plane and specified by a list of points, called its vertices, and made up of the line segments from each point in the list to the next point in the list, plus a line segment from the last point in the list to the first point. All the points are required to lie in the same plane. Sometimes the term &quot;polygon&quot; includes the interior of the shape as well as its boundary.">polygon</abbr> offset to solve the problem. The same solution is available in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>. Polygon offset can be turned on with the commands</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">enable</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">POLYGON_OFFSET_FILL</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">polygonOffset</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">);</span>
</code></pre></div>
<p>and turned off with</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">disable</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">POLYGON_OFFSET_FILL</span><span class="p">);</span>
</code></pre></div>
<p>In the sample program, <abbr title="A multi-sided shape lying in a plane and specified by a list of points, called its vertices, and made up of the line segments from each point in the list to the next point in the list, plus a line segment from the last point in the list to the first point. All the points are required to lie in the same plane. Sometimes the term &quot;polygon&quot; includes the interior of the shape as well as its boundary.">polygon</abbr> offset is turned on while drawing the graph and is turned off while drawing the grid lines.</p>
</div>
</div>
</div>
<h2 id="725-移动灯">7.2.5 移动灯<a class="headerlink" href="#725-移动灯" title="Permanent link">&para;</a></h2>
<p><strong>Moving Lights</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="6:2"><input checked="checked" id="__tabbed_6_1" name="__tabbed_6" type="radio" /><input id="__tabbed_6_2" name="__tabbed_6" type="radio" /><div class="tabbed-labels"><label for="__tabbed_6_1">中文</label><label for="__tabbed_6_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>在我们目前的示例中，光源相对于观察者是固定的。但有些光源，比如汽车的前灯，应该随着物体移动。还有些光源，比如路灯，应该保持在世界中相同的位置，但随着视点的变化而在渲染场景中改变位置。</p>
<p>光照计算是在眼睛坐标系中完成的。当光源的位置以对象坐标或世界坐标给出时，必须通过应用适当的模型视图变换将其转换为眼睛坐标。变换不能在着色器程序中完成，因为着色器程序中的模型视图矩阵代表了正在渲染的对象的变换，而这几乎从来不是光源的变换。解决方案是存储眼睛坐标中光源的位置。也就是说，代表光源位置的着色器的 uniform 变量必须设置为眼睛坐标中的位置。</p>
<p>对于相对于观察者固定的光源，光源的位置已经用眼睛坐标表示了。例如，用作视点光的点光源的位置是 (0,0,0)，这是观察者在眼睛坐标中的位置。对于这样的光源，适当的模型视图变换是单位矩阵。</p>
<p>对于在世界坐标中处于固定位置的光源，适当的模型视图变换是观察变换。必须将观察变换应用于世界坐标的光源位置，以将其转换为眼睛坐标。在 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 中，应该在 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 端应用变换，并将变换的输出发送到着色器程序中代表眼睛坐标中光源位置的 uniform 变量。同样，对于在世界中移动的光源，应该在 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 端将组合的建模和观察变换应用于光源位置。<em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em> 库 (<a href="../s1/#712-glmatrix简介">7.1.2小节</a>) 定义了函数</p>
<div class="highlight"><pre><span></span><code><span class="nx">vec4</span><span class="p">.</span><span class="nx">transformMat4</span><span class="p">(</span><span class="w"> </span><span class="nx">transformedVector</span><span class="p">,</span><span class="w"> </span><span class="nx">originalVector</span><span class="p">,</span><span class="w"> </span><span class="nx">matrix</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>可以用来执行变换。函数调用中的 <em><abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr></em> 将是模型视图变换矩阵。顺便回忆一下，光源位置是以 <em>vec4</em> 的形式给出的，使用齐次坐标。（见 <a href="../../c4/s2/#423-应用灯光">4.2.3小节</a>。）乘以模型视图矩阵将适用于任何光源，无论方向光还是点光源，只要以这种方式表示其位置。以下是一个可以用来设置位置的 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 函数：</p>
<div class="highlight"><pre><span></span><code><span class="cm">/* 设置眼睛坐标中光源的位置。</span>
<span class="cm">* @param u_position_loc 光源位置属性的 uniform 变量位置。</span>
<span class="cm">* @param modelview 将光源位置转换为眼睛坐标的模型视图矩阵。</span>
<span class="cm">* @param lightPosition 光源的位置，以对象坐标表示（一个 vec4）。</span>
<span class="cm">*/</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">setLightPosition</span><span class="p">(</span><span class="w"> </span><span class="nx">u_position_loc</span><span class="p">,</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">lightPosition</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">transformedPosition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Float32Array</span><span class="p">(</span><span class="mf">4</span><span class="p">);</span>
<span class="w">    </span><span class="nx">vec4</span><span class="p">.</span><span class="nx">transformMat4</span><span class="p">(</span><span class="w"> </span><span class="nx">transformedPosition</span><span class="p">,</span><span class="w"> </span><span class="nx">lightPosition</span><span class="p">,</span><span class="w"> </span><span class="nx">modelview</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">uniform4fv</span><span class="p">(</span><span class="w"> </span><span class="nx">u_position_loc</span><span class="p">,</span><span class="w"> </span><span class="nx">transformedPosition</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>对于相对于观察者固定的光源，适当的 <em>modelview</em> 矩阵是单位矩阵；对于在世界中有固定位置的光源，只是观察变换；或者对于在世界中移动的光源，是组合的观察和建模变换。</p>
<p>记住，光源位置和其他光源属性一样，必须在渲染任何要被光源照亮的几何体之前设置。</p>
</div>
<div class="tabbed-block">
<p>In our examples so far, lights have been fixed with respect to the viewer. But some lights, such as the headlights on a car, should move along with an object. And some, such as a street light, should stay in the same position in the world, but change position in the rendered scene as the point of view changes.</p>
<p>Lighting calculations are done in <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr>. When the position of a light is given in <abbr title="The coordinate system in which the coordinates for points in an object are originally specified, before they are transformed by any modeling or other transform that will be applied to the object.">object coordinates</abbr> or in <abbr title="The coordinate system in which a scene is defined. The image that is produced of the scene will show the contents of the world coordinate system that lie within some view volume (for 3D) or view window (for 2D). Objects are defined in their own object coordinate system. Modeling transformations are then applied to place objects into the scene; that is, they transform object coordinates to world coordinates.">world coordinates</abbr>, the position must be transformed to <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr>, by applying the appropriate <abbr title="In OpenGL 1.1, a transform that combines the modeling transform with the viewing transform. That is, it is the composition of the transformation from object coordinates to world coordinates and the transformation from world coordinates to eye coordinates. Because of the equivalence between modeling and viewing transformations, world coordinates are not really meaningful for OpenGL, and only the combined transformation is tracked.">modelview transformation</abbr>. The transformation can't be done in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program, because the modelview <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program represents the transformation for the object that is being rendered, and that is almost never the same as the transformation for the light. The solution is to store the light position in <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr>. That is, the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>'s <abbr title="Variables that represent input to a shader program in a programmable graphics pipeline. A uniform variable has the same value at every vertex and at every pixel of a primitive.">uniform variable</abbr> that represents the position of the light must be set to the position in <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr>.</p>
<p>For a light that is fixed with respect to the viewer, the position of the light is already expressed in <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr>. For example, the position of a <abbr title="A light source whose light rays emanate from a single point. Also called a &quot;lamp,&quot; since a lamp approximates a point source of light. Also called a positional light.">point light</abbr> that is used as a viewpoint light is (0,0,0), which is the location of the viewer in <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr>. For such a light, the appropriate <abbr title="In OpenGL 1.1, a transform that combines the modeling transform with the viewing transform. That is, it is the composition of the transformation from object coordinates to world coordinates and the transformation from world coordinates to eye coordinates. Because of the equivalence between modeling and viewing transformations, world coordinates are not really meaningful for OpenGL, and only the combined transformation is tracked.">modelview transformation</abbr> is the identity.</p>
<p>For a light that is at a fixed position in <abbr title="The coordinate system in which a scene is defined. The image that is produced of the scene will show the contents of the world coordinate system that lie within some view volume (for 3D) or view window (for 2D). Objects are defined in their own object coordinate system. Modeling transformations are then applied to place objects into the scene; that is, they transform object coordinates to world coordinates.">world coordinates</abbr>, the appropriate <abbr title="In OpenGL 1.1, a transform that combines the modeling transform with the viewing transform. That is, it is the composition of the transformation from object coordinates to world coordinates and the transformation from world coordinates to eye coordinates. Because of the equivalence between modeling and viewing transformations, world coordinates are not really meaningful for OpenGL, and only the combined transformation is tracked.">modelview transformation</abbr> is the <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transformation. The <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transformation must be applied to the world-coordinate light position to transform it to <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr>. In <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>, the transformation should be applied on the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side, and the output of the transformation should be sent to the <abbr title="Variables that represent input to a shader program in a programmable graphics pipeline. A uniform variable has the same value at every vertex and at every pixel of a primitive.">uniform variable</abbr> in the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program that represents the light position in <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr>. Similarly, for a light that moves around in the world, the combined modeling and <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transform should be applied to the light position on the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> side. The <em><abbr title="一个用于二维和三维向量和矩阵数学的开源JavaScript库。">glMatrix</abbr></em> library (<a href="../s1/#712-glmatrix简介">Subsection 7.1.2</a>) defines the function</p>
<div class="highlight"><pre><span></span><code><span class="nx">vec4</span><span class="p">.</span><span class="nx">transformMat4</span><span class="p">(</span><span class="w"> </span><span class="nx">transformedVector</span><span class="p">,</span><span class="w"> </span><span class="nx">originalVector</span><span class="p">,</span><span class="w"> </span><span class="nx">matrix</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>which can be used to do the transformation. The <em><abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr></em> in the function call will be the <abbr title="In OpenGL 1.1, a transform that combines the modeling transform with the viewing transform. That is, it is the composition of the transformation from object coordinates to world coordinates and the transformation from world coordinates to eye coordinates. Because of the equivalence between modeling and viewing transformations, world coordinates are not really meaningful for OpenGL, and only the combined transformation is tracked.">modelview transformation</abbr> <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>. Recall, by the way, that light position is given as a <em>vec4</em>, using <abbr title="A way of representing n-dimensional vectors as (n+1)-dimensional vectors where two (n+1) vectors represent the same n-dimensional vector if they differ by a scalar multiple. In 3D, for example, if w is not zero, then the homogeneous coordinates (x,y,z,w) are equivalent to homogeneous coordinates (x/w,y/w,z/w,1), since they differ by multiplication by the scalar w. Both sets of coordinates represent the 3D vector (x/w,y/w,z/w)">homogeneous coordinates</abbr>. (See <a href="../../c4/s2/#423-应用灯光">Subsection 4.2.3</a>.) Multiplication by the modelview <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> will work for any light, whether directional or point, whose position is represented in this way. Here is a <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> function that can be used to set the position:</p>
<div class="highlight"><pre><span></span><code><span class="cm">/* Set the position of a light, in eye coordinates.</span>
<span class="cm">* @param u_position_loc The uniform variable location for </span>
<span class="cm">*                       the position property of the light.</span>
<span class="cm">* @param modelview The modelview matrix that transforms light </span>
<span class="cm">*                  position to eye coordinates.</span>
<span class="cm">* @param lightPosition The location of the light, in object </span>
<span class="cm">*                      coordinates (a vec4).</span>
<span class="cm">*/</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">setLightPosition</span><span class="p">(</span><span class="w"> </span><span class="nx">u_position_loc</span><span class="p">,</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">lightPosition</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">transformedPosition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Float32Array</span><span class="p">(</span><span class="mf">4</span><span class="p">);</span>
<span class="w">    </span><span class="nx">vec4</span><span class="p">.</span><span class="nx">transformMat4</span><span class="p">(</span><span class="w"> </span><span class="nx">transformedPosition</span><span class="p">,</span><span class="w"> </span><span class="nx">lightPosition</span><span class="p">,</span><span class="w"> </span><span class="nx">modelview</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">uniform4fv</span><span class="p">(</span><span class="w"> </span><span class="nx">u_position_loc</span><span class="p">,</span><span class="w"> </span><span class="nx">transformedPosition</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>The appropriate <em>modelview</em> <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> is the identity, for a light fixed with respect to the viewer; just the <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transformation, for a light that has a fixed position in the world; or a combined <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> and <abbr title="A transformation that is applied to an object to map that object into the world coordinate system or into the object coordinate system for a more complex, hierarchical object.">modeling transformation</abbr>, for a light that moves around in the world.</p>
<p>Remember that the light position, like other light properties, must be set before <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> any geometry that is to be illuminated by the light.</p>
</div>
</div>
</div>
<h2 id="726-聚光灯">7.2.6 <abbr title="发出光锥的光源。聚光灯类似于点光源，因为它在3D空间中有位置，光从该位置辐射出来。然而，光只影响处于聚光灯照明锥内的物体。">聚光灯</abbr><a class="headerlink" href="#726-聚光灯" title="Permanent link">&para;</a></h2>
<p><strong>Spotlights</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="7:2"><input checked="checked" id="__tabbed_7_1" name="__tabbed_7" type="radio" /><input id="__tabbed_7_2" name="__tabbed_7" type="radio" /><div class="tabbed-labels"><label for="__tabbed_7_1">中文</label><label for="__tabbed_7_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>我们在 <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em> 中的 <a href="../../c5/s1/#515-灯光">5.1.5小节</a> 遇到了聚光灯。实际上，尽管我没有提到，聚光灯在 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1 中已经存在。与四面八方发射光线不同，聚光灯只发射一个光锥。聚光灯是一种点光源。光锥的顶点位于光源的位置。光锥指向某个方向，称为 <em>聚光方向</em>。聚光方向被指定为一个向量。光锥的大小由一个截止角指定；只有与聚光方向的角度小于截止角的方向才会发射光线。此外，对于小于截止角的角度，随着光线与聚光方向之间角度的增加，光线的强度可以减小。强度减小的速率由一个非负数决定，称为 <em>聚光指数</em>。光线的强度由 <i>I*c^s</i> 给出，其中 I 是光的基本强度，c 是光线与聚光方向之间角度的余弦值，s 是聚光指数。</p>
<p>这张图示显示了三个聚光灯照射在表面上；图像取自示例程序 <a href="../../../en/source/webgl/spotlights.html">webgl/spotlights.html</a>：</p>
<p><a class="glightbox" href="../../../en/c7/spotlights.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c7/spotlights.png" /></a></p>
<p>三个聚光灯的截止角为30度。在左侧的图像中，聚光指数为零，这意味着随着与聚光方向角度的增加，强度没有衰减。中间的图像聚光指数为10，右侧的图像为20。</p>
<p>假设我们想要将光照方程应用于聚光灯。考虑表面上的一个点 <strong>P</strong>。光照方程使用一个单位向量，<em>L</em>，从 <strong>P</strong> 指向光源。对于聚光灯，我们需要一个从光源指向 <strong>P</strong> 的向量；我们可以使用 <em>−L</em>。考虑 <em>−L</em> 与聚光方向之间的角度。如果该角度大于截止角，则 <strong>P</strong> 从聚光灯那里得不到任何照明。否则，我们可以将 <em>−L</em> 与聚光方向之间角度的余弦作为点积 <em>−D·L</em> 来计算，其中 D 是指向聚光方向的单位向量。</p>
<p><a class="glightbox" href="../../../en/c7/spotlight-light-equation.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c7/spotlight-light-equation.png" /></a></p>
<p>要在 <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> 中实现聚光灯，我们可以添加 uniform 变量来表示聚光方向、截止角和聚光指数。我的实现实际上使用截止角的余弦而不是角度本身，因为我可以这样使用点积 <em>−D·L</em> 来比较截止值，它代表了光线与聚光方向之间角度的余弦。LightProperties 结构变为：</p>
<div class="highlight"><pre><span></span><code><span class="nx">struct</span><span class="w"> </span><span class="nx">LightProperties</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">bool</span><span class="w"> </span><span class="nx">enabled</span><span class="p">;</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">position</span><span class="p">;</span>
<span class="w">    </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">color</span><span class="p">;</span>
<span class="w">    </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">spotDirection</span><span class="p">;</span><span class="w">  </span>
<span class="w">    </span><span class="kr">float</span><span class="w"> </span><span class="nx">spotCosineCutoff</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="kr">float</span><span class="w"> </span><span class="nx">spotExponent</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>如果 <em>position.z</em> 为零，则光是方向光，不能是聚光灯。对于点光源，如果 <em>spotCosineCutoff</em> 小于或等于零，则光是常规点光源，不是聚光灯。对于聚光灯，我们需要计算在表面上一个点的聚光灯的有效光强度的 c^e 因子。以下是来自示例程序片段着色器的计算代码。对于聚光灯，c^e 的值被赋给 spotFactor：</p>
<div class="highlight"><pre><span></span><code><span class="kr">float</span><span class="w"> </span><span class="nx">spotFactor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span><span class="w">  </span><span class="c1">// 用于考虑聚光灯的乘数</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="nx">light</span><span class="p">.</span><span class="nx">position</span><span class="p">.</span><span class="nx">w</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">L</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">normalize</span><span class="p">(</span><span class="w"> </span><span class="nx">light</span><span class="p">.</span><span class="nx">position</span><span class="p">.</span><span class="nx">xyz</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">L</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">normalize</span><span class="p">(</span><span class="w"> </span><span class="nx">light</span><span class="p">.</span><span class="nx">position</span><span class="p">.</span><span class="nx">xyz</span><span class="o">/</span><span class="nx">light</span><span class="p">.</span><span class="nx">position</span><span class="p">.</span><span class="nx">w</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">v_eyeCoords</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">light</span><span class="p">.</span><span class="nx">spotCosineCutoff</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 光是聚光灯</span>
<span class="w">        </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="nx">normalize</span><span class="p">(</span><span class="nx">light</span><span class="p">.</span><span class="nx">spotDirection</span><span class="p">);</span>
<span class="w">        </span><span class="kr">float</span><span class="w"> </span><span class="nx">spotCosine</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">dot</span><span class="p">(</span><span class="nx">D</span><span class="p">,</span><span class="nx">L</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">spotCosine</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="nx">light</span><span class="p">.</span><span class="nx">spotCosineCutoff</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">            </span><span class="nx">spotFactor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">pow</span><span class="p">(</span><span class="nx">spotCosine</span><span class="p">,</span><span class="nx">light</span><span class="p">.</span><span class="nx">spotExponent</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 该点在聚光灯的光锥之外</span>
<span class="w">            </span><span class="nx">spotFactor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"> </span><span class="c1">// 光将不会给该点添加任何颜色</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 光强度将乘以 spotFactor</span>
</code></pre></div>
<p>你应该尝试 <a href="../../../en/source/webgl/spotlights.html">示例程序</a>，并阅读源代码。或者尝试这个演示，它与示例程序类似，但增加了使聚光灯动画化的选项：</p>
<p><iframe src="../../../en/demos/c7/spotlight-demo.html" width="710" height="400"></iframe></p>
<hr />
<p><code>spotDirection</code> 这个 uniform 变量给出了聚光灯在眼睛坐标中的方向。对于移动的聚光灯，除了变换位置之外，我们还必须考虑变换聚光灯面对的方向。聚光方向是一个向量，它的变换方式与法线向量相同。也就是说，用于变换法线向量的相同的法线变换矩阵也用于变换聚光方向。以下是一个 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 函数，可以用来将模型视图变换应用于聚光方向向量，并将输出发送到着色器程序：</p>
<div class="highlight"><pre><span></span><code><span class="cm">/* 设置聚光灯的方向向量，以眼睛坐标表示。</span>
<span class="cm">* @param modelview 执行对象到眼睛坐标变换的矩阵</span>
<span class="cm">* @param u_direction_loc 聚光方向的 uniform 变量位置</span>
<span class="cm">* @param lightDirection 聚光灯在对象坐标中的方向（一个 vec3）</span>
<span class="cm">*/</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">setSpotlightDirection</span><span class="p">(</span><span class="nx">u_direction_loc</span><span class="p">,</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">lightDirection</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">normalMatrix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">mat3</span><span class="p">.</span><span class="nx">create</span><span class="p">();</span>
<span class="w">    </span><span class="nx">mat3</span><span class="p">.</span><span class="nx">normalFromMat4</span><span class="p">(</span><span class="nx">normalMatrix</span><span class="p">,</span><span class="w"> </span><span class="nx">modelview</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">transformedDirection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Float32Array</span><span class="p">(</span><span class="mf">3</span><span class="p">);</span>
<span class="w">    </span><span class="nx">vec3</span><span class="p">.</span><span class="nx">transformMat3</span><span class="p">(</span><span class="nx">transformedDirection</span><span class="p">,</span><span class="w"> </span><span class="nx">lightDirection</span><span class="p">,</span><span class="w"> </span><span class="nx">normalMatrix</span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">uniform3fv</span><span class="p">(</span><span class="nx">u_direction_loc</span><span class="p">,</span><span class="w"> </span><span class="nx">transformedDirection</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>当然，聚光灯的位置也必须像任何移动的光源一样进行变换。</p>
</div>
<div class="tabbed-block">
<p>We encountered spotlights in <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em> in <a href="../../c5/s1/#515-灯光">Subsection 5.1.5</a>. In fact, although I didn't mention it, spotlights already existed in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1. Instead of emitting light in all directions, a <abbr title="A light that emits a cone of illumination. A spotlight is similar to a point light in that it has a position in 3D space, and light radiates from that position. However, the light only affects objects that are in the spotlight's cone of illumination.">spotlight</abbr> emits only a cone of light. A <abbr title="A light that emits a cone of illumination. A spotlight is similar to a point light in that it has a position in 3D space, and light radiates from that position. However, the light only affects objects that are in the spotlight's cone of illumination.">spotlight</abbr> is a kind of <abbr title="A light source whose light rays emanate from a single point. Also called a &quot;lamp,&quot; since a lamp approximates a point source of light. Also called a positional light.">point light</abbr>. The <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> of the cone is located at the position of the light. The cone points in some direction, called the <em>spot direction</em>. The spot direction is specified as a <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr>. The size of the cone is specified by a cutoff angle; light is only emitted from the light position in directions whose angle with the spot direction is less than the cutoff angle. Furthermore, for angles less than the cutoff angle, the intensity of the light ray can decrease as the angle between the ray and spot direction increases. The rate at which the intensity decreases is determined by a non-negative number called the <em>spot exponent</em>. The intensity of the ray is given by <i>I*c<sup>s</sup></i> where I is the basic intensity of the light, c is the cosine of the angle between the ray and the spot direction, and s is the spot exponent.</p>
<p>This illustration shows three spotlights shining on a surface; the images are taken from the sample program <a href="../../../en/source/webgl/spotlights.html">webgl/spotlights.html</a>:</p>
<p><a class="glightbox" href="../../../en/c7/spotlights.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c7/spotlights.png" /></a></p>
<p>The cutoff angle for the three spotlights is 30 degrees. In the image on the left, the spot exponent is zero, which means there is no falloff in intensity with increasing angle from the spot direction. For the middle image, the spot exponent is 10, and for the image on the right, it is 20.</p>
<p>Suppose that we want to apply the <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> equation to a <abbr title="A light that emits a cone of illumination. A spotlight is similar to a point light in that it has a position in 3D space, and light radiates from that position. However, the light only affects objects that are in the spotlight's cone of illumination.">spotlight</abbr>. Consider a point <strong>P</strong> on a surface. The <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> equation uses a <abbr title="A vector of length one.">unit vector</abbr>, <em>L</em>, that points from <strong>P</strong> towards the light source. For a <abbr title="A light that emits a cone of illumination. A spotlight is similar to a point light in that it has a position in 3D space, and light radiates from that position. However, the light only affects objects that are in the spotlight's cone of illumination.">spotlight</abbr>, we need a <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> that points from the light source towards <strong>P</strong>; for that we can use <em>−L</em>. Consider the angle between <em>−L</em> and the spot direction. If that angle is greater than the cutoff angle, then <strong>P</strong> gets no illumination from the <abbr title="A light that emits a cone of illumination. A spotlight is similar to a point light in that it has a position in 3D space, and light radiates from that position. However, the light only affects objects that are in the spotlight's cone of illumination.">spotlight</abbr>. Otherwise, we can compute the cosine of the angle between <em>−L</em> and the spot direction as the <abbr title="The dot product of two vectors is the sum of the products of corresponding coordinates. For 3D vectors `v=(x,y,z)` and `w=(a,b,c)`, the dot product of v and w is `x*a+y*b+z*c`. The dot product is equal to the cosine of the angle between the vectors, divided by the product of their lengths.">dot product</abbr> <em>−D·L</em>, where D is a <abbr title="A vector of length one.">unit vector</abbr> that points in the spot direction.</p>
<p><a class="glightbox" href="../../../en/c7/spotlight-light-equation.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c7/spotlight-light-equation.png" /></a></p>
<p>To implement spotlights in <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr>, we can add uniform variables to represent the spot direction, cutoff angle, and spot exponent. My implementation actually uses the cosine of the cutoff angle instead of the angle itself, since I can then compare the cutoff value using the <abbr title="The dot product of two vectors is the sum of the products of corresponding coordinates. For 3D vectors `v=(x,y,z)` and `w=(a,b,c)`, the dot product of v and w is `x*a+y*b+z*c`. The dot product is equal to the cosine of the angle between the vectors, divided by the product of their lengths.">dot product</abbr>, <em>−D·L</em>, that represents the cosine of the angle between the light ray and the spot direction. The LightProperties struct becomes:</p>
<div class="highlight"><pre><span></span><code><span class="nx">struct</span><span class="w"> </span><span class="nx">LightProperties</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">bool</span><span class="w"> </span><span class="nx">enabled</span><span class="p">;</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">position</span><span class="p">;</span>
<span class="w">    </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">color</span><span class="p">;</span>
<span class="w">    </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">spotDirection</span><span class="p">;</span><span class="w">  </span>
<span class="w">    </span><span class="kr">float</span><span class="w"> </span><span class="nx">spotCosineCutoff</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="kr">float</span><span class="w"> </span><span class="nx">spotExponent</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>If <em>position.z</em> is zero, then the light is directional and cannot be a <abbr title="A light that emits a cone of illumination. A spotlight is similar to a point light in that it has a position in 3D space, and light radiates from that position. However, the light only affects objects that are in the spotlight's cone of illumination.">spotlight</abbr>. For a <abbr title="A light source whose light rays emanate from a single point. Also called a &quot;lamp,&quot; since a lamp approximates a point source of light. Also called a positional light.">point light</abbr>, if <em>spotCosineCutoff</em> is less than or equal to zero, then the light is a regular <abbr title="A light source whose light rays emanate from a single point. Also called a &quot;lamp,&quot; since a lamp approximates a point source of light. Also called a positional light.">point light</abbr>, not a <abbr title="A light that emits a cone of illumination. A spotlight is similar to a point light in that it has a position in 3D space, and light radiates from that position. However, the light only affects objects that are in the spotlight's cone of illumination.">spotlight</abbr>. For a <abbr title="A light that emits a cone of illumination. A spotlight is similar to a point light in that it has a position in 3D space, and light radiates from that position. However, the light only affects objects that are in the spotlight's cone of illumination.">spotlight</abbr>, we need to compute the factor c<sup>e</sup> that is multiplied by the basic light color to give the effective light intensity of the <abbr title="A light that emits a cone of illumination. A spotlight is similar to a point light in that it has a position in 3D space, and light radiates from that position. However, the light only affects objects that are in the spotlight's cone of illumination.">spotlight</abbr> at a point on a surface. The following code for the computation is from the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> in the sample program. For a <abbr title="A light that emits a cone of illumination. A spotlight is similar to a point light in that it has a position in 3D space, and light radiates from that position. However, the light only affects objects that are in the spotlight's cone of illumination.">spotlight</abbr>, the value of c<sup>e</sup> is assigned to spotFactor:</p>
<div class="highlight"><pre><span></span><code><span class="kr">float</span><span class="w"> </span><span class="nx">spotFactor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span><span class="w">  </span><span class="c1">// multiplier to account for spotlight</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="nx">light</span><span class="p">.</span><span class="nx">position</span><span class="p">.</span><span class="nx">w</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">L</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">normalize</span><span class="p">(</span><span class="w"> </span><span class="nx">light</span><span class="p">.</span><span class="nx">position</span><span class="p">.</span><span class="nx">xyz</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">L</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">normalize</span><span class="p">(</span><span class="w"> </span><span class="nx">light</span><span class="p">.</span><span class="nx">position</span><span class="p">.</span><span class="nx">xyz</span><span class="o">/</span><span class="nx">light</span><span class="p">.</span><span class="nx">position</span><span class="p">.</span><span class="nx">w</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">v_eyeCoords</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">light</span><span class="p">.</span><span class="nx">spotCosineCutoff</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// the light is a spotlight</span>
<span class="w">        </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="nx">normalize</span><span class="p">(</span><span class="nx">light</span><span class="p">.</span><span class="nx">spotDirection</span><span class="p">);</span>
<span class="w">        </span><span class="kr">float</span><span class="w"> </span><span class="nx">spotCosine</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">dot</span><span class="p">(</span><span class="nx">D</span><span class="p">,</span><span class="nx">L</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">spotCosine</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="nx">light</span><span class="p">.</span><span class="nx">spotCosineCutoff</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">            </span><span class="nx">spotFactor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">pow</span><span class="p">(</span><span class="nx">spotCosine</span><span class="p">,</span><span class="nx">light</span><span class="p">.</span><span class="nx">spotExponent</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// The point is outside the cone of light from the spotlight.</span>
<span class="w">            </span><span class="nx">spotFactor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"> </span><span class="c1">// The light will add no color to the point.</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="c1">// Light intensity will be multiplied by spotFactor</span>
</code></pre></div>
<p>You should try the <a href="../../../en/source/webgl/spotlights.html">sample program</a>, and read the source code. Or try this demo, which is similar to the sample program, but with an added option to animate the spotlights:</p>
<p><iframe src="../../../en/demos/c7/spotlight-demo.html" width="710" height="400"></iframe></p>
<hr />
<p>The <em>spotDirection</em> <abbr title="Variables that represent input to a shader program in a programmable graphics pipeline. A uniform variable has the same value at every vertex and at every pixel of a primitive.">uniform variable</abbr> gives the direction of the <abbr title="A light that emits a cone of illumination. A spotlight is similar to a point light in that it has a position in 3D space, and light radiates from that position. However, the light only affects objects that are in the spotlight's cone of illumination.">spotlight</abbr> in <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr>. For a moving <abbr title="A light that emits a cone of illumination. A spotlight is similar to a point light in that it has a position in 3D space, and light radiates from that position. However, the light only affects objects that are in the spotlight's cone of illumination.">spotlight</abbr>, in addition to transforming the position, we also have to worry about transforming the direction in which the <abbr title="A light that emits a cone of illumination. A spotlight is similar to a point light in that it has a position in 3D space, and light radiates from that position. However, the light only affects objects that are in the spotlight's cone of illumination.">spotlight</abbr> is facing. The spot direction is a <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr>, and it transforms in the same way as normal vectors. That is, the same normal transformation <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> that is used to transform normal vectors is also used to transform the spot direction. Here is a <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> function that can be used to apply a <abbr title="In OpenGL 1.1, a transform that combines the modeling transform with the viewing transform. That is, it is the composition of the transformation from object coordinates to world coordinates and the transformation from world coordinates to eye coordinates. Because of the equivalence between modeling and viewing transformations, world coordinates are not really meaningful for OpenGL, and only the combined transformation is tracked.">modelview transformation</abbr> to a spot direction <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> and send the output to the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program:</p>
<div class="highlight"><pre><span></span><code><span class="cm">/* Set the direction vector of a light, in eye coordinates.</span>
<span class="cm">* @param modelview the matrix that does object-to-eye coordinate transforms</span>
<span class="cm">* @param u_direction_loc the uniform variable location for the spotDirection</span>
<span class="cm">* @param lightDirection the spot direction in object coordinates (a vec3)</span>
<span class="cm">*/</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">setSpotlightDirection</span><span class="p">(</span><span class="w"> </span><span class="nx">u_direction_loc</span><span class="p">,</span><span class="w"> </span><span class="nx">modelview</span><span class="p">,</span><span class="w"> </span><span class="nx">lightDirection</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">normalMatrix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">mat3</span><span class="p">.</span><span class="nx">create</span><span class="p">();</span>
<span class="w">    </span><span class="nx">mat3</span><span class="p">.</span><span class="nx">normalFromMat4</span><span class="p">(</span><span class="w"> </span><span class="nx">normalMatrix</span><span class="p">,</span><span class="nx">modelview</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">transformedDirection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Float32Array</span><span class="p">(</span><span class="mf">3</span><span class="p">);</span>
<span class="w">    </span><span class="nx">vec3</span><span class="p">.</span><span class="nx">transformMat3</span><span class="p">(</span><span class="w"> </span><span class="nx">transformedDirection</span><span class="p">,</span><span class="w"> </span><span class="nx">lightDirection</span><span class="p">,</span><span class="w"> </span><span class="nx">normalMatrix</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">uniform3fv</span><span class="p">(</span><span class="w"> </span><span class="nx">u_direction_loc</span><span class="p">,</span><span class="w"> </span><span class="nx">transformedDirection</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Of course, the position of the <abbr title="A light that emits a cone of illumination. A spotlight is similar to a point light in that it has a position in 3D space, and light radiates from that position. However, the light only affects objects that are in the spotlight's cone of illumination.">spotlight</abbr> also has to be transformed, as for any moving light.</p>
</div>
</div>
</div>
<h2 id="727-光衰减">7.2.7 光衰减<a class="headerlink" href="#727-光衰减" title="Permanent link">&para;</a></h2>
<p><strong>Light Attenuation</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="8:2"><input checked="checked" id="__tabbed_8_1" name="__tabbed_8" type="radio" /><input id="__tabbed_8_2" name="__tabbed_8" type="radio" /><div class="tabbed-labels"><label for="__tabbed_8_1">中文</label><label for="__tabbed_8_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>光线还有一个要考虑的一般属性：<abbr title="指点光源或聚光灯的照明随着距离光源的距离而减少的方式。从物理上讲，照明应该随着距离的平方而减少，但计算机图形学通常使用线性衰减或根本没有衰减。">衰减</abbr>。这指的是随着距离光源的增加，光源的照明量应该减少。衰减只适用于点光源，因为方向光实际上在无限远的地方。根据物理学，正确的行为是照明量与距离的平方成反比。然而，这在计算机图形学中通常不会得到好的结果。实际上，到目前为止，我所有的光源都没有随距离而衰减。</p>
<p><abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1 支持衰减。光强度可以乘以 1.0 / <em>(a+b</em>d+c<em>d^2)</em>，其中 d 是到光源的距离，a、b 和 c 是光的属性。数字 a、b 和 c 分别称为光源的“常数衰减”、“线性衰减”和“二次衰减”。默认情况下，a 是 1，b 和 c 是 0，这意味着没有衰减。</p>
<p>当然，在你的应用程序中没有必要实现完全相同的模型。例如，很少使用二次衰减。在下一个示例程序中，我使用公式 1 / <em>(1+a</em>d)* 作为衰减因子。衰减常数 a 被添加为光源的另一个属性。值为零意味着没有衰减。在光照计算中，光源对光照方程的贡献会乘以光的衰减因子。</p>
</div>
<div class="tabbed-block">
<p>There is one more general property of light to consider: <abbr title="Refers to the way that illumination from a point light or spot light decreases with distance from the light. Physically, illumination should decrease with the square of the distance, but computer graphics often uses a linear attenuation with distance, or no attenuation at at all.">attenuation</abbr>. This refers to the fact that the amount of illumination from a light source should decrease with increasing distance from the light. Attenuation applies only to point lights, since directional lights are effectively at infinite distance. The correct behavior, according to physics, is that the illumination is proportional to one over the square of the distance. However, that doesn't usually give good results in computer graphics. In fact, for all of my light sources so far, there has been <strong>no</strong> <abbr title="Refers to the way that illumination from a point light or spot light decreases with distance from the light. Physically, illumination should decrease with the square of the distance, but computer graphics often uses a linear attenuation with distance, or no attenuation at at all.">attenuation</abbr> with distance.</p>
<p><abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1 supports <abbr title="Refers to the way that illumination from a point light or spot light decreases with distance from the light. Physically, illumination should decrease with the square of the distance, but computer graphics often uses a linear attenuation with distance, or no attenuation at at all.">attenuation</abbr>. The light intensity can be multiplied by 1.0 / <em>(a+b*d+c*d2)</em>, where d is the distance to the light source, and a, b, and c are properties of the light. The numbers a, b, and c are called the "constant <abbr title="Refers to the way that illumination from a point light or spot light decreases with distance from the light. Physically, illumination should decrease with the square of the distance, but computer graphics often uses a linear attenuation with distance, or no attenuation at at all.">attenuation</abbr>," "linear <abbr title="Refers to the way that illumination from a point light or spot light decreases with distance from the light. Physically, illumination should decrease with the square of the distance, but computer graphics often uses a linear attenuation with distance, or no attenuation at at all.">attenuation</abbr>," and "quadratic <abbr title="Refers to the way that illumination from a point light or spot light decreases with distance from the light. Physically, illumination should decrease with the square of the distance, but computer graphics often uses a linear attenuation with distance, or no attenuation at at all.">attenuation</abbr>" of the light source. By default, a is one, and b and c are zero, which means that there is no <abbr title="Refers to the way that illumination from a point light or spot light decreases with distance from the light. Physically, illumination should decrease with the square of the distance, but computer graphics often uses a linear attenuation with distance, or no attenuation at at all.">attenuation</abbr>.</p>
<p>Of course, there is no need to implement exactly the same model in your own applications. For example, quadratic <abbr title="Refers to the way that illumination from a point light or spot light decreases with distance from the light. Physically, illumination should decrease with the square of the distance, but computer graphics often uses a linear attenuation with distance, or no attenuation at at all.">attenuation</abbr> is rarely used. In the next sample program, I use the formula 1 / <em>(1+a*d)</em> for the <abbr title="Refers to the way that illumination from a point light or spot light decreases with distance from the light. Physically, illumination should decrease with the square of the distance, but computer graphics often uses a linear attenuation with distance, or no attenuation at at all.">attenuation</abbr> factor. The <abbr title="Refers to the way that illumination from a point light or spot light decreases with distance from the light. Physically, illumination should decrease with the square of the distance, but computer graphics often uses a linear attenuation with distance, or no attenuation at at all.">attenuation</abbr> constant a is added as another property of light sources. A value of zero means no <abbr title="Refers to the way that illumination from a point light or spot light decreases with distance from the light. Physically, illumination should decrease with the square of the distance, but computer graphics often uses a linear attenuation with distance, or no attenuation at at all.">attenuation</abbr>. In the <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> computation, the contribution of a light source to the <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> equation is multiplied by the <abbr title="Refers to the way that illumination from a point light or spot light decreases with distance from the light. Physically, illumination should decrease with the square of the distance, but computer graphics often uses a linear attenuation with distance, or no attenuation at at all.">attenuation</abbr> factor for the light.</p>
</div>
</div>
</div>
<h2 id="728-磁盘世界2">7.2.8 磁盘世界2<a class="headerlink" href="#728-磁盘世界2" title="Permanent link">&para;</a></h2>
<p><strong>Diskworld 2</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="9:2"><input checked="checked" id="__tabbed_9_1" name="__tabbed_9" type="radio" /><input id="__tabbed_9_2" name="__tabbed_9" type="radio" /><div class="tabbed-labels"><label for="__tabbed_9_1">中文</label><label for="__tabbed_9_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>示例程序 <a href="../../../en/source/webgl/diskworld-2.html">webgl/diskworld-2.html</a> 是我们在 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 中关于光照的最终、更复杂的例子。基本场景与 <a href="../../c5/s1/#516-建模示例">Subsection 5.1.6</a> 中的 <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em> 示例 <a href="../../../en/source/threejs/diskworld-1.html">threejs/diskworld-1.html</a> 相同，但我增加了几种光照效果。</p>
<p>场景显示了一辆红色的“车”在“世界”的边缘，这个世界是圆盘形的。在新版本中，有一个围绕世界旋转的“太阳”。在夜晚，当太阳在圆盘下面时，太阳被关闭了（因为没有阴影，如果夜晚太阳还亮着，它会从圆盘下照射上来，从下面照亮物体）。到了夜晚，汽车的前灯会打开。它们被实现为聚光灯，随着汽车一起移动；也就是说，它们受到与汽车相同的模型视图变换的影响。到了夜晚，世界中心的一盏灯也会打开。这盏灯使用了光衰减，所以除了靠近灯的物体外，它的照明很弱。最后，还有一种微弱的视点光总是亮着，以确保没有任何东西处于绝对黑暗中。下面是程序中的一个夜景，你可以看到前灯如何照亮道路和树木，你可能也能看到靠近灯的地方灯的照明更强：</p>
<p><a class="glightbox" href="../../../en/c7/diskworld2.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c7/diskworld2.png" /></a></p>
<p>但你应该运行程序来亲眼看看！并阅读源代码来了解它是如何实现的。</p>
<hr />
<p>我的 diskworld 示例使用了逐像素光照，这比逐顶点光照得到了更好的结果，特别是对于聚光灯。然而，有了多个光源、聚光灯和衰减，逐像素光照需要在片段着色器中使用大量的 uniform 变量——可能超过了一些实现所支持的数量。对于教科书中的示例程序来说，这并不严重，也不大可能在现代 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 上出现；这只是意味着这个示例有可能在某些设备上的某些浏览器中无法工作。但对于更严肃的应用程序，使用更复杂的光照，人们会希望有替代的方法，希望比简单地将计算移动到顶点着色器更好。一个选择是使用多遍算法，其中场景被渲染多次，每次通过都为较少数量的光源进行光照计算。参见 <a href="../s5/#754-延迟着色">7.5.4小节</a>，了解一种可以高效实现这个想法的技术。</p>
</div>
<div class="tabbed-block">
<p>The sample program <a href="../../../en/source/webgl/diskworld-2.html">webgl/diskworld-2.html</a> is our final, more complex, example of <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>. The basic scene is the same as the <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em> example <a href="../../../en/source/threejs/diskworld-1.html">threejs/diskworld-1.html</a> from <a href="../../c5/s1/#516-建模示例">Subsection 5.1.6</a>, but I have added several <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> effects.</p>
<p>The scene shows a red "car" traveling around the edge of a disk-shaped "world." In the new version, there is a sun that rotates around the world. The sun is turned off at night, when the sun is below the disk. (Since there are no shadows, if the sun were left on at night, it would shine up through the disk and illuminate objects from below.) At night, the headlights of the car turn on. They are implemented as spotlights that travel along with the car; that is, they are subject to the same <abbr title="In OpenGL 1.1, a transform that combines the modeling transform with the viewing transform. That is, it is the composition of the transformation from object coordinates to world coordinates and the transformation from world coordinates to eye coordinates. Because of the equivalence between modeling and viewing transformations, world coordinates are not really meaningful for OpenGL, and only the combined transformation is tracked.">modelview transformation</abbr> that is used on the car. Also at night, a lamp in the center of the world is turned on. Light <abbr title="Refers to the way that illumination from a point light or spot light decreases with distance from the light. Physically, illumination should decrease with the square of the distance, but computer graphics often uses a linear attenuation with distance, or no attenuation at at all.">attenuation</abbr> is used for the lamp, so that its illumination is weak except for objects that are close to the lamp. Finally, there is dim viewpoint light that is always on, to make sure that nothing is ever in absolute darkness. Here is a night scene from the program, in which you can see how the headlights illuminate the road and the trees, and you can probably see that the illumination from the lamp is stronger closer to the lamp:</p>
<p><a class="glightbox" href="../../../en/c7/diskworld2.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c7/diskworld2.png" /></a></p>
<p>But you should run the program to see it in action! And read the source code to see how it's done.</p>
<hr />
<p>My diskworld example uses per-<abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr>, which gives much better results than per-<abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr>, especially for spotlights. However, with multiple lights, spotlights, and <abbr title="Refers to the way that illumination from a point light or spot light decreases with distance from the light. Physically, illumination should decrease with the square of the distance, but computer graphics often uses a linear attenuation with distance, or no attenuation at at all.">attenuation</abbr>, per-<abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> requires a lot of uniform variables in the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> — possibly more than are supported in some implementations. (See <a href="../../c6/s3/#637-限制">Subsection 6.3.7</a> for information about limitations in <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> programs.) That's not really serious for a sample program in a textbook and not really likely on modern GPUs; it just means that there is some possibility that the example won't work in some browsers on some devices. But for more serious applications, using even more complex <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr>, an alternative approach would be desirable, hopefully better than simply moving the calculation to the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>. One option is to use a <abbr title="A rendering algorithm that draws a scene several times and combines the results somehow to compute the final image. A simple example is anaglyph stereo, in which a left-eye and right-eye image of the scene are rendered separately and combined.">multi-pass algorithm</abbr> in which the scene is rendered several times, with each pass doing the <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> calculation for a smaller number of lights. See <a href="../s5/#754-延迟着色">Subsection 7.5.4</a> for a technique that can be used to implement this idea efficiently.</p>
</div>
</div>
</div>







  
    
  
  
    
  


  <aside class="md-source-file">
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="最后更新">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1-2.1-2M12.5 7v5.2l4 2.4-1 1L11 13V7h1.5M11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2v1.8Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">2024年6月19日</span>
  </span>

    
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="创建日期">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.47 15.08 11 13V7h1.5v5.25l3.08 1.83c-.41.28-.79.62-1.11 1m-1.39 4.84c-.36.05-.71.08-1.08.08-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8c0 .37-.03.72-.08 1.08.69.1 1.33.32 1.92.64.1-.56.16-1.13.16-1.72 0-5.5-4.5-10-10-10S2 6.5 2 12s4.47 10 10 10c.59 0 1.16-.06 1.72-.16-.32-.59-.54-1.23-.64-1.92M18 15v3h-3v2h3v3h2v-3h3v-2h-3v-3h-2Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">2024年5月26日</span>
  </span>

    
    
    
  </aside>





                
              </article>
            </div>
          
          
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var tab,labels=set.querySelector(".tabbed-labels");for(tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script>

<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../../..", "features": ["content.code.copy", "content.tabs.link", "navigation.tabs", "navigation.tabs.sticky", "navigation.indexes", "navigation.top", "toc.follow", "content.tooltips"], "search": "../../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.3220b9d7.min.js"></script>
      
        <script src="../../../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="https://unpkg.com/mermaid@9.4.0/dist/mermaid.min.js"></script>
      
    
  <script>document$.subscribe(() => {const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});})</script></body>
</html>