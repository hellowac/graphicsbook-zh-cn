
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="计算机图形学概论(graphicsbook)">
      
      
      
        <link rel="canonical" href="https://hellowac.github.io/graphicsbook-zh-cn/cn/c7/s5/">
      
      
        <link rel="prev" href="../s4/">
      
      
        <link rel="next" href="../../c8/">
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.5.18">
    
    
      
        <title>7.5 WebGL 扩展 - 计算机图形学概论</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.66ac8b77.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.06af60db.min.css">
      
      

  
  
  
  
  <style>:root{--md-annotation-icon:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M22 12a10 10 0 0 1-10 10A10 10 0 0 1 2 12 10 10 0 0 1 12 2a10 10 0 0 1 10 10M6 13h8l-3.5 3.5 1.42 1.42L17.84 12l-5.92-5.92L10.5 7.5 14 11H6v2Z"/></svg>');}</style>


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
   <link href="../../../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
        html.glightbox-open { overflow: initial; height: 100%; }
        .gslide-title { margin-top: 0px; user-select: text; }
        .gslide-desc { color: #666; user-select: text; }
        .gslide-image img { background: white; }
        
            .gscrollbar-fixer { padding-right: 15px; }
            .gdesc-inner { font-size: 0.75rem; }
            body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
            body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
            body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}
            </style> <script src="../../../assets/javascripts/glightbox.min.js"></script></head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="default" data-md-color-accent="red">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#75-webgl-扩展" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="计算机图形学概论" class="md-header__button md-logo" aria-label="计算机图形学概论" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            计算机图形学概论
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              7.5 WebGL 扩展
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
      <div class="md-header__option">
  <div class="md-select">
    
    <button class="md-header__button md-icon" aria-label="选择当前语言">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m12.87 15.07-2.54-2.51.03-.03A17.52 17.52 0 0 0 14.07 6H17V4h-7V2H8v2H1v2h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04M18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12m-2.62 7 1.62-4.33L19.12 17h-3.24Z"/></svg>
    </button>
    <div class="md-select__inner">
      <ul class="md-select__list">
        
          <li class="md-select__item">
            <a href="/graphicsbook-zh-cn/en/" hreflang="en" class="md-select__link">
              English
            </a>
          </li>
        
          <li class="md-select__item">
            <a href="/graphicsbook-zh-cn/cn/" hreflang="cn" class="md-select__link">
              中文
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</div>
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/hellowac/graphicsbook-zh-cn" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    graphicsbook
  </div>
</a>
      </div>
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../" class="md-tabs__link">
        
  
    
  
  首页

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../preface/" class="md-tabs__link">
        
  
    
  
  前言

      </a>
    </li>
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c1/" class="md-tabs__link">
          
  
    
  
  1.简介

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c2/" class="md-tabs__link">
          
  
    
  
  2.二维图形

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c3/" class="md-tabs__link">
          
  
    
  
  3.几何

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c4/" class="md-tabs__link">
          
  
    
  
  4.灯光和材质

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c5/" class="md-tabs__link">
          
  
    
  
  5.three.js

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c6/" class="md-tabs__link">
          
  
    
  
  6.WebGL

        </a>
      </li>
    
  

      
        
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../" class="md-tabs__link">
          
  
    
  
  7.WebGL 3D

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c8/" class="md-tabs__link">
          
  
    
  
  8.高阶3D

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c9/" class="md-tabs__link">
          
  
    
  
  9.WEBGPU

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../a1/" class="md-tabs__link">
          
  
    
  
  附录

        </a>
      </li>
    
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../.." class="md-tabs__link">
        
  
    
  
  关于

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="计算机图形学概论" class="md-nav__button md-logo" aria-label="计算机图形学概论" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    计算机图形学概论
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/hellowac/graphicsbook-zh-cn" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    graphicsbook
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    首页
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../preface/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    前言
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c1/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    1.简介
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_3" id="__nav_3_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            1.简介
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 1 节 绘画与绘图
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 2 节：三维(3D)图形的要素
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 3 节：硬件与软件
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c2/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    2.二维图形
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_4" id="__nav_4_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            2.二维图形
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第1节: 像素、坐标和颜色
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第2节: 形状
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第3节: 变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第4节: 分层建模
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第5节: Java 绘制2D
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第6节: HTML Canvas图形
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第7节: SVG：一种场景描述语言
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c3/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    3.几何
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_5" id="__nav_5_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            3.几何
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.1 OpenGL 1.1 中的形状和颜色
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.2 3D 坐标和变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.3 投影与观看
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.4 多边形网格和 glDrawArrays
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.5 部分线性代数基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.6 使用 GLUT 和 JOGL
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c4/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    4.灯光和材质
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_6" id="__nav_6_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6">
            <span class="md-nav__icon md-icon"></span>
            4.灯光和材质
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.1 照明简介
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.2 OpenGL 1.1 中的光和材质
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.3 图像纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.4 灯光、相机、动作
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c5/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    5.three.js
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_7" id="__nav_7_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7">
            <span class="md-nav__icon md-icon"></span>
            5.three.js
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.1 Three.js 基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.2 构建对象
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.3 其他功能
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c6/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    6.WebGL
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_8" id="__nav_8_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8">
            <span class="md-nav__icon md-icon"></span>
            6.WebGL
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.1 可编程流水线
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.2 第一个例子
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.3 GLSL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.4 图像纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.5 实现 2D 变换
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" checked>
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    7.WebGL 3D
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_9" id="__nav_9_label" tabindex="">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_9">
            <span class="md-nav__icon md-icon"></span>
            7.WebGL 3D
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.1 3D变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.2 照明和材质
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.3 纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.4 帧缓冲区
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    7.5 WebGL 扩展
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    7.5 WebGL 扩展
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#751-各向异性过滤" class="md-nav__link">
    <span class="md-ellipsis">
      7.5.1 各向异性过滤
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#752-浮点颜色" class="md-nav__link">
    <span class="md-ellipsis">
      7.5.2 浮点颜色
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#753-webgl-10-中的实例化绘图" class="md-nav__link">
    <span class="md-ellipsis">
      7.5.3 WebGL 1.0 中的实例化绘图
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#754-延迟着色" class="md-nav__link">
    <span class="md-ellipsis">
      7.5.4 延迟着色
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#755-webgl-20-中的多个绘制缓冲区" class="md-nav__link">
    <span class="md-ellipsis">
      7.5.5 WebGL 2.0 中的多个绘制缓冲区
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c8/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    8.高阶3D
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_10" id="__nav_10_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_10_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10">
            <span class="md-nav__icon md-icon"></span>
            8.高阶3D
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c8/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8.1 光线追踪
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c8/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8.2 路径追踪
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_11" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c9/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    9.WEBGPU
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_11" id="__nav_11_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_11_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_11">
            <span class="md-nav__icon md-icon"></span>
            9.WEBGPU
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.1 WebGPU 基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.2 实例和索引
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.3 WGSL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.4 WebGPU 中的 3D 图形
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.5 纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.6 计算着色器
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.7 细节
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_12" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../a1/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    附录
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_12" id="__nav_12_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_12_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_12">
            <span class="md-nav__icon md-icon"></span>
            附录
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a2/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Blender 3D建模
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a3/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Gimp和Inkscape
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../source/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    示例程序源代码
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../glossary/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    术语表
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    关于
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#751-各向异性过滤" class="md-nav__link">
    <span class="md-ellipsis">
      7.5.1 各向异性过滤
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#752-浮点颜色" class="md-nav__link">
    <span class="md-ellipsis">
      7.5.2 浮点颜色
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#753-webgl-10-中的实例化绘图" class="md-nav__link">
    <span class="md-ellipsis">
      7.5.3 WebGL 1.0 中的实例化绘图
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#754-延迟着色" class="md-nav__link">
    <span class="md-ellipsis">
      7.5.4 延迟着色
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#755-webgl-20-中的多个绘制缓冲区" class="md-nav__link">
    <span class="md-ellipsis">
      7.5.5 WebGL 2.0 中的多个绘制缓冲区
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="75-webgl-扩展">7.5 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 扩展<a class="headerlink" href="#75-webgl-扩展" title="Permanent link">&para;</a></h1>
<p><strong><abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> Extensions</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="1:2"><input checked="checked" id="__tabbed_1_1" name="__tabbed_1" type="radio" /><input id="__tabbed_1_2" name="__tabbed_1" type="radio" /><div class="tabbed-labels"><label for="__tabbed_1_1">中文</label><label for="__tabbed_1_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p><abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 设计用于在各种设备上运行，包括图形能力相对有限的移动设备。因此，所有 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 实现只要求有一组最小的功能集。然而，<abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 拥有一种激活额外可选特性的机制，这些可选特性定义在 <strong><abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 扩展</strong> 中。需要 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 扩展的网页并不能保证在每个 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 实现中都能工作。然而，在许多情况下，编写一个有或没有扩展都能工作的页面相对容易，尽管在没有扩展的情况下可能缺少某些特性。已有几十个扩展的定义被标准化。这些标准扩展在 <a href="https://www.khronos.org/registry/webgl/extensions/">https://www.khronos.org/registry/webgl/extensions/</a> 有文档记录。</p>
<p>标准 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 也有一个扩展机制。历史上，许多 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 一个版本中的扩展特性在后续版本中成为了必需特性。对于 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 扩展来说也是如此：一些 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 的扩展已经被纳入为 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 的必需特性。</p>
<p>本节将介绍 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 扩展机制，并讨论一些标准扩展。</p>
</div>
<div class="tabbed-block">
<p><abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> is designed to run on a wide variety of devices, including mobile devices that have relatively limited graphical capabilities. Because of this, only a minimal set of features is required of all <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> implementations. However, <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> has a mechanism for activating additional, optional features. The optional features are defined in <strong><abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> extensions</strong>. A web page that requires a <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> extension is not guaranteed to work in every implementation of <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>. However, in many cases, it is fairly easy to write a page that can work with or without the extension, though perhaps with some missing feature when the extension is not available. There are several dozen extensions whose definitions have been standardized. These standard extensions are documented at <a href="https://www.khronos.org/registry/webgl/extensions/">https://www.khronos.org/registry/webgl/extensions/</a>.</p>
<p>Standard <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> also has an extension mechanism. Historically, many features from extensions in one version of <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> have become required features in later versions. The same is true for <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> extensions: Some of the <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 extensions have been incorporated as required features in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0.</p>
<p>This section covers the <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> extension mechanism, and it discusses a few of the standard extensions.</p>
</div>
</div>
</div>
<h2 id="751-各向异性过滤">7.5.1 <abbr title="一种更准确地采样纹理图像的技术，在正在纹理化的表面上的一个像素对应于纹理中的非矩形区域的情况下使用。在WebGL中，各向异性过滤作为可选扩展提供。">各向异性过滤</abbr><a class="headerlink" href="#751-各向异性过滤" title="Permanent link">&para;</a></h2>
<p><strong>Anisotropic Filtering</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="2:2"><input checked="checked" id="__tabbed_2_1" name="__tabbed_2" type="radio" /><input id="__tabbed_2_2" name="__tabbed_2" type="radio" /><div class="tabbed-labels"><label for="__tabbed_2_1">中文</label><label for="__tabbed_2_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>我们从一个可以改善一些场景中纹理外观的简单扩展开始。标准的图像纹理采样过滤方法在以斜角视角观察纹理时会产生较差的结果。在这种情况下，表面上的一个像素对应于纹理中的一个梯形区域，而标准的缩放和放大过滤规则，如 <em>gl.LINEAR</em>，并不太能很好地处理这种情况。（过滤在 <a href="../../c4/s3/#432-mipmap-和过滤">4.3.2小节</a> 中有介绍。）使用称为<strong><abbr title="一种更准确地采样纹理图像的技术，在正在纹理化的表面上的一个像素对应于纹理中的非矩形区域的情况下使用。在WebGL中，各向异性过滤作为可选扩展提供。">各向异性过滤</abbr></strong>的技术可以获得更好的结果，这需要额外的计算，它在采样纹理时考虑了梯形的形状。许多 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 都可以进行各向异性过滤。这不是 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 实现中的必需特性，但通常作为扩展提供。各向异性过滤扩展可以以相同的方式用于 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 和 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0。</p>
<p>示例程序 <a href="../../../en/source/webgl/anisotropic-filtering.html">webgl/anisotropic-filtering.html</a> 展示了如何使用各向异性过滤扩展。它展示了一个用砖块图像纹理的大型平面，可以从尖锐的斜角观察。如果扩展可用，用户可以开启和关闭各向异性过滤。如果不可用，程序仍然会绘制场景，但只使用标准过滤。以下是程序中的两张图像。右侧的图像使用了各向异性过滤。左侧没有使用各向异性过滤时，即使在离观察者适中的距离，纹理也会模糊：</p>
<p><a class="glightbox" href="../../../en/c7/anisotropic-filtering.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c7/anisotropic-filtering.png" /></a></p>
<p>每个 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 扩展都有一个名称。函数 <em>gl.getExtension(name)</em> 用于激活扩展，其中名称是一个包含扩展名称的字符串。如果扩展不可用，该函数的返回值为 null，你应该总是在尝试使用扩展之前检查返回值。如果返回值不是 null，那么它是一个 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 对象。该对象可能包含，例如，为了利用扩展的功能而需要传递给 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 函数的常量。它还可以包含全新的函数。</p>
<p>各向异性过滤扩展的名称是 "EXT_texture_filter_anisotropic." 要测试扩展的可用性并激活它，程序可以使用如下语句：</p>
<div class="highlight"><pre><span></span><code><span class="nx">anisotropyExtension</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getExtension</span><span class="p">(</span><span class="s2">&quot;EXT_texture_filter_anisotropic&quot;</span><span class="p">);</span>
</code></pre></div>
<p>如果 <em>anisotropyExtension</em> 是 <em>null</em>，则扩展不可用。如果它不是 null，那么该对象有一个名为 <em>TEXTURE_MAX_ANISOTROPY_EXT</em> 的属性，可以作为参数传递给 <em>gl.texParameteri</em> 来设置将应用于纹理的各向异性过滤的级别或量。例如，在创建并绑定纹理之后，程序可能会说：</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">texParameteri</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span>
<span class="w">            </span><span class="nx">anisotropyExtension</span><span class="p">.</span><span class="nx">TEXTURE_MAX_ANISOTROPY_EXT</span><span class="p">,</span><span class="w"> </span><span class="mf">16</span><span class="p">);</span>
</code></pre></div>
<p>第三个参数是各向异性过滤级别。将级别设置为 1 将关闭各向异性过滤。更高的值会产生更好的结果。有一个依赖于实现的最大级别，但是请求一个大于最大值的级别并不会产生错误——你只会得到最大级别。要找出最大值，可以使用：</p>
<div class="highlight"><pre><span></span><code><span class="nx">max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getParameter</span><span class="p">(</span><span class="nx">anisotropyExtension</span><span class="p">.</span><span class="nx">MAX_TEXTURE_MAX_ANISOTROPY_EXT</span><span class="p">);</span>
</code></pre></div>
<p>建议在使用各向异性过滤时，将缩放过滤设置为 <em>gl.LINEAR_MIPMAP_LINEAR</em>，将放大过滤设置为 <em>gl.LINEAR</em>。一个纹理通常使用以下类似的代码进行配置：</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">bindTexture</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">generateMipmap</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">);</span><span class="w"> </span><span class="c1">// 需要 mipmap 来使用缩放过滤！</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">texParameteri</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_MIN_FILTER</span><span class="p">,</span><span class="nx">gl</span><span class="p">.</span><span class="nx">LINEAR_MIPMAP_LINEAR</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">texParameteri</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_MAG_FILTER</span><span class="p">,</span><span class="nx">gl</span><span class="p">.</span><span class="nx">LINEAR</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">anisotropyExtension</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 只有在可用时才开启各向异性过滤。</span>
<span class="w">    </span><span class="nx">max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getParameter</span><span class="p">(</span><span class="nx">anisotropyExtension</span><span class="p">.</span><span class="nx">MAX_TEXTURE_MAX_ANISOTROPY_EXT</span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">texParameteri</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span>
<span class="w">            </span><span class="nx">anisotropyExtension</span><span class="p">.</span><span class="nx">TEXTURE_MAX_ANISOTROPY_EXT</span><span class="p">,</span><span class="w"> </span><span class="nx">max</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>如果扩展不可用，纹理可能看起来不如它本可以的那么好，但它仍然可以工作（而且只有非常细心的用户才可能注意到）。</p>
</div>
<div class="tabbed-block">
<p>We start with a simple extension that can improve the appearance of textures in some scenes. The standard filtering methods for <abbr title="The operation of mapping texture coordinates to colors from a texture, including using mipmaps if available and applying a minification or magnification filter if necessary.">sampling</abbr> an <abbr title="An image that is applied to a surface as a texture, so that it looks at if the image is &quot;painted&quot; onto the surface.">image texture</abbr> give poor results when the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> is viewed at an oblique angle. In that case, a <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> on the surface corresponds to a trapezoidal region in the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>, and the standard minification and <abbr title="An operation that is used when applying a texture to an object, when the texture has to be stretched to fit the object. For an image texture, a magnification filter is applied to compute the color of a pixel when that pixel covers just a fraction of a pixel in the image.">magnification filter</abbr> rules such as <em>gl.LINEAR</em> don't handle that case very well. (Filtering was covered in <a href="../../c4/s3/#432-mipmap-和过滤">Subsection 4.3.2</a>.) A better result can be obtained, at the cost of additional computation, using something called <strong><abbr title="A technique for more accurate sampling of texture images, in the case where a pixel on the surface that is being textured corresponds to a non-rectangular region in the texture. Anisotropic filtering is available as an optional extension in WebGL.">anisotropic filtering</abbr></strong>, which samples the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> taking the trapezoidal shape into account. Many GPUs can do <abbr title="A technique for more accurate sampling of texture images, in the case where a pixel on the surface that is being textured corresponds to a non-rectangular region in the texture. Anisotropic filtering is available as an optional extension in WebGL.">anisotropic filtering</abbr>. It is not a required feature in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> implementations, but it is commonly available as an extension. The <abbr title="A technique for more accurate sampling of texture images, in the case where a pixel on the surface that is being textured corresponds to a non-rectangular region in the texture. Anisotropic filtering is available as an optional extension in WebGL.">anisotropic filtering</abbr> extension can be used with both <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 and <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0, in the same way.</p>
<p>The sample program <a href="../../../en/source/webgl/anisotropic-filtering.html">webgl/anisotropic-filtering.html</a> shows how to use the <abbr title="A technique for more accurate sampling of texture images, in the case where a pixel on the surface that is being textured corresponds to a non-rectangular region in the texture. Anisotropic filtering is available as an optional extension in WebGL.">anisotropic filtering</abbr> extension. It shows a large plane textured with a brick image that can be viewed from a sharp, oblique angle. If the extension is available, then the user can turn <abbr title="A technique for more accurate sampling of texture images, in the case where a pixel on the surface that is being textured corresponds to a non-rectangular region in the texture. Anisotropic filtering is available as an optional extension in WebGL.">anisotropic filtering</abbr> on and off. If it is not available, the program will still draw the scene, but only using standard filtering. Here are two images from the program. Anisotropic filtering is used in the image on the right. On the left, without <abbr title="A technique for more accurate sampling of texture images, in the case where a pixel on the surface that is being textured corresponds to a non-rectangular region in the texture. Anisotropic filtering is available as an optional extension in WebGL.">anisotropic filtering</abbr>, the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> is blurred even at moderate distanced from the viewer:</p>
<p><a class="glightbox" href="../../../en/c7/anisotropic-filtering.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c7/anisotropic-filtering.png" /></a></p>
<p>Each <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> extension has a name. The function <em>gl.getExtension(name)</em> is used to activate an extension, where name is a string containing the name of the extension. The return value of the function is null if the extension is not available, and you should always check the return value before attempting to use the extension. If the return value is not null, then it is a <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> object. The object might contain, for example, constants that are meant to be passed to <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> functions in order to make use of the capabilities of the extension. It can also contain completely new functions.</p>
<p>The name of the <abbr title="A technique for more accurate sampling of texture images, in the case where a pixel on the surface that is being textured corresponds to a non-rectangular region in the texture. Anisotropic filtering is available as an optional extension in WebGL.">anisotropic filtering</abbr> extension is "EXT_texture_filter_anisotropic." To test for the availability of the extension and to activate it, a program can use a statement such as</p>
<div class="highlight"><pre><span></span><code><span class="nx">anisotropyExtension</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getExtension</span><span class="p">(</span><span class="s2">&quot;EXT_texture_filter_anisotropic&quot;</span><span class="p">);</span>
</code></pre></div>
<p>If <em>anisotropyExtension</em> is <em>null</em>, then the extension is not available. If it is not null, then the object has a property named <em>TEXTURE_MAX_ANISOTROPY_EXT</em> that can be used as a parameter to <em>gl.texParameteri</em> to set the level, or amount, of <abbr title="A technique for more accurate sampling of texture images, in the case where a pixel on the surface that is being textured corresponds to a non-rectangular region in the texture. Anisotropic filtering is available as an optional extension in WebGL.">anisotropic filtering</abbr> that will be applied to the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. For example, after creating and binding a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>, a program might say</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">texParameteri</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span>
<span class="w">            </span><span class="nx">anisotropyExtension</span><span class="p">.</span><span class="nx">TEXTURE_MAX_ANISOTROPY_EXT</span><span class="p">,</span><span class="w"> </span><span class="mf">16</span><span class="p">);</span>
</code></pre></div>
<p>The third parameter is the <abbr title="A technique for more accurate sampling of texture images, in the case where a pixel on the surface that is being textured corresponds to a non-rectangular region in the texture. Anisotropic filtering is available as an optional extension in WebGL.">anisotropic filtering</abbr> level. Setting the level to 1 will turn off <abbr title="A technique for more accurate sampling of texture images, in the case where a pixel on the surface that is being textured corresponds to a non-rectangular region in the texture. Anisotropic filtering is available as an optional extension in WebGL.">anisotropic filtering</abbr>. Higher values give better results. There is an implementation-dependent maximum level, but asking for a level greater than the maximum is not an error—you will simply get the maximum level. To find out the maximum, you can use</p>
<div class="highlight"><pre><span></span><code><span class="nx">max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getParameter</span><span class="p">(</span><span class="w"> </span><span class="nx">anisotropyExtension</span><span class="p">.</span><span class="nx">MAX_TEXTURE_MAX_ANISOTROPY_EXT</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>It is recommended to use <em>gl.LINEAR_MIPMAP_LINEAR</em> as the <abbr title="An operation that is used when applying a texture to an object, when the texture has to be shrunk to fit the object. For an image texture, a minification filter is applied to compute the color of a pixel when that pixel covers several pixels in the image.">minification filter</abbr> and <em>gl.LINEAR</em> as the <abbr title="An operation that is used when applying a texture to an object, when the texture has to be stretched to fit the object. For an image texture, a magnification filter is applied to compute the color of a pixel when that pixel covers just a fraction of a pixel in the image.">magnification filter</abbr> when using <abbr title="A technique for more accurate sampling of texture images, in the case where a pixel on the surface that is being textured corresponds to a non-rectangular region in the texture. Anisotropic filtering is available as an optional extension in WebGL.">anisotropic filtering</abbr>. A <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> would typically be configured using code similar to the following:</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">bindTexture</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">generateMipmap</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">);</span><span class="w"> </span><span class="c1">// Need mipmaps for the minification filter!</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">texParameteri</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_MIN_FILTER</span><span class="p">,</span><span class="nx">gl</span><span class="p">.</span><span class="nx">LINEAR_MIPMAP_LINEAR</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">texParameteri</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_MAG_FILTER</span><span class="p">,</span><span class="nx">gl</span><span class="p">.</span><span class="nx">LINEAR</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">anisotropyExtension</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// turn on anisotropic filtering only if it is available.</span>
<span class="w">    </span><span class="nx">max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getParameter</span><span class="p">(</span><span class="nx">anisotropyExtension</span><span class="p">.</span><span class="nx">MAX_TEXTURE_MAX_ANISOTROPY_EXT</span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">texParameteri</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span>
<span class="w">            </span><span class="nx">anisotropyExtension</span><span class="p">.</span><span class="nx">TEXTURE_MAX_ANISOTROPY_EXT</span><span class="p">,</span><span class="w"> </span><span class="nx">max</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>If the extension is not available, the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> might not look as good as it might have, but it will still work (and only a very observant user is likely to notice).</p>
</div>
</div>
</div>
<h2 id="752-浮点颜色">7.5.2 浮点颜色<a class="headerlink" href="#752-浮点颜色" title="Permanent link">&para;</a></h2>
<p><strong>Floating-Point Colors</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="3:2"><input checked="checked" id="__tabbed_3_1" name="__tabbed_3" type="radio" /><input id="__tabbed_3_2" name="__tabbed_3" type="radio" /><div class="tabbed-labels"><label for="__tabbed_3_1">中文</label><label for="__tabbed_3_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>作为第二个例子，我们考虑一对名为 "OES_texture_float" 和 "WEBGL_color_buffer_float" 的扩展。第一个扩展使得可以使用颜色分量值为浮点数的纹理，而不是八位整数。第二个扩展使得可以通过将这样的纹理用作帧缓冲区的颜色缓冲区来渲染。（这些扩展仅适用于 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0，但是有一个类似的 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 扩展，EXT_color_buffer_float。）</p>
<p>为什么有人想这样做呢？八位整数对于视觉上表示颜色是足够的，但它们没有足够的精度来进行准确的计算。对于使用颜色分量进行大量数值处理的应用，浮点值是必不可少的。</p>
<p>以找到图像的平均颜色值为例，这需要将大量像素的颜色值相加。这是可以通过利用 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 的并行处理能力来加速的。我使用两个帧缓冲区和两个纹理作为颜色缓冲区的技术来进行操作。我假设图像的宽度和高度是 2 的幂。首先将图像绘制到第一个纹理上。将图像想象成水平和垂直分成两半，得到四个等大小的矩形。作为第一步，计算一个半大小的图像，这是那四个矩形的平均值。也就是说，半大小图像中的一个像素的颜色是原始图像中四个像素颜色的平均值。这个平均图像可以通过绘制一个半大小的矩形到第二个帧缓冲区来计算，使用第一个纹理中的图像的多个样本。以下是完成这项工作的片段着色器：</p>
<div class="highlight"><pre><span></span><code><span class="err">#</span><span class="nx">ifdef</span><span class="w"> </span><span class="nx">GL_FRAGMENT_PRECISION_HIGH</span>
<span class="nx">precision</span><span class="w"> </span><span class="nx">highp</span><span class="w"> </span><span class="kr">float</span><span class="p">;</span>
<span class="err">#</span><span class="k">else</span>
<span class="nx">precision</span><span class="w"> </span><span class="nx">mediump</span><span class="w"> </span><span class="kr">float</span><span class="p">;</span>
<span class="err">#</span><span class="nx">endif</span>
<span class="nx">varying</span><span class="w"> </span><span class="nx">vec2</span><span class="w"> </span><span class="nx">v_coords</span><span class="p">;</span><span class="w">  </span><span class="c1">// 纹理坐标，与对象坐标相同。</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">sampler2D</span><span class="w"> </span><span class="nx">texture</span><span class="p">;</span><span class="w">  </span><span class="c1">// 包含原始图像的纹理。</span>
<span class="nx">uniform</span><span class="w"> </span><span class="kr">float</span><span class="w"> </span><span class="nx">offset</span><span class="p">;</span><span class="w">  </span><span class="c1">// 纹理坐标空间中的正方形大小。</span>
<span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">texture2D</span><span class="p">(</span><span class="nx">texture</span><span class="p">,</span><span class="w"> </span><span class="nx">v_coords</span><span class="p">);</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">texture2D</span><span class="p">(</span><span class="nx">texture</span><span class="p">,</span><span class="w"> </span><span class="nx">v_coords</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">vec2</span><span class="p">(</span><span class="nx">offset</span><span class="p">,</span><span class="mf">0</span><span class="p">));</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">texture2D</span><span class="p">(</span><span class="nx">texture</span><span class="p">,</span><span class="w"> </span><span class="nx">v_coords</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">vec2</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="nx">offset</span><span class="p">));</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">texture2D</span><span class="p">(</span><span class="nx">texture</span><span class="p">,</span><span class="w"> </span><span class="nx">v_coords</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">vec2</span><span class="p">(</span><span class="nx">offset</span><span class="p">,</span><span class="nx">offset</span><span class="p">));</span>
<span class="w">    </span><span class="nx">gl_FragColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">d</span><span class="p">)</span><span class="o">/</span><span class="mf">4.0</span><span class="p">;</span><span class="w">  </span><span class="c1">// 颜色是四个样本的平均值。</span>
<span class="p">}</span>
</code></pre></div>
<p>在这第一步中，绘制了顶点在 (0,0) 和 (0.5,0.5) 的正方形，<em>offset</em> 是 0.5。绘制是在坐标系统中完成的，其中顶点为 (0,0) 和 (1,1) 的正方形覆盖了整个绘图区域。在那个坐标系统中，顶点在 (0,0) 和 (0.5,0.5) 的正方形覆盖了绘图区域的左下四分之一。片段着色器中的第一个样本来自纹理图像的那个四分之一，另外三个样本来自图像其他三个四分之一中的对应点。</p>
<p>在第二步中，两个帧缓冲区的角色被交换，绘制了顶点在 (0,0) 和 (0.25,0.25) 的正方形，使用相同的片段着色器，<em>offset</em> 等于 0.25。由于帧缓冲区被交换了，第二步是采样第一步产生的半大小图像。结果是四分之一大小的图像，它是覆盖半大小图像的四个矩形的平均值——因此也是覆盖原始图像的 16 个矩形的平均值。这可以重复进行，使用越来越小的正方形，直到结果图像足够小，其颜色可以有效地读回到 <abbr title="The Central Processing Unit in a computer, the component that actually executes programs. The CPU reads machine language instructions from the computer's memory and carries them out.">CPU</abbr> 并在其中平均。得到的是一个颜色值，它是原始图像中所有像素颜色的平均值。我们期望，由于 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 并行完成了大量的工作，使用这种技术我们可以得到比在 <abbr title="The Central Processing Unit in a computer, the component that actually executes programs. The CPU reads machine language instructions from the computer's memory and carries them out.">CPU</abbr> 上完成所有计算更快的答案。</p>
<p>这里的关键是，为了获得准确的结果，我们希望颜色分量在 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 中以浮点值表示，而不是八位整数。</p>
<hr />
<p>我在示例程序 <a href="../../../en/source/webgl/image-evolver.html">webgl/image-evolver.html</a> 中使用了这种技术。在这个程序中，问题是找到两幅图像之间平均<em>差异</em>的颜色。我首先将两幅图像绘制到两个纹理上。然后，我渲染一个差异图像，其中像素的颜色是两个纹理中相同像素颜色差异的绝对值。这是用另一个特殊用途的着色器程序完成的。然后，我将上述平均过程应用于差异图像。</p>
<p>示例程序的实际目的是尝试使用“遗传算法”“进化”出一个给定图像的近似值。（它的灵感来自我2015年秋季课程的两位学生，Felix Taschbach 和 Pieter Schaap，他们为他们的项目做了一个类似的程序，尽管他们没有使用 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>。）在程序中，原始图像与近似值之间的平均差异被用作衡量近似值有多好的指标。我使用了一个非常简单的灰度图像作为目标，用小方块制作近似值。您不需要知道任何关于遗传算法的信息，特别是因为该程序没有实际用途。然而，如果您想尝试理解它，源代码有大量的注释。这是程序在一个特别成功的运行中的截图，显示了原始图像和在运行遗传算法7500代后产生的最好近似值：</p>
<p><a class="glightbox" href="../../../en/c7/image-evolver.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c7/image-evolver.png" /></a></p>
<p>但我们在这里感兴趣的是程序如何使用 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 浮点颜色扩展。程序在初始化期间尝试激活扩展，使用以下代码：</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">EXTcbf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getExtension</span><span class="p">(</span><span class="s2">&quot;WEBGL_color_buffer_float&quot;</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">EXTtf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getExtension</span><span class="p">(</span><span class="s2">&quot;OES_texture_float&quot;</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">EXTcbf</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="nx">EXTtf</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="ne">Error</span><span class="p">(</span><span class="s2">&quot;This program requires the WebGL extension&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span>
<span class="w">            </span><span class="s2">&quot;WEBGL_color_buffer_float, which is not available in this browser.&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>程序需要这些扩展，所以如果无法激活它们，就会抛出异常。扩展对象 <em>EXTcbf</em> 和 <em>EXTtf</em> 在这个程序中没有需要的属性；然而，调用 <em>gl.getExtension</em> 来激活扩展仍然是必要的。</p>
<p>程序创建了两个浮点纹理，它们附加到帧缓冲区用作颜色缓冲区。（见 <a href="../s4/#742-渲染到纹理">7.4.2小节</a>。）以下是创建其中一个纹理的代码：</p>
<div class="highlight"><pre><span></span><code><span class="nx">tex1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createTexture</span><span class="p">();</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bindTexture</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">tex1</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">texImage2D</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span><span class="w"> </span><span class="mf">256</span><span class="p">,</span><span class="w"> </span><span class="mf">256</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">FLOAT</span><span class="p">,</span><span class="w"> </span><span class="kc">null</span><span class="p">);</span>
</code></pre></div>
<p>最后一行的参数 <em>gl.FLOAT</em> 指定了纹理中颜色分量的数据类型为 <strong><em>float</em></strong>。如果扩展没有被激活，该数据类型将是错误的。</p>
<p>当 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 使用这些纹理进行平均计算时，它正在进行浮点计算。程序计算了一系列越来越小的平均图像，最后以一个 4x4 像素的图像结束。然后，它使用以下代码将 16 个像素颜色从纹理中读回：</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Float32Array</span><span class="p">(</span><span class="w"> </span><span class="mf">4</span><span class="o">*</span><span class="mf">4</span><span class="o">*</span><span class="mf">4</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// 16 个像素，每个像素 4 个数字</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">readPixels</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">4</span><span class="p">,</span><span class="mf">4</span><span class="p">,</span><span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FLOAT</span><span class="p">,</span><span class="nx">data</span><span class="p">)</span>
</code></pre></div>
<p><em>gl.readPixels</em> 调用将 16 个像素的颜色数据读入数组 <em>data</em> 中。同样，<em>gl.FLOAT</em> 参数指定了数据类型，只有在激活了扩展之后，该参数值在 <em>gl.readPixels</em> 中才是合法的。</p>
</div>
<div class="tabbed-block">
<p>As a second example, we consider a pair of extensions named "OES_texture_float" and "WEBGL_color_buffer_float". The first of these makes it possible to use textures in which <abbr title="One of the numbers used in a color model to specify a color. For example, in the RGB color model, a color is specified by three color components representing the amounts of red, green, and blue in the color.">color component</abbr> values are floating-point numbers, instead of eight-bit integers. The second makes it possible to render to such a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> by using it as the <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr> in a <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr>. (These extensions are only for <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0, but there is a similar <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 extension, EXT_color_buffer_float.)</p>
<p>Why would someone want to do this? Eight-bit integers are fine for representing colors visually, but they don't have enough precision for doing accurate calculations. For applications that do significant numerical processing with color components, floating-point values are essential.</p>
<p>As an example, consider finding the average color value of an image, which requires adding up the color values from a large number of <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr>. This is something that can be speeded up by using the parallel processing power of a <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>. My technique for doing so uses two framebuffers, with two textures serving as color buffers. I assume that the image width and height are powers of two. Start by drawing the image to the first <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. Think of the image as divided in half, horizontally and vertically, giving four equal-sizes rectangles. As a first step, compute a half-size image that is the average of those four rectangles. That is, the color of a <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> in the half-size image is the average of the colors of four <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr> in the original. The averaged image can be computed by drawing a half-size rectangle to the second <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr>, using multiple samples from the image in the first <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. Here is a <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> that does the work:</p>
<div class="highlight"><pre><span></span><code><span class="err">#</span><span class="nx">ifdef</span><span class="w"> </span><span class="nx">GL_FRAGMENT_PRECISION_HIGH</span>
<span class="nx">precision</span><span class="w"> </span><span class="nx">highp</span><span class="w"> </span><span class="kr">float</span><span class="p">;</span>
<span class="err">#</span><span class="k">else</span>
<span class="nx">precision</span><span class="w"> </span><span class="nx">mediump</span><span class="w"> </span><span class="kr">float</span><span class="p">;</span>
<span class="err">#</span><span class="nx">endif</span>
<span class="nx">varying</span><span class="w"> </span><span class="nx">vec2</span><span class="w"> </span><span class="nx">v_coords</span><span class="p">;</span><span class="w">  </span><span class="c1">// Texture coordinates, same as object coords.</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">sampler2D</span><span class="w"> </span><span class="nx">texture</span><span class="p">;</span><span class="w">  </span><span class="c1">// A texture containing the original image.</span>
<span class="nx">uniform</span><span class="w"> </span><span class="kr">float</span><span class="w"> </span><span class="nx">offset</span><span class="p">;</span><span class="w">  </span><span class="c1">// Size of square in texture coordinate space.</span>
<span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">texture2D</span><span class="p">(</span><span class="nx">texture</span><span class="p">,</span><span class="w"> </span><span class="nx">v_coords</span><span class="p">);</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">texture2D</span><span class="p">(</span><span class="nx">texture</span><span class="p">,</span><span class="w"> </span><span class="nx">v_coords</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">vec2</span><span class="p">(</span><span class="nx">offset</span><span class="p">,</span><span class="mf">0</span><span class="p">));</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">texture2D</span><span class="p">(</span><span class="nx">texture</span><span class="p">,</span><span class="w"> </span><span class="nx">v_coords</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">vec2</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="nx">offset</span><span class="p">));</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">texture2D</span><span class="p">(</span><span class="nx">texture</span><span class="p">,</span><span class="w"> </span><span class="nx">v_coords</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">vec2</span><span class="p">(</span><span class="nx">offset</span><span class="p">,</span><span class="nx">offset</span><span class="p">));</span>
<span class="w">    </span><span class="nx">gl_FragColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">d</span><span class="p">)</span><span class="o">/</span><span class="mf">4.0</span><span class="p">;</span><span class="w">  </span><span class="c1">// Color is average of four samples.</span>
<span class="p">}</span>
</code></pre></div>
<p>In this first pass, the square with vertices at (0,0) and (0.5,0.5) is rendered, and <em>offset</em> is 0.5. The drawing is done in a <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr> in which the square with vertices (0,0) and (1,1) covers the entire drawing area. In that <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr>, the square with vertices at (0,0) and (0.5,0.5) covers the lower left quarter of the drawing area. The first sample in the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> comes from that quarter of the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image, and the other three samples come from corresponding points in the other three quarters of the image.</p>
<p>In a second pass, the roles of the two framebuffers are swapped, and a square with vertices at (0,0) and (0.25,0.25) is drawn, using the same <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> with <em>offset</em> equal to 0.25. Since the framebuffers were swapped, the second pass is <abbr title="The operation of mapping texture coordinates to colors from a texture, including using mipmaps if available and applying a minification or magnification filter if necessary.">sampling</abbr> the half-sized image that was produced in the first pass. The result is a quarter-sized image that is the average of four rectangles that cover the half-sized image—and therefore of 16 rectangles that cover the original image. This can be repeated, with smaller and smaller squares, until the resulting image is small enough that its colors can be efficiently read back into the <abbr title="The Central Processing Unit in a computer, the component that actually executes programs. The CPU reads machine language instructions from the computer's memory and carries them out.">CPU</abbr> and averaged there. The result is a color value that is the average of all the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr> from the original image. We expect that, because a lot of the work is done in parallel by the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>, we can get the answer much faster using this technique than if we had simply done all the computations on the <abbr title="The Central Processing Unit in a computer, the component that actually executes programs. The CPU reads machine language instructions from the computer's memory and carries them out.">CPU</abbr>.</p>
<p>The point here is that for an accurate result, we want the color components to be represented as floating point values in the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>, not as eight-bit integers.</p>
<hr />
<p>I use this technique in the sample program <a href="../../../en/source/webgl/image-evolver.html">webgl/image-evolver.html</a>. In that program, the problem is to find the average <em>difference</em> in color between two images. I start by drawing the two images to two textures. I then render a difference image, in which the color of a <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> is the absolute value of the difference between the colors of the same <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> in the two textures. This is done with another special-purpose <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> program. I then apply the above averaging process to the difference image.</p>
<p>The actual point of the sample program is to try to "evolve" an approximation to a given image, using a "genetic algorithm." (It was inspired by two students from my Fall, 2015 class, Felix Taschbach and Pieter Schaap, who worked on a similar program for their final project, though they didn't use the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr>.) In the program, the average difference between the original image and an approximation is used as a measure of how good the approximation is. I used a very simple <abbr title="Refers to a color scheme or image in which each color is a shade of gray (where the term &quot;shade of gray&quot; here includes black and white). Typically, 256 shades of gray are used. Grayscale is also called &quot;monochrome.&quot;">grayscale</abbr> image as the goal, with approximations made from small squares. You don't need to know anything about the genetic algorithm, especially since the program has no practical purpose. However, the source code is heavily commented if you want to try to understand it. Here is a screenshot from one particularly successful run of the program, showing the original image and the best approximation produced after running the genetic algorithm for 7500 generations:</p>
<p><a class="glightbox" href="../../../en/c7/image-evolver.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c7/image-evolver.png" /></a></p>
<p>But what interests us here is how the program uses the <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> floating-point color extensions. The program attempts to activate the extensions during initialization using the following code:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">EXTcbf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getExtension</span><span class="p">(</span><span class="s2">&quot;WEBGL_color_buffer_float&quot;</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">EXTtf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getExtension</span><span class="p">(</span><span class="s2">&quot;OES_texture_float&quot;</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">EXTcbf</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="nx">EXTtf</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="k">throw</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="ne">Error</span><span class="p">(</span><span class="s2">&quot;This program requires the WebGL extension&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span>
<span class="w">        </span><span class="s2">&quot;WEBGL_color_buffer_float, which is not available in this browser.&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>The program requires the extensions, so an exception is thrown if they can't be activated. The extension objects, <em>EXTcbf</em> and <em>EXTtf</em>, don't have any properties that are needed in this program; however, it is still necessary to call <em>gl.getExtension</em> to activate the extensions.</p>
<p>The program creates two floating-point textures that are attached to framebuffers for use as color buffers. (See <a href="../s4/#742-渲染到纹理">Subsection 7.4.2</a>.) Here is the code that creates one of those textures:</p>
<div class="highlight"><pre><span></span><code><span class="nx">tex1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createTexture</span><span class="p">();</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bindTexture</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">tex1</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">texImage2D</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span><span class="w"> </span><span class="mf">256</span><span class="p">,</span><span class="w"> </span><span class="mf">256</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">FLOAT</span><span class="p">,</span><span class="w"> </span><span class="kc">null</span><span class="p">);</span>
</code></pre></div>
<p>The parameter <em>gl.FLOAT</em> in the last line specifies that the data type for the color components in the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> is <strong><em>float</em></strong>. That data type would be an error if the extensions had not been activated.</p>
<p>When the <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> does the averaging computation with these textures, it is doing floating-point calculations. The program computes a series of smaller and smaller averaged images, stopping with a 4-by-4 <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> image. It then reads the 16 <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> colors back from the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> using the following code:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Float32Array</span><span class="p">(</span><span class="w"> </span><span class="mf">4</span><span class="o">*</span><span class="mf">4</span><span class="o">*</span><span class="mf">4</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// 16 pixels, 4 numbers per pixels</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">readPixels</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">4</span><span class="p">,</span><span class="mf">4</span><span class="p">,</span><span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FLOAT</span><span class="p">,</span><span class="nx">data</span><span class="p">)</span>
</code></pre></div>
<p>The call to <em>gl.readPixels</em> reads the color data for the 16 <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr> into the array, <em>data</em>. Again, the <em>gl.FLOAT</em> parameter specifies the data type, and that parameter value is legal in <em>gl.readPixels</em> only because the extensions have been activated.</p>
</div>
</div>
</div>
<h2 id="753-webgl-10-中的实例化绘图">7.5.3 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 中的实例化绘图<a class="headerlink" href="#753-webgl-10-中的实例化绘图" title="Permanent link">&para;</a></h2>
<p><strong>Instanced Drawing in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="4:2"><input checked="checked" id="__tabbed_4_1" name="__tabbed_4" type="radio" /><input id="__tabbed_4_2" name="__tabbed_4" type="radio" /><div class="tabbed-labels"><label for="__tabbed_4_1">中文</label><label for="__tabbed_4_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p><a href="../../c6/s1/#617-webgl-20顶点数组对象">6.1.7小节</a> 和 <a href="../../c6/s1/#618-webgl-20实例化绘图">6.1.8小节</a> 讨论了 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 的两个特性：<abbr title="在WebGL 2.0中，顶点数组对象（VAO）是通常位于显卡上的一块内存区域，它保存了一系列属性设置，如启用状态和顶点属性指针的值。然后，所有设置都可以通过绑定VAO来选择。">顶点数组对象</abbr>（Vertex Array Objects，VAOs）和实例化绘图。尽管这些特性不是 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 的标准部分，但两者都可以作为可选的 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 扩展来使用。VAOs 由扩展 "OES_vertex_array_object" 启用，而实例化绘图由 "ANGLE_instanced_arrays" 启用。作为示例，我们简要地看一下 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 中的实例化绘图。</p>
<p>示例 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 程序 <a href="../../../en/source/webgl/instancing-test-webgl1.html">webgl/instancing-test-webgl1.html</a> 使用了实例化绘图扩展。它是从 <a href="../../c6/s1/#618-webgl-20实例化绘图">6.1.8小节</a> 中的示例 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 程序修改而来的，修改为使用版本 1.0，但功能完全相同。要在 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 中使用实例化绘图，必须启用相应的扩展：</p>
<div class="highlight"><pre><span></span><code><span class="nx">instancedDrawExt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getExtension</span><span class="p">(</span><span class="s2">&quot;ANGLE_instanced_arrays&quot;</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">instancedDrawExt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="ne">Error</span><span class="p">(</span><span class="s2">&quot;WebGL 1.0 Instanced Arrays extension is required.&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>扩展对象 <em>instancedDrawExt</em> 包含与 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 中实例化绘图功能等价的函数：<em>gl.vertexAttribDivisor()</em>、<em>gl.drawArraysInstanced()</em> 和 <em>gl.drawElementsInstanced()</em>。然而，这些函数是扩展对象的属性，而不是图形上下文 gl 的属性，它们的名字中附加了 "ANGLE" 这个词。因此，原始 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 程序中的命令</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">drawArraysInstanced</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TRIANGLE_FAN</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">64</span><span class="p">,</span><span class="w"> </span><span class="nx">DISK_COUNT</span><span class="p">);</span>
</code></pre></div>
<p>在 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 程序中被替换为</p>
<div class="highlight"><pre><span></span><code><span class="nx">instancedDrawExt</span><span class="p">.</span><span class="nx">drawArraysInstancedANGLE</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TRIANGLE_FAN</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">64</span><span class="p">,</span><span class="w"> </span><span class="nx">DISK_COUNT</span><span class="p">);</span>
</code></pre></div>
<p>同样地，</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">vertexAttribDivisor</span><span class="p">(</span><span class="nx">a_color_loc</span><span class="p">,</span><span class="mf">1</span><span class="p">);</span>
</code></pre></div>
<p>变为</p>
<div class="highlight"><pre><span></span><code><span class="nx">instancedDrawExt</span><span class="p">.</span><span class="nx">vertexAttribDivisorANGLE</span><span class="p">(</span><span class="nx">a_color_loc</span><span class="p">,</span><span class="mf">1</span><span class="p">);</span>
</code></pre></div>
<p>请注意，通常情况下，一个不使用任何扩展的 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 程序将无需任何修改即可作为 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 程序工作。然而，如果 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 程序使用了在 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 中不再可用或不再需要的扩展，那么将需要一些工作来将程序转换为 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0。</p>
</div>
<div class="tabbed-block">
<p><a href="../../c6/s1/#617-webgl-20顶点数组对象">Subsection 6.1.7</a> and <a href="../../c6/s1/#618-webgl-20实例化绘图">Subsection 6.1.8</a> discussed two features of <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0, Vertex Array Objects and <abbr title="The ability to render multiple versions of a primitive with a single function call. Each copy can have its own values for certain attributes, such as color or transformation.">instanced drawing</abbr>. Although these features are not a standard part of <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0, both are available as optional <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 extensions. VAOs are enabled by the extension "OES_vertex_array_object", while <abbr title="The ability to render multiple versions of a primitive with a single function call. Each copy can have its own values for certain attributes, such as color or transformation.">instanced drawing</abbr> is enabled by "ANGLE_instanced_arrays". As an example, we look briefly at <abbr title="The ability to render multiple versions of a primitive with a single function call. Each copy can have its own values for certain attributes, such as color or transformation.">instanced drawing</abbr> in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0.</p>
<p>The sample <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 program <a href="../../../en/source/webgl/instancing-test-webgl1.html">webgl/instancing-test-webgl1.html</a> uses the <abbr title="The ability to render multiple versions of a primitive with a single function call. Each copy can have its own values for certain attributes, such as color or transformation.">instanced drawing</abbr> extension. It is a copy of the sample <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 program from <a href="../../c6/s1/#618-webgl-20实例化绘图">Subsection 6.1.8</a>, modified to use version 1.0, but with exactly the same functionality. To use <abbr title="The ability to render multiple versions of a primitive with a single function call. Each copy can have its own values for certain attributes, such as color or transformation.">instanced drawing</abbr> in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0, the appropriate extension has to be enabled:</p>
<div class="highlight"><pre><span></span><code><span class="nx">instancedDrawExt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getExtension</span><span class="p">(</span><span class="s2">&quot;ANGLE_instanced_arrays&quot;</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">instancedDrawExt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="ne">Error</span><span class="p">(</span><span class="s2">&quot;WebGL 1.0 Instanced Arrays extension is required.&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>The extension object, <em>instancedDrawExt</em>, contains functions that are equivalent to the <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 functions for <abbr title="The ability to render multiple versions of a primitive with a single function call. Each copy can have its own values for certain attributes, such as color or transformation.">instanced drawing</abbr>: <em>gl.vertexAttribDivisor()</em>. <em>gl.drawArraysInstanced()</em>, and <em>gl.drawElementsInstanced()</em>. However, the functions are properties of the extension object, not of the graphics context gl, and their names have the word "ANGLE" appended. So, the command</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">drawArraysInstanced</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TRIANGLE_FAN</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">64</span><span class="p">,</span><span class="w"> </span><span class="nx">DISK_COUNT</span><span class="p">);</span>
</code></pre></div>
<p>from the original <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 program is replaced by</p>
<div class="highlight"><pre><span></span><code><span class="nx">instancedDrawExt</span><span class="p">.</span><span class="nx">drawArraysInstancedANGLE</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TRIANGLE_FAN</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">64</span><span class="p">,</span><span class="w"> </span><span class="nx">DISK_COUNT</span><span class="p">);</span>
</code></pre></div>
<p>in the <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 program. And</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">vertexAttribDivisor</span><span class="p">(</span><span class="nx">a_color_loc</span><span class="p">,</span><span class="mf">1</span><span class="p">);</span>
</code></pre></div>
<p>becomes</p>
<div class="highlight"><pre><span></span><code><span class="nx">instancedDrawExt</span><span class="p">.</span><span class="nx">vertexAttribDivisorANGLE</span><span class="p">(</span><span class="nx">a_color_loc</span><span class="p">,</span><span class="mf">1</span><span class="p">);</span>
</code></pre></div>
<p>Note that, in general, a <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 program that does <strong>not</strong> use any extensions will work as a <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 program without any modifications. However, if the <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 program uses extensions that are no longer available or no longer needed in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0, some work will be required to convert the program to <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0.</p>
</div>
</div>
</div>
<h2 id="754-延迟着色">7.5.4 <abbr title="一种多遍渲染技术，其中第一个遍历处理几何体并保存相关数据，例如变换后的坐标、法线向量和材质属性。这些数据可以存储在纹理中，在这种情况下被称为“几何缓冲区”或“G缓冲区”。然后，可以在额外的遍历中使用预计算的几何缓冲区中的信息来计算光照和其他效果，而不是为每个遍历重新计算。">延迟着色</abbr><a class="headerlink" href="#754-延迟着色" title="Permanent link">&para;</a></h2>
<p><strong>Deferred Shading</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="5:2"><input checked="checked" id="__tabbed_5_1" name="__tabbed_5" type="radio" /><input id="__tabbed_5_2" name="__tabbed_5" type="radio" /><div class="tabbed-labels"><label for="__tabbed_5_1">中文</label><label for="__tabbed_5_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>我们将讨论一个 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 的扩展，这个扩展对于一种称为<strong><abbr title="一种多遍渲染技术，其中第一个遍历处理几何体并保存相关数据，例如变换后的坐标、法线向量和材质属性。这些数据可以存储在纹理中，在这种情况下被称为“几何缓冲区”或“G缓冲区”。然后，可以在额外的遍历中使用预计算的几何缓冲区中的信息来计算光照和其他效果，而不是为每个遍历重新计算。">延迟着色</abbr></strong>的重要渲染技术非常有用。我没有延迟渲染的示例程序，而且我只会在一般术语中讨论它。</p>
<p>延迟着色被用作渲染复杂场景时的优化，并且经常用于加速视频游戏中的渲染。它与光照最密切相关，因为它可以用来渲染具有大量光源的场景，但对其他效果也有用。</p>
<p>回想一下，在 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 或 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 着色器中可以表示的光源数量是有限的。但是，可以使用多遍算法来渲染具有许多光源的场景：每个遍历计算一个光源或少数几个光源的贡献，并将遍历的结果相加以给出完整的场景。问题是，如果每个遍历的渲染都以正常方式完成，那么有很多必须重新计算的事情，以完全相同的方式，在每个遍历中。例如，假设使用逐像素光照，包括计算每个像素的材质属性和单位法线向量。延迟着色旨在避免重复的工作。</p>
<p>在延迟着色中，第一个遍历用于计算图像中每个像素的材质属性、法线向量以及所需的其他数据。所有这些数据都被保存起来，以便在额外的遍历中用于计算光照和其他可能的效果。对于给定的像素，只保存在像素处实际可见的对象的数据，因为隐藏表面的数据不需要渲染场景。第一个遍历使用场景中对象的几何体和属性。后续遍历需要了解的关于几何体和属性的所有信息都在保存的数据中。</p>
<p>保存的数据可以存储在纹理对象中。（浮点纹理对象非常适合此目的，因为数据将用于进一步的计算。）在这种情况下，纹理中的值并不一定代表图像。例如，一个纹理中的 RGB 颜色分量可能表示法线向量的 x、y 和 z <abbr title="一种将数值坐标分配给几何点的方法。在二维中，每个点对应一对数字。在三维中，每个点对应一组三个数字。">坐标</abbr>。如果后续遍历中需要深度值，它可能存储在同一纹理的 <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> 颜色分量中。另一个纹理可能保存漫反射颜色，而第三个纹理在其 RGB 分量中保存镜面颜色，并在其 <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> 分量中保存光泽度值。着色器程序可以自由地以它们喜欢的方式解释纹理中的数据。</p>
<hr />
<p><abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 着色器可以写入纹理数据，使用帧缓冲区。但是标准的 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 一次只能写入一个帧缓冲区。现在，我们可以使用每个需要计算的纹理的单独遍历来完成，但这将涉及到大量的冗余计算，这正是我们试图避免的。我们需要一个 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 扩展，使得着色器可以同时写入多个帧缓冲区。我们需要的扩展名为 "WEBGL_draw_buffers"。当激活该扩展时，可以将多个纹理（或渲染缓冲区）附加到帧缓冲区，并且使得着色器可以同时将数据写入所有附加的着色器。这个扩展使用起来相对复杂。它必须像通常一样通过以下形式的语句激活：</p>
<div class="highlight"><pre><span></span><code><span class="nx">EXTdb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getExtension</span><span class="p">(</span><span class="s2">&quot;WEBGL_draw_buffers&quot;</span><span class="p">);</span>
</code></pre></div>
<p>假设扩展可用，着色器中可以使用的最大颜色缓冲区数量由 <em>EXTdb.MAX_DRAW_BUFFERS_WEBGL</em> 给出，至少为四个。有了这个扩展，你可以使用以下形式的代码将多个纹理作为颜色缓冲区附加到帧缓冲区：</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">bindFramebuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAMEBUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">framebuffer</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">framebufferTexture2D</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAMEBUFFER</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="nx">EXTdb</span><span class="p">.</span><span class="nx">COLOR_ATTACHMENT0_WEBGL</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">texture1</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">framebufferTexture2D</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAMEBUFFER</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="nx">EXTdb</span><span class="p">.</span><span class="nx">COLOR_ATTACHMENT1_WEBGL</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">texture2</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">);</span>
</code></pre></div>
<p>以此类推，使用扩展对象中的常量如 <em>EXTdb.COLOR_ATTACHMENT1_WEBGL</em> 来指定附加点。</p>
<p>通常在片段着色器中，输出到颜色缓冲区的颜色是通过给特殊变量 <em>gl_FragColor</em> 分配一个值来指定的。当使用多个颜色缓冲区时，情况会发生变化。在这种情况下，片段着色器有一个特殊的变量 gl_FragData，它是一个 vec4 数组，每个可能的颜色缓冲区一个。通过给 <em>gl_FragData[0], gl_FragData[1], ....</em> 分配值，将颜色输出到颜色缓冲区。因为这是着色器合法语法的一个变化，所以还必须通过在代码开头添加以下行来在片段着色器源代码中激活扩展：</p>
<div class="highlight"><pre><span></span><code><span class="err">#</span><span class="nx">extension</span><span class="w"> </span><span class="nx">GL_EXT_draw_buffers</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">require</span>
</code></pre></div>
<p>假设我们想要在颜色缓冲区中存储法线向量、漫反射颜色、镜面颜色和对象坐标。假设这些值作为变化变量或 uniform 变量输入到着色器中，除了漫反射颜色，它是从纹理中采样的。那么片段着色器可能采用以下形式：</p>
<div class="highlight"><pre><span></span><code><span class="err">#</span><span class="nx">extension</span><span class="w"> </span><span class="nx">GL_EXT_draw_buffers</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">require</span>
<span class="nx">precision</span><span class="w"> </span><span class="nx">highp</span><span class="w"> </span><span class="kr">float</span><span class="p">;</span>
<span class="nx">varying</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">v_normal</span><span class="p">,</span><span class="w"> </span><span class="nx">v_objectCoords</span><span class="p">;</span>
<span class="nx">varying</span><span class="w"> </span><span class="nx">vec2</span><span class="w"> </span><span class="nx">v_texCoords</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">u_specular</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="kr">float</span><span class="w"> </span><span class="nx">u_shininess</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">sampler2D</span><span class="w"> </span><span class="nx">texture</span><span class="p">;</span>
<span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">gl_FragData</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="w"> </span><span class="nx">normalize</span><span class="p">(</span><span class="nx">v_normal</span><span class="p">),</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl_FragData</span><span class="p">[</span><span class="mf">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="w"> </span><span class="nx">v_object_coords</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl_FragData</span><span class="p">[</span><span class="mf">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">texture2D</span><span class="p">(</span><span class="w"> </span><span class="nx">texture</span><span class="p">,</span><span class="w"> </span><span class="nx">v_texCoords</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl_fragData</span><span class="p">[</span><span class="mf">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="w"> </span><span class="nx">u_specular</span><span class="p">,</span><span class="w"> </span><span class="nx">u_shininess</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>使用扩展的最后一个要求是指定在 gl_FragData 中使用的索引与附加到帧缓冲区的颜色缓冲区之间的对应关系。似乎这种对应关系应该是自动的，但实际上不是。你必须使用扩展对象中的 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 函数 <em>EXTdb.drawBuffersWEBGL</em> 来指定它。这个函数接受一个数组作为参数，数组中的值从常量 <em>EXTdb.COLOR_ATTACHMENT0_WEBGL</em>, <em>EXTdb.COLOR_ATTACHMENT1_WEBGL</em>, .... 中选择。这些与在帧缓冲区中指定颜色缓冲区附加点时使用的常量相同。例如，如果你出于某种原因想要片段着色器输出到附加在 2 和 3 附件点的颜色缓冲区，你会调用：</p>
<div class="highlight"><pre><span></span><code><span class="nx">EXTdb</span><span class="p">.</span><span class="nx">drawBuffersWEBGL</span><span class="p">(</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="nx">EXTdb</span><span class="p">.</span><span class="nx">COLOR_ATTACHMENT2_WEBGL</span><span class="p">,</span>
<span class="w">    </span><span class="nx">EXTdb</span><span class="p">.</span><span class="nx">COLOR_ATTACHMENT3_WEBGL</span>
<span class="p">]</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>经过所有这些设置之后，你就可以进行延迟着色的第一个遍历了。对于后续的遍历，你会使用一个不同的着色器，只有一个颜色缓冲区。对于这些遍历，你希望在图像中的每个像素上运行一次片段着色器。片段着色器将使用在第一个遍历中保存的像素数据以及其他信息（如光源属性）来计算像素的输出颜色。你可以通过绘制一个覆盖图像的单个矩形来简单地触发对每个像素的片段着色器的调用。</p>
<p>延迟着色背后的理论并不复杂，但在实现中有很多细节需要正确处理。延迟着色只是视频游戏程序员用来提高他们游戏渲染速度的众多技巧之一。</p>
</div>
<div class="tabbed-block">
<p>I will discuss one more <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 extension, one that is useful for an important <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> technique called <strong><abbr title="A multi-pass rendering technique where a first pass processes the geometry and saves relevant information such as transformed coordinates, normal vectors, and material properties. The data can be stored in textures, which are called &quot;geometry buffers&quot; or &quot;G-buffers&quot; in this context. Lighting and other effects can then be computed in additional passes, using the pre-computed information from the geometry buffers instead of re-computing it for each pass.">deferred shading</abbr></strong>. I don't have a sample program for deferred <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr>, and I will only discuss it in general terms.</p>
<p>Deferred shading is used as an optimization when <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> complex scenes, and it is often used to speed up <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> in video games. It is most closely associated with <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr>, since it can be used to render scenes with large numbers of light sources, but it can also be useful for other effects.</p>
<p>Recall that the number of lights that can be represented in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> or in a <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> is limited. But scenes with many lights can be rendered using a <abbr title="A rendering algorithm that draws a scene several times and combines the results somehow to compute the final image. A simple example is anaglyph stereo, in which a left-eye and right-eye image of the scene are rendered separately and combined.">multi-pass algorithm</abbr>: Each pass computes the contribution of one light, or a small number of lights, and the results of the passes are added together to give the complete scene. The problem is that, if the <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> in each pass is done in the normal way, then there are a lot of things that have to be recomputed, in exactly the same way, in each pass. For example, assuming that per-<abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> is used, that includes computing <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> properties and a unit <abbr title="A normal vector to a surface at a point on that surface is a vector that is perpendicular to the surface at that point. Normal vectors to curves are defined similarly. Normal vectors are important for lighting calculations.">normal vector</abbr> for each <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> in the image. Deferred shading aims to avoid the duplicated effort.</p>
<p>In <abbr title="A multi-pass rendering technique where a first pass processes the geometry and saves relevant information such as transformed coordinates, normal vectors, and material properties. The data can be stored in textures, which are called &quot;geometry buffers&quot; or &quot;G-buffers&quot; in this context. Lighting and other effects can then be computed in additional passes, using the pre-computed information from the geometry buffers instead of re-computing it for each pass.">deferred shading</abbr>, a first pass is used to compute <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> properties, normal vectors, and whatever other data is needed, for each <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> in the image. All of that data is saved, to be used in additional passes that will compute <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> and possibly other effects. For a given <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>, only the data for the object that is actually visible at the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> is saved, since data for hidden surfaces is not needed to render the scene. The first pass uses the geometry and <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr> of objects in the scene. Everything that the later passes need to know about geometry and <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr> is in the saved data.</p>
<p>The saved data can be stored in <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> objects. (Floating point textures are ideal for this, since the data will be used in further calculations.) In this case, the values in the textures don't necessarily represent images. For example, the <abbr title="A color specified by three numbers giving the amount of red, green, and blue in the color.">RGB color</abbr> components in one <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> might represent the x, y, and z coordinates of a <abbr title="A normal vector to a surface at a point on that surface is a vector that is perpendicular to the surface at that point. Normal vectors to curves are defined similarly. Normal vectors are important for lighting calculations.">normal vector</abbr>. And if a depth value is needed in later passes, it might be stored in the <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> <abbr title="One of the numbers used in a color model to specify a color. For example, in the RGB color model, a color is specified by three color components representing the amounts of red, green, and blue in the color.">color component</abbr> of the same <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. Another <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> might hold a <abbr title="A material property that represents the proportion of incident light that is reflected diffusely from a surface.">diffuse color</abbr>, while a third holds a <abbr title="A material property that represents the proportion of incident light that is reflected specularly by a surface.">specular color</abbr> in its RGB components and a <abbr title="A material property that determines the size and sharpness of specular highlights. Also called the &quot;specular exponent&quot; because of the way it is used in lighting calculations. In OpenGL, shininess is a number in the range 0 to 128.">shininess</abbr> value in its <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> component. Shader programs are free to interpret data in a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> however they like.</p>
<hr />
<p>A <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> can write data to a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>, using a <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr>. But standard <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 can only write to one <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr> at a time. Now, it would be possible to use a separate pass for each <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> that we need to compute, but that would involve a lot of redundant calculations, which is what we are trying to avoid. What we need is a <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> extension that makes it possible for a <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> to write to several framebuffers simultaneously. The extension that we need is named "WEBGL_draw_buffers". When that extension is activated, it becomes possible to attach several textures (or renderbuffers) to a <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr>, and it becomes possible for a <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> to write data to all of the attached shaders simultaneously. The extension is relatively complicated to use. It must be activated, as usual, with a statement of the form</p>
<div class="highlight"><pre><span></span><code><span class="nx">EXTdb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">getExtension</span><span class="p">(</span><span class="s2">&quot;WEBGL_draw_buffers&quot;</span><span class="p">);</span>
</code></pre></div>
<p>Assuming that the extension is available, the maximum number of color buffers that can be used in a <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> is given by <em>EXTdb.MAX_DRAW_BUFFERS_WEBGL</em>, which will be at least four. With the extension in place, you can attach multiple textures as color buffers for a <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr>, using code of the form</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">bindFramebuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAMEBUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">framebuffer</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">framebufferTexture2D</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAMEBUFFER</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="nx">EXTdb</span><span class="p">.</span><span class="nx">COLOR_ATTACHMENT0_WEBGL</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">texture1</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">framebufferTexture2D</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAMEBUFFER</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="nx">EXTdb</span><span class="p">.</span><span class="nx">COLOR_ATTACHMENT1_WEBGL</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">texture2</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">);</span>
</code></pre></div>
<p>and so on, using constants such as <em>EXTdb.COLOR_ATTACHMENT1_WEBGL</em> from the extension object to specify the attachment points.</p>
<p>Usually in a <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr>, the color that is output to the <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr> is specified by assigning a value to the special variable <em>gl_FragColor</em>. That changes when multiple color buffers are used. In that case, instead of <em>gl_FragColor</em>, the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> has a special variable gl_FragData which is an array of vec4, one for each possible <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr>. Colors are output to the color buffers by assigning values to <em>gl_FragData[0], gl_FragData[1], ....</em> Because this is a change in the legal syntax of the <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>, the extension must also be activated in the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> source code by adding the line</p>
<div class="highlight"><pre><span></span><code><span class="err">#</span><span class="nx">extension</span><span class="w"> </span><span class="nx">GL_EXT_draw_buffers</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">require</span>
</code></pre></div>
<p>to the beginning of the code. Suppose, for example, that we want to store a <abbr title="A normal vector to a surface at a point on that surface is a vector that is perpendicular to the surface at that point. Normal vectors to curves are defined similarly. Normal vectors are important for lighting calculations.">normal vector</abbr>, a <abbr title="A material property that represents the proportion of incident light that is reflected diffusely from a surface.">diffuse color</abbr>, a <abbr title="A material property that represents the proportion of incident light that is reflected specularly by a surface.">specular color</abbr>, and <abbr title="The coordinate system in which the coordinates for points in an object are originally specified, before they are transformed by any modeling or other transform that will be applied to the object.">object coordinates</abbr> in the color buffers. Let's say that these values are input to the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> as varying variables or uniform variables, except for the <abbr title="A material property that represents the proportion of incident light that is reflected diffusely from a surface.">diffuse color</abbr>, which is sampled from a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. Then the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> might take the form</p>
<div class="highlight"><pre><span></span><code><span class="err">#</span><span class="nx">extension</span><span class="w"> </span><span class="nx">GL_EXT_draw_buffers</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">require</span>
<span class="nx">precision</span><span class="w"> </span><span class="nx">highp</span><span class="w"> </span><span class="kr">float</span><span class="p">;</span>
<span class="nx">varying</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">v_normal</span><span class="p">,</span><span class="w"> </span><span class="nx">v_objectCoords</span><span class="p">;</span>
<span class="nx">varying</span><span class="w"> </span><span class="nx">vec2</span><span class="w"> </span><span class="nx">v_texCoords</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">vec3</span><span class="w"> </span><span class="nx">u_specular</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="kr">float</span><span class="w"> </span><span class="nx">u_shininess</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">sampler2D</span><span class="w"> </span><span class="nx">texture</span><span class="p">;</span>
<span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">gl_FragData</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="w"> </span><span class="nx">normalize</span><span class="p">(</span><span class="nx">v_normal</span><span class="p">),</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl_FragData</span><span class="p">[</span><span class="mf">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="w"> </span><span class="nx">v_object_coords</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl_FragData</span><span class="p">[</span><span class="mf">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">texture2D</span><span class="p">(</span><span class="w"> </span><span class="nx">texture</span><span class="p">,</span><span class="w"> </span><span class="nx">v_texCoords</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="nx">gl_fragData</span><span class="p">[</span><span class="mf">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">vec4</span><span class="p">(</span><span class="w"> </span><span class="nx">u_specular</span><span class="p">,</span><span class="w"> </span><span class="nx">u_shininess</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>The final requirement for using the extension is to specify the correspondence between the indices that are used in gl_FragData and the color buffers that have been attached to the <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr>. It seems like the correspondence should be automatic, but it's not. You have to specify it using the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> function, <em>EXTdb.drawBuffersWEBGL</em> from the extension object. This function takes an array as parameter, and the values in the array are chosen from the constants <em>EXTdb.COLOR_ATTACHMENT0_WEBGL</em>, <em>EXTdb.COLOR_ATTACHMENT1_WEBGL</em>, .... These are the same constants that are used to specify the <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr> attachment points in a <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr>. For example, if for some reason you wanted a <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> to output to the color buffers that are attached at attachment points 2 and 3, you would call</p>
<div class="highlight"><pre><span></span><code><span class="nx">EXTdb</span><span class="p">.</span><span class="nx">drawBuffersWEBGL</span><span class="p">(</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="nx">EXTdb</span><span class="p">.</span><span class="nx">COLOR_ATTACHMENT2_WEBGL</span><span class="p">,</span>
<span class="w">    </span><span class="nx">EXTdb</span><span class="p">.</span><span class="nx">COLOR_ATTACHMENT3_WEBGL</span>
<span class="p">]</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>After all that setup, you are ready to do the first pass for <abbr title="A multi-pass rendering technique where a first pass processes the geometry and saves relevant information such as transformed coordinates, normal vectors, and material properties. The data can be stored in textures, which are called &quot;geometry buffers&quot; or &quot;G-buffers&quot; in this context. Lighting and other effects can then be computed in additional passes, using the pre-computed information from the geometry buffers instead of re-computing it for each pass.">deferred shading</abbr>. For the subsequent passes, you would use a different <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr>, with a single <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr>. For those passes, you want to run the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> once for each <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> in the image. The <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> will use the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> data that was saved in the first pass, together with other information such as light properties, to compute the output color for the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>. You can trigger a call to the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> for each <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> simply by drawing a single rectangle that covers the image.</p>
<p>The theory behind <abbr title="A multi-pass rendering technique where a first pass processes the geometry and saves relevant information such as transformed coordinates, normal vectors, and material properties. The data can be stored in textures, which are called &quot;geometry buffers&quot; or &quot;G-buffers&quot; in this context. Lighting and other effects can then be computed in additional passes, using the pre-computed information from the geometry buffers instead of re-computing it for each pass.">deferred shading</abbr> is not all that complicated, but there are a lot of details to get right in the implementation. Deferred shading is just one of many tricks that are used by video game programmers to improve the <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> speed for their games.</p>
</div>
</div>
</div>
<h2 id="755-webgl-20-中的多个绘制缓冲区">7.5.5 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 中的多个绘制缓冲区<a class="headerlink" href="#755-webgl-20-中的多个绘制缓冲区" title="Permanent link">&para;</a></h2>
<p><strong>Multiple Draw Buffers in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="6:2"><input checked="checked" id="__tabbed_6_1" name="__tabbed_6" type="radio" /><input id="__tabbed_6_2" name="__tabbed_6" type="radio" /><div class="tabbed-labels"><label for="__tabbed_6_1">中文</label><label for="__tabbed_6_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>能够写入多个绘制缓冲区是 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 的标准部分。示例程序 <a href="../../../en/source/webgl/multiple-draw-buffers-webgl2.html">webgl/multiple-draw-buffers-webgl2.html</a> 是一个简单的演示。该程序获取一个示例图像，并通过附加三个纹理到帧缓冲区，并将每种颜色分量写入其中一个纹理，将其分解为显示原始图像的红色、绿色和蓝色颜色分量的三个独立图像。然后，每个纹理的图像被复制到屏幕上，作为灰度图像显示。</p>
<p>程序必须创建并为三个纹理对象分配存储，并将它们绑定到帧缓冲区作为颜色缓冲区。以下是执行此操作的代码：</p>
<div class="highlight"><pre><span></span><code><span class="nx">framebuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createFramebuffer</span><span class="p">();</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bindFramebuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAMEBUFFER</span><span class="p">,</span><span class="w"> </span><span class="nx">framebuffer</span><span class="p">);</span>
<span class="nx">texture0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createTexture</span><span class="p">();</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bindTexture</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">texture0</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">texStorage2D</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">R8</span><span class="p">,</span><span class="w"> </span><span class="mf">320</span><span class="p">,</span><span class="w"> </span><span class="mf">399</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">framebufferTexture2D</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAMEBUFFER</span><span class="p">,</span><span class="w"> </span>
<span class="w">        </span><span class="nx">gl</span><span class="p">.</span><span class="nx">COLOR_ATTACHMENT0</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">texture0</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">);</span>
<span class="nx">texture1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createTexture</span><span class="p">();</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bindTexture</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">texture1</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">texStorage2D</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">R8</span><span class="p">,</span><span class="w"> </span><span class="mf">320</span><span class="p">,</span><span class="w"> </span><span class="mf">399</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">framebufferTexture2D</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAMEBUFFER</span><span class="p">,</span><span class="w"> </span>
<span class="w">        </span><span class="nx">gl</span><span class="p">.</span><span class="nx">COLOR_ATTACHMENT1</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">texture1</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">);</span>
<span class="nx">texture2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createTexture</span><span class="p">();</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bindTexture</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">texture2</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">texStorage2D</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">R8</span><span class="p">,</span><span class="w"> </span><span class="mf">320</span><span class="p">,</span><span class="w"> </span><span class="mf">399</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">framebufferTexture2D</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAMEBUFFER</span><span class="p">,</span><span class="w"> </span>
<span class="w">        </span><span class="nx">gl</span><span class="p">.</span><span class="nx">COLOR_ATTACHMENT2</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">texture2</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">);</span>
</code></pre></div>
<p>纹理以格式 <em>gl.R8</em> 创建，每个像素存储一个八位无符号整数；这对于灰度图像是足够的。（对于此格式，一个 8 位整数被考虑为被缩放以表示范围在 0.0 到 1.0 内的颜色值。）</p>
<p>必须调用函数 <em>gl.drawBuffers()</em> 以启用写入多个绘制缓冲区，并指定输出目标。目标被指定为帧缓冲区上的附件点数组：</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">drawBuffers</span><span class="p">([</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">COLOR_ATTACHMENT0</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">COLOR_ATTACHMENT1</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">COLOR_ATTACHMENT2</span>
<span class="p">]);</span>
</code></pre></div>
<p>此示例的着色器程序使用 <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 3.00 编写，在片段着色器中使用 out 变量将输出发送到绘制缓冲区。当有一个 out 变量时，它自动将输出发送到第一个绘制缓冲区（绘制缓冲区编号零）。当有多个 out 变量时，必须使用布局限定符为每个 out 变量指定目标编号。在片段着色器中为 out 变量指定的 <em>location</em> 是传递给 <em>gl.drawBuffers()</em> 的附件点数组的索引。以下是一个示例，来自示例程序的片段着色器：</p>
<div class="highlight"><pre><span></span><code><span class="err">#</span><span class="nx">version</span><span class="w"> </span><span class="mf">300</span><span class="w"> </span><span class="nx">es</span>
<span class="nx">precision</span><span class="w"> </span><span class="nx">mediump</span><span class="w"> </span><span class="kr">float</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">sampler2D</span><span class="w"> </span><span class="nx">u_picture</span><span class="p">;</span><span class="w"> </span><span class="c1">// 包含原始图像的纹理</span>
<span class="ow">in</span><span class="w"> </span><span class="nx">vec2</span><span class="w"> </span><span class="nx">v_coords</span><span class="p">;</span>
<span class="nx">layout</span><span class="p">(</span><span class="nx">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="nx">out</span><span class="w"> </span><span class="kr">float</span><span class="w"> </span><span class="nx">red</span><span class="p">;</span><span class="w">   </span><span class="c1">// 写入绘制缓冲区 0</span>
<span class="nx">layout</span><span class="p">(</span><span class="nx">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="nx">out</span><span class="w"> </span><span class="kr">float</span><span class="w"> </span><span class="nx">green</span><span class="p">;</span><span class="w"> </span><span class="c1">// 写入绘制缓冲区 1</span>
<span class="nx">layout</span><span class="p">(</span><span class="nx">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2</span><span class="p">)</span><span class="w"> </span><span class="nx">out</span><span class="w"> </span><span class="kr">float</span><span class="w"> </span><span class="nx">blue</span><span class="p">;</span><span class="w">  </span><span class="c1">// 写入绘制缓冲区 2</span>
<span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">texture</span><span class="p">(</span><span class="nx">u_picture</span><span class="p">,</span><span class="w"> </span><span class="nx">v_coords</span><span class="p">);</span>
<span class="w">    </span><span class="nx">red</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">color</span><span class="p">.</span><span class="nx">r</span><span class="p">;</span>
<span class="w">    </span><span class="nx">green</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">color</span><span class="p">.</span><span class="nx">g</span><span class="p">;</span>
<span class="w">    </span><span class="nx">blue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">color</span><span class="p">.</span><span class="nx">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>这个片段着色器将原始图像中单独的 RGB 颜色分量发送到附加到帧缓冲区的三个纹理。</p>
<p>这是一个相当简单且不太有用的使用多个绘制缓冲区的示例，但它确实展示了这样做所需的所有步骤。</p>
</div>
<div class="tabbed-block">
<p>The ability to write to multiple draw buffers is a standard part of <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0. The sample program <a href="../../../en/source/webgl/multiple-draw-buffers-webgl2.html">webgl/multiple-draw-buffers-webgl2.html</a> is a simple demonstration. This program takes a sample image and breaks it up into three separate images that show the red, green, and blue color components from the original image. It does that by attaching three textures to a <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr>, and writing each <abbr title="One of the numbers used in a color model to specify a color. For example, in the RGB color model, a color is specified by three color components representing the amounts of red, green, and blue in the color.">color component</abbr> to one of the textures. The image from each <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> is then copied to the screen as a <abbr title="Refers to a color scheme or image in which each color is a shade of gray (where the term &quot;shade of gray&quot; here includes black and white). Typically, 256 shades of gray are used. Grayscale is also called &quot;monochrome.&quot;">grayscale</abbr> image.</p>
<p>The program has to create and allocate storage for three <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> objects, and bind them to a <abbr title="A region of memory that contains color data for a digital image. Most often refers to the memory containing the image that appears on the computer's screen.">frame buffer</abbr> as color buffers. Here is the code that does this:</p>
<div class="highlight"><pre><span></span><code><span class="nx">framebuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createFramebuffer</span><span class="p">();</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bindFramebuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAMEBUFFER</span><span class="p">,</span><span class="nx">framebuffer</span><span class="p">);</span>
<span class="nx">texture0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createTexture</span><span class="p">();</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bindTexture</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">texture0</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">texStorage2D</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">R8</span><span class="p">,</span><span class="w"> </span><span class="mf">320</span><span class="p">,</span><span class="w"> </span><span class="mf">399</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">framebufferTexture2D</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAMEBUFFER</span><span class="p">,</span><span class="w"> </span>
<span class="w">            </span><span class="nx">gl</span><span class="p">.</span><span class="nx">COLOR_ATTACHMENT0</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">texture0</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">);</span>
<span class="nx">texture1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createTexture</span><span class="p">();</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bindTexture</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">texture1</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">texStorage2D</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">R8</span><span class="p">,</span><span class="w"> </span><span class="mf">320</span><span class="p">,</span><span class="w"> </span><span class="mf">399</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">framebufferTexture2D</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAMEBUFFER</span><span class="p">,</span><span class="w"> </span>
<span class="w">            </span><span class="nx">gl</span><span class="p">.</span><span class="nx">COLOR_ATTACHMENT1</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">texture1</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">);</span>
<span class="nx">texture2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">createTexture</span><span class="p">();</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bindTexture</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">texture2</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">texStorage2D</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">R8</span><span class="p">,</span><span class="w"> </span><span class="mf">320</span><span class="p">,</span><span class="w"> </span><span class="mf">399</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">framebufferTexture2D</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAMEBUFFER</span><span class="p">,</span><span class="w"> </span>
<span class="w">            </span><span class="nx">gl</span><span class="p">.</span><span class="nx">COLOR_ATTACHMENT2</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="nx">texture2</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">);</span>
</code></pre></div>
<p>The textures are created with format <em>gl.R8</em>, which stores one eight-bit unsigned integer per <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>; that is sufficient for a <abbr title="Refers to a color scheme or image in which each color is a shade of gray (where the term &quot;shade of gray&quot; here includes black and white). Typically, 256 shades of gray are used. Grayscale is also called &quot;monochrome.&quot;">grayscale</abbr> image. (For this format, an 8-bit integer is considered to be scaled to represent a color value in the range 0.0 to 1.0.)</p>
<p>The function <em>gl.drawBuffers()</em> must be called to enable writing to multiple draw buffers and to specify the output destinations. The destinations are specified as an array of attachment points on the <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr>:</p>
<div class="highlight"><pre><span></span><code><span class="nx">gl</span><span class="p">.</span><span class="nx">drawBuffers</span><span class="p">(</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="nx">gl</span><span class="p">.</span><span class="nx">COLOR_ATTACHMENT0</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">COLOR_ATTACHMENT1</span><span class="p">,</span><span class="w"> </span><span class="nx">gl</span><span class="p">.</span><span class="nx">COLOR_ATTACHMENT2</span>
<span class="p">]</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>The <abbr title="A program to be executed at some stage of the rendering pipeline. OpenGL shaders are written in the GLSL programming languages. For WebGL, only vertex shaders and fragment shaders are supported. WebGPU also has compute shaders, which are used in compute pipelines.">shader</abbr> programs for this example are written in <abbr title="OpenGL Shader Language, the programming language that is used to write shader programs for use with OpenGL.">GLSL</abbr> ES 3.00, which uses out variables in the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> to send output to draw buffers. When there is a single out variable, it automatically sends output to the first draw buffer (draw buffer number zero). When there is more than one out variable, the destination number must be specified for every out variable using a layout qualifier. The <em>location</em> specified for an out variable in the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> is an index into the array of attachment points that was passed to <em>gl.drawBuffers()</em>. As an example, here is the <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> from the sample program:</p>
<div class="highlight"><pre><span></span><code><span class="err">#</span><span class="nx">version</span><span class="w"> </span><span class="mf">300</span><span class="w"> </span><span class="nx">es</span>
<span class="nx">precision</span><span class="w"> </span><span class="nx">mediump</span><span class="w"> </span><span class="kr">float</span><span class="p">;</span>
<span class="nx">uniform</span><span class="w"> </span><span class="nx">sampler2D</span><span class="w"> </span><span class="nx">u_picture</span><span class="p">;</span><span class="w"> </span><span class="c1">// texture containing original image</span>
<span class="ow">in</span><span class="w"> </span><span class="nx">vec2</span><span class="w"> </span><span class="nx">v_coords</span><span class="p">;</span>
<span class="nx">layout</span><span class="p">(</span><span class="nx">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="nx">out</span><span class="w"> </span><span class="kr">float</span><span class="w"> </span><span class="nx">red</span><span class="p">;</span><span class="w">   </span><span class="c1">// write to draw buffer 0</span>
<span class="nx">layout</span><span class="p">(</span><span class="nx">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="nx">out</span><span class="w"> </span><span class="kr">float</span><span class="w"> </span><span class="nx">green</span><span class="p">;</span><span class="w"> </span><span class="c1">// write to draw buffer 1</span>
<span class="nx">layout</span><span class="p">(</span><span class="nx">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2</span><span class="p">)</span><span class="w"> </span><span class="nx">out</span><span class="w"> </span><span class="kr">float</span><span class="w"> </span><span class="nx">blue</span><span class="p">;</span><span class="w">  </span><span class="c1">// write to draw buffer 2</span>
<span class="ow">void</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">vec4</span><span class="w"> </span><span class="nx">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">texture</span><span class="p">(</span><span class="nx">u_picture</span><span class="p">,</span><span class="w"> </span><span class="nx">v_coords</span><span class="p">);</span>
<span class="w">    </span><span class="nx">red</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">color</span><span class="p">.</span><span class="nx">r</span><span class="p">;</span>
<span class="w">    </span><span class="nx">green</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">color</span><span class="p">.</span><span class="nx">g</span><span class="p">;</span>
<span class="w">    </span><span class="nx">blue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">color</span><span class="p">.</span><span class="nx">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>This <abbr title="A shader program that will be executed once for each pixel in a primitive. A fragment shader must compute a color for the pixel, or discard it. Fragment shaders are also called pixel shaders.">fragment shader</abbr> sends the separate <abbr title="A color specified by three numbers giving the amount of red, green, and blue in the color.">RGB color</abbr> components from the original image to the three textures that are attached to the <abbr title="In WebGL, a data structure that organizes the buffers for rendering an image, possibly including a color buffer, a depth buffer, and a stencil buffer. A WebGL graphics context has a default framebuffer for on-screen rendering, and additional framebuffers can be created for off-screen rendering.">framebuffer</abbr>.</p>
<p>This is a fairly simple and not-very-useful example of using multiple draw buffers, but it does illustrate all the steps that are required to do so.</p>
</div>
</div>
</div>







  
    
  
  
    
  


  <aside class="md-source-file">
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="最后更新">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1-2.1-2M12.5 7v5.2l4 2.4-1 1L11 13V7h1.5M11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2v1.8Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">2024年6月19日</span>
  </span>

    
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="创建日期">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.47 15.08 11 13V7h1.5v5.25l3.08 1.83c-.41.28-.79.62-1.11 1m-1.39 4.84c-.36.05-.71.08-1.08.08-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8c0 .37-.03.72-.08 1.08.69.1 1.33.32 1.92.64.1-.56.16-1.13.16-1.72 0-5.5-4.5-10-10-10S2 6.5 2 12s4.47 10 10 10c.59 0 1.16-.06 1.72-.16-.32-.59-.54-1.23-.64-1.92M18 15v3h-3v2h3v3h2v-3h3v-2h-3v-3h-2Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">2024年5月26日</span>
  </span>

    
    
    
  </aside>





                
              </article>
            </div>
          
          
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var tab,labels=set.querySelector(".tabbed-labels");for(tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script>

<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../../..", "features": ["content.code.copy", "content.tabs.link", "navigation.tabs", "navigation.tabs.sticky", "navigation.indexes", "navigation.top", "toc.follow", "content.tooltips"], "search": "../../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.3220b9d7.min.js"></script>
      
        <script src="../../../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="https://unpkg.com/mermaid@9.4.0/dist/mermaid.min.js"></script>
      
    
  <script>document$.subscribe(() => {const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});})</script></body>
</html>