
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="计算机图形学概论(graphicsbook)">
      
      
      
        <link rel="canonical" href="https://hellowac.github.io/graphicsbook-zh-cn/cn/c3/s3/">
      
      
        <link rel="prev" href="../s2/">
      
      
        <link rel="next" href="../s4/">
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.5.18">
    
    
      
        <title>3.3 投影与观看 - 计算机图形学概论</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.66ac8b77.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.06af60db.min.css">
      
      

  
  
  
  
  <style>:root{--md-annotation-icon:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M22 12a10 10 0 0 1-10 10A10 10 0 0 1 2 12 10 10 0 0 1 12 2a10 10 0 0 1 10 10M6 13h8l-3.5 3.5 1.42 1.42L17.84 12l-5.92-5.92L10.5 7.5 14 11H6v2Z"/></svg>');}</style>


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
   <link href="../../../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
        html.glightbox-open { overflow: initial; height: 100%; }
        .gslide-title { margin-top: 0px; user-select: text; }
        .gslide-desc { color: #666; user-select: text; }
        .gslide-image img { background: white; }
        
            .gscrollbar-fixer { padding-right: 15px; }
            .gdesc-inner { font-size: 0.75rem; }
            body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
            body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
            body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}
            </style> <script src="../../../assets/javascripts/glightbox.min.js"></script></head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="default" data-md-color-accent="red">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#33-投影与观看" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="计算机图形学概论" class="md-header__button md-logo" aria-label="计算机图形学概论" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            计算机图形学概论
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              3.3 投影与观看
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
      <div class="md-header__option">
  <div class="md-select">
    
    <button class="md-header__button md-icon" aria-label="选择当前语言">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m12.87 15.07-2.54-2.51.03-.03A17.52 17.52 0 0 0 14.07 6H17V4h-7V2H8v2H1v2h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04M18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12m-2.62 7 1.62-4.33L19.12 17h-3.24Z"/></svg>
    </button>
    <div class="md-select__inner">
      <ul class="md-select__list">
        
          <li class="md-select__item">
            <a href="/graphicsbook-zh-cn/en/" hreflang="en" class="md-select__link">
              English
            </a>
          </li>
        
          <li class="md-select__item">
            <a href="/graphicsbook-zh-cn/cn/" hreflang="cn" class="md-select__link">
              中文
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</div>
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/hellowac/graphicsbook-zh-cn" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    graphicsbook
  </div>
</a>
      </div>
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../" class="md-tabs__link">
        
  
    
  
  首页

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../preface/" class="md-tabs__link">
        
  
    
  
  前言

      </a>
    </li>
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c1/" class="md-tabs__link">
          
  
    
  
  1简介

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c2/" class="md-tabs__link">
          
  
    
  
  2二维图形

        </a>
      </li>
    
  

      
        
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../" class="md-tabs__link">
          
  
    
  
  3几何

        </a>
      </li>
    
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../c4/index.md" class="md-tabs__link">
        
  
    
  
  4灯光和材质

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../c5/index.md" class="md-tabs__link">
        
  
    
  
  5three.js

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../c6/index.md" class="md-tabs__link">
        
  
    
  
  6WebGL

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../c7/index.md" class="md-tabs__link">
        
  
    
  
  7WebGL 3D

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../c8/index.md" class="md-tabs__link">
        
  
    
  
  8高阶3D

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../c9/index.md" class="md-tabs__link">
        
  
    
  
  9WEBGPU

      </a>
    </li>
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../a1/" class="md-tabs__link">
          
  
    
  
  附录

        </a>
      </li>
    
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../.." class="md-tabs__link">
        
  
    
  
  关于

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="计算机图形学概论" class="md-nav__button md-logo" aria-label="计算机图形学概论" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    计算机图形学概论
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/hellowac/graphicsbook-zh-cn" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    graphicsbook
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    首页
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../preface/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    前言
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c1/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    1简介
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_3" id="__nav_3_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            1简介
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 1 节 绘画与绘图
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 2 节：三维(3D)图形的要素
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 3 节：硬件与软件
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c2/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    2二维图形
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_4" id="__nav_4_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            2二维图形
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第1节: 像素、坐标和颜色
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第2节: 形状
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第3节: 变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第4节: 分层建模
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第5节: Java 绘制2D
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第6节: HTML Canvas图形
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第7节: SVG：一种场景描述语言
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" checked>
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    3几何
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_5" id="__nav_5_label" tabindex="">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            3几何
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.1 OpenGL 1.1 中的形状和颜色
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.2 3D 坐标和变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    3.3 投影与观看
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    3.3 投影与观看
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#331-多种坐标系" class="md-nav__link">
    <span class="md-ellipsis">
      3.3.1 多种坐标系
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#332-视口变换" class="md-nav__link">
    <span class="md-ellipsis">
      3.3.2 视口变换
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#333-投影变换" class="md-nav__link">
    <span class="md-ellipsis">
      3.3.3 投影变换
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#334-模型视图转换" class="md-nav__link">
    <span class="md-ellipsis">
      3.3.4 模型视图转换
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#335-相机抽象" class="md-nav__link">
    <span class="md-ellipsis">
      3.3.5 相机抽象
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.4 多边形网格和 glDrawArrays
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.5 部分线性代数基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.6 使用 GLUT 和 JOGL
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4灯光和材质
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5three.js
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6WebGL
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7WebGL 3D
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c8/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8高阶3D
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9WEBGPU
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_12" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../a1/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    附录
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_12" id="__nav_12_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_12_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_12">
            <span class="md-nav__icon md-icon"></span>
            附录
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a2/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Blender 3D建模
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a3/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Gimp和Inkscape
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../source/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    示例程序源代码
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../glossary/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    术语表
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    关于
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#331-多种坐标系" class="md-nav__link">
    <span class="md-ellipsis">
      3.3.1 多种坐标系
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#332-视口变换" class="md-nav__link">
    <span class="md-ellipsis">
      3.3.2 视口变换
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#333-投影变换" class="md-nav__link">
    <span class="md-ellipsis">
      3.3.3 投影变换
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#334-模型视图转换" class="md-nav__link">
    <span class="md-ellipsis">
      3.3.4 模型视图转换
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#335-相机抽象" class="md-nav__link">
    <span class="md-ellipsis">
      3.3.5 相机抽象
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="33-投影与观看">3.3 投影与观看<a class="headerlink" href="#33-投影与观看" title="Permanent link">&para;</a></h1>
<p><strong>Projection and Viewing</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="1:2"><input checked="checked" id="__tabbed_1_1" name="__tabbed_1" type="radio" /><input id="__tabbed_1_2" name="__tabbed_1" type="radio" /><div class="tabbed-labels"><label for="__tabbed_1_1">中文</label><label for="__tabbed_1_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>在前面的部分，我们讨论了建模变换，它将对象坐标转换为世界坐标。然而，对于3D计算机图形，你需要了解其他几种坐标系及其之间的转换。我们将在本节中讨论它们。</p>
<p>我们首先概述各种坐标系。其中一些是复习内容，而另一些是新内容。</p>
</div>
<div class="tabbed-block">
<p>In the previous section, we looked at the <abbr title="A transformation that is applied to an object to map that object into the world coordinate system or into the object coordinate system for a more complex, hierarchical object.">modeling transformation</abbr>, which transforms from <abbr title="The coordinate system in which the coordinates for points in an object are originally specified, before they are transformed by any modeling or other transform that will be applied to the object.">object coordinates</abbr> to <abbr title="The coordinate system in which a scene is defined. The image that is produced of the scene will show the contents of the world coordinate system that lie within some view volume (for 3D) or view window (for 2D). Objects are defined in their own object coordinate system. Modeling transformations are then applied to place objects into the scene; that is, they transform object coordinates to world coordinates.">world coordinates</abbr>. However, for 3D computer graphics, you need to know about several other <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate systems</abbr> and the transforms between them. We discuss them in this section.</p>
<p>We start with an overview of the various <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate systems</abbr>. Some of this is review, and some of it is new.</p>
</div>
</div>
</div>
<h2 id="331-多种坐标系">3.3.1 多种坐标系<a class="headerlink" href="#331-多种坐标系" title="Permanent link">&para;</a></h2>
<p><strong>Many Coordinate Systems</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="2:2"><input checked="checked" id="__tabbed_2_1" name="__tabbed_2" type="radio" /><input id="__tabbed_2_2" name="__tabbed_2" type="radio" /><div class="tabbed-labels"><label for="__tabbed_2_1">中文</label><label for="__tabbed_2_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>你实际用于绘制对象的坐标称为对象坐标。对象坐标系被选择为正在绘制的对象方便使用的坐标系。然后，可以应用建模变换来设置对象在整体场景中的大小、方向和位置（或者，在分层建模的情况下，设置在更大、更复杂对象的对象坐标系中）。建模变换是应用于对象顶点的第一个变换。</p>
<p>你用于构建完整场景的坐标被称为世界坐标。这些是整个场景的坐标，你正在创建的虚拟3D世界的坐标。建模变换从对象坐标到世界坐标的映射。</p>
<p>在现实世界中，你所看到的取决于你站立的位置和你观察的方向。也就是说，在你知道“观察者”的位置以及观察者在哪里看向之前，你无法制作出场景的图片，而且如果你考虑到，观察者的头是如何倾斜的。为了OpenGL的目的，我们想象观察者连接到他们自己的个体坐标系，这被称为<strong><abbr title="在OpenGL 1.1中定义的三维空间上的坐标系，由观察者确定。在OpenGL 1.1中的眼睛坐标中，观察者位于原点，朝着负z轴方向看，正y轴向上，正x轴向右。建模视图变换将对象映射到眼睛坐标系，投影变换将眼睛坐标映射到裁剪坐标。">眼睛坐标</abbr></strong>。在这个坐标系中，观察者位于原点（0,0,0），朝着负z轴的方向看；正y轴的方向指向上方；x轴指向右边。这是一个以观察者为中心的坐标系。换句话说，<abbr title="在OpenGL 1.1中定义的三维空间上的坐标系，由观察者确定。在OpenGL 1.1中的眼睛坐标中，观察者位于原点，朝着负z轴方向看，正y轴向上，正x轴向右。建模视图变换将对象映射到眼睛坐标系，投影变换将眼睛坐标映射到裁剪坐标。">眼睛坐标</abbr>（几乎）是你实际要在屏幕上绘制时要使用的坐标。从世界坐标到眼睛坐标的转换称为<strong><abbr title="在三维图形中，将世界坐标映射到眼睛坐标的变换。观察变换确定了观察者在世界中的位置、方向和比例。">观察变换</abbr></strong>。</p>
<p>如果这很令人困惑，可以这样想：我们可以在世界上使用任何我们想要的坐标系。眼睛坐标是制作一个由观察者观察的世界图片的自然坐标系。如果我们在构建世界时使用了不同的坐标系（<abbr title="定义场景的坐标系统。生成的场景图像将显示位于某个视图体积（对于3D）或视图窗口（对于2D）内的世界坐标系统中的内容。对象在其自己的对象坐标系统中定义。然后应用建模变换将对象放置到场景中，即将对象坐标转换为世界坐标。">世界坐标</abbr>），那么我们必须将这些坐标转换为眼睛坐标以了解观察者实际看到了什么。这个转换就是观察变换。</p>
<p>顺便提一下，OpenGL不跟踪单独的建模和观察变换。它们被合并成一个单一的变换，称为<strong><abbr title="在OpenGL 1.1中，将建模变换与观察变换结合的变换。也就是说，它是从对象坐标到世界坐标的变换和从世界坐标到眼睛坐标的变换的组合。由于建模和观察变换的等价性，世界坐标对于OpenGL并不真正有意义，只有组合变换才被跟踪。">模型视图变换</abbr></strong>。事实上，尽管世界坐标可能看起来是最重要和最自然的坐标系，但OpenGL没有任何对它们的表示，也不在内部使用它们。对于OpenGL来说，只有对象坐标和眼睛坐标有意义。OpenGL通过应用模型视图变换直接从对象坐标到眼睛坐标。</p>
<p>我们还没有完成。观察者不能看到整个3D世界，只能看到适合<strong><abbr title="2D或3D图形显示图像的矩形区域。视口上的坐标是像素坐标，更确切地称为设备坐标，因为它们是图像显示的实际物理坐标。">视口</abbr></strong>的部分，视口是屏幕或其他显示设备上将绘制图像的矩形区域。我们说，场景被视口的边缘“裁剪”。此外，在OpenGL中，观察者只能看到眼睛坐标系中有限范围的z值。具有较大或较小z值的点将被裁剪掉，不会被渲染到图像中。（当然，这不是真实世界中的观察方式，但这是由OpenGL中深度测试的使用所要求的。请参阅<a href="../s1/#314--深度测试">子节3.1.4</a>。）实际渲染到图像中的空间体积称为<strong><abbr title="在OpenGL 1.1中，是在渲染图像中可见的三维空间区域。对于正交投影，视体积是一个矩形立体。对于透视投影，视体积是一个截头锥体（截断的金字塔）。">视体积</abbr></strong>。视体积内的物体会出现在图像中；不在视体积内的物体将被裁剪掉，看不到。为了绘制的目的，OpenGL应用一个坐标变换，将视体积映射到一个<strong>立方体</strong>上。该立方体位于原点处，x方向、y方向和z方向分别从-1到1延伸。在这个立方体上的坐标系被称为<strong><abbr title="OpenGL中的默认坐标系。投影变换将三维场景映射到裁剪坐标。渲染图像将显示裁剪坐标系中的立方体内容，其中x、y和z值的范围为-1到1；任何超出该范围的内容将被“裁剪”掉。">裁剪坐标</abbr></strong>。从眼睛坐标到裁剪坐标的变换称为<strong><abbr title="在三维图形中，将三维空间中的场景映射到二维图像的变换。在OpenGL 1.1中，投影变换将视体积（即图像中可见的三维空间区域）映射到裁剪坐标，其中x、y和z的值范围为-1到1。然后将x和y坐标映射到图像上，而z坐标提供深度信息。">投影变换</abbr></strong>。在这一点上，我们还没有将3D场景投影到2D表面，但现在我们可以通过丢弃z坐标来做到这一点。（然而，仍然需要z坐标来提供深度测试所需的深度信息。）</p>
<p>请注意，如果你根本不应用任何变换，也就是说，如果模型视图和投影变换都是单位矩阵，那么裁剪坐标就是将要使用的坐标。它是一个左手坐标系，其中z轴的正方向指向屏幕内部。</p>
<p>我们<strong>还没有</strong>结束。最终，当实际绘制时，存在<strong><abbr title="在显示设备或渲染图像上使用的坐标系，通常以像素作为度量单位。">设备坐标</abbr></strong>，即在物理显示设备（如计算机屏幕）上进行实际绘制的2D坐标系。通常，在设备坐标中，像素是度量单位。绘制区域是一个像素的矩形。这个矩形称为视口。<strong><abbr title="在OpenGL 1.1中，从裁剪坐标到设备坐标的最终变换。视口变换将裁剪立方体（三维中由范围为-1到1的x、y和z坐标确定的立方体）映射到视口（图像渲染的绘制表面上的矩形）。">视口变换</abbr></strong>将裁剪坐标中的x和y进行缩放，以适应视口。</p>
<p>让我们再次浏览变换序列。想象一个基本元素，比如场</p>
<p>景的一部分，可能出现在我们想要制作的场景图片中。该基本元素经历以下一系列操作：</p>
<p><a class="glightbox" href="../../../en/c3/opengl-transform-pipeline.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c3/opengl-transform-pipeline.png" /></a></p>
<ol>
<li>定义基本元素的点使用对象坐标，使用诸如glVertex3f之类的方法。</li>
<li>点首先经过模型视图变换，这是将基本元素放置到世界中并将基本元素映射到眼睛坐标的建模变换的组合。</li>
<li>然后应用投影变换，将对观察者可见的视体积映射到裁剪坐标立方体上。如果变换后的基本元素位于该立方体之外，它将不会成为图像的一部分，并且处理停止。如果基本元素的一部分位于内部，另一部分位于外部，则位于外部的部分将被裁剪并丢弃，只有剩余的部分会进一步处理。</li>
<li>最后，应用视口变换以产生实际用于在显示设备上绘制基本元素的设备坐标。之后，只需决定如何给基本元素的各个像素着色。</li>
</ol>
<p>我们需要更详细地考虑这些变换，并了解如何在OpenGL 1.1中使用它们。</p>
</div>
<div class="tabbed-block">
<p>The coordinates that you actually use for drawing an object are called <abbr title="The coordinate system in which the coordinates for points in an object are originally specified, before they are transformed by any modeling or other transform that will be applied to the object.">object coordinates</abbr>. The object <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr> is chosen to be convenient for the object that is being drawn. A <abbr title="A transformation that is applied to an object to map that object into the world coordinate system or into the object coordinate system for a more complex, hierarchical object.">modeling transformation</abbr> can then be applied to set the size, orientation, and position of the object in the overall scene (or, in the case of <abbr title="Creating complex geometric models in a hierarchical fashion, starting with geometric primitives, combining them into components that can then be further combined into more complex components, and so on.">hierarchical modeling</abbr>, in the object <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr> of a larger, more complex object). The <abbr title="A transformation that is applied to an object to map that object into the world coordinate system or into the object coordinate system for a more complex, hierarchical object.">modeling transformation</abbr> is the first that is applied to the vertices of an object.</p>
<p>The coordinates in which you build the complete scene are called <abbr title="The coordinate system in which a scene is defined. The image that is produced of the scene will show the contents of the world coordinate system that lie within some view volume (for 3D) or view window (for 2D). Objects are defined in their own object coordinate system. Modeling transformations are then applied to place objects into the scene; that is, they transform object coordinates to world coordinates.">world coordinates</abbr>. These are the coordinates for the overall scene, the imaginary 3D world that you are creating. The <abbr title="A transformation that is applied to an object to map that object into the world coordinate system or into the object coordinate system for a more complex, hierarchical object.">modeling transformation</abbr> maps from <abbr title="The coordinate system in which the coordinates for points in an object are originally specified, before they are transformed by any modeling or other transform that will be applied to the object.">object coordinates</abbr> to <abbr title="The coordinate system in which a scene is defined. The image that is produced of the scene will show the contents of the world coordinate system that lie within some view volume (for 3D) or view window (for 2D). Objects are defined in their own object coordinate system. Modeling transformations are then applied to place objects into the scene; that is, they transform object coordinates to world coordinates.">world coordinates</abbr>.</p>
<p>In the real world, what you see depends on where you are standing and the direction in which you are looking. That is, you can't make a picture of the scene until you know the position of the "viewer" and where the viewer is looking—and, if you think about it, how the viewer's head is tilted. For the purposes of <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr>, we imagine that the viewer is attached to their own individual <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr>, which is known as <strong><abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr></strong>. In this <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr>, the viewer is at the origin, (0,0,0), looking in the direction of the negative z-axis; the positive direction of the y-axis is pointing straight up; and the x-axis is pointing to the right. This is a viewer-centric <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr>. In other words, <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr> are (almost) the coordinates that you actually want to use for drawing on the screen. The transform from <abbr title="The coordinate system in which a scene is defined. The image that is produced of the scene will show the contents of the world coordinate system that lie within some view volume (for 3D) or view window (for 2D). Objects are defined in their own object coordinate system. Modeling transformations are then applied to place objects into the scene; that is, they transform object coordinates to world coordinates.">world coordinates</abbr> to <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr> is called the <strong><abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transformation</strong>.</p>
<p>If this is confusing, think of it this way: We are free to use any <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr> that we want on the world. Eye coordinates are the natural <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr> for making a picture of the world as seen by a viewer. If we used a different <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr> (<abbr title="The coordinate system in which a scene is defined. The image that is produced of the scene will show the contents of the world coordinate system that lie within some view volume (for 3D) or view window (for 2D). Objects are defined in their own object coordinate system. Modeling transformations are then applied to place objects into the scene; that is, they transform object coordinates to world coordinates.">world coordinates</abbr>) when building the world, then we have to transform those coordinates to <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr> to find out what the viewer actually sees. That transformation is the <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transform.</p>
<p>Note, by the way, that <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> doesn't keep track of separate modeling and <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transforms. They are combined into a single transform, which is known as the <strong><abbr title="In OpenGL 1.1, a transform that combines the modeling transform with the viewing transform. That is, it is the composition of the transformation from object coordinates to world coordinates and the transformation from world coordinates to eye coordinates. Because of the equivalence between modeling and viewing transformations, world coordinates are not really meaningful for OpenGL, and only the combined transformation is tracked.">modelview transformation</abbr></strong>. In fact, even though <abbr title="The coordinate system in which a scene is defined. The image that is produced of the scene will show the contents of the world coordinate system that lie within some view volume (for 3D) or view window (for 2D). Objects are defined in their own object coordinate system. Modeling transformations are then applied to place objects into the scene; that is, they transform object coordinates to world coordinates.">world coordinates</abbr> might seem to be the most important and natural <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr>, <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> doesn't have any representation for them and doesn't use them internally. For <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr>, only object and <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr> have meaning. <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> goes directly from <abbr title="The coordinate system in which the coordinates for points in an object are originally specified, before they are transformed by any modeling or other transform that will be applied to the object.">object coordinates</abbr> to <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr> by applying the <abbr title="In OpenGL 1.1, a transform that combines the modeling transform with the viewing transform. That is, it is the composition of the transformation from object coordinates to world coordinates and the transformation from world coordinates to eye coordinates. Because of the equivalence between modeling and viewing transformations, world coordinates are not really meaningful for OpenGL, and only the combined transformation is tracked.">modelview transformation</abbr>.</p>
<p>We are not done. The viewer can't see the entire 3D world, only the part that fits into the <strong><abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr></strong>, which is the rectangular region of the screen or other display device where the image will be drawn. We say that the scene is "clipped" by the edges of the <abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr>. Furthermore, in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr>, the viewer can see only a limited range of z-values in the eye <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr>. Points with larger or smaller z-values are clipped away and are not rendered into the image. (This is not, of course, the way that <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> works in the real world, but it's required by the use of the <abbr title="A solution to the hidden surface problem that involves keeping track of the depth, or distance from the viewer, of the object currently visible at each pixel in the image. When a new object is drawn at a pixel, the depth of the new object is compared to the depth of the current object to decide which one is closer to the viewer. The advantage of the depth test is that objects can be rendered in any order. A disadvantage is that only a limited range of depths can be represented in the image.">depth test</abbr> in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr>. See <a href="../s1/#314--深度测试">Subsection 3.1.4</a>.) The volume of space that is actually rendered into the image is called the <strong><abbr title="In OpenGL 1.1, the region is 3D space that is visible in the rendered image. For orthographic projections, the view volume is a rectangular solid. For perspective projection, the view volume is a frustum (truncated pyramid).">view volume</abbr></strong>. Things inside the <abbr title="In OpenGL 1.1, the region is 3D space that is visible in the rendered image. For orthographic projections, the view volume is a rectangular solid. For perspective projection, the view volume is a frustum (truncated pyramid).">view volume</abbr> make it into the image; things that are not in the <abbr title="In OpenGL 1.1, the region is 3D space that is visible in the rendered image. For orthographic projections, the view volume is a rectangular solid. For perspective projection, the view volume is a frustum (truncated pyramid).">view volume</abbr> are clipped and cannot be seen. For purposes of drawing, <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> applies a coordinate transform that maps the <abbr title="In OpenGL 1.1, the region is 3D space that is visible in the rendered image. For orthographic projections, the view volume is a rectangular solid. For perspective projection, the view volume is a frustum (truncated pyramid).">view volume</abbr> onto a <strong>cube</strong>. The cube is centered at the origin and extends from -1 to 1 in the x-direction, in the y-direction, and in the z-direction. The <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr> on this cube is referred to as <strong><abbr title="The default coordinate system in OpenGL. The projection transform maps the 3D scene to clip coordinates. The rendered image will show the contents of the cube in the clip coordinate system that contains x, y, and z values in the range from -1 to 1; anything outside that range is &quot;clipped&quot; away.">clip coordinates</abbr></strong>. The transformation from <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr> to <abbr title="The default coordinate system in OpenGL. The projection transform maps the 3D scene to clip coordinates. The rendered image will show the contents of the cube in the clip coordinate system that contains x, y, and z values in the range from -1 to 1; anything outside that range is &quot;clipped&quot; away.">clip coordinates</abbr> is called the <strong><abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> transformation</strong>. At this point, we haven't quite <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projected</abbr> the 3D scene onto a 2D surface, but we can now do so simply by discarding the z-coordinate. (The z-coordinate, however, is still needed to provide the depth information that is needed for the <abbr title="A solution to the hidden surface problem that involves keeping track of the depth, or distance from the viewer, of the object currently visible at each pixel in the image. When a new object is drawn at a pixel, the depth of the new object is compared to the depth of the current object to decide which one is closer to the viewer. The advantage of the depth test is that objects can be rendered in any order. A disadvantage is that only a limited range of depths can be represented in the image.">depth test</abbr>.)</p>
<p>Note that <abbr title="The default coordinate system in OpenGL. The projection transform maps the 3D scene to clip coordinates. The rendered image will show the contents of the cube in the clip coordinate system that contains x, y, and z values in the range from -1 to 1; anything outside that range is &quot;clipped&quot; away.">clip coordinates</abbr> are the coordinates will be used if you apply no transformation at all, that is if both the modelview and the <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> transforms are the identity. It is a left-handed <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr>, with the positive direction of the z-axis pointing into the screen.</p>
<p>We <strong>still</strong> aren't done. In the end, when things are actually drawn, there are <strong><abbr title="The coordinate system used on a display device or rendered image, often using pixels as the unit of measure.">device coordinates</abbr></strong>, the 2D <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr> in which the actual drawing takes place on a physical display device such as the computer screen. Ordinarily, in <abbr title="The coordinate system used on a display device or rendered image, often using pixels as the unit of measure.">device coordinates</abbr>, the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> is the unit of measure. The drawing region is a rectangle of <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr>. This is the rectangle that is called the <abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr>. The <strong><abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr> transformation</strong> takes x and y from the <abbr title="The default coordinate system in OpenGL. The projection transform maps the 3D scene to clip coordinates. The rendered image will show the contents of the cube in the clip coordinate system that contains x, y, and z values in the range from -1 to 1; anything outside that range is &quot;clipped&quot; away.">clip coordinates</abbr> and scales them to fit the <abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr>.</p>
<p>Let's go through the sequence of transformations one more time. Think of a primitive, such as a line or triangle, that is part of the scene and that might appear in the image that we want to make of the scene. The primitive goes through the following sequence of operations:</p>
<p><a class="glightbox" href="../../../en/c3/opengl-transform-pipeline.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c3/opengl-transform-pipeline.png" /></a></p>
<ol>
<li>The points that define the primitive are specified in <abbr title="The coordinate system in which the coordinates for points in an object are originally specified, before they are transformed by any modeling or other transform that will be applied to the object.">object coordinates</abbr>, using methods such as glVertex3f.</li>
<li>The points are first subjected to the <abbr title="In OpenGL 1.1, a transform that combines the modeling transform with the viewing transform. That is, it is the composition of the transformation from object coordinates to world coordinates and the transformation from world coordinates to eye coordinates. Because of the equivalence between modeling and viewing transformations, world coordinates are not really meaningful for OpenGL, and only the combined transformation is tracked.">modelview transformation</abbr>, which is a combination of the modeling transform that places the primitive into the world and the <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transform that maps the primitive into <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr>.</li>
<li>The <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> transformation is then applied to map the <abbr title="In OpenGL 1.1, the region is 3D space that is visible in the rendered image. For orthographic projections, the view volume is a rectangular solid. For perspective projection, the view volume is a frustum (truncated pyramid).">view volume</abbr> that is visible to the viewer onto the clip coordinate cube. If the transformed primitive lies outside that cube, it will not be part of the image, and the processing stops. If part of the primitive lies inside and part outside, the part that lies outside is clipped away and discarded, and only the part that remains is processed further.</li>
<li>Finally, the <abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr> transform is applied to produce the <abbr title="The coordinate system used on a display device or rendered image, often using pixels as the unit of measure.">device coordinates</abbr> that will actually be used to draw the primitive on the display device. After that, it's just a matter of deciding how to color the individual <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr> that are part of the primitive.</li>
</ol>
<p>We need to consider these transforms in more detail and see how to use them in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1.</p>
</div>
</div>
</div>
<h2 id="332-视口变换">3.3.2 <abbr title="在OpenGL 1.1中，从裁剪坐标到设备坐标的最终变换。视口变换将裁剪立方体（三维中由范围为-1到1的x、y和z坐标确定的立方体）映射到视口（图像渲染的绘制表面上的矩形）。">视口变换</abbr><a class="headerlink" href="#332-视口变换" title="Permanent link">&para;</a></h2>
<p><strong>The Viewport Transformation</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="3:2"><input checked="checked" id="__tabbed_3_1" name="__tabbed_3" type="radio" /><input id="__tabbed_3_2" name="__tabbed_3" type="radio" /><div class="tabbed-labels"><label for="__tabbed_3_1">中文</label><label for="__tabbed_3_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>最简单的变换之一是视口变换。它将裁剪坐标的x和y转换为在显示设备上使用的坐标。要指定视口变换，只需要指定场景将被渲染到的设备上的矩形。这可以通过使用glViewport函数来实现。</p>
<p>OpenGL必须由其运行环境提供一个绘制表面，比如Java中的JOGL或C中的GLUT库。该绘制表面是由像素组成的矩形网格，具有水平大小和垂直大小。OpenGL在绘制表面上使用一个坐标系，将(0,0)放在左下角，y从底部向顶部增加，x从左向右增加。当绘制表面首次交给OpenGL时，视口被设置为整个绘制表面。但是，通过调用</p>
<div class="highlight"><pre><span></span><code><span class="n">glViewport</span><span class="p">(</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>其中(x, y)是视口的左下角，以绘制表面坐标系表示，width和height是视口的大小，可以将裁剪坐标从-1到1映射到指定的视口。特别要注意的是，这意味着绘制仅限于视口。视口扩展到绘制表面之外并不是错误，尽管故意设置这种情况可能不太常见。</p>
<p>当绘制表面的大小发生变化时，比如用户调整包含绘制表面的窗口的大小时，OpenGL不会自动更改视口以匹配新的大小。但是，OpenGL运行环境可能会为您完成这项工作。 （有关JOGL和GLUT如何处理此问题的信息，请参见<a href="../s6/">第3.6节</a>。）</p>
<p>glViewport经常用于在同一绘制表面上绘制多个不同的场景，或者同一场景的多个视图。例如，假设我们想要在同一绘制表面的两侧绘制两个场景，并且绘制表面的大小是600x400像素。如何做到这一点的概要非常简单：</p>
<div class="highlight"><pre><span></span><code><span class="n">glViewport</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">300</span><span class="p">,</span><span class="mi">400</span><span class="p">);</span><span class="w">  </span><span class="c1">// 绘制到绘制表面的左半部分。</span>
<span class="w">    </span><span class="p">.</span>
<span class="w">    </span><span class="p">.</span><span class="w">   </span><span class="c1">// 绘制第一个场景。</span>
<span class="w">    </span><span class="p">.</span>

<span class="n">glViewport</span><span class="p">(</span><span class="mi">300</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">300</span><span class="p">,</span><span class="mi">400</span><span class="p">);</span><span class="w">  </span><span class="c1">// 绘制到绘制表面的右半部分。</span>
<span class="w">    </span><span class="p">.</span>
<span class="w">    </span><span class="p">.</span><span class="w">   </span><span class="c1">// 绘制第二个场景。</span>
<span class="w">    </span><span class="p">.</span>
</code></pre></div>
<p>第一个glViewport命令建立了一个300x400像素的视口，其左下角位于(0,0)。也就是说，视口的左下角位于绘制表面的左下角。这个视口填充了绘制表面的左半部分。类似地，第二个视口，其左下角位于(300,0)，填充了绘制表面的右半部分。</p>
</div>
<div class="tabbed-block">
<p>The simplest of the transforms is the <abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr> transform. It transforms x and y <abbr title="The default coordinate system in OpenGL. The projection transform maps the 3D scene to clip coordinates. The rendered image will show the contents of the cube in the clip coordinate system that contains x, y, and z values in the range from -1 to 1; anything outside that range is &quot;clipped&quot; away.">clip coordinates</abbr> to the coordinates that are used on the display device. To specify the <abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr> transform, it is only necessary to specify the rectangle on the device where the scene will be rendered. This is done using the glViewport function.</p>
<p><abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> must be provided with a drawing surface by the environment in which it is running, such as <abbr title="A Java implementation of OpenGL. JOGL is very complicated, since it attempts to support all versions of OpenGL in one programming system. JOGL integrates seamlessly with Java's Swing and AWT graphics.">JOGL</abbr> for Java or the <abbr title="The OpenGL Utility Toolkit. A platform-independent library for writing OpenGL applications. OpenGL does not include support for windows or events. GLUT adds such support. It also has functions for drawing 3D shapes such as spheres and polyhedra (not to mention a teapot). GLUT is written in the C programming language and is used with the C API for OpenGL. However, many GLUT functions are also available in JOGL, the Java API for OpenGL. A newer, and somewhat improved, version of the toolkit named &quot;FreeGLUT&quot; is commonly used in place of the original version.">GLUT</abbr> library for C. That drawing surface is a rectangular grid of <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr>, with a horizontal size and a vertical size. <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> uses a <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr> on the drawing surface that puts (0,0) at the lower left, with y increasing from bottom to top and x increasing from left to right. When the drawing surface is first given to <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr>, the <abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr> is set to be the entire drawing surface. However, it is possible for <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> to draw to a different rectangle by calling</p>
<div class="highlight"><pre><span></span><code><span class="n">glViewport</span><span class="p">(</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>where (x,y) is the lower left corner of the <abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr>, in the drawing surface <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr>, and width and height are the size of the <abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr>. Clip coordinates from -1 to 1 will then be mapped to the specified <abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr>. Note that this means in particular that drawing is limited to the <abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr>. It is not an error for the <abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr> to extend outside of the drawing surface, though it would be unusual to set up that situation deliberately.</p>
<p>When the size of the drawing surface changes, such as when the user resizes a window that contains the drawing surface, <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> does not automatically change the <abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr> to match the new size. However, the environment in which <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> is running might do that for you. (See <a href="../s6/">Section 3.6</a> for information about how this is handled by <abbr title="A Java implementation of OpenGL. JOGL is very complicated, since it attempts to support all versions of OpenGL in one programming system. JOGL integrates seamlessly with Java's Swing and AWT graphics.">JOGL</abbr> and <abbr title="The OpenGL Utility Toolkit. A platform-independent library for writing OpenGL applications. OpenGL does not include support for windows or events. GLUT adds such support. It also has functions for drawing 3D shapes such as spheres and polyhedra (not to mention a teapot). GLUT is written in the C programming language and is used with the C API for OpenGL. However, many GLUT functions are also available in JOGL, the Java API for OpenGL. A newer, and somewhat improved, version of the toolkit named &quot;FreeGLUT&quot; is commonly used in place of the original version.">GLUT</abbr>.)</p>
<p>glViewport is often used to draw several different scenes, or several views of the same scene, on the same drawing surface. Suppose, for example, that we want to draw two scenes, side-by-side, and that the drawing surface is 600-by-400 <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr>. An outline for how to do that is very simple:</p>
<div class="highlight"><pre><span></span><code><span class="n">glViewport</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">300</span><span class="p">,</span><span class="mi">400</span><span class="p">);</span><span class="w">  </span><span class="c1">// Draw to left half of the drawing surface.</span>
<span class="w">    </span><span class="p">.</span>
<span class="w">    </span><span class="p">.</span><span class="w">   </span><span class="c1">// Draw the first scene.</span>
<span class="w">    </span><span class="p">.</span>

<span class="n">glViewport</span><span class="p">(</span><span class="mi">300</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">300</span><span class="p">,</span><span class="mi">400</span><span class="p">);</span><span class="w">  </span><span class="c1">// Draw to right half of the drawing surface.</span>
<span class="w">    </span><span class="p">.</span>
<span class="w">    </span><span class="p">.</span><span class="w">   </span><span class="c1">// Draw the second scene.</span>
<span class="w">    </span><span class="p">.</span>
</code></pre></div>
<p>The first glViewport command establishes a 300-by-400 <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> <abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr> with its lower left corner at (0,0). That is, the lower left corner of the <abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr> is at the lower left corner of the drawing surface. This <abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr> fills the left half of the drawing surface. Similarly, the second <abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr>, with its lower left corner at (300,0), fills the right half of the drawing surface.</p>
</div>
</div>
</div>
<h2 id="333-投影变换">3.3.3 <abbr title="在三维图形中，将三维空间中的场景映射到二维图像的变换。在OpenGL 1.1中，投影变换将视体积（即图像中可见的三维空间区域）映射到裁剪坐标，其中x、y和z的值范围为-1到1。然后将x和y坐标映射到图像上，而z坐标提供深度信息。">投影变换</abbr><a class="headerlink" href="#333-投影变换" title="Permanent link">&para;</a></h2>
<p><strong>The Projection Transformation</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="4:2"><input checked="checked" id="__tabbed_4_1" name="__tabbed_4" type="radio" /><input id="__tabbed_4_2" name="__tabbed_4" type="radio" /><div class="tabbed-labels"><label for="__tabbed_4_1">中文</label><label for="__tabbed_4_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>接下来我们来讨论投影变换。和任何变换一样，投影在OpenGL中以矩阵的形式表示。OpenGL会将投影矩阵与表示模型视图变换的矩阵分开进行跟踪。相同的变换函数，比如<em>glRotatef</em>，可以应用于这两个矩阵，所以OpenGL需要一种方式来知道这些函数应用于哪个矩阵。这由一个名为矩阵模式的OpenGL状态属性决定。矩阵模式的值是一个常量，比如<em>GL_PROJECTION</em>或<em>GL_MODELVIEW</em>。当调用诸如<em>glRotatef</em>之类的函数时，它会修改一个矩阵；哪个矩阵被修改取决于当前矩阵模式的值。通过调用函数glMatrixMode来设置值。初始值是GL_MODELVIEW。这意味着如果你想要操作投影矩阵，你必须首先调用</p>
<div class="highlight"><pre><span></span><code><span class="n">glMatrixMode</span><span class="p">(</span><span class="n">GL_PROJECTION</span><span class="p">);</span>
</code></pre></div>
<p>如果你想要回到工作在模型视图矩阵上，你必须调用</p>
<div class="highlight"><pre><span></span><code><span class="n">glMatrixMode</span><span class="p">(</span><span class="n">GL_MODELVIEW</span><span class="p">);</span>
</code></pre></div>
<p>在我的程序中，我通常将矩阵模式设置为<em>GL_PROJECTION</em>，设置投影变换，然后立即将矩阵模式设置回<em>GL_MODELVIEW</em>。这意味着在程序的其他地方，我可以确信矩阵模式是<em>GL_MODELVIEW</em>。</p>
<hr />
<p>为了帮助你理解投影，记住3D图像只能显示无限3D世界的一部分。视体积是图像中可见的世界的部分。视体积由观察变换和投影变换的组合确定。观察变换确定观察者的位置和朝向，但它不指定观察者能看到世界的多少。投影变换完成了这一点：它指定了视图中可见区域的形状和范围。将观察者想象成一个相机，带着一个大的无形盒子附着在相机前面，围绕着相机有视线的部分。盒子内部就是视体积。当相机在世界中移动时，盒子也跟着移动，视体积也会改变。但是盒子的形状和大小不会改变。盒子的形状和大小对应于投影变换。相机的位置和朝向对应于观察变换。</p>
<p>这只是另一种说法，数学上，OpenGL投影变换将眼睛坐标变换为裁剪坐标，将视体积映射到2×2×2的裁剪立方体上，该立方体包含图像中可见的所有内容。指定投影只是指定视体积的大小和形状，相对于观察者。</p>
<p>投影有两种一般类型，<strong><abbr title="从三维到二维的投影，沿着从视点射出的线投影对象。透视投影试图模拟真实视图。透视投影保留透视效果；也就是说，远离视点的对象在投影中更小。在OpenGL 1.1中，透视投影的视体积是一个截头锥体。">透视投影</abbr></strong>和<strong><abbr title="从三维到二维的投影，简单地丢弃z坐标。它沿着与xy平面正交（垂直）的线投影对象。在OpenGL 1.1中，正交投影的视体积是一个矩形立体。">正交投影</abbr></strong>。透视投影更加物理上实际。也就是说，它显示了如果OpenGL屏幕上的显示矩形是一个窗口，它是一个真实的3D世界（可以延伸到屏幕前面和后面），那么你会看到什么。它显示了你用普通相机拍摄3D世界时会看到的视图。在透视视图中，对象的视觉大小取决于它距离观察者的距离。只有位于观察者前面的东西才能被看到。事实上，暂时忽略z方向上的裁剪，可见的世界部分是一个无限金字塔，观察者位于金字塔的顶点，金字塔的侧面穿过视口矩形的侧面。</p>
<p>然而，由于OpenGL使用深度测试来解决隐藏表面问题，它实际上无法显示这个金字塔中的所有东西。由于深度缓冲区只能存储有限范围的深度值，它不能表示理论上可见的无限金字塔的整个深度值范围。只有位于观察者一定距离范围内的对象才能成为图像的一部分。这个距离范围由两个值，近裁剪面和远裁剪面确定。对于透视变换，这两个值必须是正数，而且远裁剪面必须大于近裁剪面。距离观察者更近或更远的任何东西都会被丢弃，并且不会出现在渲染的图像中。因此，在图像中表示的空间体积是一个“截断金字塔”。这个金字塔是透视投影的视体积：</p>
<p><a class="glightbox" href="../../../en/c3/projection-frustum.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c3/projection-frustum.png" /></a></p>
<p>视体积由六个平面限定——四个侧面加上截断金字塔的顶部和底部。这些平面被称为裁剪平面，因为任何位于每个平面错误一侧的东西都会被裁剪掉。投影变换将眼睛坐标中截断金字塔的六个侧面映射到裁剪坐标中裁剪立方体的六个侧面。</p>
<p>在OpenGL中，设置投影变换等同于定义视体积。对于透视变换，你必</p>
<p>须设置一个截断金字塔形状的视体积。这种形状的一个相当生僻的术语是<strong>视锥体</strong>。透视变换可以通过<em>glFrustum</em>命令设置：</p>
<div class="highlight"><pre><span></span><code><span class="n">glFrustum</span><span class="p">(</span><span class="w"> </span><span class="n">xmin</span><span class="p">,</span><span class="w"> </span><span class="n">xmax</span><span class="p">,</span><span class="w"> </span><span class="n">ymin</span><span class="p">,</span><span class="w"> </span><span class="n">ymax</span><span class="p">,</span><span class="w"> </span><span class="n">near</span><span class="p">,</span><span class="w"> </span><span class="n">far</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>最后两个参数指定观察者的近裁剪距离和远裁剪距离，如前所述。假设观察者位于原点(0,0,0)，朝向负z轴方向。（这是眼坐标系。）因此，近裁剪平面位于<code>z = −near</code>，远裁剪平面位于<code>z = −far</code>。（注意负号！）前四个参数指定了金字塔的四个侧面：xmin、xmax、ymin和ymax指定了在<strong>近裁剪平面</strong>视体积的水平和垂直限制。例如，金字塔小端的左上角的坐标是（xmin，ymax，-near）。在远裁剪平面的x和y限制比glFrustum命令中指定的限制大得多，通常是远大于近。</p>
<p>请注意，glFrustum中的x和y限制通常关于零对称。也就是说，xmin通常等于xmax的负值，ymin通常等于ymax的负值。但这不是必需的。可以有不对称的视体积，其中z轴不直接指向视野的中心。</p>
<p>由于矩阵模式必须设置为GL_PROJECTION才能工作在投影变换上，glFrustum通常在以下形式的代码段中使用</p>
<div class="highlight"><pre><span></span><code><span class="n">glMatrixMode</span><span class="p">(</span><span class="n">GL_PROJECTION</span><span class="p">);</span>
<span class="n">glLoadIdentity</span><span class="p">();</span>
<span class="n">glFrustum</span><span class="p">(</span><span class="w"> </span><span class="n">xmin</span><span class="p">,</span><span class="w"> </span><span class="n">xmax</span><span class="p">,</span><span class="w"> </span><span class="n">ymin</span><span class="p">,</span><span class="w"> </span><span class="n">ymax</span><span class="p">,</span><span class="w"> </span><span class="n">near</span><span class="p">,</span><span class="w"> </span><span class="n">far</span><span class="w"> </span><span class="p">);</span>
<span class="n">glMatrixMode</span><span class="p">(</span><span class="n">GL_MODELVIEW</span><span class="p">);</span>
</code></pre></div>
<p>调用glLoadIdentity确保了起始点是单位变换。这很重要，因为glFrustum修改了现有的投影矩阵而不是替换它，并且尽管在理论上可能，你根本不想尝试将多个投影变换组合成一个。</p>
<hr />
<p>与透视投影相比，正交投影更容易理解：在正交投影中，将眼坐标系的z坐标舍弃，将3D世界投影到2D图像上。这种投影类型是不现实的，因为它不是观察者会看到的。例如，物体的视觉大小不取决于它距离观察者的距离。在图像中，观察者后面以及前面的物体都可以被看到。然而，正交投影仍然很有用，特别是在交互式建模程序中，其中看到真实大小和角度对透视视图的畸变非常有用。</p>
<p>事实上，在正交投影的情况下，说有一个观察者并不是很清楚。尽管如此，在OpenGL中，正交投影被认为有一个观察者。观察者位于眼坐标原点，面向负z轴方向。从理论上讲，一个矩形走廊无限延伸到观察者前面和后面都能被观察到。然而，就像透视投影一样，在OpenGL图像中实际上只能显示这个无限走廊的一个有限段。这个有限的视体积是一个平行六面体——一个长方体——它被近裁剪平面和远裁剪平面削去了无限走廊的部分。远距离必须大于近距离，但对于正交投影，近距离的值允许为负数，将“近”裁剪平面置于观察者的后面，如下图的下部分所示：</p>
<p><a class="glightbox" href="../../../en/c3/projection-parallelepiped.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c3/projection-parallelepiped.png" /></a></p>
<p>注意，近裁剪平面的负值将近裁剪平面放在了正z轴上，即观察者的后面。</p>
<p>可以使用glOrtho方法在OpenGL中设置正交投影，该方法的形式如下：</p>
<div class="highlight"><pre><span></span><code><span class="n">glOrtho</span><span class="p">(</span><span class="w"> </span><span class="n">xmin</span><span class="p">,</span><span class="w"> </span><span class="n">xmax</span><span class="p">,</span><span class="w"> </span><span class="n">ymin</span><span class="p">,</span><span class="w"> </span><span class="n">ymax</span><span class="p">,</span><span class="w"> </span><span class="n">near</span><span class="p">,</span><span class="w"> </span><span class="n">far</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>前四个参数指定了视体积左、右、下和上的x和y坐标。请注意，最后两个参数是near和far，而不是zmin和zmax。实际上，视体积的最小z值为−far，最大z值为−near。然而，通常情况下near = −far，如果是这样，则最小和最大z值最终仍然是near和far！</p>
<p>与<em>glFrustum</em>一样，当矩阵模式为GL_PROJECTION时应调用glOrtho。例如，假设我们希望视体积是以原点为中心的箱子，其x、y和z值的范围为-10到10。可以通过以下方式实现：</p>
<div class="highlight"><pre><span></span><code><span class="n">glMatrixMode</span><span class="p">(</span><span class="n">GL_PROJECTION</span><span class="p">);</span>
<span class="n">glLoadIdentity</span><span class="p">();</span>
<span class="n">glOrtho</span><span class="p">(</span><span class="w"> </span><span class="mi">-10</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">-10</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">-10</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">);</span>
<span class="n">glMatrixMode</span><span class="p">(</span><span class="n">GL_MODELVIEW</span><span class="p">);</span>
</code></pre></div>
<p>现在，事实证明，在这种简单情况下，glOrtho的效果与glScalef(0.1, 0.1, -0.1)的效果完全相同，因为投影只是将箱子按比例缩小了10倍。但通常更好地将投影看作与缩放不同类型的事物。（z缩放因子上的负号是因为投影颠倒了z轴的方向，将传统的右手坐标系转换为OpenGL的左手默认坐标系。）</p>
<hr />
<p><em>glFrustum</em>方法并不特别易于使用。有一个称为GLU的库，其中包含一些用于OpenGL的实用函数。GLU库包括<em>gluPerspective</em>方法，作为设置透视投影的更简单的方法。命令</p>
<div class="highlight"><pre><span></span><code><span class="n">gluPerspective</span><span class="p">(</span><span class="w"> </span><span class="n">fieldOfViewAngle</span><span class="p">,</span><span class="w"> </span><span class="n">aspect</span><span class="p">,</span><span class="w"> </span><span class="n">near</span><span class="p">,</span><span class="w"> </span><span class="n">far</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>可以用来代替<em>glFrustum</em>。<em>fieldOfViewAngle</em>是垂直角度，以度为单位，指的是视体积金字塔的上侧和下侧之间的夹角。典型值在30到60度之间。aspect参数是视图的纵横比，即金字塔横截面的宽度除以高度。aspect的值通常应设置为视口的纵横比。<em>gluPerspective</em>中的near和far参数的含义与<em>glFrustum</em>中的相同。</p>
</div>
<div class="tabbed-block">
<p>We turn next to the <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> transformation. Like any transform, the <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> is represented in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> as a <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>. <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> keeps track of the <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> separately from the <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> that represents the <abbr title="In OpenGL 1.1, a transform that combines the modeling transform with the viewing transform. That is, it is the composition of the transformation from object coordinates to world coordinates and the transformation from world coordinates to eye coordinates. Because of the equivalence between modeling and viewing transformations, world coordinates are not really meaningful for OpenGL, and only the combined transformation is tracked.">modelview transformation</abbr>. The same transform functions, such as <em>glRotatef</em>, can be applied to both matrices, so <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> needs some way to know which <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> those functions apply to. This is determined by an <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> state property called the <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> mode. The value of the <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> mode is a constant such as <em>GL_PROJECTION</em> or <em>GL_MODELVIEW</em>. When a function such as <em>glRotatef</em> is called, it modifies a <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>; which <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> is modified depends on the current value of the <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> mode. The value is set by calling the function glMatrixMode. The initial value is GL_MODELVIEW. This means that if you want to work on the <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>, you must first call</p>
<div class="highlight"><pre><span></span><code><span class="n">glMatrixMode</span><span class="p">(</span><span class="n">GL_PROJECTION</span><span class="p">);</span>
</code></pre></div>
<p>If you want to go back to working on the modelview <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>, you must call</p>
<div class="highlight"><pre><span></span><code><span class="n">glMatrixMode</span><span class="p">(</span><span class="n">GL_MODELVIEW</span><span class="p">);</span>
</code></pre></div>
<p>In my programs, I generally set the <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> mode to <em>GL_PROJECTION</em>, set up the <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> transformation, and then immediately set the <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> mode back to <em>GL_MODELVIEW</em>. This means that anywhere else in the program, I can be sure that the <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> mode is <em>GL_MODELVIEW</em>.</p>
<hr />
<p>To help you to understand <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr>, remember that a 3D image can show only a part of the infinite 3D world. The <abbr title="In OpenGL 1.1, the region is 3D space that is visible in the rendered image. For orthographic projections, the view volume is a rectangular solid. For perspective projection, the view volume is a frustum (truncated pyramid).">view volume</abbr> is the part of the world that is visible in the image. The <abbr title="In OpenGL 1.1, the region is 3D space that is visible in the rendered image. For orthographic projections, the view volume is a rectangular solid. For perspective projection, the view volume is a frustum (truncated pyramid).">view volume</abbr> is determined by a combination of the <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transformation and the <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> transformation. The <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transform determines where the viewer is located and what direction the viewer is facing, but it doesn't say how much of the world the viewer can see. The <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> transform does that: It specifies the shape and extent of the region that is in view. Think of the viewer as a <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>, with a big invisible box attached to the front of the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> that encloses the part of the world that that <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> has in view. The inside of the box is the <abbr title="In OpenGL 1.1, the region is 3D space that is visible in the rendered image. For orthographic projections, the view volume is a rectangular solid. For perspective projection, the view volume is a frustum (truncated pyramid).">view volume</abbr>. As the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> moves around in the world, the box moves with it, and the <abbr title="In OpenGL 1.1, the region is 3D space that is visible in the rendered image. For orthographic projections, the view volume is a rectangular solid. For perspective projection, the view volume is a frustum (truncated pyramid).">view volume</abbr> changes. But the shape and size of the box don't change. The shape and size of the box correspond to the <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> transform. The position and orientation of the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> correspond to the <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transform.</p>
<p>This is all just another way of saying that, mathematically, the <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> transformation transforms <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr> to <abbr title="The default coordinate system in OpenGL. The projection transform maps the 3D scene to clip coordinates. The rendered image will show the contents of the cube in the clip coordinate system that contains x, y, and z values in the range from -1 to 1; anything outside that range is &quot;clipped&quot; away.">clip coordinates</abbr>, mapping the <abbr title="In OpenGL 1.1, the region is 3D space that is visible in the rendered image. For orthographic projections, the view volume is a rectangular solid. For perspective projection, the view volume is a frustum (truncated pyramid).">view volume</abbr> onto the 2-by-2-by-2 clipping cube that contains everything that will be visible in the image. To specify a <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> just means specifying the size and shape of the <abbr title="In OpenGL 1.1, the region is 3D space that is visible in the rendered image. For orthographic projections, the view volume is a rectangular solid. For perspective projection, the view volume is a frustum (truncated pyramid).">view volume</abbr>, relative to the viewer.</p>
<p>There are two general types of <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr>, <strong><abbr title="A projection from 3D to 2D that projects objects along lines radiating out from a viewpoint. A perspective projection attempts to simulate realistic viewing. A perspective projection preserves perspective; that is, objects that are farther from the viewpoint are smaller in the projection. In OpenGL 1.1, the view volume for a perspective projection is a frustum, or truncated pyramid.">perspective projection</abbr></strong> and <strong><abbr title="A projection from 3D to 2D that simply discards the z-coordinate. It projects objects along lines that are orthogonal (perpendicular) to the xy-plane. In OpenGL 1.1, the view volume for an orthographic projection is a rectangular solid.">orthographic projection</abbr></strong>. Perspective <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> is more physically realistic. That is, it shows what you would see if the <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> display rectangle on your computer screen were a window into an actual 3D world (one that could extend in front of the screen as well as behind it). It shows a view that you could get by taking a picture of a 3D world with an ordinary <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>. In a perspective view, the apparent size of an object depends on how far it is away from the viewer. Only things that are in front of the viewer can be seen. In fact, ignoring clipping in the z-direction for the moment, the part of the world that is in view is an infinite pyramid, with the viewer at the apex of the pyramid, and with the sides of the pyramid passing through the sides of the <abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr> rectangle.</p>
<p>However, <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> can't actually show everything in this pyramid, because of its use of the <abbr title="A solution to the hidden surface problem that involves keeping track of the depth, or distance from the viewer, of the object currently visible at each pixel in the image. When a new object is drawn at a pixel, the depth of the new object is compared to the depth of the current object to decide which one is closer to the viewer. The advantage of the depth test is that objects can be rendered in any order. A disadvantage is that only a limited range of depths can be represented in the image.">depth test</abbr> to solve the <abbr title="The problem in 3D graphics of deciding which object is visible at each pixel in an image. When one object is behind another object from the point of view of the viewer, only the front object should appear in the image. A rendering algorithm for 3D graphics must satisfy this constraint. Algorithms that solve the hidden surface problem include the painter's algorithm and the depth test algorithm.">hidden surface problem</abbr>. Since the <abbr title="A region of memory that stores the information needed for the depth test in 3D graphics, that is, a depth value for each pixel in the image. Also called the &quot;z-buffer.&quot;">depth buffer</abbr> can only store a finite range of depth values, it can't represent the entire range of depth values for the infinite pyramid that is theoretically in view. Only objects in a certain range of distances from the viewer can be part of the image. That range of distances is specified by two values, near and far. For a perspective transformation, both of these values must be positive numbers, and far must be greater than near. Anything that is closer to the viewer than the near distance or farther away than the far distance is discarded and does not appear in the rendered image. The volume of space that is represented in the image is thus a "truncated pyramid." This pyramid is the <abbr title="In OpenGL 1.1, the region is 3D space that is visible in the rendered image. For orthographic projections, the view volume is a rectangular solid. For perspective projection, the view volume is a frustum (truncated pyramid).">view volume</abbr> for a <abbr title="A projection from 3D to 2D that projects objects along lines radiating out from a viewpoint. A perspective projection attempts to simulate realistic viewing. A perspective projection preserves perspective; that is, objects that are farther from the viewpoint are smaller in the projection. In OpenGL 1.1, the view volume for a perspective projection is a frustum, or truncated pyramid.">perspective projection</abbr>:</p>
<p><a class="glightbox" href="../../../en/c3/projection-frustum.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c3/projection-frustum.png" /></a></p>
<p>The <abbr title="In OpenGL 1.1, the region is 3D space that is visible in the rendered image. For orthographic projections, the view volume is a rectangular solid. For perspective projection, the view volume is a frustum (truncated pyramid).">view volume</abbr> is bounded by six planes—the four sides plus the top and bottom of the truncated pyramid. These planes are called clipping planes because anything that lies on the wrong side of each plane is clipped away. The <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> transformation maps the six sides of the truncated pyramid in <abbr title="The coordinate system on 3D space defined by the viewer. In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the direction of the negative z-axis, with the positive y-axis pointing upwards, and the positive x-axis pointing to the right. The modelview transformation maps objects into the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates.">eye coordinates</abbr> to the six sides of the clipping cube in <abbr title="The default coordinate system in OpenGL. The projection transform maps the 3D scene to clip coordinates. The rendered image will show the contents of the cube in the clip coordinate system that contains x, y, and z values in the range from -1 to 1; anything outside that range is &quot;clipped&quot; away.">clip coordinates</abbr>.</p>
<p>In <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr>, setting up the <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> transformation is equivalent to defining the <abbr title="In OpenGL 1.1, the region is 3D space that is visible in the rendered image. For orthographic projections, the view volume is a rectangular solid. For perspective projection, the view volume is a frustum (truncated pyramid).">view volume</abbr>. For a perspective transformation, you have to set up a <abbr title="In OpenGL 1.1, the region is 3D space that is visible in the rendered image. For orthographic projections, the view volume is a rectangular solid. For perspective projection, the view volume is a frustum (truncated pyramid).">view volume</abbr> that is a truncated pyramid. A rather obscure term for this shape is a <strong><abbr title="A truncated pyramid; that is, a pyramid from which the top has been cut off. In OpenGL 1.1, the view volume for a perspective projection is a frustum.">frustum</abbr></strong>. A perspective transformation can be set up with the <em>glFrustum</em> command:</p>
<div class="highlight"><pre><span></span><code><span class="n">glFrustum</span><span class="p">(</span><span class="w"> </span><span class="n">xmin</span><span class="p">,</span><span class="w"> </span><span class="n">xmax</span><span class="p">,</span><span class="w"> </span><span class="n">ymin</span><span class="p">,</span><span class="w"> </span><span class="n">ymax</span><span class="p">,</span><span class="w"> </span><span class="n">near</span><span class="p">,</span><span class="w"> </span><span class="n">far</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>The last two parameters specify the near and far distances from the viewer, as already discussed. The viewer is assumed to be at the origin, (0,0,0), facing in the direction of the negative z-axis. (This is the eye <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr>.) So, the near clipping plane is at <code>z = −near</code>, and the far clipping plane is at <code>z = −far</code>. (Notice the minus signs!) The first four parameters specify the sides of the pyramid: xmin, xmax, ymin, and ymax specify the horizontal and vertical limits of the <abbr title="In OpenGL 1.1, the region is 3D space that is visible in the rendered image. For orthographic projections, the view volume is a rectangular solid. For perspective projection, the view volume is a frustum (truncated pyramid).">view volume</abbr> <strong>at the near clipping plane</strong>. For example, the coordinates of the upper-left corner of the small end of the pyramid are (xmin, ymax, -near). The x and y limits at the far clipping plane are larger, usually much larger, than the limits specified in the glFrustum command.</p>
<p>Note that x and y limits in glFrustum are usually symmetrical about zero. That is, xmin is usually equal to the negative of xmax and ymin is usually equal to the negative of ymax. However, this is not required. It is possible to have asymmetrical view volumes where the z-axis does not point directly down the center of the view.</p>
<p>Since the <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> mode must be set to GL_PROJECTION to work on the <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> transformation, glFrustum is often used in a code segment of the form</p>
<div class="highlight"><pre><span></span><code><span class="n">glMatrixMode</span><span class="p">(</span><span class="n">GL_PROJECTION</span><span class="p">);</span>
<span class="n">glLoadIdentity</span><span class="p">();</span>
<span class="n">glFrustum</span><span class="p">(</span><span class="w"> </span><span class="n">xmin</span><span class="p">,</span><span class="w"> </span><span class="n">xmax</span><span class="p">,</span><span class="w"> </span><span class="n">ymin</span><span class="p">,</span><span class="w"> </span><span class="n">ymax</span><span class="p">,</span><span class="w"> </span><span class="n">near</span><span class="p">,</span><span class="w"> </span><span class="n">far</span><span class="w"> </span><span class="p">);</span>
<span class="n">glMatrixMode</span><span class="p">(</span><span class="n">GL_MODELVIEW</span><span class="p">);</span>
</code></pre></div>
<p>The call to glLoadIdentity ensures that the starting point is the <abbr title="A transform that has no effect on its argument. For example, the identity transform in 2D is given by the formula I(x,y) = (x,y). The identity transform I has the property that if T is any transform, then I followed by T is the same as T, and T followed by I is the same as T.">identity transform</abbr>. This is important since glFrustum modifies the existing <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> rather than replacing it, and although it is theoretically possible, you don't even want to try to think about what would happen if you combine several <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> transformations into one.</p>
<hr />
<p>Compared to perspective projections, orthographic projections are easier to understand: In an <abbr title="A projection from 3D to 2D that simply discards the z-coordinate. It projects objects along lines that are orthogonal (perpendicular) to the xy-plane. In OpenGL 1.1, the view volume for an orthographic projection is a rectangular solid.">orthographic projection</abbr>, the 3D world is <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projected</abbr> onto a 2D image by discarding the z-coordinate of the eye-<abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr>. This type of <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> is unrealistic in that it is not what a viewer would see. For example, the apparent size of an object does not depend on its distance from the viewer. Objects in back of the viewer as well as in front of the viewer can be visible in the image. Orthographic projections are still useful, however, especially in interactive modeling programs where it is useful to see true sizes and angles, undistorted by perspective.</p>
<p>In fact, it's not really clear what it means to say that there is a viewer in the case of <abbr title="A projection from 3D to 2D that simply discards the z-coordinate. It projects objects along lines that are orthogonal (perpendicular) to the xy-plane. In OpenGL 1.1, the view volume for an orthographic projection is a rectangular solid.">orthographic projection</abbr>. Nevertheless, for <abbr title="A projection from 3D to 2D that simply discards the z-coordinate. It projects objects along lines that are orthogonal (perpendicular) to the xy-plane. In OpenGL 1.1, the view volume for an orthographic projection is a rectangular solid.">orthographic projection</abbr> in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr>, there is considered to be a viewer. The viewer is located at the eye-coordinate origin, facing in the direction of the negative z-axis. Theoretically, a rectangular corridor extending infinitely in both directions, in front of the viewer and in back, would be in view. However, as with <abbr title="A projection from 3D to 2D that projects objects along lines radiating out from a viewpoint. A perspective projection attempts to simulate realistic viewing. A perspective projection preserves perspective; that is, objects that are farther from the viewpoint are smaller in the projection. In OpenGL 1.1, the view volume for a perspective projection is a frustum, or truncated pyramid.">perspective projection</abbr>, only a finite segment of this infinite corridor can actually be shown in an <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> image. This finite <abbr title="In OpenGL 1.1, the region is 3D space that is visible in the rendered image. For orthographic projections, the view volume is a rectangular solid. For perspective projection, the view volume is a frustum (truncated pyramid).">view volume</abbr> is a parallelepiped—a rectangular solid—that is cut out of the infinite corridor by a near clipping plane and a far clipping plane. The value of far must be greater than near, but for an <abbr title="A projection from 3D to 2D that simply discards the z-coordinate. It projects objects along lines that are orthogonal (perpendicular) to the xy-plane. In OpenGL 1.1, the view volume for an orthographic projection is a rectangular solid.">orthographic projection</abbr>, the value of near is allowed to be negative, putting the "near" clipping plane behind the viewer, as shown in the lower section of this illustration:</p>
<p><a class="glightbox" href="../../../en/c3/projection-parallelepiped.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c3/projection-parallelepiped.png" /></a></p>
<p>Note that a negative value for near puts the near clipping plane on the positive z-axis, which is behind the viewer.</p>
<p>An <abbr title="A projection from 3D to 2D that simply discards the z-coordinate. It projects objects along lines that are orthogonal (perpendicular) to the xy-plane. In OpenGL 1.1, the view volume for an orthographic projection is a rectangular solid.">orthographic projection</abbr> can be set up in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> using the glOrtho method, which is has the following form:</p>
<div class="highlight"><pre><span></span><code><span class="n">glOrtho</span><span class="p">(</span><span class="w"> </span><span class="n">xmin</span><span class="p">,</span><span class="w"> </span><span class="n">xmax</span><span class="p">,</span><span class="w"> </span><span class="n">ymin</span><span class="p">,</span><span class="w"> </span><span class="n">ymax</span><span class="p">,</span><span class="w"> </span><span class="n">near</span><span class="p">,</span><span class="w"> </span><span class="n">far</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>The first four parameters specify the x- and y-coordinates of the left, right, bottom, and top of the <abbr title="In OpenGL 1.1, the region is 3D space that is visible in the rendered image. For orthographic projections, the view volume is a rectangular solid. For perspective projection, the view volume is a frustum (truncated pyramid).">view volume</abbr>. Note that the last two parameters are near and far, not zmin and zmax. In fact, the minimum z-value for the <abbr title="In OpenGL 1.1, the region is 3D space that is visible in the rendered image. For orthographic projections, the view volume is a rectangular solid. For perspective projection, the view volume is a frustum (truncated pyramid).">view volume</abbr> is −far and the maximum z-value is −near. However, it is often the case that near = −far, and if that is true then the minimum and maximum z-values turn out to be near and far after all!</p>
<p>As with <em>glFrustum</em>, glOrtho should be called when the <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> mode is GL_PROJECTION. As an example, suppose that we want the <abbr title="In OpenGL 1.1, the region is 3D space that is visible in the rendered image. For orthographic projections, the view volume is a rectangular solid. For perspective projection, the view volume is a frustum (truncated pyramid).">view volume</abbr> to be the box centered at the origin containing x, y, and z values in the range from -10 to 10. This can be accomplished with</p>
<div class="highlight"><pre><span></span><code><span class="n">glMatrixMode</span><span class="p">(</span><span class="n">GL_PROJECTION</span><span class="p">);</span>
<span class="n">glLoadIdentity</span><span class="p">();</span>
<span class="n">glOrtho</span><span class="p">(</span><span class="w"> </span><span class="mi">-10</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">-10</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">-10</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">);</span>
<span class="n">glMatrixMode</span><span class="p">(</span><span class="n">GL_MODELVIEW</span><span class="p">);</span>
</code></pre></div>
<p>Now, as it turns out, the effect of glOrtho in this simple case is exactly the same as the effect of glScalef(0.1, 0.1, -0.1), since the <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> just scales the box down by a factor of 10. But it's usually better to think of <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> as a different sort of thing from <abbr title="A geometric transform that multiplies each coordinate of a point by a number called the scaling factor. Scaling increases or decreases the size of an object, but also moves its points closer to or farther from the origin. Scaling can be uniform—the same in every direction—or non-uniform—with a different scaling factor in each coordinate direction. A negative scaling factor can be used to apply a reflection.">scaling</abbr>. (The minus sign on the z <abbr title="A geometric transform that multiplies each coordinate of a point by a number called the scaling factor. Scaling increases or decreases the size of an object, but also moves its points closer to or farther from the origin. Scaling can be uniform—the same in every direction—or non-uniform—with a different scaling factor in each coordinate direction. A negative scaling factor can be used to apply a reflection.">scaling</abbr> factor is there because <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> reverses the direction of the z-axis, transforming the conventionally right-handed eye <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr> into <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr>'s left-handed default <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr>.)</p>
<hr />
<p>The <em>glFrustum</em> method is not particularly easy to use. There is a library known as <abbr title="The OpenGL Utility library. Defines several functions for use with older versions of OpenGL, including gluPerspective and gluLookAt. Not to be confused with GLUT. GLU is a standard part of OpenGL.">GLU</abbr> that contains some utility functions for use with <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr>. The <abbr title="The OpenGL Utility library. Defines several functions for use with older versions of OpenGL, including gluPerspective and gluLookAt. Not to be confused with GLUT. GLU is a standard part of OpenGL.">GLU</abbr> library includes the method <em>gluPerspective</em> as an easier way to set up a <abbr title="A projection from 3D to 2D that projects objects along lines radiating out from a viewpoint. A perspective projection attempts to simulate realistic viewing. A perspective projection preserves perspective; that is, objects that are farther from the viewpoint are smaller in the projection. In OpenGL 1.1, the view volume for a perspective projection is a frustum, or truncated pyramid.">perspective projection</abbr>. The command</p>
<div class="highlight"><pre><span></span><code><span class="n">gluPerspective</span><span class="p">(</span><span class="w"> </span><span class="n">fieldOfViewAngle</span><span class="p">,</span><span class="w"> </span><span class="n">aspect</span><span class="p">,</span><span class="w"> </span><span class="n">near</span><span class="p">,</span><span class="w"> </span><span class="n">far</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>can be used instead of <em>glFrustum</em>. The <em>fieldOfViewAngle</em> is the vertical angle, measured in degrees, between the upper side of the <abbr title="In OpenGL 1.1, the region is 3D space that is visible in the rendered image. For orthographic projections, the view volume is a rectangular solid. For perspective projection, the view volume is a frustum (truncated pyramid).">view volume</abbr> pyramid and the lower side. Typical values are in the range 30 to 60 degrees. The aspect parameter is the <abbr title="The ratio of the width, w, of a rectangle to the height, h, of the rectangle, expressed either as a ratio **w:h** or as a fraction** w/h**.">aspect ratio</abbr> of the view, that is, the width of a cross-section of the pyramid divided by its height. The value of aspect should generally be set to the <abbr title="The ratio of the width, w, of a rectangle to the height, h, of the rectangle, expressed either as a ratio **w:h** or as a fraction** w/h**.">aspect ratio</abbr> of the <abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr>. The near and far parameters in <em>gluPerspective</em> have the same meaning as for <em>glFrustum</em>.</p>
</div>
</div>
</div>
<h2 id="334-模型视图转换">3.3.4 模型视图转换<a class="headerlink" href="#334-模型视图转换" title="Permanent link">&para;</a></h2>
<p><strong>The Modelview Transformation</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="5:2"><input checked="checked" id="__tabbed_5_1" name="__tabbed_5" type="radio" /><input id="__tabbed_5_2" name="__tabbed_5" type="radio" /><div class="tabbed-labels"><label for="__tabbed_5_1">中文</label><label for="__tabbed_5_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>“建模”和“<abbr title="设置观察者在3D世界中的位置和方向，从而确定渲染3D世界的2D图像时将可见的内容。">视图</abbr>”在概念上似乎是非常不同的事物，但在OpenGL中将它们合并成一个单一的变换。这是因为从原则上讲无法区分它们之间的区别；区别仅在概念上存在。也就是说，给定的变换可以被视为是建模变换或视图变换，这取决于您对其的理解方式。（在概念上的一个显着差异是，相同的视图变换通常适用于3D场景中的每个对象，而每个对象可以有自己的建模变换。但这不是原则上的差异。）我们在2D图形中已经看到了类似的情况(<a href="../../c2/s3/#231--视口和建模">Subsection 2.3.1</a>)，但让我们思考一下它在3D中是如何工作的。</p>
<p>例如，假设在原点有一个房子模型，朝向正z轴方向。假设观察者在正z轴上，朝向原点回望。观察者直接朝向房子的前面。现在，您可以对房子应用一个建模变换，将其围绕y轴旋转90度。在此变换之后，房子朝向正x轴的方向，观察者直接朝向房子的<strong>左侧</strong>。另一方面，您可以将<strong>观察者</strong>绕y轴<strong>负方向</strong>旋转90度。这会将观察者置于负x轴上，从而使其能够看到房子的<strong>左侧</strong>。无论哪种变换，最终的结果是观察者对房子的视图完全相同。在OpenGL中，这两种变换都可以使用命令实现：</p>
<div class="highlight"><pre><span></span><code><span class="n">glRotatef</span><span class="p">(</span><span class="mi">90</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div>
<p>也就是说，此命令表示既是将对象旋转90度的建模变换，也是将观察者绕y轴旋转-90度的视图变换。请注意，对观察者的影响与对对象的影响是相反的。建模和视图变换总是以这种方式相关联的。例如，如果您正在观察一个对象，您可以将自己向<strong>左</strong>移动5英尺（视图变换），或者将对象向<strong>右</strong>移动5英尺（<abbr title="应用于对象以将该对象映射到世界坐标系统或更复杂的分层对象的对象坐标系统的变换。">建模变换</abbr>）。无论哪种情况，您最终都会得到相同的对象视图。在OpenGL中，这两种变换都表示为</p>
<div class="highlight"><pre><span></span><code><span class="n">glTranslatef</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div>
<p>这甚至适用于缩放：如果观察者缩小，那么对于观察者来说，世界看起来与扩展的情况完全相同，反之亦然。</p>
<hr />
<p>尽管建模和视图变换在原理上是相同的，但它们在概念上仍然有很大的不同，并且通常在代码中的不同点应用它们。一般情况下，在绘制场景时，您将执行以下操作：(1)加载单位矩阵，作为明确定义的起始点；(2)应用视图变换；(3)绘制场景中的对象，每个对象都有自己的建模变换。请记住，OpenGL会跟踪多个变换，并且所有这些都必须在模型视图变换当前时完成；如果您不确定这一点，那么在步骤(1)之前，您应该调用<em>glMatrixMode(GL_MODELVIEW)</em>。在步骤(3)中，您可能会使用<em>glPushMatrix()</em>和<em>glPopMatrix()</em>将每个建模变换限制为特定的对象。</p>
<p>在加载单位矩阵后，观察者位于默认位置，即原点，沿负z轴向下看，视图中的正y轴向上指向。例如，假设我们希望将观察者从其默认位置在原点沿正z轴方向移动到点(0,0,20)。这个操作与移动世界及其包含的对象，使其沿着z轴的负方向移动20个单位具有完全相同的效果。无论执行哪种操作，观察者最终与对象的位置完全相同。这两种操作都由相同的OpenGL命令实现，即<em>glTranslatef(0,0,-20)</em>。举个例子，假设我们使用两个命令</p>
<div class="highlight"><pre><span></span><code><span class="n">glRotatef</span><span class="p">(</span><span class="mi">90</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="n">glTranslatef</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div>
<p>来建立视图变换。作为建模变换，这些命令首先将一个对象沿着正x方向平移10个单位，然后围绕y轴旋转90度。这将使原本位于(0,0,0)的对象移动到(0,0,-10)，将对象直接放置在观察者前方10个单位处。请记住，建模变换是按照与代码中出现顺序相反的顺序应用于对象的。（您应该思考一下这两个解释如何影响一个从(0,0,0)开始的房屋的视图。该变换会影响观察者看到房屋的哪一侧，以及观察者位于房屋多远的位置。）</p>
<p>顺便提一下，应用视图变换的顺序与它们在代码中出现的顺序<strong>相同</strong>。</p>
<p>以下是一个演示，说明了建模和视图之间的等价性。下图中的半透明灰色框表示用于创建显示在左上方的图像的视图体积。在这种情况下，投影是透视投影，视图体积是一个棱台。阅读演示中的帮助文本以获取更多信息。</p>
<p><iframe src="../../../en/demos/c3/transform-equivalence-3d.html" width="700" height="750"></iframe></p>
<p>通过组合旋转、缩放和平移来设置视图可能会很困难，因此OpenGL提供了一种更容易设置典型视图的方法。这个命令不是OpenGL本身的一部分，而是GLU库的一部分。</p>
<p>GLU库提供了以下方便的方法来设置视图变换：</p>
<div class="highlight"><pre><span></span><code><span class="n">gluLookAt</span><span class="p">(</span><span class="w"> </span><span class="n">eyeX</span><span class="p">,</span><span class="n">eyeY</span><span class="p">,</span><span class="n">eyeZ</span><span class="p">,</span><span class="w"> </span><span class="n">refX</span><span class="p">,</span><span class="n">refY</span><span class="p">,</span><span class="n">refZ</span><span class="p">,</span><span class="w"> </span><span class="n">upX</span><span class="p">,</span><span class="n">upY</span><span class="p">,</span><span class="n">upZ</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>该方法将观察者放置在点(eyeX,eyeY,eyeZ)，朝向点(refX,refY,refZ)。观察者的方向是使向量(upX,upY,upZ)指向观察者视图中的上方。例如，要将观察者定位在负x轴上，距离原点10个单位，向后看原点，使正方向的y轴向上，通常使用以下命令：</p>
<div class="highlight"><pre><span></span><code><span class="n">gluLookAt</span><span class="p">(</span><span class="w"> </span><span class="mi">-10</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<hr />
<p>有了所有这些，我们可以为使用OpenGL 1.1绘制3D场景图像的典型显示程序提供一个大致的概述：</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 可能在此处设置清除颜色，如果在其他地方未设置</span>

<span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">GL_DEPTH_BUFFER_BIT</span><span class="p">);</span>

<span class="c1">// 可能在此处设置投影，如果在其他地方未设置</span>

<span class="n">glMatrixMode</span><span class="p">(</span><span class="n">GL_MODELVIEW</span><span class="p">);</span>

<span class="n">glLoadIdentity</span><span class="p">();</span>

<span class="n">gluLookAt</span><span class="p">(</span><span class="n">eyeX</span><span class="p">,</span><span class="w"> </span><span class="n">eyeY</span><span class="p">,</span><span class="w"> </span><span class="n">eyeZ</span><span class="p">,</span><span class="w"> </span><span class="n">refX</span><span class="p">,</span><span class="w"> </span><span class="n">refY</span><span class="p">,</span><span class="w"> </span><span class="n">refZ</span><span class="p">,</span><span class="w"> </span><span class="n">upX</span><span class="p">,</span><span class="w"> </span><span class="n">upY</span><span class="p">,</span><span class="w"> </span><span class="n">upZ</span><span class="p">);</span><span class="w">  </span><span class="c1">// 视图变换</span>

<span class="n">glPushMatrix</span><span class="p">();</span>
<span class="p">.</span>
<span class="p">.</span><span class="w">   </span><span class="c1">// 应用建模变换并绘制一个对象</span>
<span class="p">.</span>
<span class="n">glPopMatrix</span><span class="p">();</span>

<span class="n">glPushMatrix</span><span class="p">();</span>
<span class="p">.</span>
<span class="p">.</span><span class="w">   </span><span class="c1">// 应用另一个建模变换并绘制另一个对象</span>
<span class="p">.</span>
<span class="n">glPopMatrix</span><span class="p">();</span>

<span class="p">.</span>
<span class="p">.</span>
<span class="p">.</span>
</code></pre></div>
</div>
<div class="tabbed-block">
<p>"Modeling" and "<abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr>" might seem like very different things, conceptually, but <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> combines them into a single transformation. This is because there is no way to distinguish between them in principle; the difference is purely conceptual. That is, a given transformation can be considered to be either a <abbr title="A transformation that is applied to an object to map that object into the world coordinate system or into the object coordinate system for a more complex, hierarchical object.">modeling transformation</abbr> or a <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transformation, depending on how you think about it. (One significant difference, conceptually, is that the same <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transformation usually applies to every object in the 3D scene, while each object can have its own <abbr title="A transformation that is applied to an object to map that object into the world coordinate system or into the object coordinate system for a more complex, hierarchical object.">modeling transformation</abbr>. But this is not a difference in principle.) We have already seen something similar in 2D graphics (<a href="../../c2/s3/#231--视口和建模">Subsection 2.3.1</a>), but let's think about how it works in 3D.</p>
<p>For example, suppose that there is a model of a house at the origin, facing towards the direction of the positive z-axis. Suppose the viewer is on the positive z-axis, looking back towards the origin. The viewer is looking directly at the front of the house. Now, you might apply a <abbr title="A transformation that is applied to an object to map that object into the world coordinate system or into the object coordinate system for a more complex, hierarchical object.">modeling transformation</abbr> to the house, to rotate it by 90 degrees about the y-axis. After this transformation, the house is facing in the positive direction of the x-axis, and the viewer is looking directly at the <strong>left</strong> side of the house. On the other hand, you might rotate the <strong>viewer</strong> by <strong>minus</strong> 90 degrees about the y-axis. This would put the viewer on the negative x-axis, which would give it a view of the <strong>left</strong> side of the house. The net result after either transformation is that the viewer ends up with exactly the same view of the house. Either transformation can be implemented in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> with the command</p>
<div class="highlight"><pre><span></span><code><span class="n">glRotatef</span><span class="p">(</span><span class="mi">90</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div>
<p>That is, this command represents either a <abbr title="A transformation that is applied to an object to map that object into the world coordinate system or into the object coordinate system for a more complex, hierarchical object.">modeling transformation</abbr> that rotates an object by 90 degrees or a <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transformation that rotates the viewer by -90 degrees about the y-axis. Note that the effect on the viewer is the inverse of the effect on the object. Modeling and <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transforms are always related in this way. For example, if you are looking at an object, you can move yourself 5 feet to the <strong>left</strong> (<abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transform), or you can move the object 5 feet to the <strong>right</strong> (modeling transform). In either case, you end up with the same view of the object. Both transformations would be represented in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> as</p>
<div class="highlight"><pre><span></span><code><span class="n">glTranslatef</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div>
<p>This even works for <abbr title="A geometric transform that multiplies each coordinate of a point by a number called the scaling factor. Scaling increases or decreases the size of an object, but also moves its points closer to or farther from the origin. Scaling can be uniform—the same in every direction—or non-uniform—with a different scaling factor in each coordinate direction. A negative scaling factor can be used to apply a reflection.">scaling</abbr>: If the viewer shrinks, it will look to the viewer exactly the same as if the world is expanding, and vice-versa.</p>
<hr />
<p>Although modeling and <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transformations are the same in principle, they remain very different conceptually, and they are typically applied at different points in the code. In general when drawing a scene, you will do the following: (1) Load the <abbr title="The n-by-n identity matrix is an n-by-n matrix which has ones on the diagonal and zeros elsewhere. Multiplication of any matrix B by the identity matrix, in either order, leaves B unchanged. Multiplication of an n-dimensional vector by the n-by-n identity matrix leaves the vector unchanged; that is, the identity matrix is the matrix for the identity transformation.">identity matrix</abbr>, for a well-defined starting point; (2) apply the <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transformation; and (3) draw the objects in the scene, each with its own <abbr title="A transformation that is applied to an object to map that object into the world coordinate system or into the object coordinate system for a more complex, hierarchical object.">modeling transformation</abbr>. Remember that <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> keeps track of several transformations, and that this must all be done while the modelview transform is current; if you are not sure of that then before step (1), you should call <em>glMatrixMode(GL_MODELVIEW)</em>. During step (3), you will probably use <em>glPushMatrix()</em> and <em>glPopMatrix()</em> to limit each modeling transform to a particular object.</p>
<p>After loading the <abbr title="The n-by-n identity matrix is an n-by-n matrix which has ones on the diagonal and zeros elsewhere. Multiplication of any matrix B by the identity matrix, in either order, leaves B unchanged. Multiplication of an n-dimensional vector by the n-by-n identity matrix leaves the vector unchanged; that is, the identity matrix is the matrix for the identity transformation.">identity matrix</abbr>, the viewer is in the default position, at the origin, looking down the negative z-axis, with the positive y-axis pointing upwards in the view. Suppose, for example, that we would like to move the viewer from its default location at the origin back along the positive z-axis to the point (0,0,20). This operation has exactly the same effect as moving the world, and the objects that it contains, 20 units in the negative direction along the z-axis. Whichever operation is performed, the viewer ends up in exactly the same position relative to the objects. Both operations are implemented by the same <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> command, <em>glTranslatef(0,0,-20)</em>. For another example, suppose that we use two commands</p>
<div class="highlight"><pre><span></span><code><span class="n">glRotatef</span><span class="p">(</span><span class="mi">90</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="n">glTranslatef</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div>
<p>to establish the <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transformation. As a modeling transform, these commands would first translate an object 10 units in the positive x-direction, then rotate the object 90 degrees about the y-axis. This would move an object originally at (0,0,0) to (0,0,-10), placing the object 10 units directly in front of the viewer. (Remember that modeling transformations are applied to objects in the order opposite to their order in the code.) What do these commands do as a <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transformation? The effect on the view is the inverse of the effect on objects. The inverse of "translate 90 then rotate 10" is "rotate -10 then translate -90." That is, to do the inverse, you have to undo the <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> <strong>before</strong> you undo the <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr>. The effect as a <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transformation is first to rotate the view by -90 degrees about the y-axis (which would leave the viewer at the origin, but now looking along the positive x-axis), then to translate the viewer by -10 along the x-axis (backing up the viewer to the point (-10,0,0)). An object at the point (0,0,0) would thus be 10 units directly in front of the viewer. (You should think about how the two interpretations affect the view of a house that starts out at (0,0,0). The transformation affects which side of the house the viewer is looking at, as well as how far away from the house the viewer is located).</p>
<p>Note, by the way, that the order in which <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transformations are applied is the <strong>same as</strong> the order in which they occur in the code.</p>
<p>Here is a demo that illustrates the equivalence between modeling and <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr>. The translucent gray box in the lower images represents the <abbr title="In OpenGL 1.1, the region is 3D space that is visible in the rendered image. For orthographic projections, the view volume is a rectangular solid. For perspective projection, the view volume is a frustum (truncated pyramid).">view volume</abbr> that is used to create the image that is shown in the upper left. In this case, the <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> is a <abbr title="A projection from 3D to 2D that projects objects along lines radiating out from a viewpoint. A perspective projection attempts to simulate realistic viewing. A perspective projection preserves perspective; that is, objects that are farther from the viewpoint are smaller in the projection. In OpenGL 1.1, the view volume for a perspective projection is a frustum, or truncated pyramid.">perspective projection</abbr>, and the <abbr title="In OpenGL 1.1, the region is 3D space that is visible in the rendered image. For orthographic projections, the view volume is a rectangular solid. For perspective projection, the view volume is a frustum (truncated pyramid).">view volume</abbr> is a <abbr title="A truncated pyramid; that is, a pyramid from which the top has been cut off. In OpenGL 1.1, the view volume for a perspective projection is a frustum.">frustum</abbr>. Read the help text in the demo for more information.</p>
<p><iframe src="../../../en/demos/c3/transform-equivalence-3d.html" width="700" height="750"></iframe></p>
<p>It can be difficult to set up a view by combining rotations, scalings, and translations, so <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> provides an easier way to set up a typical view. The command is not part of <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> itself but is part of the <abbr title="The OpenGL Utility library. Defines several functions for use with older versions of OpenGL, including gluPerspective and gluLookAt. Not to be confused with GLUT. GLU is a standard part of OpenGL.">GLU</abbr> library.</p>
<p>The <abbr title="The OpenGL Utility library. Defines several functions for use with older versions of OpenGL, including gluPerspective and gluLookAt. Not to be confused with GLUT. GLU is a standard part of OpenGL.">GLU</abbr> library provides the following convenient method for setting up a <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transformation:</p>
<div class="highlight"><pre><span></span><code><span class="n">gluLookAt</span><span class="p">(</span><span class="w"> </span><span class="n">eyeX</span><span class="p">,</span><span class="n">eyeY</span><span class="p">,</span><span class="n">eyeZ</span><span class="p">,</span><span class="w"> </span><span class="n">refX</span><span class="p">,</span><span class="n">refY</span><span class="p">,</span><span class="n">refZ</span><span class="p">,</span><span class="w"> </span><span class="n">upX</span><span class="p">,</span><span class="n">upY</span><span class="p">,</span><span class="n">upZ</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>This method places the viewer at the point (eyeX,eyeY,eyeZ), looking towards the point (refX,refY,refZ). The viewer is oriented so that the <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> (upX,upY,upZ) points upwards in the viewer's view. For example, to position the viewer on the negative x-axis, 10 units from the origin, looking back at the origin, with the positive direction of the y-axis pointing up as usual, use</p>
<div class="highlight"><pre><span></span><code><span class="n">gluLookAt</span><span class="p">(</span><span class="w"> </span><span class="mi">-10</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<hr />
<p>With all this, we can give an outline for a typical display routine for drawing an image of a 3D scene with <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// possibly set clear color here, if not set elsewhere</span>

<span class="n">glClear</span><span class="p">(</span><span class="w"> </span><span class="n">GL_COLOR_BUFFER_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">GL_DEPTH_BUFFER_BIT</span><span class="w"> </span><span class="p">);</span>

<span class="c1">// possibly set up the projection here, if not done elsewhere</span>

<span class="n">glMatrixMode</span><span class="p">(</span><span class="w"> </span><span class="n">GL_MODELVIEW</span><span class="w"> </span><span class="p">);</span>

<span class="n">glLoadIdentity</span><span class="p">();</span>

<span class="n">gluLookAt</span><span class="p">(</span><span class="w"> </span><span class="n">eyeX</span><span class="p">,</span><span class="n">eyeY</span><span class="p">,</span><span class="n">eyeZ</span><span class="p">,</span><span class="w"> </span><span class="n">refX</span><span class="p">,</span><span class="n">refY</span><span class="p">,</span><span class="n">refZ</span><span class="p">,</span><span class="w"> </span><span class="n">upX</span><span class="p">,</span><span class="n">upY</span><span class="p">,</span><span class="n">upZ</span><span class="w"> </span><span class="p">);</span><span class="w">  </span><span class="c1">// Viewing transform</span>

<span class="n">glPushMatrix</span><span class="p">();</span>
<span class="p">.</span>
<span class="p">.</span><span class="w">   </span><span class="c1">// apply modeling transform and draw an object</span>
<span class="p">.</span>
<span class="n">glPopMatrix</span><span class="p">();</span>

<span class="n">glPushMatrix</span><span class="p">();</span>
<span class="p">.</span>
<span class="p">.</span><span class="w">   </span><span class="c1">// apply another modeling transform and draw another object</span>
<span class="p">.</span>
<span class="n">glPopMatrix</span><span class="p">();</span>

<span class="p">.</span>
<span class="p">.</span>
<span class="p">.</span>
</code></pre></div>
</div>
</div>
</div>
<h2 id="335-相机抽象">3.3.5 相机抽象<a class="headerlink" href="#335-相机抽象" title="Permanent link">&para;</a></h2>
<p><strong>A Camera Abstraction</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="6:2"><input checked="checked" id="__tabbed_6_1" name="__tabbed_6" type="radio" /><input id="__tabbed_6_2" name="__tabbed_6" type="radio" /><div class="tabbed-labels"><label for="__tabbed_6_1">中文</label><label for="__tabbed_6_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>将投影和视图讨论时，通常会使用“<abbr title="在三维计算机图形中，将投影和观察变换组合成一个抽象，模拟物理相机或眼睛。">相机</abbr>”类比。实际相机用于拍摄3D世界的照片。对于3D图形，想象使用虚拟相机执行相同操作是很有用的。设置视图变换就像定位和指向相机一样。投影变换确定相机的属性：它的视场是多少，使用什么样的镜头？（当然，至少在一个方面，OpenGL中的这个比喻有所不同，因为实际相机在其z方向上不会进行裁剪。）</p>
<p>我编写了一个相机工具来实现这个想法。相机旨在接管设置投影和视图的工作。与手动设置相比，您可以设置相机的属性。API适用于C和Java。两个版本略有不同，因为Java版本是面向对象的。我将首先讨论C实现。（有关使用C和Java中OpenGL编程的基本信息，请参阅<a href="../s6/">第3.6节</a>。有关在程序中使用相机示例，请参阅<a href="../s4/">下一节</a>的多面体查看器示例。还要注意，还有一个用于我的OpenGL JavaScript模拟器的相机版本；它是模拟器库<a href="../../../en/source/glsim/glsim.js">glsim/glsim.js</a>的一部分，其API几乎与Java API相同。）</p>
<p>在C中，相机由样例.c文件<a href="../../../en/source/glut/camera.c">glut/<abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>.c</a>和相应的头文件<a href="../../../en/source/glut/camera.h">glut/<abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>.h</a>定义。API的完整文档可以在头文件中找到。要使用相机，您应该在程序开头包含<code>#include "camera.h"</code>，并且在编译程序时，应该在要编译的文件列表中包含camera.c。相机依赖于GLU库和C的标准数学库，因此在编译时必须确保这些库可用。要使用相机，您应该调用</p>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="n">cameraApply</span><span class="p">();</span>
</code></pre></div>
<p>在绘制场景之前设置投影和视图变换。调用此函数会替换设置投影和视图变换的常规代码。它会将矩阵模式设置为GL_MODELVIEW。</p>
<p>API中的其余函数用于配置相机。这通常作为初始化的一部分完成，但可以随时更改配置。但是，请记住，只有在调用<code>cameraApply()</code>之后，设置才会生效。可用的函数包括：</p>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="n">cameraLookAt</span><span class="p">(</span><span class="n">eyeX</span><span class="p">,</span><span class="w"> </span><span class="n">eyeY</span><span class="p">,</span><span class="w"> </span><span class="n">eyeZ</span><span class="p">,</span><span class="w"> </span><span class="n">refX</span><span class="p">,</span><span class="w"> </span><span class="n">refY</span><span class="p">,</span><span class="w"> </span><span class="n">refZ</span><span class="p">,</span><span class="w"> </span><span class="n">upX</span><span class="p">,</span><span class="w"> </span><span class="n">upY</span><span class="p">,</span><span class="w"> </span><span class="n">upZ</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// 确定视图变换，就像gluLookAt一样</span>
<span class="w">        </span><span class="c1">// 默认为 cameraLookAt(0,0,30, 0,0,0, 0,1,0);</span>

<span class="w">    </span><span class="n">cameraSetLimits</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span><span class="w"> </span><span class="n">xmax</span><span class="p">,</span><span class="w"> </span><span class="n">ymin</span><span class="p">,</span><span class="w"> </span><span class="n">ymax</span><span class="p">,</span><span class="w"> </span><span class="n">zmin</span><span class="p">,</span><span class="w"> </span><span class="n">zmax</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// 设置视图体积的限制，其中 zmin 和 zmax 是相对于视图参考点给出的，</span>
<span class="w">        </span><span class="c1">// 而 xy 限制是在视图参考点的距离上测量的，而不是在近距离处。</span>
<span class="w">        </span><span class="c1">// 默认为 cameraSetLimits(-5,5, -5,5, -10,10);</span>

<span class="w">    </span><span class="n">cameraSetScale</span><span class="p">(</span><span class="n">limit</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// 一个方便的方法，与调用</span>
<span class="w">        </span><span class="c1">// cameraSetLimits(-limit,limit, -limit,limit, -2*limit, 2*limit);</span>
<span class="w">        </span><span class="c1">// 相同</span>

<span class="w">    </span><span class="n">cameraSetOrthographic</span><span class="p">(</span><span class="n">ortho</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// 在正交和透视投影之间切换。</span>
<span class="w">        </span><span class="c1">// 参数应为 0 表示透视，1 表示正交。默认是透视。</span>

<span class="w">    </span><span class="n">cameraSetPreserveAspect</span><span class="p">(</span><span class="n">preserve</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// 确定是否应该保持视口的宽高比。</span>
<span class="w">        </span><span class="c1">// 参数应为 0 表示忽略，1 表示保持视口的宽高比。默认是保持宽高比。</span>
</code></pre></div>
<p>在许多情况下，默认设置就足够了。特别注意<code>cameraLookAt</code>和<code>cameraSetLimits</code>如何一起设置视图和投影。<code>cameraLookAt</code>的参数表示世界坐标中的三个点。视图参考点<code>(refX, refY, refZ)</code>应该位于您想要渲染的场景中间的某个位置。<code>cameraSetLimits</code>的参数定义了一个围绕视图参考点的盒子，该盒子应该包含您想要出现在图像中的所有内容。</p>
<hr />
<p>对于Java中的JOGL，相机API被实现为一个名为<strong>Camera</strong>的类，定义在文件<a href="../../../en/source/jogl/Camera.java">jogl/Camera.java</a>中。相机适用于作为OpenGL绘图表面使用的<strong>GLPanel</strong>或<strong>GLCanvas</strong>。要使用相机，请将<strong>Camera</strong>对象创建为实例变量：</p>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="n">camera</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Camera</span><span class="p">();</span>
</code></pre></div>
<p>在绘制场景之前，调用</p>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="n">camera</span><span class="p">.</span><span class="na">apply</span><span class="p">(</span><span class="n">gl2</span><span class="p">);</span>
</code></pre></div>
<p>其中<code>gl2</code>是类型为GL2的OpenGL绘图上下文。（注意参数<code>gl2</code>的存在，在C中不是必需的；它是必需的，因为在JOGL中，OpenGL绘图上下文被实现为一个对象。）与C版本类似，这会设置视图和投影变换，并可以替换您为此目的使用的任何其他代码。用于配置相机的函数在Java中与C中相同，除了它们成为相机对象中的方法，而真/假参数</p>
<p>是布尔型而不是整数型：</p>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="n">camera</span><span class="p">.</span><span class="na">lookAt</span><span class="p">(</span><span class="n">eyeX</span><span class="p">,</span><span class="w"> </span><span class="n">eyeY</span><span class="p">,</span><span class="w"> </span><span class="n">eyeZ</span><span class="p">,</span><span class="w"> </span><span class="n">refX</span><span class="p">,</span><span class="w"> </span><span class="n">refY</span><span class="p">,</span><span class="w"> </span><span class="n">refZ</span><span class="p">,</span><span class="w"> </span><span class="n">upX</span><span class="p">,</span><span class="w"> </span><span class="n">upY</span><span class="p">,</span><span class="w"> </span><span class="n">upZ</span><span class="p">);</span>
<span class="w">    </span><span class="n">camera</span><span class="p">.</span><span class="na">setLimits</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span><span class="w"> </span><span class="n">xmax</span><span class="p">,</span><span class="w"> </span><span class="n">ymin</span><span class="p">,</span><span class="w"> </span><span class="n">ymax</span><span class="p">,</span><span class="w"> </span><span class="n">zmin</span><span class="p">,</span><span class="w"> </span><span class="n">zmax</span><span class="p">);</span>
<span class="w">    </span><span class="n">camera</span><span class="p">.</span><span class="na">setScale</span><span class="p">(</span><span class="n">limit</span><span class="p">);</span>
<span class="w">    </span><span class="n">camera</span><span class="p">.</span><span class="na">setOrthographic</span><span class="p">(</span><span class="n">ortho</span><span class="p">);</span><span class="w">    </span><span class="c1">// ortho的类型为布尔型</span>
<span class="w">    </span><span class="n">camera</span><span class="p">.</span><span class="na">setPreserveAspect</span><span class="p">(</span><span class="n">preserve</span><span class="p">);</span><span class="w"> </span><span class="c1">// preserve的类型为布尔型</span>
</code></pre></div>
<hr />
<p>相机附带了一个模拟的“轨迹球”。轨迹球允许用户通过在显示屏上单击并拖动鼠标来旋转视图。要在C中使用GLUT使用它，只需通过调用安装鼠标函数和鼠标移动函数：</p>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="n">glutMouseFunc</span><span class="p">(</span><span class="n">trackballMouseFunction</span><span class="p">);</span>
<span class="w">    </span><span class="n">glutMotionFunc</span><span class="p">(</span><span class="n">trackballMotionFunction</span><span class="p">);</span>
</code></pre></div>
<p>函数<code>trackballMouseFunction</code>和<code>trackballMotionFunction</code>作为相机API的一部分定义，并在<code>camera.h</code>中声明和记录。轨迹球通过修改与相机相关联的视图变换来工作，并且只有在调用<code>cameraApply()</code>在显示函数的开头设置视图和投影变换时才有效。要在Java中为<strong>Camera</strong>对象安装轨迹球，调用</p>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="n">camera</span><span class="p">.</span><span class="n">installTrackball</span><span class="p">(</span><span class="n">drawSurface</span><span class="p">);</span>
</code></pre></div>
<p>其中<strong>drawSurface</strong>是使用相机的组件。</p>
</div>
<div class="tabbed-block">
<p>Projection and <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> are often discussed using the analogy of a <strong><abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr></strong>. A real <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> is used to take a picture of a 3D world. For 3D graphics, it useful to imagine using a virtual <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> to do the same thing. Setting up the <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transformation is like positioning and pointing the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>. The <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> transformation determines the properties of the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>: What is its field of view, what sort of lens does it use? (Of course, the analogy breaks for <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> in at least one respect, since a real <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> doesn't do clipping in its z-direction.)</p>
<p>I have written a <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> utility to implement this idea. The <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> is meant to take over the job of setting the <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> and view. Instead of doing that by hand, you set properties of the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>. The <abbr title="Application Programming Interface. A collection of related classes, functions, constants, etc., for performing some task. An API is an &quot;interface&quot; in the sense that it can be used without understanding how its functionality is actually implemented.">API</abbr> is available for both C and Java. The two versions are somewhat different because the Java version is object-oriented. I will discuss the C implementation first. (See <a href="../s6/">Section 3.6</a> for basic information about programming <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> in C and Java. For an example of using a <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> in a program, see the <abbr title="A closed 3D figure whose faces, or sides, are polygons. Usually, it is assumed that the faces of a polyhedron do not intersect, except along their edges.">polyhedron</abbr> viewer example in the <a href="../s4/">next section</a>. Note also that there is a version of the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> for use with my <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> simulator for <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr>; it is part of the simulator library <a href="../../../en/source/glsim/glsim.js">glsim/glsim.js</a> and has an <abbr title="Application Programming Interface. A collection of related classes, functions, constants, etc., for performing some task. An API is an &quot;interface&quot; in the sense that it can be used without understanding how its functionality is actually implemented.">API</abbr> almost identical to the Java <abbr title="Application Programming Interface. A collection of related classes, functions, constants, etc., for performing some task. An API is an &quot;interface&quot; in the sense that it can be used without understanding how its functionality is actually implemented.">API</abbr>.)</p>
<p>In C, the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> is defined by the sample .c file, <a href="../../../en/source/glut/camera.c">glut/<abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>.c</a> and a corresponding header file, <a href="../../../en/source/glut/camera.h">glut/<abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>.h</a>. Full documentation for the <abbr title="Application Programming Interface. A collection of related classes, functions, constants, etc., for performing some task. An API is an &quot;interface&quot; in the sense that it can be used without understanding how its functionality is actually implemented.">API</abbr> can be found in the header file. To use the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>, you should #include "<abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>.h" at the start of your program, and when you compile the program, you should include <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>.c in the list of files that you want to compile. The <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> depends on the <abbr title="The OpenGL Utility library. Defines several functions for use with older versions of OpenGL, including gluPerspective and gluLookAt. Not to be confused with GLUT. GLU is a standard part of OpenGL.">GLU</abbr> library and on C's standard math library, so you have to make sure that those libraries are available when it is compiled. To use the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>, you should call</p>
<div class="highlight"><pre><span></span><code><span class="n">cameraApply</span><span class="p">();</span>
</code></pre></div>
<p>to set up the <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> and <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transform before drawing the scene. Calling this function replaces the usual code for setting up the <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> and <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transformations. It leaves the <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> mode set to GL_MODELVIEW.</p>
<p>The remaining functions in the <abbr title="Application Programming Interface. A collection of related classes, functions, constants, etc., for performing some task. An API is an &quot;interface&quot; in the sense that it can be used without understanding how its functionality is actually implemented.">API</abbr> are used to configure the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>. This would usually be done as part of initialization, but it is possible to change the configuration at any time. However, remember that the settings are not used until you call cameraApply(). Available functions include:</p>
<div class="highlight"><pre><span></span><code><span class="n">cameraLookAt</span><span class="p">(</span><span class="w"> </span><span class="n">eyeX</span><span class="p">,</span><span class="n">eyeY</span><span class="p">,</span><span class="n">eyeZ</span><span class="p">,</span><span class="w"> </span><span class="n">refX</span><span class="p">,</span><span class="n">refY</span><span class="p">,</span><span class="n">refZ</span><span class="p">,</span><span class="w"> </span><span class="n">upX</span><span class="p">,</span><span class="n">upY</span><span class="p">,</span><span class="n">upZ</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Determines the viewing transform, just like gluLookAt</span>
<span class="w">    </span><span class="c1">// Default is cameraLookAt( 0,0,30, 0,0,0, 0,1,0 );</span>

<span class="n">cameraSetLimits</span><span class="p">(</span><span class="w"> </span><span class="n">xmin</span><span class="p">,</span><span class="w"> </span><span class="n">xmax</span><span class="p">,</span><span class="w"> </span><span class="n">ymin</span><span class="p">,</span><span class="w"> </span><span class="n">ymax</span><span class="p">,</span><span class="w"> </span><span class="n">zmin</span><span class="p">,</span><span class="w"> </span><span class="n">zmax</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Sets the limits on the view volume, where zmin and zmax are</span>
<span class="w">    </span><span class="c1">// given with respect to the view reference point, NOT the eye,</span>
<span class="w">    </span><span class="c1">// and the xy limits are measured at the distance of the</span>
<span class="w">    </span><span class="c1">// view reference point, NOT the near distance.</span>
<span class="w">    </span><span class="c1">// Default is cameraSetLimits( -5,5, -5,5, -10,10 );</span>

<span class="n">cameraSetScale</span><span class="p">(</span><span class="w"> </span><span class="n">limit</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="c1">// a convenience method, which is the same as calling</span>
<span class="w">    </span><span class="c1">// cameraSetLimits( -limit,limit, -limit,limit, -2*limit, 2*limit );</span>

<span class="n">cameraSetOrthographic</span><span class="p">(</span><span class="w"> </span><span class="n">ortho</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Switch between orthographic and perspective projection.</span>
<span class="w">    </span><span class="c1">// The parameter should be 0 for perspective, 1 for</span>
<span class="w">    </span><span class="c1">// orthographic.  The default is perspective.</span>

<span class="n">cameraSetPreserveAspect</span><span class="p">(</span><span class="w"> </span><span class="n">preserve</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Determine whether the aspect ratio of the viewport should</span>
<span class="w">    </span><span class="c1">// be respected.  The parameter should be 0 to ignore and</span>
<span class="w">    </span><span class="c1">// 1 to respect the viewport aspect ratio.  The default</span>
<span class="w">    </span><span class="c1">// is to preserve the aspect ratio.</span>
</code></pre></div>
<p>In many cases, the default settings are sufficient. Note in particular how <em>cameraLookAt</em> and <em>cameraSetLimits</em> work together to set up the view and <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr>. The parameters to cameraLookAt represent three points in <abbr title="The coordinate system in which a scene is defined. The image that is produced of the scene will show the contents of the world coordinate system that lie within some view volume (for 3D) or view window (for 2D). Objects are defined in their own object coordinate system. Modeling transformations are then applied to place objects into the scene; that is, they transform object coordinates to world coordinates.">world coordinates</abbr>. The view reference point, (refX,refY,refZ), should be somewhere in the middle of the scene that you want to render. The parameters to <em>cameraSetLimits</em> define a box about that view reference point that should contain everything that you want to appear in the image.</p>
<hr />
<p>For use with <abbr title="A Java implementation of OpenGL. JOGL is very complicated, since it attempts to support all versions of OpenGL in one programming system. JOGL integrates seamlessly with Java's Swing and AWT graphics.">JOGL</abbr> in Java, the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> <abbr title="Application Programming Interface. A collection of related classes, functions, constants, etc., for performing some task. An API is an &quot;interface&quot; in the sense that it can be used without understanding how its functionality is actually implemented.">API</abbr> is implemented as a class named <strong>Camera</strong>, defined in the file <a href="../../../en/source/jogl/Camera.java">jogl/Camera.java</a>. The <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> is meant for use with a <strong>GLPanel</strong> or <strong>GLCanvas</strong> that is being used as an <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> drawing surface. To use a <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>, create an object of type <strong>Camera</strong> as an instance variable:</p>
<p><abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> = new Camera();
Before drawing the scene, call</p>
<div class="highlight"><pre><span></span><code><span class="n">camera</span><span class="p">.</span><span class="n">apply</span><span class="p">(</span><span class="n">gl2</span><span class="p">);</span>
</code></pre></div>
<p>where gl2 is the <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> drawing context of type GL2. (Note the presence of the parameter gl2, which was not necessary in C; it is required because the <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> drawing context in <abbr title="A Java implementation of OpenGL. JOGL is very complicated, since it attempts to support all versions of OpenGL in one programming system. JOGL integrates seamlessly with Java's Swing and AWT graphics.">JOGL</abbr> is implemented as an object.) As in the C version, this sets the <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> and <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> transformations and can replace any other code that you would use for that purpose. The functions for configuring the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> are the same in Java as in C, except that they become methods in the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> object, and true/false parameters are boolean instead of int:</p>
<div class="highlight"><pre><span></span><code><span class="n">camera</span><span class="p">.</span><span class="n">lookAt</span><span class="p">(</span><span class="w"> </span><span class="n">eyeX</span><span class="p">,</span><span class="n">eyeY</span><span class="p">,</span><span class="n">eyeZ</span><span class="p">,</span><span class="w"> </span><span class="n">refX</span><span class="p">,</span><span class="n">refY</span><span class="p">,</span><span class="n">refZ</span><span class="p">,</span><span class="w"> </span><span class="n">upX</span><span class="p">,</span><span class="n">upY</span><span class="p">,</span><span class="n">upZ</span><span class="w"> </span><span class="p">);</span>
<span class="n">camera</span><span class="p">.</span><span class="n">setLimits</span><span class="p">(</span><span class="w"> </span><span class="n">xmin</span><span class="p">,</span><span class="n">xmax</span><span class="p">,</span><span class="w"> </span><span class="n">ymin</span><span class="p">,</span><span class="n">ymax</span><span class="p">,</span><span class="w"> </span><span class="n">zmin</span><span class="p">,</span><span class="n">zmax</span><span class="w"> </span><span class="p">);</span>
<span class="n">camera</span><span class="p">.</span><span class="n">setScale</span><span class="p">(</span><span class="w"> </span><span class="n">limit</span><span class="w"> </span><span class="p">);</span>
<span class="n">camera</span><span class="p">.</span><span class="n">setOrthographic</span><span class="p">(</span><span class="w"> </span><span class="n">ortho</span><span class="w"> </span><span class="p">);</span><span class="w">    </span><span class="c1">// ortho is of type boolean</span>
<span class="n">camera</span><span class="p">.</span><span class="n">setPreserveAspect</span><span class="p">(</span><span class="w"> </span><span class="n">preserve</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// preserve is of type boolean</span>
</code></pre></div>
<hr />
<p>The <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> comes with a simulated "trackball." The trackball allows the user to rotate the view by clicking and dragging the mouse on the display. To use it with <abbr title="The OpenGL Utility Toolkit. A platform-independent library for writing OpenGL applications. OpenGL does not include support for windows or events. GLUT adds such support. It also has functions for drawing 3D shapes such as spheres and polyhedra (not to mention a teapot). GLUT is written in the C programming language and is used with the C API for OpenGL. However, many GLUT functions are also available in JOGL, the Java API for OpenGL. A newer, and somewhat improved, version of the toolkit named &quot;FreeGLUT&quot; is commonly used in place of the original version.">GLUT</abbr> in C, you just need to install a mouse function and a mouse motion function by calling</p>
<div class="highlight"><pre><span></span><code><span class="n">glutMouseFunc</span><span class="p">(</span><span class="w"> </span><span class="n">trackballMouseFunction</span><span class="w"> </span><span class="p">);</span>
<span class="n">glutMotionFunc</span><span class="p">(</span><span class="w"> </span><span class="n">trackballMotionFunction</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>The functions trackballMouseFunction and trackballMotionFunction are defined as part of the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> <abbr title="Application Programming Interface. A collection of related classes, functions, constants, etc., for performing some task. An API is an &quot;interface&quot; in the sense that it can be used without understanding how its functionality is actually implemented.">API</abbr> and are declared and documented in <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>.h. The trackball works by modifying the <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transformation associated with the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>, and it only works if cameraApply() is called at the beginning of the display function to set the <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> and <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> transformations. To install a trackball for use with a <strong>Camera</strong> object in <abbr title="A Java implementation of OpenGL. JOGL is very complicated, since it attempts to support all versions of OpenGL in one programming system. JOGL integrates seamlessly with Java's Swing and AWT graphics.">JOGL</abbr>, call</p>
<div class="highlight"><pre><span></span><code><span class="n">camera</span><span class="p">.</span><span class="n">installTrackball</span><span class="p">(</span><span class="n">drawSurface</span><span class="p">);</span>
</code></pre></div>
<p>where <strong>drawSurface</strong> is the component on which the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> is used.</p>
</div>
</div>
</div>







  
    
  
  
    
  


  <aside class="md-source-file">
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="最后更新">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1-2.1-2M12.5 7v5.2l4 2.4-1 1L11 13V7h1.5M11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2v1.8Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">2024年5月25日</span>
  </span>

    
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="创建日期">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.47 15.08 11 13V7h1.5v5.25l3.08 1.83c-.41.28-.79.62-1.11 1m-1.39 4.84c-.36.05-.71.08-1.08.08-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8c0 .37-.03.72-.08 1.08.69.1 1.33.32 1.92.64.1-.56.16-1.13.16-1.72 0-5.5-4.5-10-10-10S2 6.5 2 12s4.47 10 10 10c.59 0 1.16-.06 1.72-.16-.32-.59-.54-1.23-.64-1.92M18 15v3h-3v2h3v3h2v-3h3v-2h-3v-3h-2Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">2024年5月25日</span>
  </span>

    
    
    
  </aside>





                
              </article>
            </div>
          
          
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var tab,labels=set.querySelector(".tabbed-labels");for(tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script>

<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../../..", "features": ["content.code.copy", "content.tabs.link", "navigation.tabs", "navigation.tabs.sticky", "navigation.indexes", "navigation.top", "toc.follow", "content.tooltips"], "search": "../../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.3220b9d7.min.js"></script>
      
        <script src="../../../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="https://unpkg.com/mermaid@9.4.0/dist/mermaid.min.js"></script>
      
    
  <script>document$.subscribe(() => {const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});})</script></body>
</html>