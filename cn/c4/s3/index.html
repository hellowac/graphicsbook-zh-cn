
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="计算机图形学概论(graphicsbook)">
      
      
      
        <link rel="canonical" href="https://hellowac.github.io/graphicsbook-zh-cn/cn/c4/s3/">
      
      
        <link rel="prev" href="../s2/">
      
      
        <link rel="next" href="../s4/">
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.5.18">
    
    
      
        <title>4.3 图像纹理 - 计算机图形学概论</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.66ac8b77.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.06af60db.min.css">
      
      

  
  
  
  
  <style>:root{--md-annotation-icon:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M22 12a10 10 0 0 1-10 10A10 10 0 0 1 2 12 10 10 0 0 1 12 2a10 10 0 0 1 10 10M6 13h8l-3.5 3.5 1.42 1.42L17.84 12l-5.92-5.92L10.5 7.5 14 11H6v2Z"/></svg>');}</style>


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
   <link href="../../../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
        html.glightbox-open { overflow: initial; height: 100%; }
        .gslide-title { margin-top: 0px; user-select: text; }
        .gslide-desc { color: #666; user-select: text; }
        .gslide-image img { background: white; }
        
            .gscrollbar-fixer { padding-right: 15px; }
            .gdesc-inner { font-size: 0.75rem; }
            body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
            body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
            body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}
            </style> <script src="../../../assets/javascripts/glightbox.min.js"></script></head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="default" data-md-color-accent="red">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#43-图像纹理" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="计算机图形学概论" class="md-header__button md-logo" aria-label="计算机图形学概论" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            计算机图形学概论
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              4.3 图像纹理
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
      <div class="md-header__option">
  <div class="md-select">
    
    <button class="md-header__button md-icon" aria-label="选择当前语言">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m12.87 15.07-2.54-2.51.03-.03A17.52 17.52 0 0 0 14.07 6H17V4h-7V2H8v2H1v2h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04M18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12m-2.62 7 1.62-4.33L19.12 17h-3.24Z"/></svg>
    </button>
    <div class="md-select__inner">
      <ul class="md-select__list">
        
          <li class="md-select__item">
            <a href="/graphicsbook-zh-cn/en/" hreflang="en" class="md-select__link">
              English
            </a>
          </li>
        
          <li class="md-select__item">
            <a href="/graphicsbook-zh-cn/cn/" hreflang="cn" class="md-select__link">
              中文
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</div>
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/hellowac/graphicsbook-zh-cn" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    graphicsbook
  </div>
</a>
      </div>
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../" class="md-tabs__link">
        
  
    
  
  首页

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../preface/" class="md-tabs__link">
        
  
    
  
  前言

      </a>
    </li>
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c1/" class="md-tabs__link">
          
  
    
  
  1.简介

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c2/" class="md-tabs__link">
          
  
    
  
  2.二维图形

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c3/" class="md-tabs__link">
          
  
    
  
  3.几何

        </a>
      </li>
    
  

      
        
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../" class="md-tabs__link">
          
  
    
  
  4.灯光和材质

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c5/" class="md-tabs__link">
          
  
    
  
  5.three.js

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c6/" class="md-tabs__link">
          
  
    
  
  6.WebGL

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c7/" class="md-tabs__link">
          
  
    
  
  7.WebGL 3D

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c8/" class="md-tabs__link">
          
  
    
  
  8.高阶3D

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c9/" class="md-tabs__link">
          
  
    
  
  9.WEBGPU

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../a1/" class="md-tabs__link">
          
  
    
  
  附录

        </a>
      </li>
    
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../.." class="md-tabs__link">
        
  
    
  
  关于

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="计算机图形学概论" class="md-nav__button md-logo" aria-label="计算机图形学概论" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    计算机图形学概论
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/hellowac/graphicsbook-zh-cn" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    graphicsbook
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    首页
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../preface/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    前言
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c1/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    1.简介
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_3" id="__nav_3_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            1.简介
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 1 节 绘画与绘图
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 2 节：三维(3D)图形的要素
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 3 节：硬件与软件
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c2/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    2.二维图形
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_4" id="__nav_4_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            2.二维图形
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第1节: 像素、坐标和颜色
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第2节: 形状
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第3节: 变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第4节: 分层建模
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第5节: Java 绘制2D
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第6节: HTML Canvas图形
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第7节: SVG：一种场景描述语言
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c3/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    3.几何
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_5" id="__nav_5_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            3.几何
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.1 OpenGL 1.1 中的形状和颜色
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.2 3D 坐标和变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.3 投影与观看
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.4 多边形网格和 glDrawArrays
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.5 部分线性代数基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.6 使用 GLUT 和 JOGL
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" checked>
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    4.灯光和材质
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_6" id="__nav_6_label" tabindex="">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_6">
            <span class="md-nav__icon md-icon"></span>
            4.灯光和材质
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.1 照明简介
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.2 OpenGL 1.1 中的光和材质
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    4.3 图像纹理
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    4.3 图像纹理
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#431-纹理坐标" class="md-nav__link">
    <span class="md-ellipsis">
      4.3.1 纹理坐标
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#432-mipmap-和过滤" class="md-nav__link">
    <span class="md-ellipsis">
      4.3.2 MipMap 和过滤
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#433-纹理目标和纹理参数" class="md-nav__link">
    <span class="md-ellipsis">
      4.3.3 纹理目标和纹理参数
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#434-纹理变换" class="md-nav__link">
    <span class="md-ellipsis">
      4.3.4 纹理变换
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#435-从内存加载纹理" class="md-nav__link">
    <span class="md-ellipsis">
      4.3.5 从内存加载纹理
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#436-来自颜色缓冲区的纹理" class="md-nav__link">
    <span class="md-ellipsis">
      4.3.6 来自颜色缓冲区的纹理
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#437-纹理对象" class="md-nav__link">
    <span class="md-ellipsis">
      4.3.7 纹理对象
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#438-在-c-中加载纹理" class="md-nav__link">
    <span class="md-ellipsis">
      4.3.8 在 C 中加载纹理
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#439-通过-jogl-使用纹理" class="md-nav__link">
    <span class="md-ellipsis">
      4.3.9 通过 JOGL 使用纹理
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.4 灯光、相机、动作
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c5/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    5.three.js
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_7" id="__nav_7_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7">
            <span class="md-nav__icon md-icon"></span>
            5.three.js
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.1 Three.js 基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.2 构建对象
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.3 其他功能
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c6/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    6.WebGL
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_8" id="__nav_8_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8">
            <span class="md-nav__icon md-icon"></span>
            6.WebGL
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.1 可编程流水线
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.2 第一个例子
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.3 GLSL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.4 图像纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.5 实现 2D 变换
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c7/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    7.WebGL 3D
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_9" id="__nav_9_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9">
            <span class="md-nav__icon md-icon"></span>
            7.WebGL 3D
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.1 3D变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.2 照明和材质
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.3 纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.4 帧缓冲区
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.5 WebGL 扩展
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c8/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    8.高阶3D
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_10" id="__nav_10_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_10_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10">
            <span class="md-nav__icon md-icon"></span>
            8.高阶3D
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c8/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8.1 光线追踪
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c8/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8.2 路径追踪
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_11" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c9/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    9.WEBGPU
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_11" id="__nav_11_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_11_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_11">
            <span class="md-nav__icon md-icon"></span>
            9.WEBGPU
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.1 WebGPU 基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.2 实例和索引
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.3 WGSL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.4 WebGPU 中的 3D 图形
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.5 纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.6 计算着色器
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.7 细节
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_12" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../a1/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    附录
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_12" id="__nav_12_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_12_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_12">
            <span class="md-nav__icon md-icon"></span>
            附录
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a2/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Blender 3D建模
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a3/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Gimp和Inkscape
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../source/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    示例程序源代码
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../glossary/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    术语表
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    关于
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#431-纹理坐标" class="md-nav__link">
    <span class="md-ellipsis">
      4.3.1 纹理坐标
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#432-mipmap-和过滤" class="md-nav__link">
    <span class="md-ellipsis">
      4.3.2 MipMap 和过滤
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#433-纹理目标和纹理参数" class="md-nav__link">
    <span class="md-ellipsis">
      4.3.3 纹理目标和纹理参数
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#434-纹理变换" class="md-nav__link">
    <span class="md-ellipsis">
      4.3.4 纹理变换
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#435-从内存加载纹理" class="md-nav__link">
    <span class="md-ellipsis">
      4.3.5 从内存加载纹理
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#436-来自颜色缓冲区的纹理" class="md-nav__link">
    <span class="md-ellipsis">
      4.3.6 来自颜色缓冲区的纹理
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#437-纹理对象" class="md-nav__link">
    <span class="md-ellipsis">
      4.3.7 纹理对象
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#438-在-c-中加载纹理" class="md-nav__link">
    <span class="md-ellipsis">
      4.3.8 在 C 中加载纹理
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#439-通过-jogl-使用纹理" class="md-nav__link">
    <span class="md-ellipsis">
      4.3.9 通过 JOGL 使用纹理
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="43-图像纹理">4.3 <abbr title="应用于表面的图像，看起来就像是“画”在表面上。">图像纹理</abbr><a class="headerlink" href="#43-图像纹理" title="Permanent link">&para;</a></h1>
<p><strong>Image Textures</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="1:2"><input checked="checked" id="__tabbed_1_1" name="__tabbed_1" type="radio" /><input id="__tabbed_1_2" name="__tabbed_1" type="radio" /><div class="tabbed-labels"><label for="__tabbed_1_1">中文</label><label for="__tabbed_1_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>统一颜色的3D对象看起来足够好，但它们有点单调。它们的统一颜色没有像砖墙或格子沙发那样的视觉吸引力。通过在表面添加<strong><abbr title="物体上某一点到另一点在某些属性上的变化。最常见的类型是图像纹理。当图像纹理应用于表面时，表面颜色会因点而异。">纹理</abbr></strong>，可以使三维对象看起来更有趣、更逼真。一般来说，纹理是在单个原素内部像素与像素之间的变化。我们只考虑一种纹理：<strong><abbr title="应用于表面的图像，看起来就像是“画”在表面上。">图像纹理</abbr></strong>。图像纹理可以应用于表面，使表面的色泽从点到点变化，有点像将图像复制到表面上。以下是展示了六个具有不同图像纹理的对象的图片：</p>
<p><a class="glightbox" href="../../../en/c4/TextureDemo.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="TextureDemo" src="../../../en/c4/TextureDemo.png" /></a></p>
<p>（地球地形图像，由 <a href="http://maps.jpl.nasa.gov/">NASA/JPL-Caltech</a> 提供。砖块和金属是免费纹理（从已不存在的网站下载）。地球夜景图像拍摄自 <a href="http://apod.nasa.gov/apod/ap001127.html">每日天文图片</a> 网站；它也是 NASA/JPL 的图像。可以在网站下载源文件夹中的 jogl 或 glut 文件夹内的 <a href="../../../en/source/glut/textures">textures</a> 文件夹中找到图像副本。本书中的几个示例将使用该文件夹中的图像。）</p>
<p>纹理可能是 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 最复杂的部分，并且它们是自 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1 以来一直存在并变得更加复杂的部分，因为它们对于有效创建逼真图像至关重要。本节只涵盖了 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1 <abbr title="物体上某一点到另一点在某些属性上的变化。最常见的类型是图像纹理。当图像纹理应用于表面时，表面颜色会因点而异。">纹理</abbr> <abbr title="Application Programming Interface. A collection of related classes, functions, constants, etc., for performing some task. An API is an &quot;interface&quot; in the sense that it can be used without understanding how its functionality is actually implemented.">API</abbr> 的部分内容。我们将在后续章节中看到更多的纹理。</p>
<p>请注意，用作纹理的图像应具有为二的幂的宽度和高度，例如 128、256 或 512。这是 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1 的要求。在某些版本中放宽了这一要求，但使用<strong><abbr title="宽度和高度都是二的幂的纹理图像。在一些图形系统中，这是用作纹理图像的要求。">二的幂纹理</abbr></strong>仍然是一个好主意。本节讨论的一些事情如果不使用二的幂纹理，即使在现代系统中也不会起作用。</p>
<p>当图像纹理应用于表面时，默认行为是将表面的像素的 RGBA 颜色分量与图像中的颜色分量相乘。如果启用了照明，表面颜色将被照明效果修改，然后与纹理颜色相乘。通常使用白色作为表面颜色。如果表面使用不同的颜色，它将为纹理图像的颜色添加一种“色彩倾向”。</p>
</div>
<div class="tabbed-block">
<p>Uniformly colored 3D objects look nice enough, but they are a little bland. Their uniform colors don't have the visual appeal of, say, a brick wall or a plaid couch. Three-dimensional objects can be made to look more interesting and more realistic by adding a <strong><abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr></strong> to their surfaces. A <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>, in general, is some sort of variation from <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> to <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> within a single primitive. We will consider only one kind of <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>: <strong>image textures</strong>. An <abbr title="An image that is applied to a surface as a texture, so that it looks at if the image is &quot;painted&quot; onto the surface.">image texture</abbr> can be applied to a surface to make the color of the surface vary from point to point, something like painting a copy of the image onto the surface. Here is a picture that shows six objects with various image textures:</p>
<p><a class="glightbox" href="../../../en/c4/TextureDemo.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c4/TextureDemo.png" /></a></p>
<p>(Topographical Earth image, courtesy <a href="http://maps.jpl.nasa.gov/">NASA/JPL-Caltech</a>. The brick and <abbr title="苹果的专有API，用于MacOS计算机和iOS设备上的3D图形和计算。">metal</abbr> are free textures (which were downloaded from a web site that no longer exists). EarthAtNight image taken from the <a href="http://apod.nasa.gov/apod/ap001127.html">Astronomy Picture of the Day</a> web site; it is also a NASA/JPL image. Copies of the images can be found in the folder named <a href="../../../en/source/glut/textures">textures</a> in either the jogl or glut folder inside the source folder of the web site download. Images from that folder will be used in several examples in this book.)</p>
<p>Textures might be the most complicated part of <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr>, and they are a part that has survived, and become more complicated, in the most modern versions since they are so vital for the efficient creation of realistic images. This section covers only part of the <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1 <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> <abbr title="Application Programming Interface. A collection of related classes, functions, constants, etc., for performing some task. An API is an &quot;interface&quot; in the sense that it can be used without understanding how its functionality is actually implemented.">API</abbr>. We will see more of textures in later chapters.</p>
<p>Note that an image that is used as a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> should have a width and a height that are powers of two, such as 128, 256, or 512. This is a requirement in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1. The requirement is relaxed in some versions, but it's still a good idea to use <strong>power-of-two textures</strong> Some of the things discussed in this section will not work with non-power-of-two textures, even on modern systems.</p>
<p>When an <abbr title="An image that is applied to a surface as a texture, so that it looks at if the image is &quot;painted&quot; onto the surface.">image texture</abbr> is applied to a surface, the default behavior is to multiply the <abbr title="An RGB color—specified by red, green, and blue component values—together with an alpha component. The alpha component is most often take to specify the degree of transparency of the color, with a maximal alpha value giving a fully opaque color.">RGBA color</abbr> components of <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr> on the surface by the color components from the image. The surface color will be modified by light effects, if <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> is turned on, before it is multiplied by the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> color. It is common to use white as the surface color. If a different color is used on the surface, it will add a "tint" to the color from the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image.</p>
</div>
</div>
</div>
<h2 id="431-纹理坐标">4.3.1 <abbr title="指应用于纹理图像的二维坐标系统，或用于1D和3D纹理的类似坐标系统。纹理坐标通常在垂直和水平方向上都从0到1变化，其中(0,0)位于图像的左下角。该术语还指赋予表面的坐标，用于指定如何将纹理图像映射到表面上。">纹理坐标</abbr><a class="headerlink" href="#431-纹理坐标" title="Permanent link">&para;</a></h2>
<p><strong>Texture Coordinates</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="2:2"><input checked="checked" id="__tabbed_2_1" name="__tabbed_2" type="radio" /><input id="__tabbed_2_2" name="__tabbed_2" type="radio" /><div class="tabbed-labels"><label for="__tabbed_2_1">中文</label><label for="__tabbed_2_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>当一个纹理应用于表面时，表面上的每个点必须对应于纹理中的一个点。必须有一种方法来确定如何计算这种映射。为此，对象需要<strong><abbr title="指应用于纹理图像的二维坐标系统，或用于1D和3D纹理的类似坐标系统。纹理坐标通常在垂直和水平方向上都从0到1变化，其中(0,0)位于图像的左下角。该术语还指赋予表面的坐标，用于指定如何将纹理图像映射到表面上。">纹理坐标</abbr></strong>。正如在 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 中通常的情况一样，为一个原素的每个顶点指定<strong><abbr title="指应用于纹理图像的二维坐标系统，或用于1D和3D纹理的类似坐标系统。纹理坐标通常在垂直和水平方向上都从0到1变化，其中(0,0)位于图像的左下角。该术语还指赋予表面的坐标，用于指定如何将纹理图像映射到表面上。">纹理坐标</abbr></strong>。原素内部点的纹理坐标通过插值顶点的值来计算。</p>
<p>纹理图像带有它自己的二维坐标系统。传统上，s 用于图像的水平坐标，t 用于垂直坐标。s 坐标是一个实数，从图像左侧的 0 到右侧的 1，而 t 从底部的 0 到顶部的 1。s 或 t 的值在 0 到 1 范围之外不处于图像内部，但这样的值作为纹理坐标仍然有效。请注意，纹理坐标不是基于像素的。无论图像大小如何，s 和 t 的值在 0 和 1 之间覆盖整个图像。</p>
<p>要绘制一个带纹理的原素，我们需要为每个顶点提供一对数字 (s,t)。这些是该顶点的纹理坐标。它们指示图像中的哪个点映射到顶点。例如，假设我们想要将 EarthAtNight 图像的一部分应用于一个三角形原素。假设将要映射到原素的图像区域是这里用粗橙色轮廓显示的三角形：</p>
<p><a class="glightbox" href="../../../en/c4/texCoords.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="TexCoords" src="../../../en/c4/texCoords.png" /></a></p>
<p>这个区域的顶点具有 (s,t) <abbr title="一种将数值坐标分配给几何点的方法。在二维中，每个点对应一对数字。在三维中，每个点对应一组三个数字。">坐标</abbr> (0.3,0.1)，(0.45,0.6) 和 (0.25,0.7)。这些来自图像的坐标应该用作三角形原素顶点的纹理坐标。</p>
<p>顶点的纹理坐标是顶点的属性，就像颜色、法向量和材质属性一样。纹理坐标由 <em>glTexCoord</em><em> 系列函数指定，包括函数 </em>glTexCoord2f(s,t)<em>，</em>glTexCoord2d(s,t)<em>，</em>glTexCoord2fv(array)<em> 和 </em>glTexCoord2dv(array)<em>。<abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 状态包括由这些函数指定的当前纹理坐标集。当您使用 </em>glVertex<strong> 指定一个顶点时，当前纹理坐标被复制并成为一个与顶点关联的属性。像往常一样，这意味着顶点的纹理坐标必须在调用 *glVertex</strong> 之前指定。一个原素的每个顶点都需要不同的纹理坐标集。</p>
<p>例如，要将上图中的三角形区域应用于 xy 平面上顶点位于 (0,0)，(0,1) 和 (1,0) 的三角形，我们可以这样写：</p>
<div class="highlight"><pre><span></span><code><span class="n">glNormal3d</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span><span class="w">       </span><span class="c1">// 这个法向适用于所有三个顶点。</span>
<span class="n">glBegin</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">);</span>
<span class="n">glTexCoord2d</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span><span class="mf">0.1</span><span class="p">);</span><span class="w">   </span><span class="c1">// 顶点 (0,0) 的纹理坐标</span>
<span class="n">glVertex2d</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="n">glTexCoord2d</span><span class="p">(</span><span class="mf">0.45</span><span class="p">,</span><span class="mf">0.6</span><span class="p">);</span><span class="w">  </span><span class="c1">// 顶点 (0,1) 的纹理坐标</span>
<span class="n">glVertex2d</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">glTexCoord2d</span><span class="p">(</span><span class="mf">0.25</span><span class="p">,</span><span class="mf">0.7</span><span class="p">);</span><span class="w">  </span><span class="c1">// 顶点 (1,0) 的纹理坐标</span>
<span class="n">glVertex2d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="n">glEnd</span><span class="p">();</span>
</code></pre></div>
<p>请注意，顶点的 (x,y) <abbr title="一种将数值坐标分配给几何点的方法。在二维中，每个点对应一对数字。在三维中，每个点对应一组三个数字。">坐标</abbr>（给出其在空间中的位置）与顶点关联的 (s,t) 纹理坐标之间没有特定的关系。事实上，在这种情况下，我绘制的三角形与图像中的三角形区域形状不同，那部分图像将不得不被拉伸和扭曲以适应。在大多数纹理图像的使用中都会发生这种扭曲。</p>
<p>有时，很难决定使用什么纹理坐标。一个容易决定的案例是将完整纹理应用于矩形。以下是一个代码片段，它绘制 xy 平面上的一个正方形，带有适当的纹理坐标，将整个图像映射到正方形上：</p>
<div class="highlight"><pre><span></span><code><span class="n">glBegin</span><span class="p">(</span><span class="n">GL_TRIANGLE_FAN</span><span class="p">);</span>
<span class="n">glNormal3f</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">glTexCoord2d</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="w">     </span><span class="c1">// 左下角的纹理坐标</span>
<span class="n">glVertex2d</span><span class="p">(</span><span class="mf">-0.5</span><span class="p">,</span><span class="mf">-0.5</span><span class="p">);</span>
<span class="n">glTexCoord2d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="w">     </span><span class="c1">// 右下角的纹理坐标</span>
<span class="n">glVertex2d</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">-0.5</span><span class="p">);</span>
<span class="n">glTexCoord2d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span><span class="w">     </span><span class="c1">// 右上角的纹理坐标</span>
<span class="n">glVertex2d</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">);</span>
<span class="n">glTexCoord2d</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span><span class="w">     </span><span class="c1">// 左上角的纹理坐标</span>
<span class="n">glVertex2d</span><span class="p">(</span><span class="mf">-0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">);</span>
<span class="n">glEnd</span><span class="p">();</span>
</code></pre></div>
<p>遗憾的是，<abbr title="OpenGL实用工具包。用于编写OpenGL应用程序的跨平台库。OpenGL本身不包含对窗口或事件的支持。GLUT添加了这样的支持。它还具有用于绘制3D形状（如球体和多面体，更不用说茶壶了）的函数。GLUT用C语言编写，并与OpenGL的C API一起使用。然而，许多GLUT函数也在JOGL中可用，它是OpenGL的Java API。一种较新且稍有改进的工具包版本名为“FreeGLUT”，通常用于取代原始版本。">GLUT</abbr> 库中的标准形状没有附带纹理坐标（茶壶除外）。我编写了一组函数，用于绘制带有纹理坐标的类似形状。这些函数可以在 <abbr title="OpenGL的Java实现。JOGL非常复杂，因为它试图在一个编程系统中支持所有版本的OpenGL。JOGL与Java的Swing和AWT图形无缝集成。">JOGL</abbr> 的 <a href="../../../en/source/jogl/TexturedShapes.java">jogl/TexturedShapes.java</a> 或 C 的 <a href="../../../en/source/glut/textured-shapes.c">glut/textured-shapes.c</a>（以及相应的头文件 <a href="../../../en/source/glut/textured-shapes.h">glut/textured-shapes.h</a>）中找到。当然，将纹理应用于给定对象有很多方法。如果您使用我的函数，您将受限于我关于如何做到这一点的决定。</p>
<p>示例程序 <a href="../../../en/source/jogl/TextureDemo.java">jogl/TextureDemo.java</a> 或 <a href="../../../en/source/glut/texture-demo.c">glut/<abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>-demo.c</a> 让您可以在我的带纹理形状上查看几种不同的纹理图像。</p>
<p>最后一个问题：如果您提供不在 0 到 1 范围内的纹理坐标会发生什么？结果表明这样的值是合法的。默认情况下，在 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1 中，它们的行为就好像整个 st 平面充满了图像的副本。例如，如果一个正方形的纹理坐标在两个方向上都从 0 到 3，而不是 0 到 1，那么您将在正方形上得到图像的九个副本（水平三个副本乘以垂直三个副本）。</p>
<hr />
<p>要使用 glDrawArrays 或 glDrawElements 绘制带纹理的原素，您需要在顶点数组中提供纹理坐标，就像您提供顶点坐标、颜色和法向量一样。（见 <a href="../../c3/s4/#342-gldrawarrays和gldrawelements">小节3.4.2</a>。）细节是类似的：您必须通过调用</p>
<div class="highlight"><pre><span></span><code><span class="n">glEnableClientState</span><span class="p">(</span><span class="n">GL_TEXTURE_COORD_ARRAY</span><span class="p">);</span>
</code></pre></div>
<p>启用使用纹理坐标数组，并使用函数</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="n">glTexCoordPointer</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">dataType</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">stride</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">array</span><span class="p">)</span>
</code></pre></div>
<p>告诉 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 数据的位置。对我们来说，size 总是 2。（<abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 还允许 3 或 4 个纹理坐标，但我们用不到它们。）dataType 可以是 GL_FLOAT、GL_DOUBLE 或 GL_INT。stride 通常是零，表示数组中的纹理坐标之间没有额外的数据。最后一个参数是数组或指向数据的指针，必须是 dataType 指示的类型。在 <abbr title="OpenGL的Java实现。JOGL非常复杂，因为它试图在一个编程系统中支持所有版本的OpenGL。JOGL与Java的Swing和AWT图形无缝集成。">JOGL</abbr> 中，像往常一样，您会使用 nio 缓冲区而不是数组。</p>
</div>
<div class="tabbed-block">
<p>When a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> is applied to a surface, each point on the surface has to correspond to a point in the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. There has to be a way to determine how this mapping is computed. For that, the object needs <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates. As is generally the case in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr>, <strong><abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates</strong> are specified for each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> of a primitive. Texture coordinates for points inside the primitive are calculated by interpolating the values from the vertices of the primitive.</p>
<p>A <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image comes with its own 2D <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr>. Traditionally, s is used for the horizontal coordinate on the image and t is used for the vertical coordinate. The s coordinate is a real number that ranges from 0 on the left of the image to 1 on the right, while t ranges from 0 at the bottom to 1 at the top. Values of s or t outside of the range 0 to 1 are not inside the image, but such values are still valid as <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates. Note that <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates are not based on <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr>. No matter what size the image is, values of s and t between 0 and 1 cover the entire image.</p>
<p>To draw a textured primitive, we need a pair of numbers (s,t) for each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>. These are the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates for that <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>. They tell which point in the image is mapped to the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>. For example, suppose that we want to apply part of an EarthAtNight image to a triangular primitive. Let's say that the area in the image that is to be mapped onto the primitive is the triangle shown here outlined in thick orange:</p>
<p><a class="glightbox" href="../../../en/c4/texCoords.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c4/texCoords.png" /></a></p>
<p>The vertices of this area have (s,t) coordinates (0.3,0.1), (0.45,0.6), and (0.25,0.7). These coordinates from the image should be used as the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates for the vertices of the triangular primitive.</p>
<p>The <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates of a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> are an <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> of the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>, just like color, normal vectors, and <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> properties. Texture coordinates are specified by the family of functions <em>glTexCoord*</em>, including the functions <em>glTexCoord2f(s,t)</em>, <em>glTexCoord2d(s,t)</em>, <em>glTexCoord2fv(array)</em>, and <em>glTexCoord2dv(array)</em>. The <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> state includes a current set of <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates, as specified by these functions. When you specify a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> with <em>glVertex*</em>, the current <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates are copied and become an <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> that is associated with the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>. As usual, this means that the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates for a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> must be specified before <em>glVertex*</em> is called. Each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> of a primitive will need a different set of <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates.</p>
<p>For example, to apply the triangular region in the image shown above to the triangle in the xy-plane with vertices at (0,0), (0,1), and (1,0), we can say:</p>
<div class="highlight"><pre><span></span><code><span class="n">glNormal3d</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span><span class="w">       </span><span class="c1">// This normal works for all three vertices.</span>
<span class="n">glBegin</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">);</span>
<span class="n">glTexCoord2d</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span><span class="mf">0.1</span><span class="p">);</span><span class="w">   </span><span class="c1">// Texture coords for vertex (0,0)</span>
<span class="n">glVertex2d</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="n">glTexCoord2d</span><span class="p">(</span><span class="mf">0.45</span><span class="p">,</span><span class="mf">0.6</span><span class="p">);</span><span class="w">  </span><span class="c1">// Texture coords for vertex (0,1)</span>
<span class="n">glVertex2d</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">glTexCoord2d</span><span class="p">(</span><span class="mf">0.25</span><span class="p">,</span><span class="mf">0.7</span><span class="p">);</span><span class="w">  </span><span class="c1">// Texture coords for vertex (1,0)</span>
<span class="n">glVertex2d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="n">glEnd</span><span class="p">();</span>
</code></pre></div>
<p>Note that there is no particular relationship between the (x,y) coordinates of a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>, which give its position in space, and the (s,t) <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates associated with the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>. In fact, in this case, the triangle that I am drawing has a different shape from the triangular area in the image, and that piece of the image will have to be stretched and distorted to fit. Such distortion occurs in most uses of <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> images.</p>
<p>Sometimes, it's difficult to decide what <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates to use. One case where it's easy is applying the complete <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> to a rectangle. Here is a code segment that draws a square in the xy-plane, with appropriate <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates to map the entire image onto the square:</p>
<div class="highlight"><pre><span></span><code><span class="n">glBegin</span><span class="p">(</span><span class="n">GL_TRIANGLE_FAN</span><span class="p">);</span>
<span class="n">glNormal3f</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">glTexCoord2d</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="w">     </span><span class="c1">// Texture coords for lower left corner</span>
<span class="n">glVertex2d</span><span class="p">(</span><span class="mf">-0.5</span><span class="p">,</span><span class="mf">-0.5</span><span class="p">);</span>
<span class="n">glTexCoord2d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="w">     </span><span class="c1">// Texture coords for lower right corner</span>
<span class="n">glVertex2d</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">-0.5</span><span class="p">);</span>
<span class="n">glTexCoord2d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span><span class="w">     </span><span class="c1">// Texture coords for upper right corner</span>
<span class="n">glVertex2d</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">);</span>
<span class="n">glTexCoord2d</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span><span class="w">     </span><span class="c1">// Texture coords for upper left corner</span>
<span class="n">glVertex2d</span><span class="p">(</span><span class="mf">-0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">);</span>
<span class="n">glEnd</span><span class="p">();</span>
</code></pre></div>
<p>Unfortunately, the standard shapes in the <abbr title="OpenGL实用工具包。用于编写OpenGL应用程序的跨平台库。OpenGL本身不包含对窗口或事件的支持。GLUT添加了这样的支持。它还具有用于绘制3D形状（如球体和多面体，更不用说茶壶了）的函数。GLUT用C语言编写，并与OpenGL的C API一起使用。然而，许多GLUT函数也在JOGL中可用，它是OpenGL的Java API。一种较新且稍有改进的工具包版本名为“FreeGLUT”，通常用于取代原始版本。">GLUT</abbr> library do not come with <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates (except for the teapot, which does). I have written a set of functions for drawing similar shapes that do come with <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates. The functions can be found in <a href="../../../en/source/jogl/TexturedShapes.java">jogl/TexturedShapes.java</a> for <abbr title="OpenGL的Java实现。JOGL非常复杂，因为它试图在一个编程系统中支持所有版本的OpenGL。JOGL与Java的Swing和AWT图形无缝集成。">JOGL</abbr> or in <a href="../../../en/source/glut/textured-shapes.c">glut/textured-shapes.c</a> (plus the corresponding header file <a href="../../../en/source/glut/textured-shapes.h">glut/textured-shapes.h</a>) for C. Of course, there are many ways of applying a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> to a given object. If you use my functions, you are stuck with my decision about how to do so.</p>
<p>The sample program <a href="../../../en/source/jogl/TextureDemo.java">jogl/TextureDemo.java</a> or <a href="../../../en/source/glut/texture-demo.c">glut/<abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>-demo.c</a> lets you view several different <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> images on my textured shapes.</p>
<p>One last question: What happens if you supply <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates that are not in the range from 0 to 1? It turns out that such values are legal. By default, in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1, they behave as though the entire st-plane is filled with copies of the image. For example, if the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates for a square range from 0 to 3 in both directions, instead of 0 to 1, then you get nine copies of the image on the square (three copies horizontally by three copies vertically).</p>
<hr />
<p>To draw a textured primitive using glDrawArrays or glDrawElements, you will need to supply the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates in a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> array, in the same way that you supply <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> coordinates, colors, and normal vectors. (See <a href="../../c3/s4/#342-gldrawarrays和gldrawelements">Subsection 3.4.2</a>.) The details are similar: You have to enable the use of a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinate array by calling</p>
<div class="highlight"><pre><span></span><code><span class="n">glEnableClientState</span><span class="p">(</span><span class="n">GL_TEXTURE_COORD_ARRAY</span><span class="p">);</span>
</code></pre></div>
<p>and you have to tell <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> the location of the data using the function</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="n">glTexCoordPointer</span><span class="p">(</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">dataType</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">stride</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">array</span><span class="p">)</span>
</code></pre></div>
<p>The size, for us, will always be 2. (<abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> also allows 3 or 4 <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates, but we have no use for them.) The <em>dataType</em> can be <em>GL_FLOAT</em>, <em>GL_DOUBLE</em>, or <em>GL_INT</em>. The <em>stride</em> will ordinarily be zero, to indicate that there is no extra data between <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates in the array. The last parameter is an array or pointer to the data, which must be of the type indicated by the <em>dataType</em>. In <abbr title="OpenGL的Java实现。JOGL非常复杂，因为它试图在一个编程系统中支持所有版本的OpenGL。JOGL与Java的Swing和AWT图形无缝集成。">JOGL</abbr>, as usual, you would use an <abbr title="A Java object belonging to the class java.nio.Buffer or one of its subclasses. Nio buffers are similar to arrays, but they are optimized for input/output operations. Nio buffers are used instead of arrays for certain purposes in Java's JOGL API for OpenGL.">nio buffer</abbr> instead of an array.</p>
</div>
</div>
</div>
<h2 id="432-mipmap-和过滤">4.3.2 MipMap 和过滤<a class="headerlink" href="#432-mipmap-和过滤" title="Permanent link">&para;</a></h2>
<p><strong>MipMaps and Filtering</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="3:2"><input checked="checked" id="__tabbed_3_1" name="__tabbed_3" type="radio" /><input id="__tabbed_3_2" name="__tabbed_3" type="radio" /><div class="tabbed-labels"><label for="__tabbed_3_1">中文</label><label for="__tabbed_3_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>当一个纹理应用于表面时，纹理中的像素通常不会与表面的像素一一对应，在通常情况下，纹理在映射到表面时必须被拉伸或缩小。有时，纹理中的几个像素会被映射到表面的同一个像素上。在这种情况下，应用到表面像素的颜色必须从映射到它的所有纹理像素的颜色中计算得出。这是“过滤”的一个例子；具体来说，它使用了一个<strong><abbr title="在将纹理应用于对象时使用的操作，当必须缩小纹理以适应对象时。对于图像纹理，缩放过滤被应用于计算像素的颜色，当该像素覆盖图像中的几个像素时。">缩放过滤</abbr></strong>，因为纹理正在被缩小。当纹理中的一个像素覆盖了表面的多个像素时，纹理必须被放大，我们需要一个<strong>放大过滤</strong>。</p>
<p>在我们继续之前，有一个术语：<strong><abbr title="物体上某一点到另一点在某些属性上的变化。最常见的类型是图像纹理。当图像纹理应用于表面时，表面颜色会因点而异。">纹理</abbr></strong>中的像素被称为texels（“<abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>”或“<abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> element”的缩写），从现在开始我将使用这个术语。</p>
<p>在决定如何将纹理应用到表面的一个像素上时，<abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 必须处理这样一个事实，即那个像素实际上包含无限多点，每个点都有自己的纹理坐标。那么，应该如何计算像素的纹理颜色呢？最简单的方法是从一个像素中选择一个点，比如说像素中心的点。<abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 知道那个点的纹理坐标。这些纹理坐标对应于纹理中的一个点，那个点位于纹理的一个texels 中。那个texel 的颜色可以被用作像素的纹理颜色。这被称为“最近像素过滤”。它非常快，但通常不会给出好的结果。它没有考虑到表面像素和图像中texels 大小的差异。最近像素过滤的改进是“线性过滤”，它可以通过计算几个texels 颜色的平均值来得出应用到表面的颜色。</p>
<p>线性过滤的问题在于，当一个大纹理应用到一个更小的表面积时，它会变得非常低效。在这种情况下，许多texels 映射到一个像素，计算这么多texels 的平均值变得非常低效。这里有一个巧妙的解决方案：<strong><abbr title="一系列逐渐缩小尺寸的纹理图像副本，宽度和高度逐渐减小。从原始图像开始，每个mipmap通过将前一个图像的宽度和高度除以二（除非已经是1）来获得。最后的mipmap是一个单一像素。Mipmaps用于更有效地将纹理图像映射到表面上，当图像必须缩小以适应表面时。">Mipmaps</abbr></strong>。</p>
<p>纹理的mipmap 是纹理的缩小版本。一套完整的mipmaps 包括全尺寸纹理、每个维度都除以二的半尺寸版本、四分之一尺寸版本、八分之一尺寸版本，等等。如果一个维度缩小到一个像素，它就不再进一步缩小，但另一个维度会继续减半，直到它也达到一个像素。无论如何，最终的mipmap 由一个像素组成。以下是一组砖纹理的mipmaps 的前几张图像：</p>
<p><a class="glightbox" href="../../../en/c4/mipmaps.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="Mipmaps" src="../../../en/c4/mipmaps.png" /></a></p>
<p>你会注意到mipmaps 很快就变小了。一套mipmaps 所使用的总内存只比原始纹理多大约三分之一，所以使用mipmaps 时额外的内存需求并不是一个大问题。</p>
<p><abbr title="一系列逐渐缩小尺寸的纹理图像副本，宽度和高度逐渐减小。从原始图像开始，每个mipmap通过将前一个图像的宽度和高度除以二（除非已经是1）来获得。最后的mipmap是一个单一像素。Mipmaps用于更有效地将纹理图像映射到表面上，当图像必须缩小以适应表面时。">Mipmaps</abbr> 仅用于缩放过滤。它们本质上是在缩小纹理以适应表面时预先计算所需的大部分平均值的一种方式。要纹理化一个像素，<abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 首先可以选择texels 大小最接近像素大小的mipmap。然后它可以在那个mipmap 上进行线性过滤来计算颜色，并且它最多只需要平均几个texels 就可以做到这一点。</p>
<p>在 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 的更新版本中，你可以让 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 自动生成 <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr>。在 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1 中，如果你想使用 <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr>，你必须逐个加载每个 <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmap</abbr>，或者你必须自己生成它们。（<abbr title="The OpenGL Utility library. Defines several functions for use with older versions of OpenGL, including gluPerspective and gluLookAt. Not to be confused with GLUT. GLU is a standard part of OpenGL.">GLU</abbr> 库有一个方法 <em>gluBuild2DMipmaps</em>，可以用来为 2D 纹理生成一组 <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr>。）然而，我的示例程序不使用 <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr>。</p>
</div>
<div class="tabbed-block">
<p>When a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> is applied to a surface, the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr> in the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> do not usually match up one-to-one with <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr> on the surface, and in general, the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> must be stretched or shrunk as it is being mapped onto the surface. Sometimes, several <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr> in the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> will be mapped to the same <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> on the surface. In this case, the color that is applied to the surface <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> must somehow be computed from the colors of all the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr> that map to it. This is an example of "filtering"; in particular, it uses a <strong><abbr title="An operation that is used when applying a texture to an object, when the texture has to be shrunk to fit the object. For an image texture, a minification filter is applied to compute the color of a pixel when that pixel covers several pixels in the image.">minification filter</abbr></strong> because the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> is being shrunk. When one <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> from the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> covers more than one <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> on the surface, the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> has to be magnified, and we need a <strong><abbr title="An operation that is used when applying a texture to an object, when the texture has to be stretched to fit the object. For an image texture, a magnification filter is applied to compute the color of a pixel when that pixel covers just a fraction of a pixel in the image.">magnification filter</abbr></strong>.</p>
<p>One bit of terminology before we proceed: The <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr> in a <strong><abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr></strong> are referred to as texels, short for "<abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>" or "<abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> element", and I will use that term from now on.</p>
<p>When deciding how to apply a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> to a <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> on a surface, <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> must deal with the fact that that <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> actually contains an infinite number of points, and each point has its own <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates. So, how should a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> color for the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> be computed? The easiest thing to do is to select one point from the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>, say the point at the center of the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>. <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> knows the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates for that point. Those <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates correspond to one point in the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>, and that point lies in one of the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>'s texels. The color of that <abbr title="A pixel in a texture image.">texel</abbr> could be used as the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> color for the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>. This is called "nearest <abbr title="A pixel in a texture image.">texel</abbr> filtering." It is very fast, but it does not usually give good results. It doesn't take into account the difference in size between the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr> on the surface and the texels in the image. An improvement on nearest <abbr title="A pixel in a texture image.">texel</abbr> filtering is "linear filtering," which can take an average of several <abbr title="A pixel in a texture image.">texel</abbr> colors to compute the color that will be applied to the surface.</p>
<p>The problem with linear filtering is that it will be very inefficient when a large <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> is applied to a much smaller surface area. In this case, many texels map to one <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>, and computing the average of so many texels becomes very inefficient. There is a neat solution for this: <strong><abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr></strong>.</p>
<p>A <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmap</abbr> for a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> is a scaled-down version of that <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. A complete set of <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr> consists of the full-size <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>, a half-size version in which each dimension is divided by two, a quarter-sized version, a one-eighth-sized version, and so on. If one dimension shrinks to a single <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>, it is not reduced further, but the other dimension will continue to be cut in half until it too reaches one <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>. In any case, the final <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmap</abbr> consists of a single <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>. Here are the first few images in the set of <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr> for a brick <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>:</p>
<p><a class="glightbox" href="../../../en/c4/mipmaps.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c4/mipmaps.png" /></a></p>
<p>You'll notice that the <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr> become small very quickly. The total memory used by a set of <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr> is only about one-third more than the memory used for the original <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>, so the additional memory requirement is not a big issue when using <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr>.</p>
<p><abbr title="一系列逐渐缩小尺寸的纹理图像副本，宽度和高度逐渐减小。从原始图像开始，每个mipmap通过将前一个图像的宽度和高度除以二（除非已经是1）来获得。最后的mipmap是一个单一像素。Mipmaps用于更有效地将纹理图像映射到表面上，当图像必须缩小以适应表面时。">Mipmaps</abbr> are used only for minification filtering. They are essentially a way of pre-computing the bulk of the averaging that is required when shrinking a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> to fit a surface. To <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> a <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>, <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> can first select the <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmap</abbr> whose texels most closely match the size of the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>. It can then do linear filtering on that <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmap</abbr> to compute a color, and it will have to average at most a few texels in order to do so.</p>
<p>In newer versions of <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr>, you can get <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> to generate <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr> automatically. In <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1, if you want to use <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr>, you must either load each <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmap</abbr> individually, or you must generate them yourself. (The <abbr title="The OpenGL Utility library. Defines several functions for use with older versions of OpenGL, including gluPerspective and gluLookAt. Not to be confused with GLUT. GLU is a standard part of OpenGL.">GLU</abbr> library has a method, <em>gluBuild2DMipmaps</em> that can be used to generate a set of <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr> for a 2D <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>.) However, my sample programs do not use <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr>.</p>
</div>
</div>
</div>
<h2 id="433-纹理目标和纹理参数">4.3.3 纹理目标和纹理参数<a class="headerlink" href="#433-纹理目标和纹理参数" title="Permanent link">&para;</a></h2>
<p><strong>Texture Target and Texture Parameters</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="4:2"><input checked="checked" id="__tabbed_4_1" name="__tabbed_4" type="radio" /><input id="__tabbed_4_2" name="__tabbed_4" type="radio" /><div class="tabbed-labels"><label for="__tabbed_4_1">中文</label><label for="__tabbed_4_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p><abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 可以使用一维和三维纹理，以及二维纹理。因此，许多处理纹理的 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 函数接受一个 <strong><abbr title="在OpenGL中，有几种类型的纹理，如2D图像纹理、1D纹理和立方体贴图纹理。纹理目标由常量指定，如GL_TEXTURE_2D或GL_TEXTURE_CUBE_MAP_POSITIVE_X。纹理目标是许多OpenGL函数的参数，这些函数用于处理纹理。">纹理目标</abbr></strong> 作为参数，以告诉函数应用于一维、二维或三维纹理。对我们来说，唯一的纹理目标将是 <em>GL_TEXTURE_2D</em>。</p>
<p>有一些选项适用于纹理，以控制纹理如何应用到表面上的细节。一些选项可以使用 <em>glTexParameteri()</em> 函数设置，包括两个与过滤有关的选项。<abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 支持多种不同的缩放和放大过滤技术。可以使用 <em>glTexParameteri()</em> 设置过滤器：</p>
<div class="highlight"><pre><span></span><code><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span><span class="w"> </span><span class="n">magFilter</span><span class="p">);</span>
<span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span><span class="w"> </span><span class="n">minFilter</span><span class="p">);</span>
</code></pre></div>
<p><em>magFilter</em> 和 <em>minFilter</em> 的值是指定过滤算法的常量。对于 <em>magFilter</em>，唯一的选项是 <em>GL_NEAREST</em> 和 <em>GL_LINEAR</em>，分别提供最近像素和线性过滤。MAG 过滤器的默认值是 GL_LINEAR，很少需要更改它。对于 <em>minFilter</em>，除了 <em>GL_NEAREST</em> 和 <em>GL_LINEAR</em>，还有四个选项使用 <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr> 进行更有效的过滤。MIN 过滤器的默认值是 <em>GL_NEAREST_MIPMAP_LINEAR</em>，它在每个 <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmap</abbr> 内进行 <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmap</abbr> 之间和最近像素过滤的平均处理。为了获得更好的结果，尽管效率较低，您可以使用 <em>GL_LINEAR_MIPMAP_LINEAR</em>，它在 <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmap</abbr> 之间和内部都进行平均处理。另外两个选项是 <em>GL_NEAREST_MIPMAP_NEAREST</em> 和 <em>GL_LINEAR_MIPMAP_NEAREST</em>。</p>
<p><strong>非常重要的一点</strong>：如果您不为纹理使用 <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr>，那么必须将该纹理的缩放过滤器更改为 <em>GL_LINEAR</em>，或者较少可能的是 <em>GL_NEAREST</em>。默认的 MIN 过滤器 <strong>需要</strong> <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr>，如果 <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr> 不可用，则纹理被认为未正确形成，<abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 会忽略它！请记住，如果您不创建 <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr> 并且不更改缩放过滤器，那么您的纹理将被 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 简单地忽略。</p>
<p>还有另一对纹理参数来控制范围在 0 到 1 之外的纹理坐标如何处理。如上所述，默认行为是重复纹理。另一种选择是“夹”<abbr title="物体上某一点到另一点在某些属性上的变化。最常见的类型是图像纹理。当图像纹理应用于表面时，表面颜色会因点而异。">纹理</abbr>。这意味着当指定范围在 0 到 1 之外的纹理坐标时，这些值会被强制进入该范围：小于 0 的值被替换为 0，大于 1 的值被替换为 1。可以使用以下方式分别在 <em>s</em> 和 <em>t</em> 方向上夹住值：</p>
<div class="highlight"><pre><span></span><code><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span><span class="w"> </span><span class="n">GL_CLAMP</span><span class="p">);</span>
<span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span><span class="w"> </span><span class="n">GL_CLAMP</span><span class="p">);</span>
</code></pre></div>
<p>将 <em>GL_REPEAT</em> 作为最后一个参数传入可以恢复默认行为。当启用夹取时，范围在 0 到 1 之外的纹理坐标将返回与位于图像外边缘的像素相同的颜色。这是两个带纹理的正方形上效果的样子：</p>
<p><a class="glightbox" href="../../../en/c4/repeat-vs-clamp-texture.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="Repeat vs. Clamp Texture" src="../../../en/c4/repeat-vs-clamp-texture.png" /></a></p>
<p>这张图片中的两个正方形的 s 和 t 纹理坐标范围从 -1 到 2。原始图像位于正方形的中心。左侧的正方形，纹理是重复的。右侧的正方形，纹理是夹取的。</p>
</div>
<div class="tabbed-block">
<p><abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> can actually use one-dimensional and three-dimensional textures, as well as two-dimensional. Because of this, many <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> functions dealing with textures take a <strong><abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> target</strong> as a parameter, to tell whether the function should be applied to one, two, or three dimensional textures. For us, the only <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> target will be <em>GL_TEXTURE_2D</em>.</p>
<p>There are a number of options that apply to textures, to control the details of how textures are applied to surfaces. Some of the options can be set using the <em>glTexParameteri()</em> function, including two that have to do with filtering. <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> supports several different filtering techniques for minification and magnification. The filters can be set using <em>glTexParameteri()</em>:</p>
<div class="highlight"><pre><span></span><code><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span><span class="w"> </span><span class="n">magFilter</span><span class="p">);</span>
<span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span><span class="w"> </span><span class="n">minFilter</span><span class="p">);</span>
</code></pre></div>
<p>The values of <em>magFilter</em> and minFilter are constants that specify the filtering algorithm. For the <em>magFilter</em>, the only options are <em>GL_NEAREST</em> and <em>GL_LINEAR</em>, giving nearest <abbr title="A pixel in a texture image.">texel</abbr> and linear filtering. The default for the MAG filter is GL_LINEAR, and there is rarely any need to change it. For <em>minFilter</em>, in addition to <em>GL_NEAREST</em> and <em>GL_LINEAR</em>, there are four options that use <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr> for more efficient filtering. The default MIN filter is <em>GL_NEAREST_MIPMAP_LINEAR</em>, which does averaging between <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr> and nearest <abbr title="A pixel in a texture image.">texel</abbr> filtering within each <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmap</abbr>. For even better results, at the cost of greater inefficiency, you can use <em>GL_LINEAR_MIPMAP_LINEAR</em>, which does averaging both between and within <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr>. The other two options are <em>GL_NEAREST_MIPMAP_NEAREST</em> and <em>GL_LINEAR_MIPMAP_NEAREST</em>.</p>
<p><strong>One very important note</strong>: If you are <strong>not</strong> using <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr> for a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>, it is imperative that you change the <abbr title="An operation that is used when applying a texture to an object, when the texture has to be shrunk to fit the object. For an image texture, a minification filter is applied to compute the color of a pixel when that pixel covers several pixels in the image.">minification filter</abbr> for that <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> to <em>GL_LINEAR</em> or, less likely, <em>GL_NEAREST</em>. The default MIN filter <strong>requires</strong> <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr>, and if <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr> are not available, then the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> is considered to be improperly formed, and <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> ignores it! Remember that if you don't create <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr> and if you don't change the <abbr title="An operation that is used when applying a texture to an object, when the texture has to be shrunk to fit the object. For an image texture, a minification filter is applied to compute the color of a pixel when that pixel covers several pixels in the image.">minification filter</abbr>, then your <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> will simply be ignored by <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr>.</p>
<p>There is another pair of <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> parameters to control how <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates outside the range 0 to 1 are treated. As mentioned above, the default is to repeat the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. The alternative is to "clamp" the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. This means that when <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates outside the range 0 to 1 are specified, those values are forced into that range: Values less than 0 are replaced by 0, and values greater than 1 are replaced by 1. Values can be clamped separately in the <em>s</em> and <em>t</em> directions using</p>
<div class="highlight"><pre><span></span><code><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span><span class="w"> </span><span class="n">GL_CLAMP</span><span class="p">);</span>
<span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span><span class="w"> </span><span class="n">GL_CLAMP</span><span class="p">);</span>
</code></pre></div>
<p>Passing <em>GL_REPEAT</em> as the last parameter restores the default behavior. When clamping is in effect, <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates outside the range 0 to 1 return the same color as a <abbr title="A pixel in a texture image.">texel</abbr> that lies along the outer edge of the image. Here is what the effect looks like on two textured squares:</p>
<p><a class="glightbox" href="../../../en/c4/repeat-vs-clamp-texture.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c4/repeat-vs-clamp-texture.png" /></a></p>
<p>The two squares in this image have s and t <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates that range from −1 to 2. The original image lies in the center of the square. For the square on the left, the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> is repeated. On the right, the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> is clamped.</p>
</div>
</div>
</div>
<h2 id="434-纹理变换">4.3.4 <abbr title="在用于从纹理中采样数据之前应用于纹理坐标的变换。效果是平移、旋转或缩放应用到其上表面的纹理。">纹理变换</abbr><a class="headerlink" href="#434-纹理变换" title="Permanent link">&para;</a></h2>
<p><strong>Texture Transformation</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="5:2"><input checked="checked" id="__tabbed_5_1" name="__tabbed_5" type="radio" /><input id="__tabbed_5_2" name="__tabbed_5" type="radio" /><div class="tabbed-labels"><label for="__tabbed_5_1">中文</label><label for="__tabbed_5_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>当一个纹理应用于一个原素时，顶点的纹理坐标决定了纹理中哪个点映射到该顶点。纹理图像是二维的，但 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 也支持一维纹理和三维纹理。这意味着纹理坐标不能仅限于两个坐标。实际上，<abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 内部以齐次坐标的形式表示一组纹理坐标，称为 (<em>s</em>,<em>t</em>,<em>r</em>,<em>q</em>)。我们使用 <em>glTexCoord2</em><em> 来指定纹理的 s 和 t <abbr title="一种将数值坐标分配给几何点的方法。在二维中，每个点对应一对数字。在三维中，每个点对应一组三个数字。">坐标</abbr>，但例如调用 </em>glTexCoord2f(s,t)<em> 实际上只是 </em>glTexCoord4f(s,t,0,1)* 的简写。</p>
<p>由于纹理坐标与顶点坐标没有区别，它们可以以完全相同的方式进行变换。<abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 将其状态中的<strong><abbr title="在用于从纹理中采样数据之前应用于纹理坐标的变换。效果是平移、旋转或缩放应用到其上表面的纹理。">纹理变换</abbr></strong>作为模型视图和投影变换的一部分来维护。三种变换的当前值都存储为矩阵。当一个纹理应用于一个对象时，为其顶点指定的纹理坐标会通过纹理矩阵进行变换。然后使用变换后的纹理坐标来确定纹理中的一个点。当然，默认的纹理变换是恒等变换，不会改变坐标。</p>
<p>纹理矩阵可以表示缩放、<abbr title="一种几何变换，它围绕某个点（在2D中）或轴（在3D中）旋转每个点到指定角度。">旋转</abbr>、平移以及这些基本变换的组合。要指定纹理变换，您必须使用 <em>glMatrixMode()</em> 将矩阵模式设置为 <em>GL_TEXTURE</em>。在这种模式下，调用如 <em>glRotate</em><em>、</em>glScale<em><em> 和 </em>glLoadIdentity</em> 等方法将应用于纹理矩阵。例如，要安装一个在每个方向上将纹理坐标缩放两倍的纹理变换，您可以这样做：</p>
<div class="highlight"><pre><span></span><code><span class="n">glMatrixMode</span><span class="p">(</span><span class="n">GL_TEXTURE</span><span class="p">);</span>
<span class="n">glLoadIdentity</span><span class="p">();</span><span class="w"> </span><span class="c1">// 确保我们从恒等矩阵开始。</span>
<span class="n">glScalef</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">glMatrixMode</span><span class="p">(</span><span class="n">GL_MODELVIEW</span><span class="p">);</span><span class="w"> </span><span class="c1">// 将矩阵模式设置回 GL_MODELVIEW。</span>
</code></pre></div>
<p>由于图像位于 st 平面上，因此 <em>glScalef</em> 的前两个参数才重要。对于旋转，您将使用 (0,0,1) 作为旋转轴，这将在 st 平面上旋转图像。</p>
<p>现在，这对纹理在表面上的外观实际上意味着什么？在示例中，缩放变换将每个纹理坐标乘以 2。例如，如果一个顶点被分配了二维纹理坐标 (0.4,0.1)，那么在应用纹理变换后，该顶点将映射到纹理中的点 (s,t) = (0.8,0.2)。纹理坐标在表面上的变化速度是不带缩放变换时的两倍。一个在没有变换时会映射到纹理图像中 1x1 平方区域的表面上的区域，将改为映射到图像中的 2x2 平方区域——因此，在该区域内将看到图像的更大一部分。换句话说，纹理图像在表面上将被<em>缩小</em>两倍！更一般地说，纹理变换对纹理外观的影响是其对纹理坐标影响的<strong>逆</strong>。（这与视图变换和建模变换之间的逆关系完全类似。）如果纹理变换是向右平移，那么纹理就会在表面上向左移动。如果纹理变换是逆时针旋转，那么纹理就会在表面上顺时针旋转。</p>
<p>我在这里提到纹理变换主要是为了展示 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 如何在另一个上下文中使用变换。但有时变换纹理以使其更好地适应表面是有用的。并且为了获得不寻常的效果，您甚至可以动画化纹理变换，使纹理图像在表面上移动。这里有一个演示，让您尝试纹理变换并查看效果。在左侧，您可以看到 st 平面上 s 和 t 介于 -1 和 2 之间的区域。一个框勾勒出映射到具有纹理坐标范围在 0 到 1 的 3D 对象区域的纹理区域。您可以通过拖动滑块来应用纹理变换，看看变换如何影响框以及如何影响对象上的纹理。有关更多信息，请查看演示中的帮助文本。</p>
<p><iframe src="../../../en/demos/c4/texture-transform.html" width="675" height="550"></iframe></p>
</div>
<div class="tabbed-block">
<p>When a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> is applied to a primitive, the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates for a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> determine which point in the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> is mapped to that <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>. Texture images are 2D, but <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> also supports one-dimensional textures and three-dimensional textures. This means that <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates cannot be restricted to two coordinates. In fact, a set of <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> is represented internally in the form of <abbr title="A way of representing n-dimensional vectors as (n+1)-dimensional vectors where two (n+1) vectors represent the same n-dimensional vector if they differ by a scalar multiple. In 3D, for example, if w is not zero, then the homogeneous coordinates (x,y,z,w) are equivalent to homogeneous coordinates (x/w,y/w,z/w,1), since they differ by multiplication by the scalar w. Both sets of coordinates represent the 3D vector (x/w,y/w,z/w)">homogeneous coordinates</abbr>, which are referred to as (<em>s</em>,<em>t</em>,<em>r</em>,<em>q</em>). We have used <em>glTexCoord2*</em> to specify <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> s and t coordinates, but a call to <em>glTexCoord2f(s,t)</em>, for example, is really just shorthand for <em>glTexCoord4f(s,t,0,1)</em>.</p>
<p>Since <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates are no different from <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> coordinates, they can be transformed in exactly the same way. <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> maintains a <strong><abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> transformation</strong> as part of its state, along with the modelview and <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> transformations. The current value of each of the three transformations is stored as a <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>. When a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> is applied to an object, the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates that were specified for its vertices are transformed by the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>. The transformed <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates are then used to pick out a point in the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. Of course, the default <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> transform is the <abbr title="A transform that has no effect on its argument. For example, the identity transform in 2D is given by the formula I(x,y) = (x,y). The identity transform I has the property that if T is any transform, then I followed by T is the same as T, and T followed by I is the same as T.">identity transform</abbr>, which doesn't change the coordinates.</p>
<p>The <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> can represent <abbr title="A geometric transform that multiplies each coordinate of a point by a number called the scaling factor. Scaling increases or decreases the size of an object, but also moves its points closer to or farther from the origin. Scaling can be uniform—the same in every direction—or non-uniform—with a different scaling factor in each coordinate direction. A negative scaling factor can be used to apply a reflection.">scaling</abbr>, <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr>, <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr> and combinations of these basic transforms. To specify a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> transform, you have to use <em>glMatrixMode()</em> to set the <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> mode to <em>GL_TEXTURE</em>. With this mode in effect, calls to methods such as <em>glRotate*</em>, <em>glScale*</em>, and <em>glLoadIdentity</em> are applied to the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>. For example to install a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> transform that scales <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates by a factor of two in each direction, you could say:</p>
<div class="highlight"><pre><span></span><code><span class="n">glMatrixMode</span><span class="p">(</span><span class="n">GL_TEXTURE</span><span class="p">);</span>
<span class="n">glLoadIdentity</span><span class="p">();</span><span class="w"> </span><span class="c1">// Make sure we are starting from the identity matrix.</span>
<span class="n">glScalef</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">glMatrixMode</span><span class="p">(</span><span class="n">GL_MODELVIEW</span><span class="p">);</span><span class="w"> </span><span class="c1">// Leave matrix mode set to GL_MODELVIEW.</span>
</code></pre></div>
<p>Since the image lies in the st-plane, only the first two parameters of <em>glScalef</em> matter. For rotations, you would use (0,0,1) as the <abbr title="Rotation in 3D space is rotation about a line, which is called the axis of rotation. The axis of rotation remains fixed, while everything else moves in circles around the axis.">axis of rotation</abbr>, which will rotate the image within the st-plane.</p>
<p>Now, what does this actually mean for the appearance of the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> on a surface? In the example, the <abbr title="A geometric transform that multiplies each coordinate of a point by a number called the scaling factor. Scaling increases or decreases the size of an object, but also moves its points closer to or farther from the origin. Scaling can be uniform—the same in every direction—or non-uniform—with a different scaling factor in each coordinate direction. A negative scaling factor can be used to apply a reflection.">scaling</abbr> transform multiplies each <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinate by 2. For example, if a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> was assigned 2D <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates (0.4,0.1), then after the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> transform is applied, that <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> will be mapped to the point (s,t) = (0.8,0.2) in the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. The <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates vary twice as fast on the surface as they would without the <abbr title="A geometric transform that multiplies each coordinate of a point by a number called the scaling factor. Scaling increases or decreases the size of an object, but also moves its points closer to or farther from the origin. Scaling can be uniform—the same in every direction—or non-uniform—with a different scaling factor in each coordinate direction. A negative scaling factor can be used to apply a reflection.">scaling</abbr> transform. A region on the surface that would map to a 1-by-1 square in the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image without the transform will instead map to a 2-by-2 square in the image—so that a larger piece of the image will be seen inside the region. In other words, the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image will be <em>shrunk</em> by a factor of two on the surface! More generally, the effect of a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> transformation on the appearance of the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> is the <strong>inverse</strong> of its effect on the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates. (This is exactly analogous to the inverse relationship between a <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> transformation and a <abbr title="A transformation that is applied to an object to map that object into the world coordinate system or into the object coordinate system for a more complex, hierarchical object.">modeling transformation</abbr>.) If the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> transform is <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr> to the right, then the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> moves to the left on the surface. If the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> transform is a counterclockwise <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr>, then the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> rotates clockwise on the surface.</p>
<p>I mention <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> transforms here mostly to show how <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> can use transformations in another context. But it is sometimes useful to transform a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> to make it fit better on a surface. And for an unusual effect, you might even animate the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> transform to make the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image move on the surface. Here is a demo that lets you experiment with <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> transforms and see the effect. On the left, you see the region in the st-plane for s and t between −1 and 2. A box outlines the region in the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> that maps to a region on the 3D object with <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates in the range 0 to 1. You can drag the sliders to apply <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> transforms to see how the transforms affect the box and how they affect the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> on the object. See the help text in the demo for more information.</p>
<p><iframe src="../../../en/demos/c4/texture-transform.html" width="675" height="550"></iframe></p>
</div>
</div>
</div>
<h2 id="435-从内存加载纹理">4.3.5 从内存加载纹理<a class="headerlink" href="#435-从内存加载纹理" title="Permanent link">&para;</a></h2>
<p><strong>Loading a Texture from Memory</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="6:2"><input checked="checked" id="__tabbed_6_1" name="__tabbed_6" type="radio" /><input id="__tabbed_6_2" name="__tabbed_6" type="radio" /><div class="tabbed-labels"><label for="__tabbed_6_1">中文</label><label for="__tabbed_6_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p><abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 中将图像用作纹理的过程通常开始于文件中的图像。<abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 本身没有从文件加载图像的函数。目前，我们假设图像已经从文件加载到计算机的内存中。本节稍后，我将解释如何在 C 和 Java 中完成这一过程。</p>
<p><abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 从计算机内存中加载图像数据到 2D 纹理的函数是 <em>glTexImage2D()</em>，其形式如下：</p>
<div class="highlight"><pre><span></span><code><span class="n">glTexImage2D</span><span class="p">(</span><span class="n">target</span><span class="p">,</span><span class="w"> </span><span class="n">mipmapLevel</span><span class="p">,</span><span class="w"> </span><span class="n">internalFormat</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="n">border</span><span class="p">,</span>
<span class="w">            </span><span class="n">format</span><span class="p">,</span><span class="w"> </span><span class="n">dataType</span><span class="p">,</span><span class="w"> </span><span class="n">pixels</span><span class="p">);</span>
</code></pre></div>
<p>target 应该是 <em>GL_TEXTURE_2D</em>。mipmapLevel 通常应该是 0。值 0 用于加载主纹理；更大的值用于加载单独的 <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmap</abbr>。internalFormat 告诉 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 您希望纹理数据在 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 纹理内存中的存储方式。它可以是 <em>GL_RGB</em>，用于为每个像素存储 8 位的红色/绿色/蓝色分量。另一种可能性是 <em>GL_RGBA</em>，它增加了一个 <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> 分量。width 和 height 提供了图像的大小；这些值应该是 2 的幂。border 的值应该是 0；另一种可能性是 1，这表明已经在图像数据周围添加了一像素的边界，我将不讨论其原因。最后三个参数描述了图像数据。format 告诉如何在计算机的内存中表示原始图像数据，例如 <em>GL_RGB</em> 或 <em>GL_RGBA</em>。dataType 通常是 <em>GL_UNSIGNED_BYTE</em>，表示每个颜色分量被表示为范围在 0 到 255 的一字节值。而 <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr> 是指向像素实际颜色数据的起始点的指针。像素数据必须在特定的格式中，但这在这里并不需要我们关心，因为通常由用于从文件中读取图像的函数来处理。（对于 <abbr title="OpenGL的Java实现。JOGL非常复杂，因为它试图在一个编程系统中支持所有版本的OpenGL。JOGL与Java的Swing和AWT图形无缝集成。">JOGL</abbr>，指针将被缓冲区替换。）</p>
<p>这看起来相当复杂，但实际上，对 glTexImage2D 的调用通常采取以下形式，只是可能用 <em>GL_RGBA</em> 替换 <em>GL_RGB</em>。</p>
<div class="highlight"><pre><span></span><code><span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">GL_RGB</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">            </span><span class="n">GL_RGB</span><span class="p">,</span><span class="w"> </span><span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span><span class="w"> </span><span class="n">pixels</span><span class="p">);</span>
</code></pre></div>
<p>调用这个函数将把图像加载到纹理中，但它不会导致纹理被使用。为此，您还必须调用</p>
<div class="highlight"><pre><span></span><code><span class="n">glEnable</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">);</span>
</code></pre></div>
<p>如果您希望在某些对象上使用纹理而在其他对象上不使用，您可以在绘制希望有纹理的对象之前启用 <em>GL_TEXTURE_2D</em>，在绘制无纹理的对象之前将其禁用。您也可以随时通过调用 <em>glTexImage2D</em> 更改正在使用的纹理。</p>
</div>
<div class="tabbed-block">
<p>It's about time that we looked at the process of getting an image into <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> so that it can be used as a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. Usually, the image starts out in a file. <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> does not have functions for loading images from a file. For now, we assume that the file has already been loaded from the file into the computer's memory. Later in this section, I will explain how that's done in C and in Java.</p>
<p>The <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> function for loading image data from the computer's memory into a 2D <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> is <em>glTexImage2D()</em>, which takes the form:</p>
<div class="highlight"><pre><span></span><code><span class="n">glTexImage2D</span><span class="p">(</span><span class="n">target</span><span class="p">,</span><span class="w"> </span><span class="n">mipmapLevel</span><span class="p">,</span><span class="w"> </span><span class="n">internalFormat</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="n">border</span><span class="p">,</span>
<span class="w">                            </span><span class="n">format</span><span class="p">,</span><span class="w"> </span><span class="n">dataType</span><span class="p">,</span><span class="w"> </span><span class="n">pixels</span><span class="p">);</span>
</code></pre></div>
<p>The target should be <em>GL_TEXTURE_2D</em>. The mipmapLevel should ordinarily be 0. The value 0 is for loading the main <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>; a larger value is used to load an individual <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmap</abbr>. The internalFormat tells <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> how you want the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> data to be stored in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> memory. It can be <em>GL_RGB</em> to store an 8-bit red/green/blue component for each <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr>. Another possibility is <em>GL_RGBA</em>, which adds an <abbr title="An extra component (that is, one of the numbers that are used to specify a color) in a color model that is not part of the actual color specification. The alpha component is extra information. It is most often used to specify the degree of transparency of a color.">alpha</abbr> component. The width and height give the size of the image; the values should be powers of two. The value of <em>border</em> should be 0; the only other possibility is 1, which indicates that a one-<abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> border has been added around the image data for reasons that I will not discuss. The last three parameters describe the image data. The format tells how the original image data is represented in the computer's memory, such as <em>GL_RGB</em> or <em>GL_RGBA</em>. The <em>dataType</em> is usually <em>GL_UNSIGNED_BYTE</em>, indicating that each <abbr title="One of the numbers used in a color model to specify a color. For example, in the RGB color model, a color is specified by three color components representing the amounts of red, green, and blue in the color.">color component</abbr> is represented as a one-byte value in the range 0 to 255. And <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr> is a pointer to the start of the actual color data for the <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr>. The <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> data has to be in a certain format, but that need not concern us here, since it is usually taken care of by the functions that are used to read the image from a file. (For <abbr title="OpenGL的Java实现。JOGL非常复杂，因为它试图在一个编程系统中支持所有版本的OpenGL。JOGL与Java的Swing和AWT图形无缝集成。">JOGL</abbr>, the pointer would be replaced by a buffer.)</p>
<p>This all looks rather complicated, but in practice, a call to glTexImage2D generally takes the following form, except possibly with <em>GL_RGB</em> replaced with <em>GL_RGBA</em>.</p>
<div class="highlight"><pre><span></span><code><span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">GL_RGB</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">                    </span><span class="n">GL_RGB</span><span class="p">,</span><span class="w"> </span><span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span><span class="w"> </span><span class="n">pixels</span><span class="p">);</span>
</code></pre></div>
<p>Calling this function will load the image into the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>, but it does not cause the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> to be used. For that, you also have to call</p>
<div class="highlight"><pre><span></span><code><span class="n">glEnable</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">);</span>
</code></pre></div>
<p>If you want to use the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> on some objects but not others, you can enable <em>GL_TEXTURE_2D</em> before drawing objects that you want to be textured and disable it before drawing untextured objects. You can also change the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> that is being used at any time by calling <em>glTexImage2D</em>.</p>
</div>
</div>
</div>
<h2 id="436-来自颜色缓冲区的纹理">4.3.6 来自颜色缓冲区的纹理<a class="headerlink" href="#436-来自颜色缓冲区的纹理" title="Permanent link">&para;</a></h2>
<p><strong>Texture from Color Buffer</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="7:2"><input checked="checked" id="__tabbed_7_1" name="__tabbed_7" type="radio" /><input id="__tabbed_7_2" name="__tabbed_7" type="radio" /><div class="tabbed-labels"><label for="__tabbed_7_1">中文</label><label for="__tabbed_7_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p><abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 程序中使用的纹理图像通常来自外部来源，最常见的是图像文件。然而，<abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 本身是一个强大的图像创建引擎。有时，与其加载一个图像文件，不如让 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 内部创建图像更方便，通过渲染来实现。这是可能的，因为 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 可以从它自己的颜色缓冲区读取纹理数据，它在那里进行绘图。要使用 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 创建纹理图像，您只需使用标准的 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 绘图命令绘制图像，然后使用以下方法将该图像加载为纹理：</p>
<div class="highlight"><pre><span></span><code><span class="n">glCopyTexImage2D</span><span class="p">(</span><span class="n">目标</span><span class="p">,</span><span class="w"> </span><span class="n">mipmap级别</span><span class="p">,</span><span class="w"> </span><span class="n">内部格式</span><span class="p">,</span>
<span class="w">                                    </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">宽度</span><span class="p">,</span><span class="w"> </span><span class="n">高度</span><span class="p">,</span><span class="w"> </span><span class="n">边框</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>在这个方法中，目标将是 <em>GL_TEXTURE_2D</em>；<em>mipmap级别</em> 应该是零；<em>内部格式</em> 通常是 <em>GL_RGB</em> 或 <em>GL_RGBA</em>；x 和 y 指定从颜色缓冲区读取纹理的矩形的左下角；<em>width</em> 和 <em>height</em> 是该矩形的大小；边框应该是 0。像往常一样，纹理的宽度和高度应该是 2 的幂。对 <em>glCopyTexImage2D</em> 的调用通常看起来像这样：</p>
<div class="highlight"><pre><span></span><code><span class="n">glCopyTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">GL_RGB</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">宽度</span><span class="p">,</span><span class="w"> </span><span class="n">高度</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</code></pre></div>
<p>最终结果是，颜色缓冲区中指定的矩形将被复制到纹理内存，并成为当前的 2D <abbr title="物体上某一点到另一点在某些属性上的变化。最常见的类型是图像纹理。当图像纹理应用于表面时，表面颜色会因点而异。">纹理</abbr>。这与对 <em>glTexImage2D()</em> 的调用的工作方式相同，只是图像数据的来源不同。</p>
<p>一个示例可以在 <abbr title="OpenGL的Java实现。JOGL非常复杂，因为它试图在一个编程系统中支持所有版本的OpenGL。JOGL与Java的Swing和AWT图形无缝集成。">JOGL</abbr> 程序 <a href="../../../en/source/jogl/TextureFromColorBuffer.java">jogl/TextureFromColorBuffer.java</a> 或 C 版本 <a href="../../../en/source/glut/texture-from-color-buffer.c">glut/<abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>-from-color-buffer.c</a> 中找到。这个程序绘制了 <a href="../../c2/s4/#241--构建复杂对象">2.4.1 小节</a> 中的风车和推车场景，并随后将该绘图作为纹理应用于 3D 对象。这是一个程序的演示版本。</p>
<p><iframe src="../../../en/demos/c4/texture-from-color-buffer.html" width="440" height="460"></iframe></p>
<p>纹理可以被动画化！对于动画，每个帧都会绘制一个新的纹理。所有工作都在程序的显示函数中完成。在该函数中，首先将风车和推车场景的当前帧作为禁用照明的 2D 场景绘制。这幅画不会显示在电脑屏幕上；绘图是在屏幕外完成的，图像将在显示在屏幕上之前被擦除并替换为 3D 图像。然后调用 <em>glCopyTexImage2D()</em> 函数将场景复制到当前纹理中。然后，清除颜色缓冲区，启用照明，并设置 3D <abbr title="将3D中的坐标映射到2D中的坐标的转换。投影用于将三维场景转换为二维图像。">投影</abbr>，最后绘制在电脑屏幕上看到的 3D 对象。</p>
</div>
<div class="tabbed-block">
<p>Texture images for use in an <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> program usually come from an external source, most often an image file. However, <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> is itself a powerful engine for creating images. Sometimes, instead of loading an image file, it's convenient to have <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> create the image internally, by <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> it. This is possible because <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> can read <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> data from its own <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr>, where it does its drawing. To create a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image using <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr>, you just have to draw the image using standard <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> drawing commands and then load that image as a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> using the method</p>
<div class="highlight"><pre><span></span><code><span class="n">glCopyTexImage2D</span><span class="p">(</span><span class="w"> </span><span class="n">target</span><span class="p">,</span><span class="w"> </span><span class="n">mipmapLevel</span><span class="p">,</span><span class="w"> </span><span class="n">internalFormat</span><span class="p">,</span>
<span class="w">                                    </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="n">border</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>In this method, target will be <em>GL_TEXTURE_2D</em>; <em>mipmapLevel</em> should be zero; the <em>internalFormat</em> will ordinarily be <em>GL_RGB</em> or <em>GL_RGBA</em>; x and y specify the lower left corner of the rectangle from which the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> will be read; <em>width</em> and <em>height</em> are the size of that rectangle; and border should be 0. As usual with textures, the width and height should ordinarily be powers of two. A call to <em>glCopyTexImage2D</em> will typically look like</p>
<div class="highlight"><pre><span></span><code><span class="n">glCopyTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">GL_RGB</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</code></pre></div>
<p>The end result is that the specified rectangle from the <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr> will be copied to <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> memory and will become the current 2D <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. This works in the same way as a call to <em>glTexImage2D()</em>, except for the source of the image data.</p>
<p>An example can be found in the <abbr title="OpenGL的Java实现。JOGL非常复杂，因为它试图在一个编程系统中支持所有版本的OpenGL。JOGL与Java的Swing和AWT图形无缝集成。">JOGL</abbr> program <a href="../../../en/source/jogl/TextureFromColorBuffer.java">jogl/TextureFromColorBuffer.java</a> or in the C version <a href="../../../en/source/glut/texture-from-color-buffer.c">glut/<abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>-from-color-buffer.c</a>. This program draws the windmill-and-cart scene from <a href="../../c2/s4/#241--构建复杂对象">Subsection 2.4.1</a> and then uses that drawing as a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> on 3D objects. Here is a demo version of the program.</p>
<p><iframe src="../../../en/demos/c4/texture-from-color-buffer.html" width="440" height="460"></iframe></p>
<p>The <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> can be animated! For the <abbr title="A sequence of images that, when displayed quickly one after the other, will produce the impression of continuous motion or change. The term animation also refers to the process of creating such image sequences.">animation</abbr>, a new <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> is drawn for each frame. All the work is done in the program's display function. In that function, the current frame of the windmill-and-cart scene is first drawn as a 2D scene with <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> disabled. This picture is not shown on the computer screen; the drawing is done off-screen and the image will be erased and replaced with the 3D image before it's ever shown on screen. The <em>glCopyTexImage2D()</em> function is then called to copy the scene into the current <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. Then, the <abbr title="In OpenGL, the region of memory that holds the color data for the image. It acts as the drawing surface where images are rendered.">color buffer</abbr> is cleared, <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> is enabled, and a 3D <abbr title="A transformation that maps coordinates in 3D to coordinates in 2D. Projection is used to convert a three-dimensional scene into a two-dimensional image.">projection</abbr> is set up, before finally drawing the 3D object that is seen on the computer screen.</p>
</div>
</div>
</div>
<h2 id="437-纹理对象">4.3.7 <abbr title="可能存储在显卡上的数据结构，可以保存纹理图像、一组mipmaps以及配置数据，例如当前的缩放和放大过滤器设置。使用纹理对象可以快速切换纹理，而无需重新将数据加载到显卡中。">纹理对象</abbr><a class="headerlink" href="#437-纹理对象" title="Permanent link">&para;</a></h2>
<p><strong>Texture Objects</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="8:2"><input checked="checked" id="__tabbed_8_1" name="__tabbed_8" type="radio" /><input id="__tabbed_8_2" name="__tabbed_8" type="radio" /><div class="tabbed-labels"><label for="__tabbed_8_1">中文</label><label for="__tabbed_8_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p><abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.0 中关于纹理的所有内容在 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1 中仍然适用。<abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1 引入了一个名为纹理对象的新特性，以使纹理处理更加高效。<strong><abbr title="可能存储在显卡上的数据结构，可以保存纹理图像、一组mipmaps以及配置数据，例如当前的缩放和放大过滤器设置。使用纹理对象可以快速切换纹理，而无需重新将数据加载到显卡中。">纹理对象</abbr></strong>用于当你需要在同一个程序中使用多个纹理图像时。加载纹理图像的常用方法 <em>glTexImage2D</em>，将数据从你的程序传输到显卡。这是一个昂贵的操作，使用这种方法在多个纹理之间切换可能会严重降低程序的性能。纹理对象提供了在显卡上存储多个纹理数据的可能性。有了纹理对象，你可以使用一个单一的、快速的 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 命令在不同的纹理对象之间切换：你只需要告诉 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 你想要使用哪个纹理对象。（当然，显卡只有有限的内存用于存储纹理，你不能保证所有的纹理对象都会被实际存储在显卡上。不适合放在显卡内存中的纹理对象并不比普通纹理更高效。）</p>
<p>纹理对象由 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 和图形硬件管理。一个纹理对象由一个整数 ID 号标识。要使用一个纹理对象，你需要从 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 获取一个 ID 号。这是通过 <em>glGenTextures</em> 函数完成的：</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="n">glGenTextures</span><span class="p">(</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">textureCount</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="p">)</span>
</code></pre></div>
<p>这个函数可以一次调用生成多个纹理 ID。第一个参数指定你想要多少个 ID。第二个参数说明生成的 ID 将被存储在哪里。它应该是一个至少为 textureCount 长度的数组。例如，如果你计划使用三个纹理对象，你可以说：</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">idList</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="n">glGenTextures</span><span class="p">(</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">idList</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>然后，你可以使用 <em>idList[0]</em>、<em>idList[1]</em> 和 <em>idList[2]</em> 来引用纹理。由于 C 中指针的工作方式，如果你想要获取一个单一的纹理 ID，你可以将一个整型变量的指针作为第二个参数传递给 <em>glGenTextures()</em>。例如：</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">texID</span><span class="p">;</span>
<span class="n">glGenTextures</span><span class="p">(</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">texID</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>新的纹理 ID 将被存储在变量 <em>texID</em> 中。</p>
<p>每个纹理对象都有自己的状态，其中包括纹理参数的值，如 GL_TEXTURE_MIN_FILTER，以及纹理图像本身。要使用特定的纹理对象，你必须首先调用</p>
<div class="highlight"><pre><span></span><code><span class="n">glBindTexture</span><span class="p">(</span><span class="w"> </span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="n">texID</span><span class="w"> </span><span class="p">)</span>
</code></pre></div>
<p>其中 texID 是由 <em>glGenTextures</em> 返回的纹理 ID。在此调用之后，任何对 <em>glTexParameteri</em>、<em>glTexImage2D</em> 或 <em>glCopyTexImage2D</em> 的使用都将应用于 ID 为 texID 的纹理对象。</p>
<p>类似地，当渲染一个带纹理的原素时，所使用的纹理是最近一次使用 <em>glBindTexture</em> 绑定的那个。一个典型的模式是在程序初始化期间加载和配置多个纹理：</p>
<div class="highlight"><pre><span></span><code><span class="n">glGenTextures</span><span class="p">(</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">textureIdList</span><span class="w"> </span><span class="p">);</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">glBindTexture</span><span class="p">(</span><span class="w"> </span><span class="n">textureIDList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">.</span>
<span class="w">    </span><span class="p">.</span><span class="w">  </span><span class="c1">// 加载第 i 个纹理图像</span>
<span class="w">    </span><span class="p">.</span><span class="w">  </span><span class="c1">// 配置第 i 个纹理图像</span>
<span class="w">    </span><span class="p">.</span>
<span class="p">}</span>
</code></pre></div>
<p>然后，在渲染场景时，每次你想要从一个纹理图像切换到另一个纹理图像时，你会调用 <em>glBindTexture</em>。这将比每次想要切换纹理时调用 <em>glTexImage2D</em> 更高效。</p>
<p><abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1 将纹理 ID 零保留为默认纹理对象，最初是绑定的。这是如果你从未调用 <em>glBindTexture</em> 就会使用的纹理对象。这意味着你可以编写使用纹理而不提及 <em>glBindTexture</em> 的程序。（然而，我应该指出，当我们到达 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 时，情况将不再如此。）</p>
<p>小型示例程序 <a href="../../../en/source/glut/texture-objects.c">glut/<abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>-objects.c</a> 展示了如何在 C 中使用纹理对象。它仅在 C 中可用，因为正如我们将看到的，<abbr title="OpenGL的Java实现。JOGL非常复杂，因为它试图在一个编程系统中支持所有版本的OpenGL。JOGL与Java的Swing和AWT图形无缝集成。">JOGL</abbr> 有它自己的处理纹理对象的方式。</p>
</div>
<div class="tabbed-block">
<p>Everything that I've said so far about textures was already true for <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.0. <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1 introduced a new feature called <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> objects to make <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> handling more efficient. <strong>Texture objects</strong> are used when you need to work with several <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> images in the same program. The usual method for loading <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> images, <em>glTexImage2D</em>, transfers data from your program into the graphics card. This is an expensive operation, and switching among multiple textures by using this method can seriously degrade a program's performance. Texture objects offer the possibility of storing <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> data for multiple textures on the graphics card. With <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> objects, you can switch from one <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object to another with a single, fast <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> command: You just have to tell <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> which <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object you want to use. (Of course, the graphics card has only a limited amount of memory for storing textures, and you aren't guaranteed that all of your <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> objects will actually be stored on the graphics card. Texture objects that don't fit in the graphics card's memory are no more efficient than ordinary textures.)</p>
<p>Texture objects are managed by <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> and the graphics hardware. A <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object is identified by an integer ID number. To use a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object, you need to obtain an ID number from <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr>. This is done with the <em>glGenTextures</em> function:</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="n">glGenTextures</span><span class="p">(</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">textureCount</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="p">)</span>
</code></pre></div>
<p>This function can generate multiple <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> IDs with a single call. The first parameter specifies how many IDs you want. The second parameter says where the generated IDs will be stored. It should be an array whose length is at least textureCount. For example, if you plan to use three <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> objects, you can say</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">idList</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="n">glGenTextures</span><span class="p">(</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">idList</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>You can then use <em>idList[0]</em>, <em>idList[1]</em>, and <em>idList[2]</em> to refer to the textures. Because of the way pointers work in C, if you want to get a single <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> ID, you can pass a pointer to an integer variable as the second parameter to <em>glGenTextures()</em>. For example,</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">texID</span><span class="p">;</span>
<span class="n">glGenTextures</span><span class="p">(</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">texID</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>The new <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> ID will be stored in the variable <em>texID</em>.</p>
<p>Every <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object has its own state, which includes the values of <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> parameters such as GL_TEXTURE_MIN_FILTER as well as the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image itself. To work with a specific <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object, you must first call</p>
<div class="highlight"><pre><span></span><code><span class="n">glBindTexture</span><span class="p">(</span><span class="w"> </span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="n">texID</span><span class="w"> </span><span class="p">)</span>
</code></pre></div>
<p>where texID is the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> ID returned by <em>glGenTextures</em>. After this call, any use of <em>glTexParameteri</em>, <em>glTexImage2D</em>, or <em>glCopyTexImage2D</em> will be applied to the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object with ID texID.</p>
<p>Similarly, when a textured primitive is rendered, the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> that is used is the one that was most recently bound using <em>glBindTexture</em>. A typical pattern would be to load and configure a number of textures during program initialization:</p>
<div class="highlight"><pre><span></span><code><span class="n">glGenTextures</span><span class="p">(</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">textureIdList</span><span class="w"> </span><span class="p">);</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">glBindTexture</span><span class="p">(</span><span class="w"> </span><span class="n">textureIDList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">.</span>
<span class="w">    </span><span class="p">.</span><span class="w">  </span><span class="c1">// Load texture image number i</span>
<span class="w">    </span><span class="p">.</span><span class="w">  </span><span class="c1">// Configure texture image number i</span>
<span class="w">    </span><span class="p">.</span>
<span class="p">}</span>
</code></pre></div>
<p>Then, while <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> a scene, you would call <em>glBindTexture</em> every time you want to switch from one <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image to another <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image. This would be much more efficient than calling <em>glTexImage2D</em> every time you want to switch textures.</p>
<p><abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 1.1 reserves <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> ID zero as the default <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object, which is bound initially. It is the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object that you are using if you never call <em>glBindTexture</em>. This means that you can write programs that use textures without ever mentioning <em>glBindTexture</em>. (However, I should note that when we get to <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>, that will no longer be true.)</p>
<p>The small sample program <a href="../../../en/source/glut/texture-objects.c">glut/<abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>-objects.c</a> shows how to use <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> objects in C. In is available only in C since, as we will see, <abbr title="OpenGL的Java实现。JOGL非常复杂，因为它试图在一个编程系统中支持所有版本的OpenGL。JOGL与Java的Swing和AWT图形无缝集成。">JOGL</abbr> has its own way of working with <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> objects.</p>
</div>
</div>
</div>
<h2 id="438-在-c-中加载纹理">4.3.8 在 C 中加载纹理<a class="headerlink" href="#438-在-c-中加载纹理" title="Permanent link">&para;</a></h2>
<p><strong>Loading Textures in C</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="9:2"><input checked="checked" id="__tabbed_9_1" name="__tabbed_9" type="radio" /><input id="__tabbed_9_2" name="__tabbed_9" type="radio" /><div class="tabbed-labels"><label for="__tabbed_9_1">中文</label><label for="__tabbed_9_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>我们已经看到了如何将纹理图像数据从内存加载到 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 中。剩下的问题是，在调用 <code>glTexImage2D</code> 之前如何将图像数据加载到内存中。一种可能性是计算数据——实际上，你的程序可以即时生成纹理数据。然而，更有可能的是，你想要从文件中加载它。本节将探讨如何在 C 语言中完成这项工作。你可能想要使用一个图像处理函数库。有几个免费的图像处理库可用。我将讨论其中之一，FreeImage，它可以与许多图像文件格式一起工作。FreeImage 可以从 <a href="http://freeimage.sourceforge.net/">http://freeimage.sourceforge.net/</a> 获取，但我在 Linux 上简单地通过安装包 <em>libfreeimage-dev</em> 来使用它。为了使我的程序可以使用它，我在 C 程序的顶部添加了 <code>#include "FreeImage.h"</code>，并在 gcc 命令中添加了选项 -lfreeimage 以使库对编译器可用。（有关使用此库的示例程序，请参见 <a href="../../../en/source/glut/texture-demo.c">glut/<abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>-demo.c</a>。）与其详细讨论 FreeImage，我提供了一个使用它从文件加载图像数据的注释良好的函数：</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">imgPixels</span><span class="p">;</span><span class="w"> </span><span class="c1">// 指向内存中纹理的原始 RGB 数据的指针。</span>
<span class="kt">int</span><span class="w"> </span><span class="n">imgWidth</span><span class="p">;</span><span class="w">    </span><span class="c1">// 纹理图像的宽度。</span>
<span class="kt">int</span><span class="w"> </span><span class="n">imgHeight</span><span class="p">;</span><span class="w">   </span><span class="c1">// 纹理图像的高度。</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">loadTexture</span><span class="p">(</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">fileName</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 使用 FreeImage 库加载纹理图像，并将所需的信息存储在全局变量</span>
<span class="w">    </span><span class="c1">// imgPixels, imgWidth, imgHeight 中。参数 fileName 是一个字符串，</span>
<span class="w">    </span><span class="c1">// 包含要从中加载图像的图像文件的名称。如果无法加载图像，</span>
<span class="w">    </span><span class="c1">// 则 imgPixels 将被设置为 null 指针。</span>

<span class="w">    </span><span class="n">imgPixels</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// 空指针，表示尚未读取数据。</span>

<span class="w">    </span><span class="n">FREE_IMAGE_FORMAT</span><span class="w"> </span><span class="n">format</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FreeImage_GetFIFFromFilename</span><span class="p">(</span><span class="n">fileName</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// FREE_IMAGE_FORMAT 是 FreeImage 库定义的类型。</span>
<span class="w">    </span><span class="c1">// 在这里，格式是从文件名中的文件扩展名（如 .png, .jpg 或 .gif）确定的，</span>
<span class="w">    </span><span class="c1">// 支持许多格式。</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">format</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">FIF_UNKNOWN</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Unknown file type for texture image file %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fileName</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">FIBITMAP</span><span class="o">*</span><span class="w"> </span><span class="n">bitmap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FreeImage_Load</span><span class="p">(</span><span class="n">format</span><span class="p">,</span><span class="w"> </span><span class="n">fileName</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// FIBITMAP 是 FreeImage 库定义的类型，表示原始图像数据加上一些元数据，</span>
<span class="w">    </span><span class="c1">// 如宽度、高度以及图像数据的格式。这实际上尝试从指定的文件中读取数据。</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">bitmap</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Failed to load image %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fileName</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">FIBITMAP</span><span class="o">*</span><span class="w"> </span><span class="n">bitmap2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FreeImage_ConvertTo24Bits</span><span class="p">(</span><span class="n">bitmap</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// 这会创建图像的副本，数据以标准 RGB（或 BGR）格式表示，供 OpenGL 使用。</span>

<span class="w">    </span><span class="n">FreeImage_Unload</span><span class="p">(</span><span class="n">bitmap</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// 使用完位图后，应该释放它。</span>
<span class="w">    </span><span class="c1">// 我们已经完成了 bitmap 的使用，但还没有完成 bitmap2 的使用，因为</span>
<span class="w">    </span><span class="c1">// 我们将会继续使用 bitmap2 的数据。</span>

<span class="w">    </span><span class="n">imgPixels</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FreeImage_GetBits</span><span class="p">(</span><span class="n">bitmap2</span><span class="p">);</span><span class="w">  </span><span class="c1">// 获取我们所需的数据！</span>
<span class="w">    </span><span class="n">imgWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FreeImage_GetWidth</span><span class="p">(</span><span class="n">bitmap2</span><span class="p">);</span>
<span class="w">    </span><span class="n">imgHeight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FreeImage_GetHeight</span><span class="p">(</span><span class="n">bitmap2</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">imgPixels</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Texture image loaded from file %s, size %dx%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="n">fileName</span><span class="p">,</span><span class="w"> </span><span class="n">imgWidth</span><span class="p">,</span><span class="w"> </span><span class="n">imgHeight</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Failed to get texture data from %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fileName</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// end loadTexture</span>
</code></pre></div>
<p>这个函数被调用后，我们需要的 <code>glTexImage2D()</code> 数据就在全局变量 <code>imgWidth</code>、<code>imgHeight</code> 和 <code>imgPixels</code> 中（或者 <code>imgPixels</code> 为 0，表示加载图像的尝试失败）。有一个复杂性：FreeImage 会在某些平台上以红/绿/蓝的顺序存储像素的颜色分量，但在其他平台上以蓝/绿/红的顺序存储。第二种数据格式在 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 中被称为 <em>GL_BGR</em>。如果你在 <code>glTexImage2D()</code> 中使用了错误的格式，那么颜色的红色和蓝色分量将会颠倒。为了区分，你可以使用 FreeImage 常量 FI_RGBA_RED，它告诉像素数据中红色分量的位置。如果格式是 <em>GL_RGB</em>，这个常量将是 0；如果格式是 <em>GL_BGR</em>，这个常量将是 2。所以，要在 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 中使用纹理，你可能会说：</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">imgPixels</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 图像数据存在</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">format</span><span class="p">;</span><span class="w"> </span><span class="c1">// 内存中颜色数据的格式</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">FI_RGBA_RED</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="n">format</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GL_RGB</span><span class="p">;</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="n">format</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GL_BGR</span><span class="p">;</span>
<span class="w">    </span><span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">GL_RGBA</span><span class="p">,</span><span class="w"> </span><span class="n">imgWidth</span><span class="p">,</span><span class="w"> </span><span class="n">imgHeight</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">format</span><span class="p">,</span>
<span class="w">                        </span><span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span><span class="w"> </span><span class="n">imgPixels</span><span class="p">);</span>
<span class="w">    </span><span class="n">glEnable</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 没有加载图像数据，所以不要尝试使用纹理。</span>
<span class="w">    </span><span class="n">glDisable</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>为了更加小心，你可以检查图像的宽度和高度是否为 2 的幂。如果不是，你可以使用 FreeImage 库中的 <code>FreeImage_Rescale()</code> 函数来调整大小。</p>
<hr />
<p>FreeImage 是一个庞大且复杂的系统，可能不容易在你的计算机上提供。为了让你更容易地在 C 中尝试纹理，我还包括了一个小型的 C 实用程序，用于从 .rgb 文件中读取纹理。rgb 文件格式相当简单，但 rgb 文件通常比相应的 .png 或 .jpeg 文件大得多。该格式不被广泛支持，但我在 <a href="../../../en/source/glut/textures-rgb">glut/textures-rgb</a> 文件夹中包含了我的示例纹理图像的 .rgb 版本。加载它们的小型库是 <a href="../../../en/source/glut/textures-rgb/readrgb.c">glut/textures-rgb/readrgb.c</a> 及其头文件 <a href="../../../en/source/glut/textures-rgb/readrgb.h">glut/textures-rgb/readrgb.h</a>。（该库来自 <a href="http://paulbourke.net/dataformats/sgirgb/">http://paulbourke.net/dataformats/sgirgb/</a>。）使用该库的示例程序是 <a href="../../../en/source/glut/texture-objects-rgb.c">glut/<abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>-objects-rgb.c</a> 和 <a href="../../../en/source/glut/texture-demo-rgb.c">glut/<abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>-demo-rgb.c</a>。</p>
</div>
<div class="tabbed-block">
<p>We have seen how to load <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image data from memory into <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr>. The problem that remains is how to get the image data into memory before calling <em>glTexImage2D</em>. One possibility is to compute the data—you can actually have your program generate <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> data on the fly. More likely, however, you want to load it from a file. This section looks at how that might be done in C. You will probably want to use a library of image-manipulation functions. Several free image processing libraries are available. I will discuss one of them, FreeImage, which can work with many image file formats. <em>FreeImage</em> can be obtained from <a href="http://freeimage.sourceforge.net/">http://freeimage.sourceforge.net/</a>, but I was able to use it in Linux simply by installing the package <em>libfreeimage-dev</em>. To make it available to my program, I added <code>#include "FreeImage.h"</code> to the top of my C program, and I added the option -lfreeimage to the gcc command to make the library available to the compiler. (See the sample program <a href="../../../en/source/glut/texture-demo.c">glut/<abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>-demo.c</a> for an example that uses this library.) Instead of discussing FreeImage in detail, I present a well-commented function that uses it to load image data from a file:</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">imgPixels</span><span class="p">;</span><span class="w"> </span><span class="c1">// Pointer to raw RGB data for texture in memory.</span>
<span class="kt">int</span><span class="w"> </span><span class="n">imgWidth</span><span class="p">;</span><span class="w">    </span><span class="c1">// Width of the texture image.</span>
<span class="kt">int</span><span class="w"> </span><span class="n">imgHeight</span><span class="p">;</span><span class="w">   </span><span class="c1">// Height of the texture image.</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">loadTexture</span><span class="p">(</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">fileName</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Loads a texture image using the FreeImage library, and stores the</span>
<span class="w">        </span><span class="c1">// required info in global variables imgPixels, imgWidth, imgHeight.</span>
<span class="w">        </span><span class="c1">// The parameter fileName is a string that contains the name of the</span>
<span class="w">        </span><span class="c1">// image file from which the image is to be loaded.  If the image</span>
<span class="w">        </span><span class="c1">// can&#39;t be loaded, then imgPixels will be set to be a null pointer.</span>

<span class="w">    </span><span class="n">imgPixels</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// Null pointer to signal that data has not been read.</span>

<span class="w">    </span><span class="n">FREE_IMAGE_FORMAT</span><span class="w"> </span><span class="n">format</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FreeImage_GetFIFFromFilename</span><span class="p">(</span><span class="n">fileName</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// FREE_IMAGE_FORMAT is a type defined by the FreeImage library.</span>
<span class="w">        </span><span class="c1">// Here, the format is determined from the file extension in</span>
<span class="w">        </span><span class="c1">// the file name, such as .png, .jpg, or .gif.  Many formats</span>
<span class="w">        </span><span class="c1">// are supported.</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">format</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">FIF_UNKNOWN</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Unknown file type for texture image file %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fileName</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">FIBITMAP</span><span class="o">*</span><span class="w"> </span><span class="n">bitmap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FreeImage_Load</span><span class="p">(</span><span class="n">format</span><span class="p">,</span><span class="w"> </span><span class="n">fileName</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// FIBITMAP is a type defined by the FreeImage library, representing</span>
<span class="w">        </span><span class="c1">// the raw image data plus some metadata such as width, height,</span>
<span class="w">        </span><span class="c1">// and the format of the image data.  This actually tries to</span>
<span class="w">        </span><span class="c1">// read the data from the specified file.</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">bitmap</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Failed to load image %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fileName</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">FIBITMAP</span><span class="o">*</span><span class="w"> </span><span class="n">bitmap2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FreeImage_ConvertTo24Bits</span><span class="p">(</span><span class="n">bitmap</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// This creates a copy of the image, with the data represented</span>
<span class="w">        </span><span class="c1">// in standard RGB (or BGR) format, for use with OpenGL.</span>

<span class="w">    </span><span class="n">FreeImage_Unload</span><span class="p">(</span><span class="n">bitmap</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// After finishing with a bitmap, it should be disposed.</span>
<span class="w">        </span><span class="c1">// We are finished with bitmap, but not with bitmap2, since</span>
<span class="w">        </span><span class="c1">// we will continue to use the data from bitmap2.</span>

<span class="w">    </span><span class="n">imgPixels</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FreeImage_GetBits</span><span class="p">(</span><span class="n">bitmap2</span><span class="p">);</span><span class="w">  </span><span class="c1">// Get the data we need!</span>
<span class="w">    </span><span class="n">imgWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FreeImage_GetWidth</span><span class="p">(</span><span class="n">bitmap2</span><span class="p">);</span>
<span class="w">    </span><span class="n">imgHeight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FreeImage_GetHeight</span><span class="p">(</span><span class="n">bitmap2</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">imgPixels</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Texture image loaded from file %s, size %dx%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span>
<span class="w">                        </span><span class="n">fileName</span><span class="p">,</span><span class="w"> </span><span class="n">imgWidth</span><span class="p">,</span><span class="w"> </span><span class="n">imgHeight</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Failed to get texture data from %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fileName</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// end loadTexture</span>
</code></pre></div>
<p>After this function has been called, the data that we need for <em>glTexImage2D()</em> is in the global variables <em>imgWidth</em>, <em>imgHeight</em>, and <em>imgPixels</em> (or imgPixels is 0 to indicate that the attempt to load the image failed). There is one complication: FreeImage will store the color components for a <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> in the order red/green/blue on some platforms but in the order blue/green/red on other platforms. The second data format is called <em>GL_BGR</em> in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr>. If you use the wrong format in <em>glTextImage2D()</em>, then the red and blue components of the color will be reversed. To tell the difference, you can use the FreeImage constant FI_RGBA_RED, which tells the position of the red <abbr title="One of the numbers used in a color model to specify a color. For example, in the RGB color model, a color is specified by three color components representing the amounts of red, green, and blue in the color.">color component</abbr> in <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> data. This constant will be 0 if the format is <em>GL_RGB</em> and will be 2 if the format is <em>GL_BGR</em>. So, to use the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr>, you might say:</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">imgPixels</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// The image data exists</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">format</span><span class="p">;</span><span class="w"> </span><span class="c1">// The format of the color data in memory</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">FI_RGBA_RED</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="n">format</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GL_RGB</span><span class="p">;</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="n">format</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GL_BGR</span><span class="p">;</span>
<span class="w">    </span><span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">GL_RGBA</span><span class="p">,</span><span class="w"> </span><span class="n">imgWidth</span><span class="p">,</span><span class="w"> </span><span class="n">imgHeight</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">format</span><span class="p">,</span>
<span class="w">                        </span><span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span><span class="w"> </span><span class="n">imgPixels</span><span class="p">);</span>
<span class="w">    </span><span class="n">glEnable</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// The image data was not loaded, so don&#39;t attempt to use the texture.</span>
<span class="w">    </span><span class="n">glDisable</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>To be even more careful, you could check that the width and the height of the image are powers of two. If not, you can resize it using the function <em>FreeImage_Rescale()</em> from the FreeImage library.</p>
<hr />
<p>FreeImage is a large, complicated system that might not be easily made available on your computer. To make it easier for you to experiment with textures in C, I have also included a small C utility for reading textures from .rgb files. The rgb file format is fairly simple, but rgb files are generally much larger than the corresponding .png or .jpeg files. The format is not widely supported, but I have included .rgb versions of my sample <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> images in the folder <a href="../../../en/source/glut/textures-rgb">glut/textures-rgb</a>. The small library for loading them into textures is <a href="../../../en/source/glut/textures-rgb/readrgb.c">glut/textures-rgb/readrgb.c</a> and its header file <a href="../../../en/source/glut/textures-rgb/readrgb.h">glut/textures-rgb/readrgb.h</a>. (The library is from <a href="http://paulbourke.net/dataformats/sgirgb/">http://paulbourke.net/dataformats/sgirgb/</a>.) Sample programs that use the library are <a href="../../../en/source/glut/texture-objects-rgb.c">glut/<abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>-objects-rgb.c</a> and <a href="../../../en/source/glut/texture-demo-rgb.c">glut/<abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>-demo-rgb.c</a>.</p>
</div>
</div>
</div>
<h2 id="439-通过-jogl-使用纹理">4.3.9 通过 <abbr title="OpenGL的Java实现。JOGL非常复杂，因为它试图在一个编程系统中支持所有版本的OpenGL。JOGL与Java的Swing和AWT图形无缝集成。">JOGL</abbr> 使用纹理<a class="headerlink" href="#439-通过-jogl-使用纹理" title="Permanent link">&para;</a></h2>
<p><strong>Using Textures with <abbr title="OpenGL的Java实现。JOGL非常复杂，因为它试图在一个编程系统中支持所有版本的OpenGL。JOGL与Java的Swing和AWT图形无缝集成。">JOGL</abbr></strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="10:2"><input checked="checked" id="__tabbed_10_1" name="__tabbed_10" type="radio" /><input id="__tabbed_10_2" name="__tabbed_10" type="radio" /><div class="tabbed-labels"><label for="__tabbed_10_1">中文</label><label for="__tabbed_10_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>我们终于转向在 Java 中使用纹理图像。<abbr title="OpenGL的Java实现。JOGL非常复杂，因为它试图在一个编程系统中支持所有版本的OpenGL。JOGL与Java的Swing和AWT图形无缝集成。">JOGL</abbr> 带有多个类，使得在 Java 中使用纹理相对容易，特别是包 <em>com.jogamp.opengl.util.<abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr></em> 中的 <strong>Texture</strong> 和 <strong>TextureIO</strong> 类，以及包 <em>com.jogamp.opengl.util.<abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>.awt</em> 中的 <strong>AWTTextureIO</strong> 类。有关使用 <abbr title="OpenGL的Java实现。JOGL非常复杂，因为它试图在一个编程系统中支持所有版本的OpenGL。JOGL与Java的Swing和AWT图形无缝集成。">JOGL</abbr> 纹理的示例，请参见示例程序 <a href="../../../en/source/jogl/TextureDemo.java">jogl/TextureDemo.java</a>。</p>
<p>一个 <strong>Texture</strong> 类型的对象代表一个已经被加载到 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 中的纹理。在内部，它使用一个纹理对象来存储纹理及其配置数据。如果 tex 是一个 <strong>Texture</strong> 类型的对象，你可以调用</p>
<div class="highlight"><pre><span></span><code><span class="n">tex</span><span class="p">.</span><span class="na">bind</span><span class="p">(</span><span class="n">gl</span><span class="p">);</span>
</code></pre></div>
<p>在渲染对象时使用纹理图像。参数 gl 像往常一样，是一个表示 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 绘图上下文的 <strong>GL2</strong> 类型的变量。这个函数等价于调用 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 纹理对象的 glBindTexture。你仍然需要通过调用 <em>gl.glEnable(GL2.GL_TEXTURE_2D)</em> 或等价地，</p>
<div class="highlight"><pre><span></span><code><span class="n">tex</span><span class="p">.</span><span class="na">enable</span><span class="p">(</span><span class="n">gl</span><span class="p">);</span>
</code></pre></div>
<p>来启用 <em>GL_TEXTURE_2D</em>。</p>
<p>你可以按照通常的方式设置纹理参数，通过在绑定纹理时调用 gl.glTexParameteri()，但最好使用 Texture 类中的方法来设置参数：</p>
<div class="highlight"><pre><span></span><code><span class="n">tex</span><span class="p">.</span><span class="na">setTexParameteri</span><span class="p">(</span><span class="n">gl</span><span class="p">,</span><span class="w"> </span><span class="n">parameterName</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>
</code></pre></div>
<p>这将在设置纹理参数之前自动绑定纹理对象。例如，</p>
<div class="highlight"><pre><span></span><code><span class="n">tex</span><span class="p">.</span><span class="na">setTexParameteri</span><span class="p">(</span><span class="n">gl</span><span class="p">,</span><span class="w"> </span><span class="n">GL2</span><span class="p">.</span><span class="na">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span><span class="w"> </span><span class="n">GL2</span><span class="p">.</span><span class="na">LINEAR_MIPMAP_LINEAR</span><span class="p">);</span>
</code></pre></div>
<p>所以，一旦你有了 <strong>Texture</strong>，使用起来就相当容易了。但仍然存在创建 <strong>Texture</strong> 对象的问题。为此，你可以使用 <strong>TextureIO</strong> 和 <strong>AWTTextureIO</strong> 类中的静态方法。例如，如果 fileName 是一个图像文件（或指向该文件的路径）的名称，那么你可以这样说</p>
<div class="highlight"><pre><span></span><code><span class="n">tex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TextureIO</span><span class="p">.</span><span class="na">newTexture</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">File</span><span class="p">(</span><span class="n">fileName</span><span class="p">),</span><span class="w"> </span><span class="kc">true</span><span class="p">);</span>
</code></pre></div>
<p>将文件中的纹理加载到 <strong>Texture</strong> 对象 tex 中。这里的 <em>boolean</em> 参数，以及我们将要查看的所有方法中的参数，告诉 <abbr title="OpenGL的Java实现。JOGL非常复杂，因为它试图在一个编程系统中支持所有版本的OpenGL。JOGL与Java的Swing和AWT图形无缝集成。">JOGL</abbr> 是否为纹理创建 <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr>；通过传递 true，我们自动获得一组完整的 <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr>！</p>
<p><strong>一个重要的注意事项</strong>：Java 的纹理创建函数只有在 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 上下文是“当前的”时才会工作。这将在 <strong>GLEventListener</strong> 的事件处理方法中成立，包括 <em>init()</em> 和 <em>display()</em> 方法。然而，在普通方法和构造函数中，这将不成立。</p>
<p>当然，在 Java 中，你更有可能将图像作为程序中的资源存储，而不是作为一个单独的文件。如果 <em>resourceName</em> 是指向图像资源的路径，你可以使用</p>
<div class="highlight"><pre><span></span><code><span class="n">URL</span><span class="w"> </span><span class="n">textureURL</span><span class="p">;</span>
<span class="n">textureURL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getClass</span><span class="p">().</span><span class="na">getClassLoader</span><span class="p">().</span><span class="na">getResource</span><span class="p">(</span><span class="n">resourceName</span><span class="p">);</span>
<span class="n">texture</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TextureIO</span><span class="p">.</span><span class="na">newTexture</span><span class="p">(</span><span class="n">textureURL</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="kc">null</span><span class="p">);</span>
</code></pre></div>
<p>将图像加载到纹理中。</p>
<p>这个版本的 <em>newTexture</em> 的第三个参数指定了图像类型，可以作为一个包含文件后缀如 "png" 或 "jpg" 的字符串给出；null 值告诉 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 自动检测图像类型，这通常应该可以工作。（顺便说一下，我在这里讨论的所有纹理加载代码都可能抛出异常，你必须以某种方式捕获或处理它们。）</p>
<p>所有这些的一个问题是，以这种方式加载的纹理将会是上下颠倒的！这是因为 Java 从图像的顶行存储图像数据到底部，而 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 期望图像数据从底行开始存储。如果这对你有影响，你可以在创建纹理之前翻转图像。为此，你必须将图像加载到 <strong>BufferedImage</strong> 中，然后使用 <strong>AWTTextureIO</strong> 类将其加载到纹理中。例如，假设 resourceName 是程序中图像资源的路径：</p>
<div class="highlight"><pre><span></span><code><span class="n">URL</span><span class="w"> </span><span class="n">textureURL</span><span class="p">;</span>
<span class="n">textureURL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getClass</span><span class="p">().</span><span class="na">getClassLoader</span><span class="p">().</span><span class="na">getResource</span><span class="p">(</span><span class="n">resourceName</span><span class="p">);</span>
<span class="n">BufferedImage</span><span class="w"> </span><span class="n">img</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ImageIO</span><span class="p">.</span><span class="na">read</span><span class="p">(</span><span class="n">textureURL</span><span class="p">);</span>
<span class="n">ImageUtil</span><span class="p">.</span><span class="na">flipImageVertically</span><span class="p">(</span><span class="n">img</span><span class="p">);</span>
<span class="n">texture</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AWTTextureIO</span><span class="p">.</span><span class="na">newTexture</span><span class="p">(</span><span class="n">GLProfile</span><span class="p">.</span><span class="na">getDefault</span><span class="p">(),</span><span class="w"> </span><span class="n">img</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">);</span>
</code></pre></div>
<p><strong>ImageUtil</strong> 类在包 <em>com.jogamp.opengl.util.awt</em> 中定义。在这里，我通过从资源中读取来获取一个 <strong>BufferedImage</strong>。你也可以从文件中读取它——甚至使用 Java 2D 图形绘制它。</p>
</div>
<div class="tabbed-block">
<p>We turn finally to using <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> images in Java. <abbr title="OpenGL的Java实现。JOGL非常复杂，因为它试图在一个编程系统中支持所有版本的OpenGL。JOGL与Java的Swing和AWT图形无缝集成。">JOGL</abbr> comes with several classes that make it fairly easy to use textures in Java, notably the classes <strong>Texture</strong> and <strong>TextureIO</strong> in package <em>com.jogamp.opengl.util.<abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr></em> and <strong>AWTTextureIO</strong> in package <em>com.jogamp.opengl.util.<abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>.awt</em>. For an example of using textures with <abbr title="OpenGL的Java实现。JOGL非常复杂，因为它试图在一个编程系统中支持所有版本的OpenGL。JOGL与Java的Swing和AWT图形无缝集成。">JOGL</abbr>, see the sample program <a href="../../../en/source/jogl/TextureDemo.java">jogl/TextureDemo.java</a>.</p>
<p>An object of type <strong>Texture</strong> represents a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> that has already been loaded into <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr>. Internally, it uses a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object to store the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> and its configuration data. If tex is an object of type <strong>Texture</strong>, you can call</p>
<div class="highlight"><pre><span></span><code><span class="n">tex</span><span class="p">.</span><span class="na">bind</span><span class="p">(</span><span class="n">gl</span><span class="p">);</span>
</code></pre></div>
<p>to use the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image while <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> objects. The parameter, gl, as usual, is a variable of type <strong>GL2</strong> the represents the <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> drawing context. This function is equivalent to calling glBindTexture for the <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object that is used by the Java <strong>Texture</strong>. You still need to enable <em>GL_TEXTURE_2D</em> by calling <em>gl.glEnable(GL2.GL_TEXTURE_2D)</em> or, equivalently,</p>
<div class="highlight"><pre><span></span><code><span class="n">tex</span><span class="p">.</span><span class="na">enable</span><span class="p">(</span><span class="n">gl</span><span class="p">);</span>
</code></pre></div>
<p>You can set <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> parameters in the usual way, by calling gl.glTexParameteri() while the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> is bound, but it is preferable to use a method from the Texture class to set the parameters:</p>
<div class="highlight"><pre><span></span><code><span class="n">tex</span><span class="p">.</span><span class="na">setTexParameteri</span><span class="p">(</span><span class="w"> </span><span class="n">gl</span><span class="p">,</span><span class="w"> </span><span class="n">parameterName</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>This will automatically bind the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object before setting the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> parameter. For example,</p>
<div class="highlight"><pre><span></span><code><span class="n">tex</span><span class="p">.</span><span class="na">setTexParameteri</span><span class="p">(</span><span class="n">gl</span><span class="p">,</span><span class="w"> </span><span class="n">GL2</span><span class="p">.</span><span class="na">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span><span class="w"> </span><span class="n">GL2</span><span class="p">.</span><span class="na">LINEAR_MIPMAP_LINEAR</span><span class="p">);</span>
</code></pre></div>
<p>So, once you have a <strong>Texture</strong>, it's pretty easy to use. But there remains the problem of creating <strong>Texture</strong> objects. For that, you can use static methods in the <strong>TextureIO</strong> and <strong>AWTTextureIO</strong> classes. For example, if fileName is the name of an image file (or a path to such a file), then you can say</p>
<div class="highlight"><pre><span></span><code><span class="n">tex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TextureIO</span><span class="p">.</span><span class="na">newTexture</span><span class="p">(</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">File</span><span class="p">(</span><span class="n">fileName</span><span class="p">),</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>to load a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> from the file into a <strong>Texture</strong> object, <em>tex</em>. The <em>boolean</em> parameter here, and in all the methods we will look at, tells <abbr title="OpenGL的Java实现。JOGL非常复杂，因为它试图在一个编程系统中支持所有版本的OpenGL。JOGL与Java的Swing和AWT图形无缝集成。">JOGL</abbr> whether or not to create <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr> for the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>; by passing <em>true</em>, we automatically get a full set of <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr>!</p>
<p><strong>One important note</strong>: Java's <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> creation functions will only work when an <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> context is "current." This will be true in the event-handling methods of a <strong>GLEventListener</strong>, including the <em>init()</em> and <em>display()</em> methods. However, it will <strong>not</strong> be true in ordinary methods and constructors.</p>
<p>Of course, in Java, you are more likely to store the image as a resource in the program than as a separate file. If <em>resourceName</em> is a path to the image resource, you can load the image into a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> with</p>
<div class="highlight"><pre><span></span><code><span class="n">URL</span><span class="w"> </span><span class="n">textureURL</span><span class="p">;</span>
<span class="n">textureURL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getClass</span><span class="p">().</span><span class="na">getClassLoader</span><span class="p">().</span><span class="na">getResource</span><span class="p">(</span><span class="w"> </span><span class="n">resourceName</span><span class="w"> </span><span class="p">);</span>
<span class="n">texture</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TextureIO</span><span class="p">.</span><span class="na">newTexture</span><span class="p">(</span><span class="n">textureURL</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="kc">null</span><span class="p">);</span>
</code></pre></div>
<p>The third parameter to this version of <em>newTexture</em> specifies the image type and can be given as a string containing a file suffix such as "png" or "jpg"; the value null tells <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> to autodetect the image type, which should work in general. (By the way, all the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>-loading code that I discuss here can throw exceptions, which you will have to catch or otherwise handle in some way.)</p>
<p>One problem with all this is that textures loaded in this way will be upside down! This happens because Java stores image data from the top row of the image to the bottom, whereas <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> expects image data to be stored starting with the bottom row. If this is a problem for you, you can flip the image before using it to create a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. To do that, you have to load the image into a <strong>BufferedImage</strong> and then load that into a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> using the <strong>AWTTextureIO</strong> class. For example, assuming resourceName is a path to an image resource in the program:</p>
<div class="highlight"><pre><span></span><code><span class="n">URL</span><span class="w"> </span><span class="n">textureURL</span><span class="p">;</span>
<span class="n">textureURL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getClass</span><span class="p">().</span><span class="na">getClassLoader</span><span class="p">().</span><span class="na">getResource</span><span class="p">(</span><span class="w"> </span><span class="n">resourceName</span><span class="w"> </span><span class="p">);</span>
<span class="n">BufferedImage</span><span class="w"> </span><span class="n">img</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ImageIO</span><span class="p">.</span><span class="na">read</span><span class="p">(</span><span class="w"> </span><span class="n">textureURL</span><span class="w"> </span><span class="p">);</span>
<span class="n">ImageUtil</span><span class="p">.</span><span class="na">flipImageVertically</span><span class="p">(</span><span class="w"> </span><span class="n">img</span><span class="w"> </span><span class="p">);</span>
<span class="n">texture</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AWTTextureIO</span><span class="p">.</span><span class="na">newTexture</span><span class="p">(</span><span class="n">GLProfile</span><span class="p">.</span><span class="na">getDefault</span><span class="p">(),</span><span class="w"> </span><span class="n">img</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">);</span>
</code></pre></div>
<p>The <strong>ImageUtil</strong> class is defined in package <em>com.jogamp.opengl.util.awt</em>. Here, I obtained a <strong>BufferedImage</strong> by reading it from a resource. You could also read it from a file—or even draw it using Java 2D graphics.</p>
</div>
</div>
</div>







  
    
  
  
    
  


  <aside class="md-source-file">
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="最后更新">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1-2.1-2M12.5 7v5.2l4 2.4-1 1L11 13V7h1.5M11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2v1.8Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">2024年6月8日</span>
  </span>

    
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="创建日期">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.47 15.08 11 13V7h1.5v5.25l3.08 1.83c-.41.28-.79.62-1.11 1m-1.39 4.84c-.36.05-.71.08-1.08.08-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8c0 .37-.03.72-.08 1.08.69.1 1.33.32 1.92.64.1-.56.16-1.13.16-1.72 0-5.5-4.5-10-10-10S2 6.5 2 12s4.47 10 10 10c.59 0 1.16-.06 1.72-.16-.32-.59-.54-1.23-.64-1.92M18 15v3h-3v2h3v3h2v-3h3v-2h-3v-3h-2Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">2024年5月26日</span>
  </span>

    
    
    
  </aside>





                
              </article>
            </div>
          
          
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var tab,labels=set.querySelector(".tabbed-labels");for(tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script>

<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../../..", "features": ["content.code.copy", "content.tabs.link", "navigation.tabs", "navigation.tabs.sticky", "navigation.indexes", "navigation.top", "toc.follow", "content.tooltips"], "search": "../../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.3220b9d7.min.js"></script>
      
        <script src="../../../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="https://unpkg.com/mermaid@9.4.0/dist/mermaid.min.js"></script>
      
    
  <script>document$.subscribe(() => {const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});})</script></body>
</html>