
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="计算机图形学概论(graphicsbook)">
      
      
      
        <link rel="canonical" href="https://hellowac.github.io/graphicsbook-zh-cn/cn/c5/s3/">
      
      
        <link rel="prev" href="../s2/">
      
      
        <link rel="next" href="../../c6/">
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.5.18">
    
    
      
        <title>5.3 其他功能 - 计算机图形学概论</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.66ac8b77.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.06af60db.min.css">
      
      

  
  
  
  
  <style>:root{--md-annotation-icon:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M22 12a10 10 0 0 1-10 10A10 10 0 0 1 2 12 10 10 0 0 1 12 2a10 10 0 0 1 10 10M6 13h8l-3.5 3.5 1.42 1.42L17.84 12l-5.92-5.92L10.5 7.5 14 11H6v2Z"/></svg>');}</style>


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
   <link href="../../../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
        html.glightbox-open { overflow: initial; height: 100%; }
        .gslide-title { margin-top: 0px; user-select: text; }
        .gslide-desc { color: #666; user-select: text; }
        .gslide-image img { background: white; }
        
            .gscrollbar-fixer { padding-right: 15px; }
            .gdesc-inner { font-size: 0.75rem; }
            body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
            body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
            body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}
            </style> <script src="../../../assets/javascripts/glightbox.min.js"></script></head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="default" data-md-color-accent="red">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#53-其他功能" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="计算机图形学概论" class="md-header__button md-logo" aria-label="计算机图形学概论" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            计算机图形学概论
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              5.3 其他功能
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
      <div class="md-header__option">
  <div class="md-select">
    
    <button class="md-header__button md-icon" aria-label="选择当前语言">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m12.87 15.07-2.54-2.51.03-.03A17.52 17.52 0 0 0 14.07 6H17V4h-7V2H8v2H1v2h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04M18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12m-2.62 7 1.62-4.33L19.12 17h-3.24Z"/></svg>
    </button>
    <div class="md-select__inner">
      <ul class="md-select__list">
        
          <li class="md-select__item">
            <a href="/graphicsbook-zh-cn/en/" hreflang="en" class="md-select__link">
              English
            </a>
          </li>
        
          <li class="md-select__item">
            <a href="/graphicsbook-zh-cn/cn/" hreflang="cn" class="md-select__link">
              中文
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</div>
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/hellowac/graphicsbook-zh-cn" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    graphicsbook
  </div>
</a>
      </div>
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../" class="md-tabs__link">
        
  
    
  
  首页

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../preface/" class="md-tabs__link">
        
  
    
  
  前言

      </a>
    </li>
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c1/" class="md-tabs__link">
          
  
    
  
  1.简介

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c2/" class="md-tabs__link">
          
  
    
  
  2.二维图形

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c3/" class="md-tabs__link">
          
  
    
  
  3.几何

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c4/" class="md-tabs__link">
          
  
    
  
  4.灯光和材质

        </a>
      </li>
    
  

      
        
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../" class="md-tabs__link">
          
  
    
  
  5.three.js

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c6/" class="md-tabs__link">
          
  
    
  
  6.WebGL

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c7/" class="md-tabs__link">
          
  
    
  
  7.WebGL 3D

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c8/" class="md-tabs__link">
          
  
    
  
  8.高阶3D

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c9/" class="md-tabs__link">
          
  
    
  
  9.WEBGPU

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../a1/" class="md-tabs__link">
          
  
    
  
  附录

        </a>
      </li>
    
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../.." class="md-tabs__link">
        
  
    
  
  关于

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="计算机图形学概论" class="md-nav__button md-logo" aria-label="计算机图形学概论" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    计算机图形学概论
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/hellowac/graphicsbook-zh-cn" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    graphicsbook
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    首页
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../preface/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    前言
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c1/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    1.简介
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_3" id="__nav_3_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            1.简介
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 1 节 绘画与绘图
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 2 节：三维(3D)图形的要素
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 3 节：硬件与软件
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c2/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    2.二维图形
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_4" id="__nav_4_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            2.二维图形
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第1节: 像素、坐标和颜色
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第2节: 形状
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第3节: 变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第4节: 分层建模
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第5节: Java 绘制2D
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第6节: HTML Canvas图形
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第7节: SVG：一种场景描述语言
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c3/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    3.几何
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_5" id="__nav_5_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            3.几何
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.1 OpenGL 1.1 中的形状和颜色
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.2 3D 坐标和变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.3 投影与观看
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.4 多边形网格和 glDrawArrays
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.5 部分线性代数基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.6 使用 GLUT 和 JOGL
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c4/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    4.灯光和材质
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_6" id="__nav_6_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6">
            <span class="md-nav__icon md-icon"></span>
            4.灯光和材质
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.1 照明简介
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.2 OpenGL 1.1 中的光和材质
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.3 图像纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.4 灯光、相机、动作
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" checked>
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    5.three.js
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_7" id="__nav_7_label" tabindex="">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_7">
            <span class="md-nav__icon md-icon"></span>
            5.three.js
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.1 Three.js 基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.2 构建对象
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    5.3 其他功能
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    5.3 其他功能
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#531-实例化网格" class="md-nav__link">
    <span class="md-ellipsis">
      5.3.1 实例化网格
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#532-用户输入" class="md-nav__link">
    <span class="md-ellipsis">
      5.3.2 用户输入
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#533-阴影" class="md-nav__link">
    <span class="md-ellipsis">
      5.3.3 阴影
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#534-立方体贴图纹理和天空盒" class="md-nav__link">
    <span class="md-ellipsis">
      5.3.4 立方体贴图纹理和天空盒
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#535-反射和折射" class="md-nav__link">
    <span class="md-ellipsis">
      5.3.5 反射和折射
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c6/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    6.WebGL
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_8" id="__nav_8_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8">
            <span class="md-nav__icon md-icon"></span>
            6.WebGL
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.1 可编程流水线
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.2 第一个例子
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.3 GLSL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.4 图像纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.5 实现 2D 变换
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c7/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    7.WebGL 3D
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_9" id="__nav_9_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9">
            <span class="md-nav__icon md-icon"></span>
            7.WebGL 3D
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.1 3D变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.2 照明和材质
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.3 纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.4 帧缓冲区
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.5 WebGL 扩展
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c8/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    8.高阶3D
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_10" id="__nav_10_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_10_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10">
            <span class="md-nav__icon md-icon"></span>
            8.高阶3D
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c8/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8.1 光线追踪
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c8/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8.2 路径追踪
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_11" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c9/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    9.WEBGPU
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_11" id="__nav_11_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_11_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_11">
            <span class="md-nav__icon md-icon"></span>
            9.WEBGPU
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.1 WebGPU 基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.2 实例和索引
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.3 WGSL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.4 WebGPU 中的 3D 图形
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.5 纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.6 计算着色器
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.7 细节
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_12" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../a1/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    附录
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_12" id="__nav_12_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_12_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_12">
            <span class="md-nav__icon md-icon"></span>
            附录
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a2/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Blender 3D建模
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a3/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Gimp和Inkscape
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../source/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    示例程序源代码
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../glossary/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    术语表
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    关于
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#531-实例化网格" class="md-nav__link">
    <span class="md-ellipsis">
      5.3.1 实例化网格
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#532-用户输入" class="md-nav__link">
    <span class="md-ellipsis">
      5.3.2 用户输入
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#533-阴影" class="md-nav__link">
    <span class="md-ellipsis">
      5.3.3 阴影
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#534-立方体贴图纹理和天空盒" class="md-nav__link">
    <span class="md-ellipsis">
      5.3.4 立方体贴图纹理和天空盒
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#535-反射和折射" class="md-nav__link">
    <span class="md-ellipsis">
      5.3.5 反射和折射
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="53-其他功能">5.3 其他功能<a class="headerlink" href="#53-其他功能" title="Permanent link">&para;</a></h1>
<p><strong>Other Features</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="1:2"><input checked="checked" id="__tabbed_1_1" name="__tabbed_1" type="radio" /><input id="__tabbed_1_2" name="__tabbed_1" type="radio" /><div class="tabbed-labels"><label for="__tabbed_1_1">中文</label><label for="__tabbed_1_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>我们将以对<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>的一些额外功能的审视来结束这一章。在这个过程中，你将了解到一些3D图形的新方面。</p>
</div>
<div class="tabbed-block">
<p>We will finish this chapter with a look at a few additional features of <abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr>. In the process, you will learn about some new aspects of 3D graphics.</p>
</div>
</div>
</div>
<h2 id="531-实例化网格">5.3.1 实例化网格<a class="headerlink" href="#531-实例化网格" title="Permanent link">&para;</a></h2>
<p><strong>Instanced Meshes</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="2:2"><input checked="checked" id="__tabbed_2_1" name="__tabbed_2" type="radio" /><input id="__tabbed_2_2" name="__tabbed_2" type="radio" /><div class="tabbed-labels"><label for="__tabbed_2_1">中文</label><label for="__tabbed_2_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p><strong><em>THREE.InstancedMesh</em></strong> 类使得能够快速渲染多个对象，可能是大量的对象，这些对象使用相同的几何体，但在应用到它们的变换上有所不同，并且在材质颜色上也可能有所不同。每个对象的副本被称为一个“实例”，创建所有副本的过程称为实例化绘制或实例化。在 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0（以及在 <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 中使用扩展）中，可以使用单个函数调用来绘制所有实例，这非常高效。</p>
<p><strong><em>InstancedMesh</em></strong> 使用起来相当容易。在构造函数中，除了网格的几何体和材质外，还需要指定它支持的最大实例数量：</p>
<div class="highlight"><pre><span></span><code><span class="nx">instances</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">InstancedMesh</span><span class="p">(</span><span class="nx">geometry</span><span class="p">,</span><span class="w"> </span><span class="nx">material</span><span class="p">,</span><span class="w"> </span><span class="nx">count</span><span class="p">)</span>
</code></pre></div>
<p>要为第 <em>i</em> 个实例设置变换，可以调用：</p>
<div class="highlight"><pre><span></span><code><span class="nx">instances</span><span class="p">.</span><span class="nx">setMatrixAt</span><span class="p">(</span><span class="w"> </span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">matrix</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>其中 <em><abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr></em> 是类型为 <strong><em>THREE.Matrix4</em></strong> 的对象，表示建模变换。类似地，可以使用以下方式为第 <em>i</em> 个实例设置颜色：</p>
<div class="highlight"><pre><span></span><code><span class="nx">instances</span><span class="p">.</span><span class="nx">setColorAt</span><span class="p">(</span><span class="w"> </span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">color</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>其中 <em>color</em> 是类型为 <strong><em>THREE.Color</em></strong> 的对象。实例颜色是可选的。如果提供了它们，它们将替换材质的颜色属性。</p>
<p><strong><em>Matrix4</em></strong> 类包括一些方法，可以轻松地创建变换矩阵。构造函数：</p>
<div class="highlight"><pre><span></span><code><span class="nx">matrix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">Matrix4</span><span class="p">();</span>
</code></pre></div>
<p>创建了一个单位矩阵，然后可以对其进行修改。例如，方法 <em><abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>.makeTranslation(dx,dy,dz)</em> 将当前矩阵替换为平移变换矩阵，平移向量为 <em>(dx,dy,dz)</em>。有用于制作缩放和旋转矩阵的函数。要制作更复杂的变换，有一个用于矩阵乘法的函数。</p>
<p>示例程序 <a href="../../../en/source/threejs/instanced-mesh.html">threejs/instanced-mesh.html</a> 使用单个 <strong><em>InstancedMesh</em></strong> 创建了 1331 个球体，排列在一个 11x11x11 的立方体中。要将球体移动到位置，对每个实例应用了不同的平移。还为每个实例设置了实例颜色。</p>
<p><a class="glightbox" href="../../../en/c5/instanced-mesh.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c5/instanced-mesh.png" /></a></p>
</div>
<div class="tabbed-block">
<p>The class <strong><em>THREE.InstancedMesh</em></strong> makes it possible to quickly render several objects, possibly a large number of objects, that use the same geometry but differ in the transformations that are applied to them and, possibly, in their <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> color. Each copy of the object is called an "instance," and the process of creating all of the copies is called <abbr title="The ability to render multiple versions of a primitive with a single function call. Each copy can have its own values for certain attributes, such as color or transformation.">instanced drawing</abbr> or instancing. In <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 2.0 (and in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> 1.0 with an extension), it is possible to draw all of the instances with a single function call, making it very efficient.</p>
<p><strong><em>InstancedMesh</em></strong> is fairly easy to use. Along with the geometry and <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> for the mesh, the <abbr title="In object-oriented programming, a subroutine that is used to create objects. A constructor for a class creates and initializes objects belonging to that class.">constructor</abbr> specifies the maximum number of instances that it can support:</p>
<div class="highlight"><pre><span></span><code><span class="nx">instances</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">InstancedMesh</span><span class="p">(</span><span class="nx">geometry</span><span class="p">,</span><span class="w"> </span><span class="nx">material</span><span class="p">,</span><span class="w"> </span><span class="nx">count</span><span class="p">)</span>
</code></pre></div>
<p>To set the transformation for instance number <em>i</em>, you can call</p>
<div class="highlight"><pre><span></span><code><span class="nx">instances</span><span class="p">.</span><span class="nx">setMatrixAt</span><span class="p">(</span><span class="w"> </span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">matrix</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>where <em><abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr></em> is an object of type <strong><em>THREE.Matrix4</em></strong> representing the <abbr title="A transformation that is applied to an object to map that object into the world coordinate system or into the object coordinate system for a more complex, hierarchical object.">modeling transformation</abbr>. Similarly, you can set the color for instance number <em>i</em> with</p>
<div class="highlight"><pre><span></span><code><span class="nx">instances</span><span class="p">.</span><span class="nx">setColorAt</span><span class="p">(</span><span class="w"> </span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">color</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>where <em>color</em> is of type <strong><em>THREE.Color</em></strong>. Instance colors are optional. If provided, they replace the color property of <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr>.</p>
<p>The <strong><em>Matrix4</em></strong> class includes methods that make it easy to create a transformation <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>. The <abbr title="In object-oriented programming, a subroutine that is used to create objects. A constructor for a class creates and initializes objects belonging to that class.">constructor</abbr></p>
<div class="highlight"><pre><span></span><code><span class="nx">matrix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">Matrix4</span><span class="p">();</span>
</code></pre></div>
<p>creates an <abbr title="The n-by-n identity matrix is an n-by-n matrix which has ones on the diagonal and zeros elsewhere. Multiplication of any matrix B by the identity matrix, in either order, leaves B unchanged. Multiplication of an n-dimensional vector by the n-by-n identity matrix leaves the vector unchanged; that is, the identity matrix is the matrix for the identity transformation.">identity matrix</abbr>, which can then be modified. For example, the method <em><abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>.makeTranslation(dx,dy,dz)</em> replaces the current <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> with the transformation <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> for a <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr> by the <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> <em>(dx,dy,dz)</em>. There are functions for making <abbr title="A geometric transform that multiplies each coordinate of a point by a number called the scaling factor. Scaling increases or decreases the size of an object, but also moves its points closer to or farther from the origin. Scaling can be uniform—the same in every direction—or non-uniform—with a different scaling factor in each coordinate direction. A negative scaling factor can be used to apply a reflection.">scaling</abbr> and <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> matrices. To make more complex transformations, there is a function for multiplying matrices.</p>
<p>The sample program <a href="../../../en/source/threejs/instanced-mesh.html">threejs/instanced-mesh.html</a> uses a single <strong><em>InstancedMesh</em></strong> to make 1331 spheres, arranged in an 11-by-11-by-11 cube. To move the spheres into position, different translations are applied to each instance. An instance color is also set for each instance.</p>
<p><a class="glightbox" href="../../../en/c5/instanced-mesh.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c5/instanced-mesh.png" /></a></p>
</div>
</div>
</div>
<h2 id="532-用户输入">5.3.2 用户输入<a class="headerlink" href="#532-用户输入" title="Permanent link">&para;</a></h2>
<p><strong>User Input</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="3:2"><input checked="checked" id="__tabbed_3_1" name="__tabbed_3" type="radio" /><input id="__tabbed_3_2" name="__tabbed_3" type="radio" /><div class="tabbed-labels"><label for="__tabbed_3_1">中文</label><label for="__tabbed_3_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>大多数实际程序需要某种形式的用户交互。对于Web应用程序，程序当然可以使用HTML小部件（如按钮和文本输入框）获取用户输入。但在许多程序中，直接使用鼠标与3D世界的交互更为自然。</p>
<p>最基础的例子是使用鼠标旋转场景。在<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>中，可以使用<strong><em>TrackballControls</em></strong>类或<strong><em>OrbitControls</em></strong>类实现旋转。注意，这两个类都支持触摸屏以及鼠标交互。类之间的主要区别在于，使用OrbitControls时，旋转受到限制，使得正y轴始终是视图中的上方。而<em>TrackballControls</em>则允许完全自由的旋转。另一个区别是，<em>TrackballControls</em>旨在仅与连续动画的场景一起使用。OrbitControls用于大多数示例程序和演示中的旋转。<em>TrackballControls</em>仅在<a href="../../../en/source/threejs/full-window.html">threejs/full-window.html</a>和<a href="../../../en/source/threejs/curves-and-surfaces.html">threejs/curves-and-surfaces.html</a>中使用。</p>
<p>这两个控制类不是主要<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em> JavaScript文件的一部分。它们可以从模块"OrbitControls.js"和"TrackballControls.js"导入，这些模块可以在教科书源文件夹的<a href="https://math.hws.edu/graphicsbook/source/threejs/script/controls">threejs/script/controls</a>文件夹中找到，或在<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>下载包的examples/jsm/loaders文件夹中找到。</p>
<p>这两个类以类似的方式使用。我将首先讨论<strong><em>OrbitControls</em></strong>。在我的示例中，我创建了一个相机并将其从原点移开。我通常向相机对象添加一个灯光对象，以便灯光随着相机移动，为相机可见的任何对象提供一些照明。<strong><em>OrbitControls</em></strong>对象用于围绕场景旋转相机。控制对象的构造函数有两个参数，相机和渲染场景的画布。这是一个典型的设置：</p>
<div class="highlight"><pre><span></span><code><span class="nx">camera</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">PerspectiveCamera</span><span class="p">(</span><span class="mf">45</span><span class="p">,</span><span class="w"> </span><span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span><span class="o">/</span><span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span><span class="p">,</span><span class="w"> </span><span class="mf">0.1</span><span class="p">,</span><span class="w"> </span><span class="mf">100</span><span class="p">);</span>
<span class="nx">camera</span><span class="p">.</span><span class="nx">position</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="mf">15</span><span class="p">,</span><span class="mf">35</span><span class="p">);</span>
<span class="nx">camera</span><span class="p">.</span><span class="nx">lookAt</span><span class="p">(</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">Vector3</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// 相机朝向原点</span>

<span class="kd">let</span><span class="w"> </span><span class="nx">light</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">PointLight</span><span class="p">(</span><span class="mh">0xffffff</span><span class="p">,</span><span class="w"> </span><span class="mf">0.6</span><span class="p">);</span>
<span class="nx">camera</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">light</span><span class="p">);</span><span class="w">  </span><span class="c1">// 视点灯光随相机移动</span>
<span class="nx">scene</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">camera</span><span class="p">);</span>

<span class="nx">controls</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">OrbitControls</span><span class="p">(</span><span class="w"> </span><span class="nx">camera</span><span class="p">,</span><span class="w"> </span><span class="nx">canvas</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>构造函数在<em>canvas</em>上安装了侦听器，以便控件可以响应鼠标事件。如果正在运行动画，你需要做的其他事情就是在渲染场景之前调用：</p>
<div class="highlight"><pre><span></span><code><span class="nx">controls</span><span class="p">.</span><span class="nx">update</span><span class="p">();</span>
</code></pre></div>
<p>用户将能够通过使用左键点击并拖动来旋转场景。控件还可以通过使用右键点击并拖动来“<abbr title="一种几何变换，它将点的每个坐标添加给定的平移量。平移用于移动对象而不改变其大小或方向。">平移</abbr>”（在屏幕平面上拖动场景）和使用中键或滚轮来“<abbr title="一种几何变换，它将点的每个坐标乘以一个称为缩放因子的数。缩放增加或减少对象的大小，但也将其点移动到原点更近或更远的位置。缩放可以是均匀的——在每个方向上都相同——或非均匀的——在每个坐标方向上具有不同的缩放因子。可以使用负的缩放因子来应用反射。">缩放</abbr>”（向前和向后移动相机）。要禁用缩放和平移，可以设置：</p>
<div class="highlight"><pre><span></span><code><span class="nx">controls</span><span class="p">.</span><span class="nx">enablePan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span>
<span class="nx">controls</span><span class="p">.</span><span class="nx">enableZoom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span>
</code></pre></div>
<p>你可以通过调用<em>controls.reset()</em>来恢复场景的原始视图。</p>
<p>如果你的程序没有运行连续的动画，你需要一种方法来响应用户操作重新渲染场景。当用户拖动鼠标时，<em>controls</em>对象会生成一个“change”事件。你可以为该事件添加一个侦听器，通过重绘场景来响应事件。要做到这一点，只需调用：</p>
<div class="highlight"><pre><span></span><code><span class="nx">controls</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="w"> </span><span class="s2">&quot;change&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">callback</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>其中<em>callback()</em>是在事件发生时应该调用的函数。如果你有一个函数<em>render()</em>来渲染你的场景，你可以简单地将render作为callback的值传递。</p>
<p>遗憾的是，<strong><em>TrackballControls</em></strong>对象不发出“change”事件，似乎没有办法在没有运行动画的情况下使用它。有了动画，<em>TrackballControls</em>的使用方法与<em>OrbitControls</em>相同，只是平移和缩放的属性是<em>controls.noPan</em>和<em>controls.noZoom</em>；应该将它们设置为<em>true</em>以禁用平移和缩放。<strong><em>TrackballControls</em></strong>的一个不错的特性是它们实现了惯性：当用户在拖动后释放鼠标时，场景的运动会逐渐停止，而不是突然停止。</p>
<hr />
<p>一种更有趣的鼠标交互形式是让用户通过点击场景中的对象来选择它们。问题在于确定用户点击了哪个对象。一般程序如下：从相机通过用户在屏幕上点击的点发出一条射线，并找到场景中第一条被该射线相交的对象。那就是在用户点击点可见的对象。不幸的是，这个过程涉及大量计算。幸运的是，<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>有一个类可以为你完成这项工作：<strong><em>THREE.Raycaster</em></strong>。</p>
<p><strong><em>Raycaster</em></strong>可以用来找到射线与场景中对象的交点。（射线只是一条线的一半，从某个给定的起始点向给定方向无限延伸。）你可以创建一个射线投射器对象在整个程序中使用：</p>
<div class="highlight"><pre><span></span><code><span class="nx">raycaster</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">Raycaster</span><span class="p">();</span>
</code></pre></div>
<p>要告诉它使用哪个射线，可以调用</p>
<div class="highlight"><pre><span></span><code><span class="nx">raycaster</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="w"> </span><span class="nx">startingPoint</span><span class="p">,</span><span class="w"> </span><span class="nx">direction</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>其中两个参数都是<strong><em>THREE.Vector3</em></strong>类型。它们的值以世界坐标为准，这是你用于整个场景的坐标系统。<em>direction</em>必须是规范化的向量，长度等于一。例如，假设你想要发射激光枪....<em>startingPoint</em>是枪的位置，<em>direction</em>是枪指向的方向。使用这些参数配置射线投射器，你可以用它来找出哪个对象被激光束击中。</p>
<p>或者，更方便地处理用户输入，你可以基于相机和屏幕上的点表达射线：</p>
<div class="highlight"><pre><span></span><code><span class="nx">raycaster</span><span class="p">.</span><span class="nx">setFromCamera</span><span class="p">(</span><span class="w"> </span><span class="nx">screenCoords</span><span class="p">,</span><span class="w"> </span><span class="nx">camera</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p><em>screenCoords</em>以<strong><em>THREE.Vector2</em></strong>的形式给出，以裁剪坐标表示。这意味着水平坐标从视口左侧的-1到右侧的1，垂直坐标从底部的-1到顶部的1。（在<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>中，裁剪坐标称为“规范化设备坐标”。）所以，我们需要将画布上的像素坐标转换为裁剪坐标。这里有一种方法可以做到这一点，给定一个鼠标事件，<em>evt</em>：</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">canvas</span><span class="p">.</span><span class="nx">getBoundingClientRect</span><span class="p">();</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">evt</span><span class="p">.</span><span class="nx">clientX</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">r</span><span class="p">.</span><span class="nx">left</span><span class="p">;</span><span class="w"> </span><span class="c1">// 将鼠标位置转换为画布像素坐标</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">evt</span><span class="p">.</span><span class="nx">clientY</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">r</span><span class="p">.</span><span class="nx">top</span><span class="p">;</span>

<span class="kd">let</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2</span><span class="o">*</span><span class="nx">x</span><span class="o">/</span><span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// 将画布像素坐标转换为裁剪坐标</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2</span><span class="o">*</span><span class="nx">y</span><span class="o">/</span><span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span><span class="p">;</span>

<span class="nx">raycaster</span><span class="p">.</span><span class="nx">setFromCamera</span><span class="p">(</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">Vector2</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">),</span><span class="w"> </span><span class="nx">camera</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>一旦你告诉了射线投射器使用哪个射线，它就准备好找到射线与场景中对象的交点了。这可以通过函数完成：</p>
<div class="highlight"><pre><span></span><code><span class="nx">raycaster</span><span class="p">.</span><span class="nx">intersectObjects</span><span class="p">(</span><span class="w"> </span><span class="nx">objectArray</span><span class="p">,</span><span class="w"> </span><span class="nx">recursive</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>第一个参数是一个<strong><em>Object3D</em></strong>数组。射线投射器将在数组中搜索其当前射线与对象的交点。如果第二个参数是<em>true</em>，它还将搜索场景图中那些对象的后代；如果是false或省略，则只搜索数组中的对象。例如，要搜索与场景中所有对象的交点，请使用：</p>
<div class="highlight"><pre><span></span><code><span class="nx">raycaster</span><span class="p">.</span><span class="nx">intersectObjects</span><span class="p">(</span><span class="w"> </span><span class="nx">scene</span><span class="p">.</span><span class="nx">children</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p><em>intersectObjects</em>的返回值是一个JavaScript对象数组。数组中的每个项目代表射线与<strong><em>Object3D</em></strong>的交点。该函数找到所有这样的交点，而不仅仅是第一个。如果没有找到交点，数组为空。数组按从射线起始点起的距离递增排序。如果你只想要第一个交点，使用数组的第一个元素。</p>
<p>数组中的每个元素都是一个对象，其属性包含有关交点的信息。假设项目是数组元素之一。那么最有用属性是：item.object，被射线相交的<strong><em>Object3D</em></strong>；和item.point，交点，以世界坐标中的<strong><em>Vector3</em></strong>给出。这些信息足以实现一些有趣的用户交互。</p>
<p>下面的演示使用一些基本的鼠标交互，让用户编辑场景。场景显示了一些细口黄色圆柱体站在绿色基座上。用户可以拖动圆柱体，添加和删除圆柱体，以及旋转场景。一组单选按钮让用户选择鼠标执行的操作。</p>
<p><iframe src="../../../en/demos/c5/raycaster-input.html" width="620" height="430"></iframe></p>
<p>让我们看看这些操作是如何实现的。程序中唯一的对象是基座和圆柱体。在程序中，基座被称为<em>ground</em>，所有对象都是一个名为<em>world</em>的<strong><em>Object3D</em></strong>的子对象。（我使用world对象，可以轻松地旋转所有可见对象的集合，而不需要移动相机或灯光。）对于所有拖动、添加和删除操作，我寻找这些对象与从相机通过鼠标位置的射线的交点：</p>
<div class="highlight"><pre><span></span><code><span class="nx">raycaster</span><span class="p">.</span><span class="nx">setFromCamera</span><span class="p">(</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">Vector2</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">),</span><span class="w"> </span><span class="nx">camera</span><span class="w"> </span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">intersects</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">raycaster</span><span class="p">.</span><span class="nx">intersectObjects</span><span class="p">(</span><span class="w"> </span><span class="nx">world</span><span class="p">.</span><span class="nx">children</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>如果<em>intersects.length</em>为零，则没有交点，没有什么可做的。否则，我查看<em>intersects[0]</em>，它表示与鼠标位置可见的对象的交点。所以，<em>intersects[0].object</em>是用户点击的对象，<em>intersects[0].point</em>是交点。</p>
<p>删除操作最容易实现：当用户点击一个圆柱体时，圆柱体应该从场景中删除。如果第一个交点是与<em>ground</em>，那么什么都不删除。否则，被点击的对象是一个圆柱体，应该被删除：</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="nx">intersects</span><span class="p">[</span><span class="mf">0</span><span class="p">].</span><span class="nx">object</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nx">ground</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">world</span><span class="p">.</span><span class="nx">remove</span><span class="p">(</span><span class="w"> </span><span class="nx">intersects</span><span class="p">[</span><span class="mf">0</span><span class="p">].</span><span class="nx">object</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="nx">render</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>对于添加操作，我们只有在用户点击地面时才应该添加一个圆柱体。在这种情况下，交点告诉了我们应该在哪里添加圆柱体。这里有一个有趣的问题是，我们以世界坐标的形式获得了交点，但为了将圆柱体作为<em>world</em>的子对象添加，我需要知道交点在<em>world</em>的局部坐标系中的位置。如果world已经旋转了，那么这两个坐标系将会不同。幸运的是，每个<strong><em>Object3D</em></strong>都有一个<em>worldToLocal(v)</em>方法，可以用来将<strong><em>Vector3</em></strong> v从世界坐标转换为该对象的局部坐标。这个方法不会返回一个值；它修改向量v的坐标。（还有一个<em>localToWorld</em>方法。）所以，添加操作可以这样实现：</p>
<div class="highlight"><pre><span></span><code><span class="nx">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">intersects</span><span class="p">[</span><span class="mf">0</span><span class="p">];</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">object</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">ground</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">locationX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">item</span><span class="p">.</span><span class="nx">point</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span><span class="w">  </span><span class="c1">// 交点的世界坐标</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">locationZ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">item</span><span class="p">.</span><span class="nx">point</span><span class="p">.</span><span class="nx">z</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">Vector3</span><span class="p">(</span><span class="nx">locationX</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">locationZ</span><span class="p">);</span><span class="w"> </span><span class="c1">// y总是0</span>
<span class="w">    </span><span class="nx">world</span><span class="p">.</span><span class="nx">worldToLocal</span><span class="p">(</span><span class="nx">coords</span><span class="p">);</span><span class="w"> </span><span class="c1">// 转换为局部坐标</span>
<span class="w">    </span><span class="nx">addCylinder</span><span class="p">(</span><span class="nx">coords</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">coords</span><span class="p">.</span><span class="nx">z</span><span class="p">);</span><span class="w"> </span><span class="c1">// 在校正后的位置添加圆柱体</span>
<span class="w">    </span><span class="nx">render</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>对于拖动操作，我们可以使用与删除相同的测试来确定哪个圆柱体被点击。然而，随着用户拖动鼠标移动圆柱体的问题引发了一个新问题：我们怎么知道在鼠标移动时要将圆柱体放在哪里？我们不知何故必须将新鼠标位置转换为圆柱体的新位置。为此，我们可以再次使用射线投射器。我最初的想法是从相机通过新鼠标位置创建一条射线，使用该射线找到它与地面的交点，然后将圆柱体移动到那个交点。不幸的是，这会把圆柱体的<strong>底部</strong>放在鼠标位置，当我一开始移动鼠标时，圆柱体就会跳到错误的位置。我意识到我不想追踪与地面的交点；我需要追踪与原始交点高度相同的平面的交点。为了实现这一点，我在拖动期间添加了一个那个高度的不可见平面，并使用与该平面的交点代替与地面的交点。（你可以在<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>中拥有不可见的对象——只需将材质的<em>visible</em>属性设置为<em>false</em>。）</p>
</div>
<div class="tabbed-block">
<p>Most real programs require some kind of user interaction. For a web application, of course, the program can get user input using <abbr title="HyperText Markup Language. A language that is used for specifying the content of web pages. An HTML document is made up of text, along with &quot;elements&quot; for adding other content, such as images, and for defining the structure of the document. Because of nesting of elements, the document can be represented by a tree-like data structure.">HTML</abbr> widgets such as buttons and text input boxes. But direct mouse interaction with a 3D world is more natural in many programs.</p>
<p>The most basic example is using the mouse to rotate the scene. In <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>, <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> can be implemented using the class <strong><em>TrackballControls</em></strong> or the class <strong><em>OrbitControls</em></strong>. Note that both classes support touchscreen as well as mouse interaction. The main difference between the classes is that with OrbitControls, the <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> is constrained so that the positive y-axis is always the up direction in the view. <em>TrackballControls</em>, on the other hand, allows completely free <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr>. Another difference is that <em>TrackballControls</em> is meant to be used only with a scene that is continuously animated. OrbitControls is used for <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> in most of my sample programs and demos. <em>TrackballControls</em> is used only in <a href="../../../en/source/threejs/full-window.html">threejs/full-window.html</a> and <a href="../../../en/source/threejs/curves-and-surfaces.html">threejs/curves-and-surfaces.html</a>.</p>
<p>The two control classes are not part of the main <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em> <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> file. They can be imported from the modules "OrbitControls.js" and "TrackballControls.js", which can be found in the <a href="https://math.hws.edu/graphicsbook/source/threejs/script/controls">threejs/script/controls</a> folder in the source folder for this textbook, or in the examples/jsm/loaders folder in the <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em> download.</p>
<p>The two classes are used in a similar way. I will discuss <strong><em>OrbitControls</em></strong> first. In my examples, I create a <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> and move it away from the origin. I usually add a light object to the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> object, so that the light will move along with the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>, providing some illumination to anything that is visible to the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>. The <strong><em>OrbitControls</em></strong> object is used to rotate the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> around the scene. The <abbr title="In object-oriented programming, a subroutine that is used to create objects. A constructor for a class creates and initializes objects belonging to that class.">constructor</abbr> for the control object has two parameters, the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> and the canvas on which the scene is rendered. Here is typical setup:</p>
<div class="highlight"><pre><span></span><code><span class="nx">camera</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">PerspectiveCamera</span><span class="p">(</span><span class="mf">45</span><span class="p">,</span><span class="w"> </span><span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span><span class="o">/</span><span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span><span class="p">,</span><span class="w"> </span><span class="mf">0.1</span><span class="p">,</span><span class="w"> </span><span class="mf">100</span><span class="p">);</span>
<span class="nx">camera</span><span class="p">.</span><span class="nx">position</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="mf">15</span><span class="p">,</span><span class="mf">35</span><span class="p">);</span>
<span class="nx">camera</span><span class="p">.</span><span class="nx">lookAt</span><span class="p">(</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">Vector3</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// camera looks toward origin</span>

<span class="kd">let</span><span class="w"> </span><span class="nx">light</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">PointLight</span><span class="p">(</span><span class="mh">0xffffff</span><span class="p">,</span><span class="w"> </span><span class="mf">0.6</span><span class="p">);</span>
<span class="nx">camera</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">light</span><span class="p">);</span><span class="w">  </span><span class="c1">// viewpoint light moves with camera</span>
<span class="nx">scene</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">camera</span><span class="p">);</span>

<span class="nx">controls</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">OrbitControls</span><span class="p">(</span><span class="w"> </span><span class="nx">camera</span><span class="p">,</span><span class="w"> </span><span class="nx">canvas</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>The <abbr title="In object-oriented programming, a subroutine that is used to create objects. A constructor for a class creates and initializes objects belonging to that class.">constructor</abbr> installs listeners on the <em>canvas</em> so that the controls can respond to mouse events. If an <abbr title="A sequence of images that, when displayed quickly one after the other, will produce the impression of continuous motion or change. The term animation also refers to the process of creating such image sequences.">animation</abbr> is running, the only other thing that you need to do is call</p>
<div class="highlight"><pre><span></span><code><span class="nx">controls</span><span class="p">.</span><span class="nx">update</span><span class="p">();</span>
</code></pre></div>
<p>before <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> the scene. The user will be able to rotate the scene by dragging on it with the left mouse button. The controls will also do "panning" (dragging the scene in the plane of the screen) with the right mouse button and "zooming" (moving the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> forward and backward) with the middle mouse button or scroll wheel. To disable zooming and panning, you can set</p>
<div class="highlight"><pre><span></span><code><span class="nx">controls</span><span class="p">.</span><span class="nx">enablePan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span>
<span class="nx">controls</span><span class="p">.</span><span class="nx">enableZoom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span>
</code></pre></div>
<p>And you can return the original view of the scene by calling <em>controls.reset()</em>.</p>
<p>If your program is not running a continuous <abbr title="A sequence of images that, when displayed quickly one after the other, will produce the impression of continuous motion or change. The term animation also refers to the process of creating such image sequences.">animation</abbr>, you need a way to re-render the scene in response to user actions. When the user drags the mouse, the <em>controls</em> object generates a "change" event. You can add a listener for that event, to respond to the event by redrawing the scene. To do that, just call</p>
<div class="highlight"><pre><span></span><code><span class="nx">controls</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="w"> </span><span class="s2">&quot;change&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">callback</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>Where <em>callback()</em> is the function that should be called when the event occurs. If you have a function <em>render()</em> that renders your scene, you can simply pass render as the value of callback.</p>
<p>Unfortunately, a <strong><em>TrackballControls</em></strong> object does not emit "change" events, and there does not seem to be any way to use it without having an <abbr title="A sequence of images that, when displayed quickly one after the other, will produce the impression of continuous motion or change. The term animation also refers to the process of creating such image sequences.">animation</abbr> running. With an <abbr title="A sequence of images that, when displayed quickly one after the other, will produce the impression of continuous motion or change. The term animation also refers to the process of creating such image sequences.">animation</abbr>, <em>TrackballControls</em> are used in the same way as <em>OrbitControls</em>, except that the properties for panning and zooming are <em>controls.noPan</em> and <em>controls.noZoom</em>; they should be set to <em>true</em> to disable panning and zooming. One nice feature of <strong><em>TrackballControls</em></strong> is that they implement inertia: When the user releases the mouse after dragging, the motion of the scene will slow to a stop instead of stopping abruptly.</p>
<hr />
<p>A much more interesting form of mouse interaction is to let the user select objects in the scene by clicking on them. The problem is to determine which object the user is clicking. The general procedure is something like this: Follow a ray from the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> through the point on the screen where the user clicked and find the first object in the scene that is intersected by that ray. That's the object that is visible at the point where the user clicked. Unfortunately, the procedure involves a lot of calculations. Fortunately, <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em> has a class that can do the work for you: <strong><em>THREE.Raycaster</em></strong>.</p>
<p>A <strong><em>Raycaster</em></strong> can be used to find intersections of a ray with objects in a scene. (A ray is just half of a line, stretching from some given starting point in a given direction towards infinity.) You can make one raycaster object to use throughout your program:</p>
<div class="highlight"><pre><span></span><code><span class="nx">raycaster</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">Raycaster</span><span class="p">();</span>
</code></pre></div>
<p>To tell it which ray to use, you can call</p>
<div class="highlight"><pre><span></span><code><span class="nx">raycaster</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="w"> </span><span class="nx">startingPoint</span><span class="p">,</span><span class="w"> </span><span class="nx">direction</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>where both of the parameters are of type <strong><em>THREE.Vector3</em></strong>. Their values are in terms of <abbr title="The coordinate system in which a scene is defined. The image that is produced of the scene will show the contents of the world coordinate system that lie within some view volume (for 3D) or view window (for 2D). Objects are defined in their own object coordinate system. Modeling transformations are then applied to place objects into the scene; that is, they transform object coordinates to world coordinates.">world coordinates</abbr>, the same <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr> that you use for the scene as a whole. The <em>direction</em> must be a <abbr title="The result of dividing a non-zero vector by its length, giving a unit vector, that is, a vector of length one. (Note that &quot;normalized vector&quot; and &quot;normal vector&quot; are, confusingly, unrelated terms!)">normalized vector</abbr>, with length equal to one. For example, suppose that you want to fire a laser gun.... The <em>startingPoint</em> is the location of the gun, and the <em>direction</em> is the direction that the gun is pointing. Configure the raycaster with those parameters, and you can use it to find out what object is struck by the laser beam.</p>
<p>Alternatively, and more conveniently for processing user input, you can express the ray in terms of the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> and a point on the screen:</p>
<div class="highlight"><pre><span></span><code><span class="nx">raycaster</span><span class="p">.</span><span class="nx">setFromCamera</span><span class="p">(</span><span class="w"> </span><span class="nx">screenCoords</span><span class="p">,</span><span class="w"> </span><span class="nx">camera</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>The <em>screenCoords</em> are given as a <strong><em>THREE.Vector2</em></strong> expressed in <abbr title="The default coordinate system in OpenGL. The projection transform maps the 3D scene to clip coordinates. The rendered image will show the contents of the cube in the clip coordinate system that contains x, y, and z values in the range from -1 to 1; anything outside that range is &quot;clipped&quot; away.">clip coordinates</abbr>. This means the horizontal coordinate ranges from −1 on the left edge of the <abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr> to 1 on the right, and the vertical coordinate ranges from −1 at the bottom to 1 on the top. (Clip coordinates are called "normalized <abbr title="The coordinate system used on a display device or rendered image, often using pixels as the unit of measure.">device coordinates</abbr>" in <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>.) So, we need to convert from <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> coordinates on a canvas to <abbr title="The default coordinate system in OpenGL. The projection transform maps the 3D scene to clip coordinates. The rendered image will show the contents of the cube in the clip coordinate system that contains x, y, and z values in the range from -1 to 1; anything outside that range is &quot;clipped&quot; away.">clip coordinates</abbr>. Here's one way to do it, given a mouse event, <em>evt</em>:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">canvas</span><span class="p">.</span><span class="nx">getBoundingClientRect</span><span class="p">();</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">evt</span><span class="p">.</span><span class="nx">clientX</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">r</span><span class="p">.</span><span class="nx">left</span><span class="p">;</span><span class="w"> </span><span class="c1">// convert mouse location to canvas pixel coords</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">evt</span><span class="p">.</span><span class="nx">clientY</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">r</span><span class="p">.</span><span class="nx">top</span><span class="p">;</span>

<span class="kd">let</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2</span><span class="o">*</span><span class="nx">x</span><span class="o">/</span><span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// convert canvas pixel coords to clip coords</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2</span><span class="o">*</span><span class="nx">y</span><span class="o">/</span><span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span><span class="p">;</span>

<span class="nx">raycaster</span><span class="p">.</span><span class="nx">setFromCamera</span><span class="p">(</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">Vector2</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">),</span><span class="w"> </span><span class="nx">camera</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>Once you have told the raycaster which ray to use, it is ready to find intersections of that ray with objects in the scene. This can be done with the function</p>
<div class="highlight"><pre><span></span><code><span class="nx">raycaster</span><span class="p">.</span><span class="nx">intersectObjects</span><span class="p">(</span><span class="w"> </span><span class="nx">objectArray</span><span class="p">,</span><span class="w"> </span><span class="nx">recursive</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>The first parameter is an array of <strong><em>Object3D</em></strong>. The raycaster will search for intersections of its current ray with objects in the array. If the second parameter is <em>true</em>, it will also search descendants of those objects in the <abbr title="A data structure that represents the objects in a scene, together with attributes of the objects and the modeling transformations that are applied to the objects. An image of the scene is created by traversing the scene graph data structure. A scene graph might exist only conceptually, or it might be an actual data structure in a program.">scene graph</abbr>; if it is false or is omitted, then only the objects in the array will be searched. For example, to search for intersections with all objects in the scene, use</p>
<div class="highlight"><pre><span></span><code><span class="nx">raycaster</span><span class="p">.</span><span class="nx">intersectObjects</span><span class="p">(</span><span class="w"> </span><span class="nx">scene</span><span class="p">.</span><span class="nx">children</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>The return value from <em>intersectObjects</em> is an array of <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> objects. Each item in the array represents an intersection of the ray with an <strong><em>Object3D</em></strong>. The function finds all such intersections, not just the first. If no intersection is found, the array is empty. The array is sorted by increasing distance from the starting point of the ray. If you just want the first intersection, use the first element of the array.</p>
<p>Each element in the array is an object whose properties contain information about the intersection. Suppose that item is one of the array elements. Then the most useful properties are: item.object, which is the <strong><em>Object3D</em></strong> that was intersected by the ray; and item.point, which is the point of intersection, given as a <strong><em>Vector3</em></strong> in <abbr title="The coordinate system in which a scene is defined. The image that is produced of the scene will show the contents of the world coordinate system that lie within some view volume (for 3D) or view window (for 2D). Objects are defined in their own object coordinate system. Modeling transformations are then applied to place objects into the scene; that is, they transform object coordinates to world coordinates.">world coordinates</abbr>. That information is enough to implement some interesting user interaction.</p>
<p>The following demo uses some basic mouse interaction to let the user edit a scene. The scene shows a number of tapered yellow cylinders standing on a green base. The user can drag the cylinders, add and delete cylinders, and rotate the scene. A set of radio buttons lets the user select which action should be performed by the mouse.</p>
<p><iframe src="../../../en/demos/c5/raycaster-input.html" width="620" height="430"></iframe></p>
<p>Let's look at how the actions are implemented. The only objects are the base and the cylinders. In the program, the base is referred to as <em>ground</em>, and all the objects are children of an <strong><em>Object3D</em></strong> named <em>world</em>. (I use the world object to make it easy to rotate the set of all visible objects without moving the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> or lights.) For all drag, add, and delete actions, I look for intersections of these objects with a ray that extends from the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> through the mouse position:</p>
<div class="highlight"><pre><span></span><code><span class="nx">raycaster</span><span class="p">.</span><span class="nx">setFromCamera</span><span class="p">(</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">Vector2</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">),</span><span class="w"> </span><span class="nx">camera</span><span class="w"> </span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">intersects</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">raycaster</span><span class="p">.</span><span class="nx">intersectObjects</span><span class="p">(</span><span class="w"> </span><span class="nx">world</span><span class="p">.</span><span class="nx">children</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>If <em>intersects.length</em> is zero, there are no intersections, and there is nothing to do. Otherwise, I look at <em>intersects[0]</em>, which represents an intersection with the object that is visible at the mouse position. So, <em>intersects[0].object</em> is the object that the user clicked, and <em>intersects[0].point</em> is the point of intersection.</p>
<p>The Delete action is the simplest to implement: When the user clicks a cylinder, the cylinder should be removed from the scene. If the first intersection is with the <em>ground</em>, then nothing is deleted. Otherwise, the clicked object was a cylinder and should be deleted:</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="nx">intersects</span><span class="p">[</span><span class="mf">0</span><span class="p">].</span><span class="nx">object</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nx">ground</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">world</span><span class="p">.</span><span class="nx">remove</span><span class="p">(</span><span class="w"> </span><span class="nx">intersects</span><span class="p">[</span><span class="mf">0</span><span class="p">].</span><span class="nx">object</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="nx">render</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>For an Add action, we should add a cylinder only if the user clicked the ground. In that case, the point of intersection tells where the cylinder should be added. An interesting issue here is that we get the point of intersection in <abbr title="The coordinate system in which a scene is defined. The image that is produced of the scene will show the contents of the world coordinate system that lie within some view volume (for 3D) or view window (for 2D). Objects are defined in their own object coordinate system. Modeling transformations are then applied to place objects into the scene; that is, they transform object coordinates to world coordinates.">world coordinates</abbr>, but in order to add the cylinder as a child of <em>world</em>, I need to know the point of intersection in the local <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr> for <em>world</em>. The two <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate systems</abbr> will be different if the world has been rotated. Fortunately, every <strong><em>Object3D</em></strong> has a method <em>worldToLocal(v)</em> that can be used to transform a <strong><em>Vector3</em></strong>, v, from <abbr title="The coordinate system in which a scene is defined. The image that is produced of the scene will show the contents of the world coordinate system that lie within some view volume (for 3D) or view window (for 2D). Objects are defined in their own object coordinate system. Modeling transformations are then applied to place objects into the scene; that is, they transform object coordinates to world coordinates.">world coordinates</abbr> to local coordinates for that object. This method does not return a value; it modifies the coordinates of the <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> v. (There is also a <em>localToWorld</em> method.) So, the Add action can be implemented like this:</p>
<div class="highlight"><pre><span></span><code><span class="nx">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">intersects</span><span class="p">[</span><span class="mf">0</span><span class="p">];</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">object</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">ground</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">locationX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">item</span><span class="p">.</span><span class="nx">point</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span><span class="w">  </span><span class="c1">// world coords of intersection point</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">locationZ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">item</span><span class="p">.</span><span class="nx">point</span><span class="p">.</span><span class="nx">z</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">Vector3</span><span class="p">(</span><span class="nx">locationX</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">locationZ</span><span class="p">);</span><span class="w"> </span><span class="c1">// y is always 0</span>
<span class="w">    </span><span class="nx">world</span><span class="p">.</span><span class="nx">worldToLocal</span><span class="p">(</span><span class="nx">coords</span><span class="p">);</span><span class="w"> </span><span class="c1">// transform to local coords</span>
<span class="w">    </span><span class="nx">addCylinder</span><span class="p">(</span><span class="nx">coords</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">coords</span><span class="p">.</span><span class="nx">z</span><span class="p">);</span><span class="w"> </span><span class="c1">// adds a cylinder at corrected location</span>
<span class="w">    </span><span class="nx">render</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>For a Drag action, we can determine which cylinder was clicked using the same test as for delete. However, the problem of moving the cylinder as the user drags the mouse raises a new issue: how do we know where to put the cylinder when the mouse moves? We somehow have to transform a new mouse position into a new position for the cylinder. For that, we can use the raycaster again. My first thought was to create a ray from the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> through the new mouse position, use that ray to find its intersection with the ground, and then to move the cylinder to that point of intersection. Unfortunately, this puts the <strong>base</strong> of the cylinder at the mouse position, and it made the cylinder jump to the wrong position as soon as I started moving the mouse. I realized that I didn't want to track the intersection with the ground; I needed to track the intersection with a plane that lies at the same height as the original point of intersection. To implement this, I add an invisible plane at that height just during dragging, and I use intersections with that plane instead of intersections with the ground. (You can have invisible objects in <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>—just set the <em>visible</em> property of the <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> to <em>false</em>.)</p>
</div>
</div>
</div>
<h2 id="533-阴影">5.3.3 阴影<a class="headerlink" href="#533-阴影" title="Permanent link">&para;</a></h2>
<p><strong>Shadows</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="4:2"><input checked="checked" id="__tabbed_4_1" name="__tabbed_4" type="radio" /><input id="__tabbed_4_2" name="__tabbed_4" type="radio" /><div class="tabbed-labels"><label for="__tabbed_4_1">中文</label><label for="__tabbed_4_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>在我们的3D图像中，有一件事情一直没有出现，那就是阴影。即使你没有意识到缺少了阴影，它也会让许多图像看起来不对劲。阴影可以为场景增添一丝逼真感，但OpenGL，包括WebGL，不能自动生成阴影。有一些计算阴影的方法可以在OpenGL中实现，但它们使用起来很棘手，并且在物理上也不完全真实。一种称为<strong><abbr title="一种确定场景中哪些部分被照亮，哪些部分处于阴影中的技术。该技术涉及从光源的视角渲染场景，但只使用那次渲染的深度缓冲区。深度缓冲区是“阴影映射”。沿着从光源发出的给定方向，被光照亮的物体是离光最近的物体。到该物体的距离基本上编码在深度缓冲区中。更远距离的物体处于阴影中。">阴影映射</abbr></strong>的方法在<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>中得到了实现。在<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>中的阴影映射使用起来当然不是微不足道的，但它比从头开始尝试做同样的事情要容易。</p>
<p>这里有一个演示，展示了使用阴影映射的<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>场景。投射阴影的灯光可以被动画化，所以你可以看到随着灯光移动阴影的变化。</p>
<p><iframe src="../../../en/demos/c5/shadows.html" width="560" height="520"></iframe></p>
<p>阴影映射的基本思想相当直接：要确定场景中哪些部分处于阴影中，你必须从光源的角度来看待场景。从光源的视角可以看到的东西会被该光源照亮。从光源看不到的东西则处于阴影中。（这是忽略了透明度和间接反射光的可能性，阴影映射无法处理。）为了实现这个想法，在光源处放置一个相机并拍照。实际上，你不需要照片本身。你需要的是深度缓冲区。在渲染完照片后，存储在深度缓冲区中某个像素的值本质上是从光源到那个点从光源可见的物体的距离。那个物体被光源照亮。如果一个物体的深度大于存储在深度缓冲区中的值，那么那个物体就在阴影中。深度缓冲区就是阴影映射。现在，回到相机的视角，并考虑在从相机的视角渲染某个物体上的一个点时，那个点是否在阴影中？你只需要将那个点从相机的视图坐标变换到光源的视图坐标，并检查变换点的深度。如果这个深度大于阴影映射中的相应值，那么那个点就在阴影中。请注意，如果有多个光源，每个光源都会投射自己的阴影，你需要为每个光源准备一个阴影映射。</p>
<p>计算阴影映射并应用它们在计算上是昂贵的，阴影在<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>中默认是禁用的。要获得阴影，你需要做几件事情。你需要通过以下方式在WebGL渲染器中启用阴影计算：</p>
<div class="highlight"><pre><span></span><code><span class="nx">renderer</span><span class="p">.</span><span class="nx">shadowMap</span><span class="p">.</span><span class="nx">enabled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
</code></pre></div>
<p>只有<strong><em>DirectionalLights</em></strong>和<strong><em>SpotLights</em></strong>才能投射阴影。即使在渲染器中启用了阴影，要从一个光源获得阴影，你也必须将光源的<em>castShadow</em>属性设置为true：</p>
<div class="highlight"><pre><span></span><code><span class="nx">light</span><span class="p">.</span><span class="nx">castShadow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">  </span><span class="c1">// 这个光源将投射阴影。</span>
</code></pre></div>
<p>此外，必须为每个将要投射或接收阴影的对象启用阴影。“接收”阴影意味着阴影将显示在该对象上。投射和接收是为对象单独启用的。</p>
<div class="highlight"><pre><span></span><code><span class="nx">object</span><span class="p">.</span><span class="nx">castShadow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">     </span><span class="c1">// 这个对象将投射阴影。</span>
<span class="nx">object</span><span class="p">.</span><span class="nx">receiveShadow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">  </span><span class="c1">// 阴影将显示在这个对象上。</span>
</code></pre></div>
<p>即使这样做了，也可能没有任何阴影显示出来，如果显示出来，它们可能看起来也很糟糕。问题是你通常需要配置用于制作阴影映射的相机。</p>
<p>每个<strong><em>DirectionalLight</em></strong>或<strong><em>SpotLight</em>*都有自己的阴影相机，用于从该光源的视角创建阴影映射。（</strong><em>DirectionalLight</em><strong>有一个名为shadow的属性，类型为</strong><em>THREE.DirectionalLightShadow</em><strong>，它又有一个名为camera的属性，类型为</strong><em>THREE.OrthographicCamera</em><em><em>，保存阴影相机。所以，定向光dl的阴影相机是dl.shadow.<abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>。）定向光的阴影相机使用正交投影。正交投影由视体积限制</em>xmin</em>, <em>xmax</em>, <em>ymin</em>, <em>ymax</em>, <em>near</em>, 和 <em>far</em>配置（见<a href="../../c3/s3/#333-投影变换">3.3.3小节</a>）。对于定向光dl，这些限制对应于属性dl.shadow.<abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>.left, dl.shadow.<abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>.right, dl.shadow.<abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>.bottom, dl.shadow.<abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>.top, dl.shadow.<abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>.near, 和 dl.shadow.<abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>.far。这些值在阴影相机的视图中；即，它们相对于dl.position。重要的是确保你场景中的所有对象，或者至少那些投射阴影的对象，都在阴影相机的视体积内。此外，你不希望限制太大：如果场景只占据了相机视体积的一小部分，那么只有一小部分阴影映射包含有用信息——然后由于关于阴影的信息如此之少，你的阴影就不会非常准确。默认值假设了一个非常大的场景。对于一个相对较小的场景，你可能会设置：</p>
<div class="highlight"><pre><span></span><code><span class="nx">dl</span><span class="p">.</span><span class="nx">shadow</span><span class="p">.</span><span class="nx">camera</span><span class="p">.</span><span class="nx">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mf">20</span><span class="p">;</span>
<span class="nx">dl</span><span class="p">.</span><span class="nx">shadow</span><span class="p">.</span><span class="nx">camera</span><span class="p">.</span><span class="nx">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">20</span><span class="p">;</span>
<span class="nx">dl</span><span class="p">.</span><span class="nx">shadow</span><span class="p">.</span><span class="nx">camera</span><span class="p">.</span><span class="nx">bottom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mf">20</span><span class="p">;</span>
<span class="nx">dl</span><span class="p">.</span><span class="nx">shadow</span><span class="p">.</span><span class="nx">camera</span><span class="p">.</span><span class="nx">top</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">20</span><span class="p">;</span>
<span class="nx">dl</span><span class="p">.</span><span class="nx">shadow</span><span class="p">.</span><span class="nx">camera</span><span class="p">.</span><span class="nx">near</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1</span><span class="p">;</span>
<span class="nx">dl</span><span class="p">.</span><span class="nx">shadow</span><span class="p">.</span><span class="nx">camera</span><span class="p">.</span><span class="nx">far</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">30</span><span class="p">;</span>
</code></pre></div>
<p>聚光灯的阴影相机类型为<strong><em>THREE.PerspectiveCamera</em></strong>，使用透视投影。（使用视场有限的相机是你可以有聚光灯的阴影，但没有点光源的阴影的原因。）对于聚光灯sl，阴影相机由属性sl.shadow.<abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>.near, sl.shadow.<abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>.far, 和 sl.shadow.<abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>.fov（其中"fov"是垂直视场角度，以度而不是弧度给出）配置。fov的默认值可能没问题，只是如果你改变了聚光灯的截止角度，你将想要改变fov以匹配。但你应该确保为近和远设置适当的值，以包含你的场景和尽可能少的额外部分。同样，近和远是从sl.position的距离。</p>
<p>要获得更准确的阴影，你可能想要增加阴影映射的大小。阴影映射是一种纹理图像，默认情况下是512x512像素。你可以通过使用更大的阴影映射来提高阴影的精度。对于一个光源，<em>light</em>，设置属性light.shadow.mapSize.width和light.shadow.mapSize.height的值。例如，</p>
<div class="highlight"><pre><span></span><code><span class="nx">light</span><span class="p">.</span><span class="nx">shadow</span><span class="p">.</span><span class="nx">mapSize</span><span class="p">.</span><span class="nx">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1024</span><span class="p">;</span>
<span class="nx">light</span><span class="p">.</span><span class="nx">shadow</span><span class="p">.</span><span class="nx">mapSize</span><span class="p">.</span><span class="nx">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1024</span><span class="p">;</span>
</code></pre></div>
<p>我不确定这里是否绝对需要幂次方值，但它们通常用于纹理。</p>
</div>
<div class="tabbed-block">
<p>One thing that has been missing in our 3D images is shadows. Even if you didn't notice the lack consciously, it made many of the images look wrong. Shadows can add a nice touch of realism to a scene, but <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr>, including <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>, cannot generate shadows automatically. There are ways to compute shadows that can be implemented in <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr>, but they are tricky to use and they are not completely realistic physically. One method, which is called <strong><abbr title="A technique for determining which parts of a scene are illuminated and which are in shadow from a given light source. The technique involves rendering the scene from the point of the view of the light source, but uses only the depth buffer from that rendering. The depth buffer is the &quot;shadow map.&quot; Along a given direction from the light source, the object that is illuminated by the light is the one that is closest to the light. The distance to that object is essentially encoded in the depth buffer. Objects at greater distance are in shadow.">shadow mapping</abbr></strong>, is implemented in <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>. Shadow mapping in <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em> is certainly not trivial to use, but it is easier than trying to do the same thing from scratch.</p>
<p>Here is a demo that shows a <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em> scene that uses <abbr title="A technique for determining which parts of a scene are illuminated and which are in shadow from a given light source. The technique involves rendering the scene from the point of the view of the light source, but uses only the depth buffer from that rendering. The depth buffer is the &quot;shadow map.&quot; Along a given direction from the light source, the object that is illuminated by the light is the one that is closest to the light. The distance to that object is essentially encoded in the depth buffer. Objects at greater distance are in shadow.">shadow mapping</abbr>. The lights that cast the shadows can be animated, so you can watch the shadows change as the lights move.</p>
<p><iframe src="../../../en/demos/c5/shadows.html" width="560" height="520"></iframe></p>
<p>The basic idea of <abbr title="A technique for determining which parts of a scene are illuminated and which are in shadow from a given light source. The technique involves rendering the scene from the point of the view of the light source, but uses only the depth buffer from that rendering. The depth buffer is the &quot;shadow map.&quot; Along a given direction from the light source, the object that is illuminated by the light is the one that is closest to the light. The distance to that object is essentially encoded in the depth buffer. Objects at greater distance are in shadow.">shadow mapping</abbr> is fairly straightforward: To tell what parts of a scene are in shadow, you have to look at the scene from the point of view of the light source. Things that are visible from the point of view of the light are illuminated by that light. Things that are not visible from the light are in shadow. (This is ignoring the possibility of transparency and indirect, reflected light, which cannot be handled by <abbr title="A technique for determining which parts of a scene are illuminated and which are in shadow from a given light source. The technique involves rendering the scene from the point of the view of the light source, but uses only the depth buffer from that rendering. The depth buffer is the &quot;shadow map.&quot; Along a given direction from the light source, the object that is illuminated by the light is the one that is closest to the light. The distance to that object is essentially encoded in the depth buffer. Objects at greater distance are in shadow.">shadow mapping</abbr>.) To implement this idea, place a <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> at the light source and take a picture. In fact, you don't need the picture itself. What you need is the <abbr title="A region of memory that stores the information needed for the depth test in 3D graphics, that is, a depth value for each pixel in the image. Also called the &quot;z-buffer.&quot;">depth buffer</abbr>. After the picture has been rendered, the value stored in the <abbr title="A region of memory that stores the information needed for the depth test in 3D graphics, that is, a depth value for each pixel in the image. Also called the &quot;z-buffer.&quot;">depth buffer</abbr> for a given <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> contains, essentially, the distance from the light to the object that is visible from the light at that point. That object is illuminated by the light. If an object is at greater depth than the value stored in the <abbr title="A region of memory that stores the information needed for the depth test in 3D graphics, that is, a depth value for each pixel in the image. Also called the &quot;z-buffer.&quot;">depth buffer</abbr>, then that object is in shadow. The <abbr title="A region of memory that stores the information needed for the depth test in 3D graphics, that is, a depth value for each pixel in the image. Also called the &quot;z-buffer.&quot;">depth buffer</abbr> is the shadow map. Now, go back to the point of view of the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>, and consider a point on some object as it is rendered from the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>'s point of view. Is that point in shadow or not? You just have to transform that point from the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>'s <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> coordinates to the light's <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr> coordinates and check the depth of the transformed point. If that depth is greater than the corresponding value in the shadow map, then the point is in shadow. Note that if there are several lights, each light casts its own shadows, and you need a shadow map for each light.</p>
<p>It is computationally expensive to compute shadow maps and to apply them, and shadows are disabled by default in <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>. To get shadows, you need to do several things. You need to enable shadow computations in the <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> renderer by saying</p>
<div class="highlight"><pre><span></span><code><span class="nx">renderer</span><span class="p">.</span><span class="nx">shadowMap</span><span class="p">.</span><span class="nx">enabled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
</code></pre></div>
<p>Only <strong><em>DirectionalLights</em></strong> and <strong><em>SpotLights</em></strong> can cast shadows. To get shadows from a light, even after enabling shadows in the renderer, you have to set the light's <em>castShadow</em> property to true:</p>
<div class="highlight"><pre><span></span><code><span class="nx">light</span><span class="p">.</span><span class="nx">castShadow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">  </span><span class="c1">// This light will cast shadows.</span>
</code></pre></div>
<p>Furthermore, shadows have to be enabled for each object that will cast or receive shadows. "Receiving" a shadow means that shadows will be visible on that object. Casting and receiving are enabled separately for an object.</p>
<div class="highlight"><pre><span></span><code><span class="nx">object</span><span class="p">.</span><span class="nx">castShadow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">     </span><span class="c1">// This object will cast shadows.</span>
<span class="nx">object</span><span class="p">.</span><span class="nx">receiveShadow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">  </span><span class="c1">// Shadows will show up on this object.</span>
</code></pre></div>
<p>Even this might not make any shadows show up, and if they do they might look pretty bad. The problem is that you usually have to configure the cameras that are used to make the shadow maps.</p>
<p>Each <strong><em>DirectionalLight</em></strong> or <strong><em>SpotLight</em></strong> has its own shadow <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>, which is used to create the shadow map from the point of view of that light. (A <strong><em>DirectionalLight</em></strong> has a property named shadow of type <strong><em>THREE.DirectionalLightShadow</em></strong>, which in turn has a property named <em><abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr></em> of type <strong><em>THREE.OrthographicCamera</em></strong> that holds the shadow <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>. So, the shadow <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> for a <abbr title="A light source whose light rays are parallel, all arriving from the same direction. Can be considered to be a light source at an effectively infinite distance. Also called a &quot;sun,&quot; since the Sun is an example of a directional light source.">directional light</abbr> <em>dl</em> is <em>dl.shadow.<abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr></em>.) The shadow <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> for a <abbr title="A light source whose light rays are parallel, all arriving from the same direction. Can be considered to be a light source at an effectively infinite distance. Also called a &quot;sun,&quot; since the Sun is an example of a directional light source.">directional light</abbr> uses an <abbr title="A projection from 3D to 2D that simply discards the z-coordinate. It projects objects along lines that are orthogonal (perpendicular) to the xy-plane. In OpenGL 1.1, the view volume for an orthographic projection is a rectangular solid.">orthographic projection</abbr>. An <abbr title="A projection from 3D to 2D that simply discards the z-coordinate. It projects objects along lines that are orthogonal (perpendicular) to the xy-plane. In OpenGL 1.1, the view volume for an orthographic projection is a rectangular solid.">orthographic projection</abbr> is configured by <abbr title="In OpenGL 1.1, the region is 3D space that is visible in the rendered image. For orthographic projections, the view volume is a rectangular solid. For perspective projection, the view volume is a frustum (truncated pyramid).">view volume</abbr> limits <em>xmin</em>, <em>xmax</em>, <em>ymin</em>, <em>ymax</em>, <em>near</em>, and <em>far</em> (see <a href="../../c3/s3/#333-投影变换">Subsection 3.3.3</a>). For a <abbr title="A light source whose light rays are parallel, all arriving from the same direction. Can be considered to be a light source at an effectively infinite distance. Also called a &quot;sun,&quot; since the Sun is an example of a directional light source.">directional light</abbr>, <em>dl</em>, these limits correspond to the properties <em>dl.shadow.<abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>.left</em>, <em>dl.shadow.<abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>.right</em>, <em>dl.shadow.<abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>.bottom</em>, <em>dl.shadow.<abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>.top</em>, <em>dl.shadow.<abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>.near</em>, and <em>dl.shadow.<abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>.far</em>. These values are in view coordinates for the shadow <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>; that is, they are relative to <em>dl.position</em>. It is important to make sure that all the objects in your scene, or at least those that cast shadows, are within the <abbr title="In OpenGL 1.1, the region is 3D space that is visible in the rendered image. For orthographic projections, the view volume is a rectangular solid. For perspective projection, the view volume is a frustum (truncated pyramid).">view volume</abbr> of the shadow <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>. Furthermore, you don't want the limits to be too big: If the scene occupies only a small part of the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>'s <abbr title="In OpenGL 1.1, the region is 3D space that is visible in the rendered image. For orthographic projections, the view volume is a rectangular solid. For perspective projection, the view volume is a frustum (truncated pyramid).">view volume</abbr>, then only a small part of the shadow map contains useful information—and then since there is so little information about shadows, your shadows won't be very accurate. The default values assume a very large scene. For a relatively small scene, you might set:</p>
<div class="highlight"><pre><span></span><code><span class="nx">dl</span><span class="p">.</span><span class="nx">shadow</span><span class="p">.</span><span class="nx">camera</span><span class="p">.</span><span class="nx">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mf">20</span><span class="p">;</span>
<span class="nx">dl</span><span class="p">.</span><span class="nx">shadow</span><span class="p">.</span><span class="nx">camera</span><span class="p">.</span><span class="nx">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">20</span><span class="p">;</span>
<span class="nx">dl</span><span class="p">.</span><span class="nx">shadow</span><span class="p">.</span><span class="nx">camera</span><span class="p">.</span><span class="nx">bottom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mf">20</span><span class="p">;</span>
<span class="nx">dl</span><span class="p">.</span><span class="nx">shadow</span><span class="p">.</span><span class="nx">camera</span><span class="p">.</span><span class="nx">top</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">20</span><span class="p">;</span>
<span class="nx">dl</span><span class="p">.</span><span class="nx">shadow</span><span class="p">.</span><span class="nx">camera</span><span class="p">.</span><span class="nx">near</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1</span><span class="p">;</span>
<span class="nx">dl</span><span class="p">.</span><span class="nx">shadow</span><span class="p">.</span><span class="nx">camera</span><span class="p">.</span><span class="nx">far</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">30</span><span class="p">;</span>
</code></pre></div>
<p>The shadow <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> for a <abbr title="A light that emits a cone of illumination. A spotlight is similar to a point light in that it has a position in 3D space, and light radiates from that position. However, the light only affects objects that are in the spotlight's cone of illumination.">spotlight</abbr> is of type <strong><em>THREE.PerspectiveCamera</em></strong> and uses a <abbr title="A projection from 3D to 2D that projects objects along lines radiating out from a viewpoint. A perspective projection attempts to simulate realistic viewing. A perspective projection preserves perspective; that is, objects that are farther from the viewpoint are smaller in the projection. In OpenGL 1.1, the view volume for a perspective projection is a frustum, or truncated pyramid.">perspective projection</abbr>. (The use of a <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> with a limited view is why you can have shadows from spotlights but not from point lights.) For a <abbr title="A light that emits a cone of illumination. A spotlight is similar to a point light in that it has a position in 3D space, and light radiates from that position. However, the light only affects objects that are in the spotlight's cone of illumination.">spotlight</abbr> sl, the shadow <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> is configured by the properties <em>sl.shadow.<abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>.near</em>, <em>sl.shadow.<abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>.far</em>, and <em>sl.shadow.<abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>.fov</em> (where "fov" is the vertical field of view angle, given in degrees rather than radians). The default value for fov is probably OK, except that if you change the <abbr title="A light that emits a cone of illumination. A spotlight is similar to a point light in that it has a position in 3D space, and light radiates from that position. However, the light only affects objects that are in the spotlight's cone of illumination.">spotlight</abbr>'s cutoff angle, you will want to change the <em>fov</em> to match. But you should be sure to set appropriate values for near and far, to include all of your scene and as little extra as is practical. Again, <em>near</em> and <em>far</em> are distances from <em>sl.position</em>.</p>
<p>To get more accurate shadows, you might want to increase the size of the shadow map. The shadow map is a kind of <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image which by default is 512 by 512 <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr>. You can increase the accuracy of the shadows by using a larger shadow map. To do that for a light, <em>light</em>, set the values of the properties <em>light.shadow.mapSize.width</em> and <em>light.shadow.mapSize.height</em>. For example,</p>
<div class="highlight"><pre><span></span><code><span class="nx">light</span><span class="p">.</span><span class="nx">shadow</span><span class="p">.</span><span class="nx">mapSize</span><span class="p">.</span><span class="nx">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1024</span><span class="p">;</span>
<span class="nx">light</span><span class="p">.</span><span class="nx">shadow</span><span class="p">.</span><span class="nx">mapSize</span><span class="p">.</span><span class="nx">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1024</span><span class="p">;</span>
</code></pre></div>
<p>I'm not sure whether power-of-two values are absolutely required here, but they are commonly used for textures.</p>
</div>
</div>
</div>
<h2 id="534-立方体贴图纹理和天空盒">5.3.4 立方体贴图纹理和天空盒<a class="headerlink" href="#534-立方体贴图纹理和天空盒" title="Permanent link">&para;</a></h2>
<p><strong>Cubemap Textures and Skyboxes</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="5:2"><input checked="checked" id="__tabbed_5_1" name="__tabbed_5" type="radio" /><input id="__tabbed_5_2" name="__tabbed_5" type="radio" /><div class="tabbed-labels"><label for="__tabbed_5_1">中文</label><label for="__tabbed_5_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>我们已经创建并查看了简单的场景，它们显示在纯色背景上。如果我们能把场景放在一个“环境”中，比如建筑物内部、自然风光或公共广场，那就太好了。用几何基元构建这样复杂的环境的表示是不切实际的，但我们可以使用纹理获得相当好的效果。在<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>中使用的技术被称为<strong><abbr title="一个围绕场景的大立方体，用图像纹理，形成该场景所有方向的背景。">skybox</abbr></strong>。Skybox是一个大立方体——实际上是无限大——立方体的每个面都应用了不同的纹理。这些纹理是某些环境的图像。对于立方体内部的观察者来说，立方体上的六张纹理图像拼合在一起，提供了每个方向上环境的完整视图。这六张纹理图像一起构成了所谓的<strong><abbr title="A texture made up of six images, one for each of the directions positive x, negative x, positive y, negative y, positive z, and negative z. The images are intended to include everything that can be seen from a given point. Cubemap textures are used for environment mapping and skyboxes.">cubemap texture</abbr></strong>。这些图像必须沿着立方体的边缘匹配，形成一个无缝的环境视图。</p>
<p>可以通过在六个方向：左、右、上、下、前、后拍摄环境的六张照片来制作实际物理环境的立方图。（更现实的做法是拍摄足够多的照片来覆盖所有方向，有重叠，然后使用软件将图像“拼接”成一个完整的立方图。）这六个方向按与坐标轴的关系称为：正x、负x、正y、负y、正z和负z，当你指定立方图时，图像必须按顺序列出。这里有一个例子。第一张图片显示了并排放置的六张立方图图像。正y图像在顶部，负y图像在底部。中间是负x、正z、正x和负z图像排成一行。第二张图片显示了用于对立方体进行纹理处理的图像，从外部查看。你可以看到图像如何沿着立方体的边缘匹配：</p>
<p><a class="glightbox" href="../../../en/c5/cubemap.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c5/cubemap.png" /></a></p>
<p>（这张立方图和本节中使用的其他立方图是由Emil Persson制作的，他在<a href="http://www.humus.name/index.php?page=Textures">http://www.humus.name/index.php?page=Textures</a> 提供了大量的立方图下载，遵循创意共享许可。）</p>
<p>对于skybox，从概念上讲，将使用一个非常大的立方体。<abbr title="在三维计算机图形中，将投影和观察变换组合成一个抽象，模拟物理相机或眼睛。">相机</abbr>、灯光和任何要成为场景一部分的对象都在立方体内。可以手工构建一个skybox。</p>
<p>然而，<em>Three.js</em>非常容易地使用skybox作为场景的背景。它有类<strong><em>THREE.CubeTexture</em></strong>来表示立方图，你可以通过将<strong><em>CubeTexture</em></strong>赋值为属性<em>scene.background</em>的值来简单地将你的scene封装在一个skybox中。（该属性的值也可以是普通的<strong><em>Texture</em></strong>或<strong><em>Color</em></strong>。）</p>
<p><strong><em>CubeTexture</em></strong>可以通过<strong><em>CubeTextureLoader</em></strong>创建，它可以加载构成立方图的六张图像。加载器有一个名为<em>load()</em>的方法，它的工作方式与<strong><em>TextureLoader</em></strong>的<em>load()</em>方法相同（见<a href="../s2/#523-纹理">5.2.3小节</a>），除了该方法的第一个参数是一个包含六张立方图图像URL的字符串数组。例如：</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">textureURLs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w">  </span><span class="c1">// 立方图六个面的URL</span>
<span class="w">        </span><span class="s2">&quot;cubemap-textures/park/posx.jpg&quot;</span><span class="p">,</span><span class="w">   </span><span class="c1">// 注意：图像列出的顺序</span>
<span class="w">        </span><span class="s2">&quot;cubemap-textures/park/negx.jpg&quot;</span><span class="p">,</span><span class="w">   </span><span class="c1">// 很重要！</span>
<span class="w">        </span><span class="s2">&quot;cubemap-textures/park/posy.jpg&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;cubemap-textures/park/negy.jpg&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;cubemap-textures/park/posz.jpg&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;cubemap-textures/park/negz.jpg&quot;</span>
<span class="p">];</span>
<span class="nx">loader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">CubeTextureLoader</span><span class="p">();</span>
<span class="nx">cubeTexture</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">loader</span><span class="p">.</span><span class="nx">load</span><span class="p">(</span><span class="w"> </span><span class="nx">textureURLs</span><span class="p">,</span><span class="w"> </span><span class="nx">onLoad</span><span class="p">,</span><span class="w"> </span><span class="kc">undefined</span><span class="p">,</span><span class="w"> </span><span class="nx">onError</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>这里，<em>onLoad</em>是一个在纹理加载完成后将被调用的函数。该函数可以，例如，将<em>scene.background</em>设置为<em>cubeTexture</em>，并使用新的背景重新渲染场景。最后一个参数onError是一个函数，如果无法加载纹理，将调用该函数。只有一个参数是必需的。</p>
<p>示例程序<a href="../../../en/source/threejs/skybox.html">threejs/<abbr title="一个围绕场景的大立方体，用图像纹理，形成该场景所有方向的背景。">skybox</abbr>.html</a>显示了两个WebGL场景。第一个场景显示了一个立方体，立方图的六张图像作为普通纹理应用到立方体的六个面上。第二个场景使用相同的立方图作为skybox。如果你旋转第二个场景的视图，你可以查看skybox的所有部分，并看到它如何形成一个无缝的环境，完全包围了场景。</p>
</div>
<div class="tabbed-block">
<p>We have created and viewed simple scenes, shown on a solid-colored background. It would be nice to put our scenes in an "environment" such as the interior of a building, a nature scene, or a public square. It's not practical to build representations of such complex environments out of <abbr title="Geometric objects in a graphics system, such as OpenGL, that are not made up of simpler objects. Examples in OpenGL include points, lines, and triangles, but the set of available primitives depends on the graphics system. (Note that as the term is used in OpenGL, a single primitive can be made up of many points, line segments, or triangles.)">geometric primitives</abbr>, but we can get a reasonably good effect using textures. The technique that is used in <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em> is called a <strong><abbr title="一个围绕场景的大立方体，用图像纹理，形成该场景所有方向的背景。">skybox</abbr></strong>. A <abbr title="一个围绕场景的大立方体，用图像纹理，形成该场景所有方向的背景。">skybox</abbr> is a large cube — effectively, infinitely large — where a different <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> is applied to each face of the cube. The textures are images of some environment. For a viewer inside the cube, the six <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> images on the cube fit together to provide a complete view of the environment in every direction. The six <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> images together make up what is called a <strong><abbr title="A texture made up of six images, one for each of the directions positive x, negative x, positive y, negative y, positive z, and negative z. The images are intended to include everything that can be seen from a given point. Cubemap textures are used for environment mapping and skyboxes.">cubemap texture</abbr></strong>. The images must match up along the edges of the cube to form a seamless view of the environment.</p>
<p>A cube map of an actual physical environment can be made by taking six pictures of the environment in six directions: left, right, up, down, forward, and back. (More realistically, it is made by taking enough photographs to cover all directions, with overlaps, and then using software to "stitch" the images together into a complete cube map.) The six directions are referred to by their relation to the coordinate axes as: positive x, negative x, positive y, negative y, positive z, and negative z, and the images must be listed in that order when you specify the cube map. Here is an example. The first picture shows the six images of a cube map laid out next to each other. The positive y image is at the top, the negative y image is at the bottom. In between are the negative x, positive z, positive x, and negative z images laid out in a row. The second picture shows the images used to <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> a cube, viewed here from the outside. You can see how the images match up along the edges of the cube:</p>
<p><a class="glightbox" href="../../../en/c5/cubemap.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c5/cubemap.png" /></a></p>
<p>(This cube map, and others used in this section, are by Emil Persson, who has made a large number of cube maps available for download at <a href="http://www.humus.name/index.php?page=Textures">http://www.humus.name/index.php?page=Textures</a> under a creative commons license.)</p>
<p>For a <abbr title="一个围绕场景的大立方体，用图像纹理，形成该场景所有方向的背景。">skybox</abbr>, conceptually, a very large cube would be used. The <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>, lights, and any objects that are to be part of the scene would be inside the cube. It is possible to construct a <abbr title="一个围绕场景的大立方体，用图像纹理，形成该场景所有方向的背景。">skybox</abbr> by hand in just this way.</p>
<p>However, <em>Three.js</em> makes it very easy to use a <abbr title="一个围绕场景的大立方体，用图像纹理，形成该场景所有方向的背景。">skybox</abbr> as the background for a scene. It has the class <strong><em>THREE.CubeTexture</em></strong> to represent cube maps, and you can enclose your scene in a <abbr title="一个围绕场景的大立方体，用图像纹理，形成该场景所有方向的背景。">skybox</abbr> simply by assigning a <strong><em>CubeTexture</em></strong> as the value of the property <em>scene.background</em>. (The value of that property could also be a normal <strong><em>Texture</em></strong> or a <strong><em>Color</em></strong>.)</p>
<p>A <strong><em>CubeTexture</em></strong> can be created by a <strong><em>CubeTextureLoader</em></strong>, which can load the six images that make up the cube map. The loader has a method named <em>load()</em> that works in the same way as the <em>load()</em> method of a <strong><em>TextureLoader</em></strong> (<a href="../s2/#523-纹理">Subsection 5.2.3</a>), except that the first parameter to the method is an array of six strings giving the URLs of the six images for the cube map. For example:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">textureURLs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w">  </span><span class="c1">// URLs of the six faces of the cube map</span>
<span class="w">        </span><span class="s2">&quot;cubemap-textures/park/posx.jpg&quot;</span><span class="p">,</span><span class="w">   </span><span class="c1">// Note:  The order in which</span>
<span class="w">        </span><span class="s2">&quot;cubemap-textures/park/negx.jpg&quot;</span><span class="p">,</span><span class="w">   </span><span class="c1">//   the images are listed is</span>
<span class="w">        </span><span class="s2">&quot;cubemap-textures/park/posy.jpg&quot;</span><span class="p">,</span><span class="w">   </span><span class="c1">//   important!</span>
<span class="w">        </span><span class="s2">&quot;cubemap-textures/park/negy.jpg&quot;</span><span class="p">,</span><span class="w">  </span>
<span class="w">        </span><span class="s2">&quot;cubemap-textures/park/posz.jpg&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;cubemap-textures/park/negz.jpg&quot;</span>
<span class="p">];</span>
<span class="nx">loader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">CubeTextureLoader</span><span class="p">();</span>
<span class="nx">cubeTexture</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">loader</span><span class="p">.</span><span class="nx">load</span><span class="p">(</span><span class="w"> </span><span class="nx">textureURLs</span><span class="p">,</span><span class="w"> </span><span class="nx">onLoad</span><span class="p">,</span><span class="w"> </span><span class="kc">undefined</span><span class="p">,</span><span class="w"> </span><span class="nx">onError</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>Here, <em>onLoad</em> is a function that will be called after the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> has finished loading. The function could, for example, set <em>scene.background</em> equal to <em>cubeTexture</em> and re-render the scene with the new background. The last parameter onError is a function that will be called if the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> cannot be loaded. Only the first parameter is required.</p>
<p>The sample program <a href="../../../en/source/threejs/skybox.html">threejs/<abbr title="一个围绕场景的大立方体，用图像纹理，形成该场景所有方向的背景。">skybox</abbr>.html</a> shows two <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> scenes. The first scene shows a cube with the six images from a cube map applied as normal textures to the six faces of a cube. The second scene uses the same cube map as a <abbr title="一个围绕场景的大立方体，用图像纹理，形成该场景所有方向的背景。">skybox</abbr>. If you rotate the view of the second scene, you can look at all parts of the <abbr title="一个围绕场景的大立方体，用图像纹理，形成该场景所有方向的背景。">skybox</abbr> and see how it forms a seamless environment that completely encloses the scene.</p>
</div>
</div>
</div>
<h2 id="535-反射和折射">5.3.5 反射和折射<a class="headerlink" href="#535-反射和折射" title="Permanent link">&para;</a></h2>
<p><strong>Reflection and Refraction</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="6:2"><input checked="checked" id="__tabbed_6_1" name="__tabbed_6" type="radio" /><input id="__tabbed_6_2" name="__tabbed_6" type="radio" /><div class="tabbed-labels"><label for="__tabbed_6_1">中文</label><label for="__tabbed_6_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>反射面不应该仅仅反射光线——它应该反射其环境。<em>Three.js</em>可以使用<strong><abbr title="一种模拟物体表面类似镜面反射的方法。要从表面上反射的环境被表示为立方体贴图。为了确定纹理中哪个点在物体上的给定点可见，从视点反射到表面点的射线，并且与纹理立方体相交的反射射线。环境映射也称为反射映射。">环境映射</abbr></strong>来模拟反射。（环境映射也称为“反射映射。”）环境映射使用立方体贴图。给定表面上的一个点，从相机位置向该点投射一条射线，然后射线从表面反射。反射射线击中立方体的点决定了应该将纹理中的哪个点映射到表面上的点。对于完美镜面反射的模拟，表面点简单地用来自纹理的颜色绘制。注意，表面并不会字面意义上反射场景中的其他对象。它反射的是立方体贴图中的内容。然而，如果相同的立方体贴图在skybox中使用，并且skybox是场景中唯一的其他对象，那么看起来表面就像是一个完美反射其环境的镜子。</p>
<p>这种类型的反射在three.js中非常容易实现。你只需要制作一个网格材质，并将其envMap属性设置为立方体贴图对象。例如，如果cubeTexture是使用<strong><em>THREE.CubeTextureLoader</em></strong>获得的纹理对象，就像上面的skybox示例一样，我们可以通过以下方式制作一个完美反射纹理的球体：</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">geometry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">SphereGeometry</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="mf">32</span><span class="p">,</span><span class="mf">16</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">material</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">MeshBasicMaterial</span><span class="p">(</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="nx">color</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;white&quot;</span><span class="p">,</span><span class="w">  </span><span class="c1">// 颜色将乘以环境贴图。</span>
<span class="w">        </span><span class="nx">envMap</span><span class="o">:</span><span class="w"> </span><span class="nx">cubeTexture</span><span class="w">  </span><span class="c1">// 用作环境贴图的CubeTexture。</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">mirrorSphere</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">Mesh</span><span class="p">(</span><span class="w"> </span><span class="nx">geometry</span><span class="p">,</span><span class="w"> </span><span class="nx">material</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>为了使效果看起来好，你会想使用与场景背景相同的纹理。注意，场景中不需要照明，因为球体使用<strong><em>MeshBasicMaterial</em></strong>。在球体上看到的颜色完全来自环境贴图和球体材质的基本颜色。环境贴图颜色乘以基本颜色。在这个例子中，材质的基本<em>颜色</em>是白色的，球体的颜色与纹理中的颜色完全相同。使用不同的基础颜色，环境贴图纹理将被该颜色“染色”。你甚至可以给球体应用一个常规的纹理映射，以代替颜色，以便skybox的反射与纹理结合。</p>
<p>示例程序<a href="../../../en/source/threejs/reflection.html">threejs/reflection.html</a>演示了环境映射。它可以显示各种环境映射的对象，具有各种skybox纹理，并且它有几个选项用于对象的基本颜色。这里有两个来自该程序的图像。左边的一个显示了一个白色基础颜色的反射箭头形状。右边的对象是一匹马的模型（来自<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>下载），其基础颜色是粉色：</p>
<p><a class="glightbox" href="../../../en/c5/threejs-reflection.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c5/threejs-reflection.png" /></a></p>
<p>这里有一个与示例程序非常相似的演示。在演示中，你可以选择只查看skybox或只查看反射对象，你可以看到对象似乎只反射其实际环境。使用鼠标旋转场景，以查看随着对象方向变化反射如何变化。</p>
<p><iframe src="../../../en/demos/c5/reflection-demo.html" width="600" height="525"></iframe></p>
<p><em>Three.js</em>也可以进行<strong><abbr title="光线从一种透明或半透明介质进入另一种介质时的弯曲。">折射</abbr></strong>。折射发生在光线通过透明或半透明物体时。当光线在物体内部和外部之间通过时，光线会被弯曲。弯曲的程度取决于所谓物体外部和内部材料的“折射率”。更准确地说，它取决于两个折射率之间的比率。即使是完全透明的物体也会因为这种弯曲引起的畸变而可见（除非比率是1，这意味着光线根本没有弯曲）。</p>
<p>在<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>中，折射使用环境映射来实现。与反射一样，折射物体不会显示其实际环境；它折射用作环境映射的立方体贴图。对于折射，必须为环境贴图纹理使用特殊的“映射”。纹理的<em>mapping</em>属性告诉如何将该纹理映射到表面上。对于用于折射的立方体贴图，它应该设置为<em>THREE.CubeRefractionMapping</em>。（立方体贴图的这个属性的默认值适用于反射而不是折射。）以下是一个加载立方体贴图并为其折射使用设置映射属性的示例：</p>
<div class="highlight"><pre><span></span><code><span class="nx">cubeTexture</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">CubeTextureLoader</span><span class="p">().</span><span class="nx">load</span><span class="p">(</span><span class="w"> </span><span class="nx">textureURLs</span><span class="w"> </span><span class="p">);</span>
<span class="nx">cubeTexture</span><span class="p">.</span><span class="nx">mapping</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">CubeRefractionMapping</span><span class="p">;</span>
</code></pre></div>
<p>除此之外，应用于折射物体的材质的<em>refractionRatio</em>属性还应该设置。该值是一个介于0和1之间的数字；越接近1，光线的弯曲就越少。默认值非常接近1，以至于物体几乎看不见。这个示例使用0.6的值：</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">material</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">MeshBasicMaterial</span><span class="p">(</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="nx">color</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;white&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nx">envMap</span><span class="o">:</span><span class="w"> </span><span class="nx">cubeTexture</span><span class="p">,</span>
<span class="w">        </span><span class="nx">refractionRatio</span><span class="o">:</span><span class="w"> </span><span class="mf">0.6</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>这会产生强烈的折射效果。如果你将材质颜色设置为白色以外的其他颜色，你将得到看起来像有色玻璃的东西。另一个可能设置的属性是<em><abbr title="The proportion or fraction of incident light that is reflected by an object. An object can have different reflectivities at different wavelengths. The color of an object is determined by its reflectivities at all wavelengths.">reflectivity</abbr></em>。对于一个折射物体，这个值告诉有多少光线通过物体传输而不是从其表面反射。默认值1使光线传输达到100%；较小的值使物体看起来像是用“多云”的玻璃制成的，这种玻璃会阻挡一些光线。</p>
<p>示例程序<a href="../../../en/source/threejs/refraction.html">threejs/<abbr title="The bending of light as it passes from one transparent or translucent medium into another.">refraction</abbr>.html</a>是<em>reflection.html</em>的副本，已修改为进行折射而不是反射。物体看起来像是用玻璃而不是镜子制成的。该程序有一个复选框，使玻璃看起来多云，还有一个将<em>refractionRatio</em>从0.6增加到0.9的复选框。以下图像来自该程序。第一张图像显示了一个完全透明的箭头，第二张是一个多云的球体。注意球体如何显示它背后的物体的倒像：</p>
<p><a class="glightbox" href="../../../en/c5/threejs-refraction.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c5/threejs-refraction.png" /></a></p>
<p>在我的反射和折射示例中，环境是一个skybox，有一个单一的物体反射或折射该环境。但是，如果一个场景包括多个对象怎么办？物体不会出现在立方体贴图中。如果你在物体上使用立方体贴图，它们就不会相互反射或折射。WebGL中这个问题没有完整的解决方案。然而，你可以通过制作包括这些物体的环境贴图来使一个物体反射或折射其他物体。如果物体在移动，这意味着你必须为每一帧制作一个新的环境贴图。回想一下，环境贴图可以通过从不同方向拍摄环境的六张照片来制作。Three.js有一种可以这样做的相机，<strong><em>THREE.CubeCamera</em></strong>。我不会详细介绍，但CubeCamera可以从给定的视角拍摄场景的六重图像，并从这些图像中制作立方体贴图。要使用相机，你必须将其放置在物体的位置——并使物体看不见，这样它就不会出现在图片中。拍照，并将其作为环境贴图应用于物体。对于动画场景，你必须在每一帧都这样做，你需要为场景中的每个反射/折射物体都这样做。显然，这可能会变得非常计算密集！并且结果仍然不是完美的。首先，你不会看到多重反射，物体彼此之间来回反射几次。为此，你需要使用OpenGL使用的不同类型的渲染。我们将在<a href="../../c7/s4/#744-动态立方体贴图纹理">7.4.4小节</a>中回到动态立方体贴图的话题，并在<a href="../../c8/">第8章</a>中回到替代渲染技术的话题。</p>
</div>
<div class="tabbed-block">
<p>A reflective surface shouldn't just reflect light—it should reflect its environment. <em>Three.js</em> can use <strong><abbr title="A way of simulating mirror-like reflection from the surface of an object. The environment that is to be reflected from the surface is represented as a cubemap texture. To determine what point in the texture is visible at a given point on the object, a ray from the viewpoint is reflected from the surface point, and the reflected ray is intersected with the texture cube. Environment mapping is also called reflection mapping.">environment mapping</abbr></strong> to simulate reflection. (Environment mapping is also called "<abbr title="Another name for environment mapping.">reflection mapping</abbr>.") Environment mapping uses a cube map <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. Given a point on a surface, a ray is cast from the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> position to that point, and then the ray is reflected off the surface. The point where the reflected ray hits the cube determines which point from the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> should be mapped to the point on the surface. For a simulation of perfect, mirror-like reflection, the surface point is simply painted with the color from the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. Note that the surface does not literally reflect other objects in the scene. It reflects the contents of the cube map <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. However, if the same cube map <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> is used on a <abbr title="一个围绕场景的大立方体，用图像纹理，形成该场景所有方向的背景。">skybox</abbr>, and if the <abbr title="一个围绕场景的大立方体，用图像纹理，形成该场景所有方向的背景。">skybox</abbr> is the only other object in the scene, then it will look like the surface is a mirror that perfectly reflects its environment.</p>
<p>This type of reflection is very easy to do in <abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr>. You only need to make a mesh <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> and set its envMap property equal to the <abbr title="A texture made up of six images, one for each of the directions positive x, negative x, positive y, negative y, positive z, and negative z. The images are intended to include everything that can be seen from a given point. Cubemap textures are used for environment mapping and skyboxes.">cubemap texture</abbr> object. For example, if cubeTexture is the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object obtained using a <strong><em>THREE.CubeTextureLoader</em></strong>, as in the <abbr title="一个围绕场景的大立方体，用图像纹理，形成该场景所有方向的背景。">skybox</abbr> example above, we can make a sphere that perfectly reflects the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> by saying:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">geometry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">SphereGeometry</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="mf">32</span><span class="p">,</span><span class="mf">16</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">material</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">MeshBasicMaterial</span><span class="p">(</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="nx">color</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;white&quot;</span><span class="p">,</span><span class="w">  </span><span class="c1">// Color will be multiplied by the environment map. </span>
<span class="w">        </span><span class="nx">envMap</span><span class="o">:</span><span class="w"> </span><span class="nx">cubeTexture</span><span class="w">  </span><span class="c1">// CubeTexture to be used as an environment map.</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">mirrorSphere</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">Mesh</span><span class="p">(</span><span class="w"> </span><span class="nx">geometry</span><span class="p">,</span><span class="w"> </span><span class="nx">material</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>For the effect to look good, you would want to use the same <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> as the scene background. Note that no <abbr title="Using light sources in a 3D scene, so that the appearance of objects in the scene can be computed based on the interaction of light with the objects' material properties.">lighting</abbr> would be necessary in the scene, since the sphere uses a <strong><em>MeshBasicMaterial</em></strong>. The colors seen on the sphere come entirely from the environment map and the basic color of the sphere <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr>. The environment map color is multiplied by the basic color. In this example, the basic <em>color</em> of the <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> is white, and the sphere color is exactly equal to the color from the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. With a different base color, the environment map <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> would be "tinted" with that color. You could even apply a regular <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> map to the sphere, to be used in place of the color, so that the reflection of the <abbr title="一个围绕场景的大立方体，用图像纹理，形成该场景所有方向的背景。">skybox</abbr> would be combined with the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>.</p>
<p>The sample program <a href="../../../en/source/threejs/reflection.html">threejs/reflection.html</a> demonstrates <abbr title="A way of simulating mirror-like reflection from the surface of an object. The environment that is to be reflected from the surface is represented as a cubemap texture. To determine what point in the texture is visible at a given point on the object, a ray from the viewpoint is reflected from the surface point, and the reflected ray is intersected with the texture cube. Environment mapping is also called reflection mapping.">environment mapping</abbr>. It can show a variety of environment-mapped objects, with a variety of <abbr title="一个围绕场景的大立方体，用图像纹理，形成该场景所有方向的背景。">skybox</abbr> textures, and it has several options for the base color of the object. Here are two images from that program. The one on the left shows a reflective arrowhead shape with a white base color. On the right, the object is a model of a horse (taken from the <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em> download) whose base color is pink:</p>
<p><a class="glightbox" href="../../../en/c5/threejs-reflection.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c5/threejs-reflection.png" /></a></p>
<p>Here is a demo that is very similar to the sample program. In the demo, you can choose to view just the <abbr title="一个围绕场景的大立方体，用图像纹理，形成该场景所有方向的背景。">skybox</abbr> or just the reflective object, and you can see that the object only seems to be reflecting its actual environment. Use your mouse to rotate the scene to see how the reflection changes as the orientation of the object changes.</p>
<p><iframe src="../../../en/demos/c5/reflection-demo.html" width="600" height="525"></iframe></p>
<p><em>Three.js</em> can also do <strong><abbr title="The bending of light as it passes from one transparent or translucent medium into another.">refraction</abbr></strong>. Refraction occurs when light passes through a transparent or translucent object. A ray of light will be bent as it passes between the inside of the object and the outside. The amount of bending depends on the so-called "indices of <abbr title="The bending of light as it passes from one transparent or translucent medium into another.">refraction</abbr>" of the <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> outside and the <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> inside the object. More exactly, it depends on the ratio between the two indices. Even a perfectly transparent object will be visible because of the distortion induced by this bending (unless the ratio is 1, meaning that there is no bending of light at all).</p>
<p>In <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>, <abbr title="The bending of light as it passes from one transparent or translucent medium into another.">refraction</abbr> is implemented using environment maps. As with reflection, a refracting object does not show its actual environment; it refracts the <abbr title="A texture made up of six images, one for each of the directions positive x, negative x, positive y, negative y, positive z, and negative z. The images are intended to include everything that can be seen from a given point. Cubemap textures are used for environment mapping and skyboxes.">cubemap texture</abbr> that is used as the environment map. For <abbr title="The bending of light as it passes from one transparent or translucent medium into another.">refraction</abbr>, a special "mapping" must be used for the environment map <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. The <em>mapping</em> property of a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> tells how that <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> will be mapped to a surface. For a <abbr title="A texture made up of six images, one for each of the directions positive x, negative x, positive y, negative y, positive z, and negative z. The images are intended to include everything that can be seen from a given point. Cubemap textures are used for environment mapping and skyboxes.">cubemap texture</abbr> being used for <abbr title="The bending of light as it passes from one transparent or translucent medium into another.">refraction</abbr>, it should be set to <em>THREE.CubeRefractionMapping</em>. (The default value of this property in a <abbr title="A texture made up of six images, one for each of the directions positive x, negative x, positive y, negative y, positive z, and negative z. The images are intended to include everything that can be seen from a given point. Cubemap textures are used for environment mapping and skyboxes.">cubemap texture</abbr> is appropriate for reflection rather than <abbr title="The bending of light as it passes from one transparent or translucent medium into another.">refraction</abbr>.) Here is an example of loading a <abbr title="A texture made up of six images, one for each of the directions positive x, negative x, positive y, negative y, positive z, and negative z. The images are intended to include everything that can be seen from a given point. Cubemap textures are used for environment mapping and skyboxes.">cubemap texture</abbr> and setting its mapping property for use with <abbr title="The bending of light as it passes from one transparent or translucent medium into another.">refraction</abbr>:</p>
<div class="highlight"><pre><span></span><code><span class="nx">cubeTexture</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">CubeTextureLoader</span><span class="p">().</span><span class="nx">load</span><span class="p">(</span><span class="w"> </span><span class="nx">textureURLs</span><span class="w"> </span><span class="p">);</span>
<span class="nx">cubeTexture</span><span class="p">.</span><span class="nx">mapping</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">CubeRefractionMapping</span><span class="p">;</span>
</code></pre></div>
<p>In addition to this, the <em>refractionRatio</em> property of the <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> that is applied to the refracting object should be set. The value is a number between 0 and 1; the closer to 1, the less bending of light. The default value is so close to 1 that the object will be almost invisible. This example uses a value of 0.6:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">material</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">MeshBasicMaterial</span><span class="p">(</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="nx">color</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;white&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nx">envMap</span><span class="o">:</span><span class="w"> </span><span class="nx">cubeTexture</span><span class="p">,</span>
<span class="w">        </span><span class="nx">refractionRatio</span><span class="o">:</span><span class="w"> </span><span class="mf">0.6</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>This gives a strong refractive effect. If you set the <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> color to something other than white, you will get something that looks like tinted glass. Another property that you might set is the <em><abbr title="The proportion or fraction of incident light that is reflected by an object. An object can have different reflectivities at different wavelengths. The color of an object is determined by its reflectivities at all wavelengths.">reflectivity</abbr></em>. For a refractive object, this value tells how much light is transmitted through the object rather than reflected from its surface. The default value, 1, gives 100% transmission of light; smaller values make objects look like they are made out of "cloudy" glass that blocks some of the light.</p>
<p>The sample program <a href="../../../en/source/threejs/refraction.html">threejs/<abbr title="The bending of light as it passes from one transparent or translucent medium into another.">refraction</abbr>.html</a> is a copy of <em>reflection.html</em> that has been modified to do <abbr title="The bending of light as it passes from one transparent or translucent medium into another.">refraction</abbr> instead of reflection. The objects look like they are made of glass instead of mirrors. The program has a checkbox that makes the glass look cloudy and one that increases the <em>refractionRatio</em> from 0.6 to 0.9. The following images are from that program. A perfectly transmissive arrowhead is shown in the first image, and a cloudy sphere in the second. Notice how the sphere shows an inverted image of the objects behind it:</p>
<p><a class="glightbox" href="../../../en/c5/threejs-refraction.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c5/threejs-refraction.png" /></a></p>
<p>In my reflection and <abbr title="The bending of light as it passes from one transparent or translucent medium into another.">refraction</abbr> examples, the environment is a <abbr title="一个围绕场景的大立方体，用图像纹理，形成该场景所有方向的背景。">skybox</abbr>, and there is a single object that reflects or refracts that environment. But what if a scene includes more than one object? The objects won't be in the <abbr title="A texture made up of six images, one for each of the directions positive x, negative x, positive y, negative y, positive z, and negative z. The images are intended to include everything that can be seen from a given point. Cubemap textures are used for environment mapping and skyboxes.">cubemap texture</abbr>. If you use the <abbr title="A texture made up of six images, one for each of the directions positive x, negative x, positive y, negative y, positive z, and negative z. The images are intended to include everything that can be seen from a given point. Cubemap textures are used for environment mapping and skyboxes.">cubemap texture</abbr> on the objects, they won't reflect or refract <strong>each other</strong>. There is no complete solution to this problem in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>. However, you can make an object reflect or refract other objects by making an environment map that includes those objects. If the objects are moving, this means that you have to make a new environment map for every frame. Recall that an environment map can be made by taking six pictures of the environment from different directions. Three.js has a kind of <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> that can do just that, <strong><em>THREE.CubeCamera</em></strong>. I won't go into the full details, but a CubeCamera can take a six-fold picture of a scene from a given point of view and make a <abbr title="A texture made up of six images, one for each of the directions positive x, negative x, positive y, negative y, positive z, and negative z. The images are intended to include everything that can be seen from a given point. Cubemap textures are used for environment mapping and skyboxes.">cubemap texture</abbr> from those images. To use the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>, you have to place it at the location of an object—and make the object invisible so it doesn't show up in the pictures. Snap the picture, and apply it as an environment map on the object. For animated scenes, you have to do this in every frame, and you need to do it for every reflective/refractive object in the scene. Obviously, this can get very computationally expensive! And the result still isn't perfect. For one thing, you won't see multiple reflections, where objects reflect back and forth on each other several times. For that, you need a different kind of <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> from the one used by <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr>. We will return to the topic of dynamic cubemaps in <a href="../../c7/s4/#744-动态立方体贴图纹理">Subsection 7.4.4</a> and to alternative <abbr title="The process of producing a 2D image from a 3D scene description.">rendering</abbr> techniques in <a href="../../c8/">Chapter 8</a>.</p>
</div>
</div>
</div>







  
    
  
  
    
  


  <aside class="md-source-file">
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="最后更新">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1-2.1-2M12.5 7v5.2l4 2.4-1 1L11 13V7h1.5M11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2v1.8Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">2024年5月26日</span>
  </span>

    
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="创建日期">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.47 15.08 11 13V7h1.5v5.25l3.08 1.83c-.41.28-.79.62-1.11 1m-1.39 4.84c-.36.05-.71.08-1.08.08-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8c0 .37-.03.72-.08 1.08.69.1 1.33.32 1.92.64.1-.56.16-1.13.16-1.72 0-5.5-4.5-10-10-10S2 6.5 2 12s4.47 10 10 10c.59 0 1.16-.06 1.72-.16-.32-.59-.54-1.23-.64-1.92M18 15v3h-3v2h3v3h2v-3h3v-2h-3v-3h-2Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">2024年5月26日</span>
  </span>

    
    
    
  </aside>





                
              </article>
            </div>
          
          
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var tab,labels=set.querySelector(".tabbed-labels");for(tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script>

<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../../..", "features": ["content.code.copy", "content.tabs.link", "navigation.tabs", "navigation.tabs.sticky", "navigation.indexes", "navigation.top", "toc.follow", "content.tooltips"], "search": "../../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.3220b9d7.min.js"></script>
      
        <script src="../../../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="https://unpkg.com/mermaid@9.4.0/dist/mermaid.min.js"></script>
      
    
  <script>document$.subscribe(() => {const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});})</script></body>
</html>