
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="计算机图形学概论(graphicsbook)">
      
      
      
        <link rel="canonical" href="https://hellowac.github.io/graphicsbook-zh-cn/cn/c5/s2/">
      
      
        <link rel="prev" href="../s1/">
      
      
        <link rel="next" href="../s3/">
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.5.18">
    
    
      
        <title>5.2 构建对象 - 计算机图形学概论</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.66ac8b77.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.06af60db.min.css">
      
      

  
  
  
  
  <style>:root{--md-annotation-icon:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M22 12a10 10 0 0 1-10 10A10 10 0 0 1 2 12 10 10 0 0 1 12 2a10 10 0 0 1 10 10M6 13h8l-3.5 3.5 1.42 1.42L17.84 12l-5.92-5.92L10.5 7.5 14 11H6v2Z"/></svg>');}</style>


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
   <link href="../../../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
        html.glightbox-open { overflow: initial; height: 100%; }
        .gslide-title { margin-top: 0px; user-select: text; }
        .gslide-desc { color: #666; user-select: text; }
        .gslide-image img { background: white; }
        
            .gscrollbar-fixer { padding-right: 15px; }
            .gdesc-inner { font-size: 0.75rem; }
            body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
            body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
            body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}
            </style> <script src="../../../assets/javascripts/glightbox.min.js"></script></head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="default" data-md-color-accent="red">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#52-构建对象" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="计算机图形学概论" class="md-header__button md-logo" aria-label="计算机图形学概论" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            计算机图形学概论
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              5.2 构建对象
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
      <div class="md-header__option">
  <div class="md-select">
    
    <button class="md-header__button md-icon" aria-label="选择当前语言">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m12.87 15.07-2.54-2.51.03-.03A17.52 17.52 0 0 0 14.07 6H17V4h-7V2H8v2H1v2h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04M18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12m-2.62 7 1.62-4.33L19.12 17h-3.24Z"/></svg>
    </button>
    <div class="md-select__inner">
      <ul class="md-select__list">
        
          <li class="md-select__item">
            <a href="/graphicsbook-zh-cn/en/" hreflang="en" class="md-select__link">
              English
            </a>
          </li>
        
          <li class="md-select__item">
            <a href="/graphicsbook-zh-cn/cn/" hreflang="cn" class="md-select__link">
              中文
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</div>
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/hellowac/graphicsbook-zh-cn" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    graphicsbook
  </div>
</a>
      </div>
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../" class="md-tabs__link">
        
  
    
  
  首页

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../preface/" class="md-tabs__link">
        
  
    
  
  前言

      </a>
    </li>
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c1/" class="md-tabs__link">
          
  
    
  
  1.简介

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c2/" class="md-tabs__link">
          
  
    
  
  2.二维图形

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c3/" class="md-tabs__link">
          
  
    
  
  3.几何

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c4/" class="md-tabs__link">
          
  
    
  
  4.灯光和材质

        </a>
      </li>
    
  

      
        
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../" class="md-tabs__link">
          
  
    
  
  5.three.js

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c6/" class="md-tabs__link">
          
  
    
  
  6.WebGL

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c7/" class="md-tabs__link">
          
  
    
  
  7.WebGL 3D

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c8/" class="md-tabs__link">
          
  
    
  
  8.高阶3D

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c9/" class="md-tabs__link">
          
  
    
  
  9.WEBGPU

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../a1/" class="md-tabs__link">
          
  
    
  
  附录

        </a>
      </li>
    
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../.." class="md-tabs__link">
        
  
    
  
  关于

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="计算机图形学概论" class="md-nav__button md-logo" aria-label="计算机图形学概论" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    计算机图形学概论
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/hellowac/graphicsbook-zh-cn" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    graphicsbook
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    首页
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../preface/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    前言
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c1/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    1.简介
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_3" id="__nav_3_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            1.简介
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 1 节 绘画与绘图
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 2 节：三维(3D)图形的要素
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 3 节：硬件与软件
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c2/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    2.二维图形
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_4" id="__nav_4_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            2.二维图形
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第1节: 像素、坐标和颜色
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第2节: 形状
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第3节: 变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第4节: 分层建模
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第5节: Java 绘制2D
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第6节: HTML Canvas图形
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c2/s7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第7节: SVG：一种场景描述语言
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c3/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    3.几何
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_5" id="__nav_5_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            3.几何
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.1 OpenGL 1.1 中的形状和颜色
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.2 3D 坐标和变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.3 投影与观看
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.4 多边形网格和 glDrawArrays
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.5 部分线性代数基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.6 使用 GLUT 和 JOGL
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c4/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    4.灯光和材质
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_6" id="__nav_6_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6">
            <span class="md-nav__icon md-icon"></span>
            4.灯光和材质
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.1 照明简介
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.2 OpenGL 1.1 中的光和材质
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.3 图像纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.4 灯光、相机、动作
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" checked>
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    5.three.js
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_7" id="__nav_7_label" tabindex="">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_7">
            <span class="md-nav__icon md-icon"></span>
            5.three.js
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.1 Three.js 基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    5.2 构建对象
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    5.2 构建对象
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#521-多边形网格和-ifs" class="md-nav__link">
    <span class="md-ellipsis">
      5.2.1 多边形网格和 IFS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#522-曲线和曲面" class="md-nav__link">
    <span class="md-ellipsis">
      5.2.2 曲线和曲面
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#523-纹理" class="md-nav__link">
    <span class="md-ellipsis">
      5.2.3 纹理
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#524-变换" class="md-nav__link">
    <span class="md-ellipsis">
      5.2.4 变换
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#525-加载模型" class="md-nav__link">
    <span class="md-ellipsis">
      5.2.5 加载模型
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.3 其他功能
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c6/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    6.WebGL
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_8" id="__nav_8_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8">
            <span class="md-nav__icon md-icon"></span>
            6.WebGL
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.1 可编程流水线
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.2 第一个例子
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.3 GLSL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.4 图像纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.5 实现 2D 变换
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c7/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    7.WebGL 3D
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_9" id="__nav_9_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9">
            <span class="md-nav__icon md-icon"></span>
            7.WebGL 3D
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.1 3D变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.2 照明和材质
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.3 纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.4 帧缓冲区
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.5 WebGL 扩展
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c8/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    8.高阶3D
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_10" id="__nav_10_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_10_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10">
            <span class="md-nav__icon md-icon"></span>
            8.高阶3D
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c8/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8.1 光线追踪
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c8/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8.2 路径追踪
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_11" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c9/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    9.WEBGPU
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_11" id="__nav_11_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_11_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_11">
            <span class="md-nav__icon md-icon"></span>
            9.WEBGPU
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.1 WebGPU 基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.2 实例和索引
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.3 WGSL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.4 WebGPU 中的 3D 图形
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.5 纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.6 计算着色器
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.7 细节
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_12" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../a1/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    附录
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_12" id="__nav_12_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_12_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_12">
            <span class="md-nav__icon md-icon"></span>
            附录
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a2/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Blender 3D建模
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a3/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Gimp和Inkscape
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../source/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    示例程序源代码
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../glossary/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    术语表
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    关于
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#521-多边形网格和-ifs" class="md-nav__link">
    <span class="md-ellipsis">
      5.2.1 多边形网格和 IFS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#522-曲线和曲面" class="md-nav__link">
    <span class="md-ellipsis">
      5.2.2 曲线和曲面
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#523-纹理" class="md-nav__link">
    <span class="md-ellipsis">
      5.2.3 纹理
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#524-变换" class="md-nav__link">
    <span class="md-ellipsis">
      5.2.4 变换
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#525-加载模型" class="md-nav__link">
    <span class="md-ellipsis">
      5.2.5 加载模型
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="52-构建对象">5.2 构建对象<a class="headerlink" href="#52-构建对象" title="Permanent link">&para;</a></h1>
<p><strong>Building Objects</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="1:2"><input checked="checked" id="__tabbed_1_1" name="__tabbed_1" type="radio" /><input id="__tabbed_1_2" name="__tabbed_1" type="radio" /><div class="tabbed-labels"><label for="__tabbed_1_1">中文</label><label for="__tabbed_1_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>在<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>中，一个可见对象是由几何体和材质构建的。我们已经看到了如何创建适用于点和线原语的简单几何体，并遇到了使用<em>GL_TRIANGLES</em>原语的各种标准网格几何体，例如<strong><em>THREE.CylinderGeometry</em></strong>和<strong><em>THREE.IcosahedronGeometry</em></strong>。在这一部分，我们将看到如何从头开始创建新的网格几何体。我们还将看看three.js为处理对象和材质提供的一些其他支持。</p>
</div>
<div class="tabbed-block">
<p>In <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>, a visible object is constructed from a geometry and a <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr>. We have seen how to create simple geometries that are suitable for point and line primitives, and we have encountered a variety of standard mesh geometries, such as <strong><em>THREE.CylinderGeometry</em></strong> and <strong><em>THREE.IcosahedronGeometry</em></strong>, that use the <em>GL_TRIANGLES</em> primitive. In this section, we will see how to create new mesh geometries from scratch. We'll also look at some of the other support that <abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr> provides for working with objects and materials.</p>
</div>
</div>
</div>
<h2 id="521-多边形网格和-ifs">5.2.1 多边形网格和 IFS<a class="headerlink" href="#521-多边形网格和-ifs" title="Permanent link">&para;</a></h2>
<p><strong>Polygonal Meshes and IFSs</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="2:2"><input checked="checked" id="__tabbed_2_1" name="__tabbed_2" type="radio" /><input id="__tabbed_2_2" name="__tabbed_2" type="radio" /><div class="tabbed-labels"><label for="__tabbed_2_1">中文</label><label for="__tabbed_2_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>在<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>中，我们所说的网格是指在<a href="../../c3/s4/">第3.4节</a>中提到的多边形网格，尽管在<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>的网格中，所有的多边形都必须是三角形。在WebGL中绘制多边形网格有两种方法。一种使用的是函数<em>glDrawArrays()</em>，它只需要一个顶点列表。另一种使用的是我们称之为索引面集（IFS）的表示方法，它是使用函数<em>glDrawElements()</em>绘制的。除了顶点列表，IFS还使用面索引列表来指定三角形。我们将以这个金字塔为例，来查看两种方法：</p>
<p><a class="glightbox" href="../../../en/c5/pyramid-IFS.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c5/pyramid-IFS.png" /></a></p>
<p>请注意，金字塔的底部是一个正方形，必须被分割成两个三角形，以便将金字塔表示为网格几何体。顶点从0编号到4。一个三角形面可以通过三个数字来指定，这三个数字给出了该三角形顶点的顶点编号。像往常一样，当从前面，即从金字塔的外部观察时，三角形的顶点应该按逆时针顺序指定。这里是我们需要的数据。</p>
<div class="highlight"><pre><span></span><code>    VERTEX COORDINATES:         FACE INDICES:

    Vertex 0:   1, 0,  1        Face 1:  3, 2, 1 
    Vertex 1:   1, 0, -1        Face 2:  3, 1, 0 
    Vertex 2:  -1, 0, -1        Face 3:  3, 0, 4 
    Vertex 3:  -1, 0,  1        Face 4:  0, 1, 4 
    Vertex 4:   0, 1,  0        Face 5:  1, 2, 4 
                                Face 6:  2, 3, 4
</code></pre></div>
<p>一个基本的多边形网格表示不使用面索引。相反，它通过列出顶点的坐标来指定每个三角形。这需要九个数字——每个顶点三个数字——用于三角形的三个顶点。由于一个顶点可以被几个三角形共享，所以存在一些冗余。对于金字塔，一个顶点的坐标将被重复三到四次。</p>
<p><em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>的网格对象需要一个几何体和一个材质。几何体是一个类型为<strong><em>THREE.BufferedGeometry</em></strong>的对象，它有一个“position”<abbr title="图形对象的属性，例如颜色。图像可以通过其包含的几何形状以及它们的属性来指定。">属性</abbr>，该属性保存了网格中使用的顶点的坐标。该属性使用一个类型化数组来保存构成网格的三角形的顶点坐标。金字塔的几何体可以这样创建：</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">pyramidVertices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Float32Array</span><span class="p">(</span><span class="w"> </span><span class="p">[</span>
<span class="w">            </span><span class="c1">// 金字塔Geom &quot;position&quot;属性的数据。</span>
<span class="w">            </span><span class="c1">// 包含顶点的x,y,z坐标。</span>
<span class="w">            </span><span class="c1">// 每组三个数字是一个顶点；</span>
<span class="w">            </span><span class="c1">// 每组三个顶点是一个面。</span>
<span class="w">            </span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="c1">// 底部的第一个三角形。</span>
<span class="w">            </span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w">   </span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="c1">// 底部的第二个三角形。</span>
<span class="w">            </span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w">   </span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w">   </span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="c1">// 前面。</span>
<span class="w">            </span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w">   </span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="c1">// 右面。</span>
<span class="w">            </span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="c1">// 后面。</span>
<span class="w">            </span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w">   </span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="w">   </span><span class="c1">// 左面。</span>
<span class="w">        </span><span class="p">]</span><span class="w"> </span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">pyramidGeom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">BufferGeometry</span><span class="p">();</span>
<span class="nx">pyramidGeom</span><span class="p">.</span><span class="nx">setAttribute</span><span class="p">(</span><span class="s2">&quot;position&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">BufferAttribute</span><span class="p">(</span><span class="nx">pyramidVertices</span><span class="p">,</span><span class="mf">3</span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>当这个几何体与Lambert或Phong材质一起使用时，需要为顶点提供法向量。如果几何体没有法向量，Lambert和Phong材质将显示为黑色。网格的法向量必须存储在<strong><em>BufferedGeometry</em></strong>的另一个属性中。属性的名称是"normal"，它为"position"属性中的每个顶点保存一个法向量。它可以以与创建"position"属性相同的方式创建，但<strong><em>BufferedGeometry</em></strong>对象包括一个计算法向量的方法。对于<em>pyramidGeom</em>，我们可以简单地调用</p>
<div class="highlight"><pre><span></span><code><span class="nx">pyramidGeom</span><span class="p">.</span><span class="nx">computeVertexNormals</span><span class="p">();</span>
</code></pre></div>
<p>对于一个基本的多边形网格，这将创建垂直于面的法向量。当几个面共享一个顶点时，该顶点将为每个面有一个不同的法向量。这将产生平面看起来的面，这对于多面体是适当的，其侧面实际上是平的。如果多边形网格被用来近似一个平滑的表面，这是不适当的。在这种情况下，我们应该使用垂直于表面的法向量，这意味着通过手工创建"normal"<abbr title="图形对象的属性，例如颜色。图像可以通过其包含的几何形状以及它们的属性来指定。">属性</abbr>。（见<a href="../../c4/s1/#413-法向量">4.1.3小节</a>。）</p>
<p>一旦我们有了金字塔的几何体，我们可以通过将它与一个黄色的Lambert材质结合来在<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>网格对象中使用它：</p>
<div class="highlight"><pre><span></span><code><span class="nx">pyramid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">Mesh</span><span class="p">(</span><span class="w"> </span>
<span class="w">            </span><span class="nx">pyramidGeom</span><span class="p">,</span>
<span class="w">            </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">MeshLambertMaterial</span><span class="p">({</span><span class="w"> </span><span class="nx">color</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;yellow&quot;</span><span class="w"> </span><span class="p">})</span><span class="w"> </span>
<span class="w">        </span><span class="p">);</span>
</code></pre></div>
<p>但是，如果只有一种颜色，金字塔看起来会有点无聊。可以将不同的材质应用到网格的不同面上。为了实现这一点，几何体中的顶点必须被分成组。<strong><em>BufferedGeometry</em></strong>类的<em>addGroup()</em>方法用于创建这些组。几何体中的顶点根据它们在"position"属性中的顺序被编号为0, 1, 2, ...（这与上面使用的编号不同）。<em>addGroup()</em>方法接受三个参数：组中第一个顶点的编号、组中的顶点数和一个材质索引。材质索引是一个整数，它决定了哪个材质将被应用到该组。如果您正在使用组，重要的是将所有顶点都放入组中。以下是如何为金字塔创建组：</p>
<div class="highlight"><pre><span></span><code><span class="nx">pyramidGeom</span><span class="p">.</span><span class="nx">addGroup</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="mf">6</span><span class="p">,</span><span class="mf">0</span><span class="p">);</span><span class="w">  </span><span class="c1">// 底部（2个三角形）</span>
<span class="nx">pyramidGeom</span><span class="p">.</span><span class="nx">addGroup</span><span class="p">(</span><span class="mf">6</span><span class="p">,</span><span class="mf">3</span><span class="p">,</span><span class="mf">1</span><span class="p">);</span><span class="w">  </span><span class="c1">// 前面。</span>
<span class="nx">pyramidGeom</span><span class="p">.</span><span class="nx">addGroup</span><span class="p">(</span><span class="mf">9</span><span class="p">,</span><span class="mf">3</span><span class="p">,</span><span class="mf">2</span><span class="p">);</span><span class="w">  </span><span class="c1">// 右面。</span>
<span class="nx">pyramidGeom</span><span class="p">.</span><span class="nx">addGroup</span><span class="p">(</span><span class="mf">12</span><span class="p">,</span><span class="mf">3</span><span class="p">,</span><span class="mf">3</span><span class="p">);</span><span class="w"> </span><span class="c1">// 后面。</span>
<span class="nx">pyramidGeom</span><span class="p">.</span><span class="nx">addGroup</span><span class="p">(</span><span class="mf">15</span><span class="p">,</span><span class="mf">3</span><span class="p">,</span><span class="mf">4</span><span class="p">);</span><span class="w"> </span><span class="c1">// 左面。</span>
</code></pre></div>
<p>要将不同的材质应用到不同的组，应该将材质放入一个数组中。一个组的材质索引是该数组中的索引。</p>
<div class="highlight"><pre><span></span><code><span class="nx">pyramidMaterialArray</span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w"> </span>
<span class="w">        </span><span class="c1">// 材质数组，用于金字塔的材质。</span>
<span class="w">        </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">MeshLambertMaterial</span><span class="p">(</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">color</span><span class="o">:</span><span class="w"> </span><span class="mh">0xffffff</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">),</span>
<span class="w">        </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">MeshLambertMaterial</span><span class="p">(</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">color</span><span class="o">:</span><span class="w"> </span><span class="mh">0x99ffff</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">),</span>
<span class="w">        </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">MeshLambertMaterial</span><span class="p">(</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">color</span><span class="o">:</span><span class="w"> </span><span class="mh">0xff99ff</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">),</span>
<span class="w">        </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">MeshLambertMaterial</span><span class="p">(</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">color</span><span class="o">:</span><span class="w"> </span><span class="mh">0xffff99</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">),</span>
<span class="w">        </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">MeshLambertMaterial</span><span class="p">(</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">color</span><span class="o">:</span><span class="w"> </span><span class="mh">0xff9999</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">];</span>
</code></pre></div>
<p>这个数组可以作为第二个参数传递给<strong><em>THREE.Mesh</em></strong>构造函数，通常那里会使用单一材质。</p>
<div class="highlight"><pre><span></span><code><span class="nx">pyramid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">Mesh</span><span class="p">(</span><span class="w"> </span><span class="nx">pyramidGeom</span><span class="p">,</span><span class="w"> </span><span class="nx">pyramidMaterialArray</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>（但请注意，即使网格几何体使用组，您仍然可以在网格上使用单一材质。）</p>
<p><strong><em>THREE.BoxGeometry</em></strong>带有组，使得可以为每个面分配不同的材质。示例程序<a href="../../../en/source/threejs/vertex-groups.html">threejs/<abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>-groups.html</a>使用本节中的代码创建金字塔，并显示金字塔和立方体，每个对象上使用多种材质。它们看起来像这样：</p>
<p><a class="glightbox" href="../../../en/c5/MeshFaceMaterial.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c5/MeshFaceMaterial.png" /></a></p>
<p>还有另一种方法可以将不同的颜色分配给不同的顶点。<strong><em>BufferedGeometry</em></strong>可以有一个名为"color"的属性，它为每个顶点指定一种颜色。"color"属性使用一个数组，其中包含每个顶点的一组三个RGB分量值。顶点颜色默认被忽略。要使用它们，几何体必须与一个将<em>vertexColors</em>属性设置为<em>true</em>的材质结合使用。以下是如何使用顶点颜色来给金字塔的侧面上色：</p>
<div class="highlight"><pre><span></span><code><span class="nx">pyramidGeom</span><span class="p">.</span><span class="nx">setAttribute</span><span class="p">(</span>
<span class="w">        </span><span class="s2">&quot;color&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">BufferAttribute</span><span class="p">(</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Float32Array</span><span class="p">([</span>
<span class="w">                </span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="c1">// 底部顶点是白色</span>
<span class="w">                </span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span>
<span class="w">                </span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="c1">// 前面顶点是红色，</span>
<span class="w">                </span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="c1">// 右面顶点是绿色，</span>
<span class="w">                </span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="c1">// 后面顶点是蓝色，</span>
<span class="w">                </span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="w">  </span><span class="c1">// 左面顶点是黄色。</span>
<span class="w">            </span><span class="p">]),</span><span class="w"> </span><span class="mf">3</span><span class="p">)</span>
<span class="w">    </span><span class="p">);</span>
<span class="nx">pyramid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">Mesh</span><span class="p">(</span><span class="w"> </span>
<span class="w">        </span><span class="nx">pyramidGeom</span><span class="p">,</span><span class="w"> </span>
<span class="w">        </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">MeshLambertMaterial</span><span class="p">({</span>
<span class="w">            </span><span class="nx">color</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;white&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="nx">vertexColors</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">})</span><span class="w"> </span>
<span class="w">    </span><span class="p">);</span>
</code></pre></div>
<p>来自几何体的顶点颜色的颜色分量实际上是与Lambert材质中的颜色分量相乘的。将该颜色设置为白色，颜色分量等于一，这是有意义的；在这种情况下，顶点颜色不会被材质颜色修改。</p>
<p>在这个例子中，金字塔的每个面都是一个纯色。金字塔的颜色数组有很多冗余，因为必须为每个顶点指定颜色，即使给定面的顶点颜色都相同。实际上，并不要求一个面的顶点都有相同的颜色。如果它们被分配了不同的颜色，颜色将从顶点插值到面的内部。例如，在下面的演示中，为一个球体的二十面体近似的每个顶点指定了随机的顶点颜色：</p>
<p><iframe src="../../../en/demos/c5/vertex-and-color-animation.html" width="590" height="375"></iframe></p>
<p>该演示可以运行两个有点傻的动画；顶点颜色和顶点位置可以被动画化。</p>
<hr />
<p><em>glDrawElements()</em>函数用于避免基本多边形网格表示中的冗余。它使用索引面集（IFS）模式，这需要一个面索引数组来指定网格面的顶点。在该数组中，一个顶点是通过一个数字来指定的，而不是重复所有坐标和其他数据。注意，一个给定的顶点编号指的是该顶点的所有数据：顶点坐标、<abbr title="表面上某点的法向量是与该点表面垂直的向量。曲线的法向量定义类似。法向量对照明计算很重要。">法向量</abbr>、顶点颜色以及几何体的属性中提供的任何其他数据。假设两个面共享一个顶点。如果该顶点在两个面中有不同的法向量，或者某个其他属性有不同的值，那么这个向量将需要在属性数组中出现两次。只有当顶点在两个面中具有相同的属性时，这两个出现才能合并。IFS表示最适合用作平滑表面的近似的多边形网格，因为在这种情况下，顶点对所有它出现的顶点都有相同的法向量。它也适用于使用<strong><em>MeshBasicMaterial</em></strong>的对象，因为这种类型的材质不使用法向量。</p>
<p>要在使用<strong><em>BufferedGeometry</em></strong>时使用IFS模式，您需要为几何体提供一个面索引数组。该数组由几何体的setIndex()方法指定。参数可以是一个普通的JavaScript整数数组。对于我们的金字塔示例，几何体的“position”属性将只包含每个顶点一次，面索引数组将通过其在该顶点列表中的位置来引用一个顶点：</p>
<div class="highlight"><pre><span></span><code><span class="nx">pyramidVertices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Float32Array</span><span class="p">(</span><span class="w"> </span><span class="p">[</span>
<span class="w">            </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="c1">// 顶点编号0</span>
<span class="w">            </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="c1">// 顶点编号1</span>
<span class="w">            </span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="c1">// 顶点编号2</span>
<span class="w">            </span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="c1">// 顶点编号3</span>
<span class="w">            </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="mf">0</span><span class="w">   </span><span class="c1">// 顶点编号4</span>
<span class="p">]</span><span class="w"> </span><span class="p">);</span>

<span class="nx">pyramidFaceIndexArray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span>
<span class="w">            </span><span class="mf">3</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="c1">// 底部的第一个三角形。</span>
<span class="w">            </span><span class="mf">3</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="c1">// 底部的第二个三角形。</span>
<span class="w">            </span><span class="mf">3</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">4</span><span class="p">,</span><span class="w">  </span><span class="c1">// 前面。</span>
<span class="w">            </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">4</span><span class="p">,</span><span class="w">  </span><span class="c1">// 右面。</span>
<span class="w">            </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">4</span><span class="p">,</span><span class="w">  </span><span class="c1">// 后面。</span>
<span class="w">            </span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">3</span><span class="p">,</span><span class="w"> </span><span class="mf">4</span><span class="w">   </span><span class="c1">// 左面。</span>
<span class="p">];</span>

<span class="nx">pyramidGeom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">BufferGeometry</span><span class="p">();</span>
<span class="nx">pyramidGeom</span><span class="p">.</span><span class="nx">setAttribute</span><span class="p">(</span><span class="s2">&quot;position&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">BufferAttribute</span><span class="p">(</span><span class="nx">pyramidVertices</span><span class="p">,</span><span class="mf">3</span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="nx">pyramidGeom</span><span class="p">.</span><span class="nx">setIndex</span><span class="p">(</span><span class="w"> </span><span class="nx">pyramidFaceIndexArray</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>这将与<strong><em>MeshBasicMaterial</em></strong>一起工作。示例程序<a href="../../../en/source/threejs/vertex-groups-indexed.html">threejs/<abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>-groups-indexed.html</a>是<a href="../../../en/source/threejs/vertex-groups.html">threejs/<abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>-groups.html</a>的一个变体，它使用了这种方法。</p>
<p><em>computeVertexNormals()</em>方法仍然可以用于具有索引数组的<strong><em>BufferedGeometry</em></strong>。要计算一个顶点的法向量，它找到该顶点出现的所有的面。对于这些面中的每一个，它计算一个垂直于面的向量。然后它平均这些向量以得到顶点法向量。（我会指出，如果你对我们的金字塔尝试这个，它看起来会非常糟糕。它真的只适用于平滑表面。）</p>
</div>
<div class="tabbed-block">
<p>A mesh in <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em> is what we called a <abbr title="A collection of polygons, where the polygons can be joined together along their edges. A polygonal mesh can represent a polyhedron, or can be used as an approximation for a curved surface. A polygonal mesh can be represented as an indexed face set.">polygonal mesh</abbr> in Section 3.4, although in a <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em> mesh, all of the polygons must be triangles. There are two ways to draw polygonal meshes in <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr>. One uses the function <em>glDrawArrays()</em>, which requires just a list of vertices. The other uses the representation that we called an <abbr title="(IFS). A data structure that represents a polyhedron or polygonal mesh. The data structure includes a numbered list of vertices and a list of faces. A face is specified by listing the indices of the vertices of the face; that is, a face is given as a list of numbers where each number is an index into the list of vertices.">indexed face set</abbr> (IFS), which is drawn using the function <em>glDrawElements()</em>. In addition to a list of vertices, an IFS uses a list of face indices to specify the triangles. We will look at both methods, using this pyramid as an example:</p>
<p><a class="glightbox" href="../../../en/c5/pyramid-IFS.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c5/pyramid-IFS.png" /></a></p>
<p>Note that the bottom face of the pyramid, which is a square, has to be divided into two triangles in order for the pyramid to be represented as a mesh geometry. The vertices are numbered from 0 to 4. A triangular face can be specified by the three numbers that give the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> numbers of the vertices of that triangle. As usual, the vertices of a triangle should be specified in counterclockwise order when viewed from the front, that is, from outside the pyramid. Here is the data that we need.</p>
<div class="highlight"><pre><span></span><code>    VERTEX COORDINATES:         FACE INDICES:

    Vertex 0:   1, 0,  1        Face 1:  3, 2, 1 
    Vertex 1:   1, 0, -1        Face 2:  3, 1, 0 
    Vertex 2:  -1, 0, -1        Face 3:  3, 0, 4 
    Vertex 3:  -1, 0,  1        Face 4:  0, 1, 4 
    Vertex 4:   0, 1,  0        Face 5:  1, 2, 4 
                                Face 6:  2, 3, 4
</code></pre></div>
<p>A basic <abbr title="A collection of polygons, where the polygons can be joined together along their edges. A polygonal mesh can represent a polyhedron, or can be used as an approximation for a curved surface. A polygonal mesh can be represented as an indexed face set.">polygonal mesh</abbr> representation does not use face indices. Instead, it specifies each triangle by listing the coordinates of the vertices. This requires nine numbers—three numbers per <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>—for the three vertices of the triangle. Since a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> can be shared by several triangles, there is some redundancy. For the pyramid, the coordinates for a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> will be repeated three or four times.</p>
<p>A <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em> mesh object requires a geometry and a <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr>. The geometry is an object of type <strong><em>THREE.BufferedGeometry</em></strong>, which has a "position" <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> that holds the coordinates of the vertices that are used in the mesh. The <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> uses a <abbr title="In JavaScript, an array type that is limited to holding numerical values of a single type. For example, the type Float32Array represents arrays that can hold 32-bit floating point values, and Uint8Array arrays can hold only 8-bit integer values. Such arrays are more efficient than general JavaScript arrays for numerical calculations. The were introduced into JavaScript along with HTML canvas graphics and WebGL.">typed array</abbr> that holds the coordinates of the vertices of the triangles that make up the mesh. Geometry for the pyramid can be created like this:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">pyramidVertices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Float32Array</span><span class="p">(</span><span class="w"> </span><span class="p">[</span>
<span class="w">            </span><span class="c1">// Data for the pyramidGeom &quot;position&quot; attribute.</span>
<span class="w">            </span><span class="c1">// Contains the x,y,z coordinates for the vertices.</span>
<span class="w">            </span><span class="c1">// Each group of three numbers is a vertex;</span>
<span class="w">            </span><span class="c1">// each group of three vertices is one face.</span>
<span class="w">            </span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="c1">// First triangle in the base.</span>
<span class="w">            </span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w">   </span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="c1">// Second triangle in the base.</span>
<span class="w">            </span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w">   </span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w">   </span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="c1">// Front face.</span>
<span class="w">            </span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w">   </span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="c1">// Right face.</span>
<span class="w">            </span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="c1">// Back face.</span>
<span class="w">            </span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w">   </span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="w">   </span><span class="c1">// Left face.</span>
<span class="w">        </span><span class="p">]</span><span class="w"> </span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">pyramidGeom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">BufferGeometry</span><span class="p">();</span>
<span class="nx">pyramidGeom</span><span class="p">.</span><span class="nx">setAttribute</span><span class="p">(</span><span class="s2">&quot;position&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">BufferAttribute</span><span class="p">(</span><span class="nx">pyramidVertices</span><span class="p">,</span><span class="mf">3</span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>When this geometry is used with a Lambert or Phong <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr>, normal vectors are required for the vertices. If the geometry has no normal vectors, Lambert and Phong materials will appear black. The normal vectors for a mesh have to be stored in another <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> of the <strong><em>BufferedGeometry</em></strong>. The name of the <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> is "normal", and it holds a <abbr title="A normal vector to a surface at a point on that surface is a vector that is perpendicular to the surface at that point. Normal vectors to curves are defined similarly. Normal vectors are important for lighting calculations.">normal vector</abbr> for each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> in the "position" <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>. It could be created in the same way that the "position" <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> is created, but a <strong><em>BufferedGeometry</em></strong> object includes a method for calculating normal vectors. For the <em>pyramidGeom</em>, we can simply call</p>
<div class="highlight"><pre><span></span><code><span class="nx">pyramidGeom</span><span class="p">.</span><span class="nx">computeVertexNormals</span><span class="p">();</span>
</code></pre></div>
<p>For a basic <abbr title="A collection of polygons, where the polygons can be joined together along their edges. A polygonal mesh can represent a polyhedron, or can be used as an approximation for a curved surface. A polygonal mesh can be represented as an indexed face set.">polygonal mesh</abbr>, this will create normal vectors that are perpendicular to the faces. When several faces share a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>, that <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> will have a different <abbr title="A normal vector to a surface at a point on that surface is a vector that is perpendicular to the surface at that point. Normal vectors to curves are defined similarly. Normal vectors are important for lighting calculations.">normal vector</abbr> for each face. This will produce flat-looking faces, which are appropriate for a <abbr title="A closed 3D figure whose faces, or sides, are polygons. Usually, it is assumed that the faces of a polyhedron do not intersect, except along their edges.">polyhedron</abbr>, whose sides are in fact flat. It is not appropriate if the <abbr title="A collection of polygons, where the polygons can be joined together along their edges. A polygonal mesh can represent a polyhedron, or can be used as an approximation for a curved surface. A polygonal mesh can be represented as an indexed face set.">polygonal mesh</abbr> is being used to approximate a smooth surface. In that case, we should be using normal vectors that are perpendicular to the surface, which would mean creating the "normal" <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> by hand. (See <a href="../../c4/s1/#413-法向量">Subsection 4.1.3</a>.)</p>
<p>Once we have the geometry for our pyramid, we can use it in a <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em> mesh object by combining it with, say, a yellow Lambert <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr>:</p>
<div class="highlight"><pre><span></span><code><span class="nx">pyramid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">Mesh</span><span class="p">(</span><span class="w"> </span>
<span class="w">            </span><span class="nx">pyramidGeom</span><span class="p">,</span>
<span class="w">            </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">MeshLambertMaterial</span><span class="p">({</span><span class="w"> </span><span class="nx">color</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;yellow&quot;</span><span class="w"> </span><span class="p">})</span><span class="w"> </span>
<span class="w">        </span><span class="p">);</span>
</code></pre></div>
<p>But the pyramid would look a little boring with just one color. It is possible to use different materials on different faces of a mesh. For that to work, the vertices in the geometry must be divided into groups. The <em>addGroup()</em> method in the <strong><em>BufferedGeometry</em></strong> class is used to create the groups. The vertices in the geometry are numbered 0, 1, 2, ..., according their sequence in the "position" <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>. (This is not the same numbering used above.) The <em>addGroup()</em> method takes three parameters: the number of the first <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> in the group, the number of vertices in the group, and a <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> index. The <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> index is an integer that determines which <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> will be applied to the group. If you are using groups, it is important to put all of the vertices into groups. Here is how groups can be created for the pyramid:</p>
<div class="highlight"><pre><span></span><code><span class="nx">pyramidGeom</span><span class="p">.</span><span class="nx">addGroup</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="mf">6</span><span class="p">,</span><span class="mf">0</span><span class="p">);</span><span class="w">  </span><span class="c1">// The base (2 triangles)</span>
<span class="nx">pyramidGeom</span><span class="p">.</span><span class="nx">addGroup</span><span class="p">(</span><span class="mf">6</span><span class="p">,</span><span class="mf">3</span><span class="p">,</span><span class="mf">1</span><span class="p">);</span><span class="w">  </span><span class="c1">// Front face.</span>
<span class="nx">pyramidGeom</span><span class="p">.</span><span class="nx">addGroup</span><span class="p">(</span><span class="mf">9</span><span class="p">,</span><span class="mf">3</span><span class="p">,</span><span class="mf">2</span><span class="p">);</span><span class="w">  </span><span class="c1">// Right face.</span>
<span class="nx">pyramidGeom</span><span class="p">.</span><span class="nx">addGroup</span><span class="p">(</span><span class="mf">12</span><span class="p">,</span><span class="mf">3</span><span class="p">,</span><span class="mf">3</span><span class="p">);</span><span class="w"> </span><span class="c1">// Back face.</span>
<span class="nx">pyramidGeom</span><span class="p">.</span><span class="nx">addGroup</span><span class="p">(</span><span class="mf">15</span><span class="p">,</span><span class="mf">3</span><span class="p">,</span><span class="mf">4</span><span class="p">);</span><span class="w"> </span><span class="c1">// Left face.</span>
</code></pre></div>
<p>To apply different materials to different groups, the materials should be put into an array. The <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> index of a group is an index into that array.</p>
<div class="highlight"><pre><span></span><code><span class="nx">pyramidMaterialArray</span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w"> </span>
<span class="w">        </span><span class="c1">// Array of materials, for use as pyramids&#39;s material.</span>
<span class="w">        </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">MeshLambertMaterial</span><span class="p">(</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">color</span><span class="o">:</span><span class="w"> </span><span class="mh">0xffffff</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">),</span>
<span class="w">        </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">MeshLambertMaterial</span><span class="p">(</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">color</span><span class="o">:</span><span class="w"> </span><span class="mh">0x99ffff</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">),</span>
<span class="w">        </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">MeshLambertMaterial</span><span class="p">(</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">color</span><span class="o">:</span><span class="w"> </span><span class="mh">0xff99ff</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">),</span>
<span class="w">        </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">MeshLambertMaterial</span><span class="p">(</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">color</span><span class="o">:</span><span class="w"> </span><span class="mh">0xffff99</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">),</span>
<span class="w">        </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">MeshLambertMaterial</span><span class="p">(</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">color</span><span class="o">:</span><span class="w"> </span><span class="mh">0xff9999</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">];</span>
</code></pre></div>
<p>This array can be passed as the second parameter to the <strong><em>THREE.Mesh</em></strong> <abbr title="In object-oriented programming, a subroutine that is used to create objects. A constructor for a class creates and initializes objects belonging to that class.">constructor</abbr>, where a single <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> would ordinarily be used.</p>
<div class="highlight"><pre><span></span><code><span class="nx">pyramid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">Mesh</span><span class="p">(</span><span class="w"> </span><span class="nx">pyramidGeom</span><span class="p">,</span><span class="w"> </span><span class="nx">pyramidMaterialArray</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>(But note that you can still use a single <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> on a mesh, even if the mesh geometry uses groups.)</p>
<p>A <strong><em>THREE.BoxGeometry</em></strong> comes with groups that make it possible to assign a different <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> to each face. The sample program <a href="../../../en/source/threejs/vertex-groups.html">threejs/<abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>-groups.html</a> uses the code from this section to create a pyramid, and it displays both the pyramid and a cube, using multiple materials on each object. Here's what they look like:</p>
<p><a class="glightbox" href="../../../en/c5/MeshFaceMaterial.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c5/MeshFaceMaterial.png" /></a></p>
<p>There is another way to assign different colors to different vertices. A <strong><em>BufferedGeometry</em></strong> can have an <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> named "color" that specifies a color for each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>. The "color" <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> uses an array containing a set of three RGB component values for each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>. The <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> colors are ignored by default. To use them, the geometry must be combined with a <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> in which the <em>vertexColors</em> property is set to <em>true</em>. Here is how <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> colors could be used to color the sides of the pyramid:</p>
<div class="highlight"><pre><span></span><code><span class="nx">pyramidGeom</span><span class="p">.</span><span class="nx">setAttribute</span><span class="p">(</span>
<span class="w">        </span><span class="s2">&quot;color&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">BufferAttribute</span><span class="p">(</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Float32Array</span><span class="p">([</span>
<span class="w">                </span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="c1">// Base vertices are white</span>
<span class="w">                </span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span>
<span class="w">                </span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="c1">// Front face vertices are red,</span>
<span class="w">                </span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="c1">// Right face vertices are green,</span>
<span class="w">                </span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="c1">// Back face vertices are blue,</span>
<span class="w">                </span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="w">  </span><span class="c1">// Left face vertices are yellow.</span>
<span class="w">            </span><span class="p">]),</span><span class="w"> </span><span class="mf">3</span><span class="p">)</span>
<span class="w">    </span><span class="p">);</span>
<span class="nx">pyramid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">Mesh</span><span class="p">(</span><span class="w"> </span>
<span class="w">        </span><span class="nx">pyramidGeom</span><span class="p">,</span><span class="w"> </span>
<span class="w">        </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">MeshLambertMaterial</span><span class="p">({</span>
<span class="w">            </span><span class="nx">color</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;white&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="nx">vertexColors</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">})</span><span class="w"> </span>
<span class="w">    </span><span class="p">);</span>
</code></pre></div>
<p>The color components of the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> colors from the geometry are actually multiplied by the color components of the color in the Lambert <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr>. It makes sense for that color to be white, with color components equal to one; in that case the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> colors are not modified by the <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> color.</p>
<p>In this example, each face of the pyramid is a solid color. There is a lot of redundancy in the color array for the pyramid, because a color must be specified for every <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>, even if all of the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> colors for a given face are the same. In fact, it's not required that all of the vertices of a face have the same color. If they are assigned different colors, colors will be interpolated from the vertices to the interior of the face. As an example, in the following demo, a random <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> color was specified for each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> of an icosahedral approximation for a sphere:</p>
<p><iframe src="../../../en/demos/c5/vertex-and-color-animation.html" width="590" height="375"></iframe></p>
<p>The demo can run two somewhat silly animations; the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> colors and the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> positions can be animated.</p>
<hr />
<p>The <em>glDrawElements()</em> function is used to avoid the redundancy of the basic <abbr title="A collection of polygons, where the polygons can be joined together along their edges. A polygonal mesh can represent a polyhedron, or can be used as an approximation for a curved surface. A polygonal mesh can be represented as an indexed face set.">polygonal mesh</abbr> representation. It uses the <abbr title="(IFS). A data structure that represents a polyhedron or polygonal mesh. The data structure includes a numbered list of vertices and a list of faces. A face is specified by listing the indices of the vertices of the face; that is, a face is given as a list of numbers where each number is an index into the list of vertices.">indexed face set</abbr> pattern, which requires an array of face indices to specify the vertices for the faces of the mesh. In that array, a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> is specified by a single number, rather than repeating all of the coordinates and other data for that <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>. Note that a given <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> number refers to <strong>all</strong> of the data for that <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>: <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> coordinates, <abbr title="A normal vector to a surface at a point on that surface is a vector that is perpendicular to the surface at that point. Normal vectors to curves are defined similarly. Normal vectors are important for lighting calculations.">normal vector</abbr>, <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> color, and any other data that are provided in <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attributes</abbr> of the geometry. Suppose that two faces share a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>. If that <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> has a different <abbr title="A normal vector to a surface at a point on that surface is a vector that is perpendicular to the surface at that point. Normal vectors to curves are defined similarly. Normal vectors are important for lighting calculations.">normal vector</abbr>, or a different value for some other <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr>, in the two faces, then that <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> will need to occur twice in the <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> arrays. The two occurrences can be combined only if the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> has identical properties in the two faces. The IFS representation is most suitable for a <abbr title="A collection of polygons, where the polygons can be joined together along their edges. A polygonal mesh can represent a polyhedron, or can be used as an approximation for a curved surface. A polygonal mesh can be represented as an indexed face set.">polygonal mesh</abbr> that is being used as an approximation for a smooth surface, since in that case a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> has the same <abbr title="A normal vector to a surface at a point on that surface is a vector that is perpendicular to the surface at that point. Normal vectors to curves are defined similarly. Normal vectors are important for lighting calculations.">normal vector</abbr> for all of the vertices in which it occurs. It can also be appropriate for an object that uses a <strong><em>MeshBasicMaterial</em></strong>, since normal vectors are not used with that type of <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr>.</p>
<p>To use the IFS pattern with a <strong><em>BufferedGeometry</em></strong>, you need to provide a face index array for the geometry. The array is specified by the geometry's setIndex() method. The parameter can be an ordinary <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> array of integers. For our pyramid example the "position" <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> of the geometry would contain each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> just once, and the face index array would refer to a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> by its position in that list of vertices:</p>
<div class="highlight"><pre><span></span><code><span class="nx">pyramidVertices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Float32Array</span><span class="p">(</span><span class="w"> </span><span class="p">[</span>
<span class="w">            </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="c1">// vertex number 0</span>
<span class="w">            </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="c1">// vertex number 1</span>
<span class="w">            </span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="c1">// vertex number 2</span>
<span class="w">            </span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="c1">// vertex number 3</span>
<span class="w">            </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="mf">0</span><span class="w">   </span><span class="c1">// vertex number 4</span>
<span class="p">]</span><span class="w"> </span><span class="p">);</span>

<span class="nx">pyramidFaceIndexArray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span>
<span class="w">            </span><span class="mf">3</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="c1">// First triangle in the base.</span>
<span class="w">            </span><span class="mf">3</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="c1">// Second Triangle in the base.</span>
<span class="w">            </span><span class="mf">3</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">4</span><span class="p">,</span><span class="w">  </span><span class="c1">// Front face.</span>
<span class="w">            </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">4</span><span class="p">,</span><span class="w">  </span><span class="c1">// Right face.</span>
<span class="w">            </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">4</span><span class="p">,</span><span class="w">  </span><span class="c1">// Back face.</span>
<span class="w">            </span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">3</span><span class="p">,</span><span class="w"> </span><span class="mf">4</span><span class="w">   </span><span class="c1">// Left face.</span>
<span class="p">];</span>

<span class="nx">pyramidGeom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">BufferGeometry</span><span class="p">();</span>
<span class="nx">pyramidGeom</span><span class="p">.</span><span class="nx">setAttribute</span><span class="p">(</span><span class="s2">&quot;position&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">BufferAttribute</span><span class="p">(</span><span class="nx">pyramidVertices</span><span class="p">,</span><span class="mf">3</span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="nx">pyramidGeom</span><span class="p">.</span><span class="nx">setIndex</span><span class="p">(</span><span class="w"> </span><span class="nx">pyramidFaceIndexArray</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>This would work with a <strong><em>MeshBasicMaterial</em></strong>. The sample program <a href="../../../en/source/threejs/vertex-groups-indexed.html">threejs/<abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>-groups-indexed.html</a> is a variation on <a href="../../../en/source/threejs/vertex-groups.html">threejs/<abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>-groups.html</a> that uses this approach.</p>
<p>The <em>computeVertexNormals()</em> method can still be used for a <strong><em>BufferedGeometry</em></strong> that has an index array. To compute a <abbr title="A normal vector to a surface at a point on that surface is a vector that is perpendicular to the surface at that point. Normal vectors to curves are defined similarly. Normal vectors are important for lighting calculations.">normal vector</abbr> for a <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>, it finds all of the faces in which that <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> occurs. For each of those faces, it computes a <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> perpendicular to the face. Then it averages those vectors to get the <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> normal. (I will note if you tried this for our pyramid, it would look pretty bad. It's really only appropriate for smooth surfaces.)</p>
</div>
</div>
</div>
<h2 id="522-曲线和曲面">5.2.2 曲线和曲面<a class="headerlink" href="#522-曲线和曲面" title="Permanent link">&para;</a></h2>
<p><strong>Curves and Surfaces</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="3:2"><input checked="checked" id="__tabbed_3_1" name="__tabbed_3" type="radio" /><input id="__tabbed_3_2" name="__tabbed_3" type="radio" /><div class="tabbed-labels"><label for="__tabbed_3_1">中文</label><label for="__tabbed_3_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>除了允许你构建索引面集，<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>还支持使用数学定义的曲线和曲面。一些可能性在示例程序<a href="../../../en/source/threejs/curves-and-surfaces.html">threejs/curves-and-surfaces.html</a>中进行了说明，我将在这里讨论其中的一些。</p>
<p>参数化曲面是最容易处理的。它们由一个名为<strong><em>ParametricGeometry</em></strong>的<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>插件表示。作为一个插件，它必须从主要的<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>模块中单独导入。在我的示例程序中，它是这样导入的：</p>
<div class="highlight"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="nx">ParametricGeometry</span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;addons/geometries/ParametricGeometry.js&quot;</span><span class="p">;</span>
</code></pre></div>
<p>参数化曲面由一个数学函数定义，该函数有两个参数<em>(u,v)</em>，其中u和v是数字，函数的每个值都是空间中的一个点。曲面由函数在某些指定范围内对u和v的值构成的所有点组成。对于<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>，该函数是一个常规的JavaScript函数，它接受三个参数：<em>u, v</em>和一个类型为<strong><em>THREE.Vector3</em></strong>的对象。该函数必须修改向量以表示对应于<em>u</em>和<em>v</em>参数值的空间中的点。通过在<em>(u,v)</em>点的网格上调用函数来创建参数化曲面几何体。这提供了曲面上的一组点，然后这些点被连接起来，以给出曲面的多边形近似。在<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>中，u和v的值总是在0.0到1.0的范围内。几何体是通过构造函数创建的：</p>
<div class="highlight"><pre><span></span><code><span class="ow">new</span><span class="w"> </span><span class="nx">ParametricGeometry</span><span class="p">(</span><span class="w"> </span><span class="nx">func</span><span class="p">,</span><span class="w"> </span><span class="nx">slices</span><span class="p">,</span><span class="w"> </span><span class="nx">stacks</span><span class="w"> </span><span class="p">)</span>
</code></pre></div>
<p>其中<em>func</em>是定义曲面的JavaScript函数，<em>slices</em>和<em>stacks</em>确定网格中的点数；<em>slices</em>给出了从0到1的区间在<em>u</em>方向上的细分数量，而<em>stacks</em>在<em>v</em>方向上。一旦有了几何体，就可以像通常一样使用它来制作网格。这是一个示例，来自示例程序：</p>
<p><a class="glightbox" href="../../../en/c5/parametric-surface.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c5/parametric-surface.png" /></a></p>
<p>这个曲面由函数定义：</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span><span class="w"> </span><span class="nx">surfaceFunction</span><span class="p">(</span><span class="w"> </span><span class="nx">u</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="p">,</span><span class="w"> </span><span class="nx">vector</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">,</span><span class="nx">z</span><span class="p">;</span><span class="w">  </span><span class="c1">// 曲面上的点的坐标，</span>
<span class="w">                </span><span class="c1">// 根据u,v计算，其中u和v的范围从0.0到1.0。</span>
<span class="w">    </span><span class="nx">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">20</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="nx">u</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">0.5</span><span class="p">);</span><span class="w">  </span><span class="c1">// x和z的范围从-10到10</span>
<span class="w">    </span><span class="nx">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">20</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="nx">v</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">0.5</span><span class="p">);</span>
<span class="w">    </span><span class="nx">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2</span><span class="o">*</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">sin</span><span class="p">(</span><span class="nx">x</span><span class="o">/</span><span class="mf">2</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nb">Math</span><span class="p">.</span><span class="nx">cos</span><span class="p">(</span><span class="nx">z</span><span class="p">));</span>
<span class="w">    </span><span class="nx">vector</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="w"> </span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="p">,</span><span class="w"> </span><span class="nx">z</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>代表曲面的<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>网格是使用创建的：</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">surfaceGeometry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">ParametricGeometry</span><span class="p">(</span><span class="nx">surfaceFunction</span><span class="p">,</span><span class="w"> </span><span class="mf">64</span><span class="p">,</span><span class="w"> </span><span class="mf">64</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">surface</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">Mesh</span><span class="p">(</span><span class="w"> </span><span class="nx">surfaceGeometry</span><span class="p">,</span><span class="w"> </span><span class="nx">material</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>曲线在<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>中更复杂。<strong><em>THREE.Curve</em></strong>类表示二维或三维参数化曲线的抽象概念。（它不表示<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>几何体。）参数化曲线由一个数值变量t的函数定义。函数返回的值类型为<strong><em>THREE.Vector2</em></strong>对于2D曲线或<strong><em>THREE.Vector3</em></strong>对于3D曲线。对于类型为<strong><em>THREE.Curve</em></strong>的对象，曲线，方法<em>curve.getPoint(t)</em>应该返回对应于参数t的曲线上的点。曲线由这个函数生成的点组成，对于<em>t</em>的值范围从0.0到1.0。然而，在<strong><em>Curve</em></strong>类本身中，<em>getPoint()</em>是未定义的。要得到一个实际的曲线，你必须定义它。例如，</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">helix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">Curve</span><span class="p">();</span>
<span class="nx">helix</span><span class="p">.</span><span class="nx">getPoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kd">function</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">t</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">0.5</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">12</span><span class="o">*</span><span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// 当t从0到1变化时，s的范围从-6*PI到6*PI</span>
<span class="k">return</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">Vector3</span><span class="p">(</span>
<span class="w">        </span><span class="mf">5</span><span class="o">*</span><span class="nb">Math</span><span class="p">.</span><span class="nx">cos</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span>
<span class="w">        </span><span class="nx">s</span><span class="p">,</span>
<span class="w">        </span><span class="mf">5</span><span class="o">*</span><span class="nb">Math</span><span class="p">.</span><span class="nx">sin</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>一旦<em>getPoint</em>被定义，你就有一个可用的曲线。你可以用它做的一件事是创建一个管状几何体，它定义了一个以圆截面和曲线沿管中心运行的管状表面。示例程序使用上面定义的<em>helix</em>曲线来创建两个管子：</p>
<p><a class="glightbox" href="../../../en/c5/tube-geometry.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="adf" src="../../../en/c5/tube-geometry.png" /></a></p>
<p>较宽管子的几何体是这样创建的：</p>
<div class="highlight"><pre><span></span><code><span class="nx">tubeGeometry1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">TubeGeometry</span><span class="p">(</span><span class="w"> </span><span class="nx">helix</span><span class="p">,</span><span class="w"> </span><span class="mf">128</span><span class="p">,</span><span class="w"> </span><span class="mf">2.5</span><span class="p">,</span><span class="w"> </span><span class="mf">32</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>构造函数的第二个参数是沿曲线长度的曲面细分数量。第三个是管的圆截面半径，第四个是截面周长上的细分数量。</p>
<p>要制作一个管子，你需要一个3D曲线。也有几种方法可以从2D曲线创建一个曲面。一种方法是围绕一条线旋转曲线，生成一个旋转曲面。曲面由曲线在旋转时经过的所有点组成。这称为<strong><abbr title="通过围绕与曲线在同一平面内的线旋转平面曲线来产生表面的一种技术。当曲线上的每个点围绕该线旋转时，它生成一个圆。表面是由曲线上所有点生成的圆的集合。车削模仿了机械车床可以产生的形态。">车削</abbr></strong>。这张来自示例程序的图像显示了通过车削余弦曲线生成的曲面。（图像旋转了90度，以便y轴是水平的。）曲线本身显示在曲面上方：</p>
<p><a class="glightbox" href="../../../en/c5/lathe-geometry.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c5/lathe-geometry.png" /></a></p>
<p>在<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>中，使用<strong><em>THREE.LatheGeometry</em></strong>对象创建曲面。一个<strong><em>LatheGeometry</em></strong>不是从一个曲线而是从一个位于曲线上的点的数组构建的。这些点是<strong><em>Vector2</em></strong>类型的，曲线位于xy平面内。曲面是通过围绕y轴旋转曲线生成的。<strong><em>LatheGeometry</em></strong>构造函数的形式为：</p>
<div class="highlight"><pre><span></span><code><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">LatheGeometry</span><span class="p">(</span><span class="w"> </span><span class="nx">points</span><span class="p">,</span><span class="w"> </span><span class="nx">slices</span><span class="w"> </span><span class="p">)</span>
</code></pre></div>
<p>第一个参数是<strong><em>Vector2</em></strong>数组。第二个是沿生成的圆圈的曲面细分数量。（曲面的“<abbr title="一种具有push()和pop()操作的数据结构。将项目推入堆栈只是将该项目添加到堆栈中。从堆栈中弹出将删除并返回最近推入堆栈的项目。">堆栈</abbr>”数量由点数组的长度给出。）在示例程序中，我通过调用<strong>cosine.getPoints(128)<em>，从类型为</em></strong>Curve<em><strong>的对象</strong>cosine</em>创建点的数组。这个函数创建了曲线上的128个点，使用的参数值范围从0.0到1.0。</p>
<p>你可以用2D曲线做的另一件事就是简单地填充曲线的内部，给出一个2D填充形状。在<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>中，要这样做，你可以使用类型为<strong><em>THREE.Shape</em></strong>的对象，它是<strong><em>THREE.Curve</em></strong>的一个子类。一个<strong><em>Shape</em></strong>可以像在<a href="../../c2/s6/">第2.6节</a>中介绍的2D Canvas API中的路径一样定义。也就是说，一个类型为<strong><em>THREE.Shape</em></strong>的对象shape具有方法<em>shape.moveTo</em>, <em>shape.lineTo</em>, <em>shape.quadraticCurveTo</em>和<em>shape.bezierCurveTo</em>，可以用来定义路径。有关这些函数如何工作的详细信息，请参阅<a href="../../c2/s6/#262--形状">2.6.2小节</a>。例如，我们可以创建一个泪滴形状：</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">Shape</span><span class="p">();</span>
<span class="nx">path</span><span class="p">.</span><span class="nx">moveTo</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="mf">10</span><span class="p">);</span>
<span class="nx">path</span><span class="p">.</span><span class="nx">bezierCurveTo</span><span class="p">(</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="mf">5</span><span class="p">,</span><span class="w"> </span><span class="mf">20</span><span class="p">,</span><span class="o">-</span><span class="mf">10</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="o">-</span><span class="mf">10</span><span class="w"> </span><span class="p">);</span>
<span class="nx">path</span><span class="p">.</span><span class="nx">bezierCurveTo</span><span class="p">(</span><span class="w"> </span><span class="o">-</span><span class="mf">20</span><span class="p">,</span><span class="o">-</span><span class="mf">10</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="mf">5</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="mf">10</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>要使用路径在<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>中创建一个填充形状，我们需要一个<strong><em>ShapeGeometry</em></strong>对象：</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">shapeGeom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">ShapeGeometry</span><span class="p">(</span><span class="w"> </span><span class="nx">path</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>使用此几何体创建的2D形状显示在这张图片的左侧：</p>
<p><a class="glightbox" href="../../../en/c5/extrusion-geometry.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c5/extrusion-geometry.png" /></a></p>
<p>图片中的其他两个对象是通过<strong><abbr title="通过沿着3D中的曲线移动2D形状来制作实体的技术。实体是形状沿着曲线移动时穿过的点集。最常见的情况是将形状沿着垂直于包含形状的平面的线段移动。在实践中，计算机图形学中通过拉伸产生的物体只是拉伸实体的表面。">拉伸</abbr></strong>形状创建的。在拉伸中，一个填充的2D形状沿着3D中的路径移动。形状经过的点组成了一个3D实体。在这种情况下，形状沿着垂直于形状的线段拉伸，这是最常见的情况。基本拉伸形状在插图的右侧显示。中间的对象是具有“斜面”边缘的相同形状。有关拉伸的更多详细信息，请参阅<strong><em>THREE.ExtrudeGeometry</em></strong>的文档和<a href="../../../en/source/threejs/curves-and-surfaces.html">示例程序</a>的源代码。</p>
</div>
<div class="tabbed-block">
<p>In addition to letting you build indexed face sets, <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em> has support for working with curves and surfaces that are defined mathematically. Some of the possibilities are illustrated in the sample program <a href="../../../en/source/threejs/curves-and-surfaces.html">threejs/curves-and-surfaces.html</a>, and I will discuss a few of them here.</p>
<p>Parametric surfaces are the easiest to work with. They are represented by a <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em> add-on named <strong><em>ParametricGeometry</em></strong>. As an add-on, it must be imported separately from the main <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em> module. In my sample program, it is imported with</p>
<div class="highlight"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="nx">ParametricGeometry</span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;addons/geometries/ParametricGeometry.js&quot;</span><span class="p">;</span>
</code></pre></div>
<p>A parametric surface is defined by a mathematical function of two parameters <em>(u,v)</em>, where u and v are numbers, and each value of the function is a point in space. The surface consists of all the points that are values of the function for u and v in some specified ranges. For <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>, the function is a regular <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> function that takes three parameters: <em>u, v</em>, and an object of type <strong><em>THREE.Vector3</em></strong>. The function must modify the <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> to represent the point in space that corresponds to the values of the <em>u</em> and <em>v</em> parameters. A parametric surface geometry is created by calling the function at a grid of <em>(u,v)</em> points. This gives a collection of points on the surface, which are then connected to give a polygonal approximation of the surface. In <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>, the values of both u and v are always in the range 0.0 to 1.0. The geometry is created by a <abbr title="In object-oriented programming, a subroutine that is used to create objects. A constructor for a class creates and initializes objects belonging to that class.">constructor</abbr></p>
<div class="highlight"><pre><span></span><code><span class="ow">new</span><span class="w"> </span><span class="nx">ParametricGeometry</span><span class="p">(</span><span class="w"> </span><span class="nx">func</span><span class="p">,</span><span class="w"> </span><span class="nx">slices</span><span class="p">,</span><span class="w"> </span><span class="nx">stacks</span><span class="w"> </span><span class="p">)</span>
</code></pre></div>
<p>where <em>func</em> is the <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> function that defines the surface, and <em>slices</em> and <em>stacks</em> determine the number of points in the grid; slices gives the number of subdivisions of the interval from 0 to 1 in the <em>u</em> direction, and <em>stacks</em>, in the <em>v</em> direction. Once you have the geometry, you can use it to make a mesh in the usual way. Here is an example, from the sample program:</p>
<p><a class="glightbox" href="../../../en/c5/parametric-surface.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c5/parametric-surface.png" /></a></p>
<p>This surface is defined by the function</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span><span class="w"> </span><span class="nx">surfaceFunction</span><span class="p">(</span><span class="w"> </span><span class="nx">u</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="p">,</span><span class="w"> </span><span class="nx">vector</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">,</span><span class="nx">z</span><span class="p">;</span><span class="w">  </span><span class="c1">// Coordinates for a point on the surface, </span>
<span class="w">                </span><span class="c1">// calculated from u,v, where u and v</span>
<span class="w">                </span><span class="c1">// range from 0.0 to 1.0.</span>
<span class="w">    </span><span class="nx">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">20</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="nx">u</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">0.5</span><span class="p">);</span><span class="w">  </span><span class="c1">// x and z range from -10 to 10</span>
<span class="w">    </span><span class="nx">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">20</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="nx">v</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">0.5</span><span class="p">);</span>
<span class="w">    </span><span class="nx">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2</span><span class="o">*</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">sin</span><span class="p">(</span><span class="nx">x</span><span class="o">/</span><span class="mf">2</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nb">Math</span><span class="p">.</span><span class="nx">cos</span><span class="p">(</span><span class="nx">z</span><span class="p">));</span>
<span class="w">    </span><span class="nx">vector</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="w"> </span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="p">,</span><span class="w"> </span><span class="nx">z</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>and the <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em> mesh that represents the surface is created using</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">surfaceGeometry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">ParametricGeometry</span><span class="p">(</span><span class="nx">surfaceFunction</span><span class="p">,</span><span class="w"> </span><span class="mf">64</span><span class="p">,</span><span class="w"> </span><span class="mf">64</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">surface</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">Mesh</span><span class="p">(</span><span class="w"> </span><span class="nx">surfaceGeometry</span><span class="p">,</span><span class="w"> </span><span class="nx">material</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>Curves are more complicated in <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>. The class <strong><em>THREE.Curve</em></strong> represents the abstract idea of a parametric curve in two or three dimensions. (It does <strong>not</strong> represent a <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em> geometry.) A parametric curve is defined by a function of one numeric variable t. The value returned by the function is of type <strong><em>THREE.Vector2</em></strong> for a 2D curve or <strong><em>THREE.Vector3</em></strong> for a 3D curve. For an object, curve, of type <strong><em>THREE.Curve</em></strong>, the method <em>curve.getPoint(t)</em> should return the point on the curve corresponding to the value of the parameter t. The curve consists of points generated by this function for values of <em>t</em> ranging from 0.0 to 1.0. However, in the <strong><em>Curve</em></strong> class itself, <em>getPoint()</em> is undefined. To get an actual curve, you have to define it. For example,</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">helix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">Curve</span><span class="p">();</span>
<span class="nx">helix</span><span class="p">.</span><span class="nx">getPoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kd">function</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">t</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">0.5</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">12</span><span class="o">*</span><span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// As t ranges from 0 to 1, s ranges from -6*PI to 6*PI</span>
<span class="k">return</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">Vector3</span><span class="p">(</span>
<span class="w">        </span><span class="mf">5</span><span class="o">*</span><span class="nb">Math</span><span class="p">.</span><span class="nx">cos</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span>
<span class="w">        </span><span class="nx">s</span><span class="p">,</span>
<span class="w">        </span><span class="mf">5</span><span class="o">*</span><span class="nb">Math</span><span class="p">.</span><span class="nx">sin</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Once <em>getPoint</em> is defined, you have a usable curve. One thing that you can do with it is create a tube geometry, which defines a surface that is a tube with a circular cross-section and with the curve running along the center of the tube. The sample program uses the <em>helix</em> curve, defined above, to create two tubes:</p>
<p><a class="glightbox" href="../../../en/c5/tube-geometry.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="adf" src="../../../en/c5/tube-geometry.png" /></a></p>
<p>The geometry for the wider tube is created with</p>
<div class="highlight"><pre><span></span><code><span class="nx">tubeGeometry1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">TubeGeometry</span><span class="p">(</span><span class="w"> </span><span class="nx">helix</span><span class="p">,</span><span class="w"> </span><span class="mf">128</span><span class="p">,</span><span class="w"> </span><span class="mf">2.5</span><span class="p">,</span><span class="w"> </span><span class="mf">32</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>The second parameter to the <abbr title="In object-oriented programming, a subroutine that is used to create objects. A constructor for a class creates and initializes objects belonging to that class.">constructor</abbr> is the number of subdivisions of the surface along the length of the curve. The third is the radius of the circular cross-section of the tube, and the fourth is the number of subdivisions around the circumference of the cross-section.</p>
<p>To make a tube, you need a 3D curve. There are also several ways to make a surface from a 2D curve. One way is to rotate the curve about a line, generating a surface of <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr>. The surface consists of all the points that the curve passes through as it rotates. This is called <strong><abbr title="A technique for producing a surface by rotating a planar curve about a line that lies in the same plane as the curve. As each point rotates about the line, it generates a circle. The surface is the union of the circles generated by all the points on the curve. Lathing imitates shapes that can be produced by a mechanical lathe.">lathing</abbr></strong>. This image from the sample program shows the surface generated by <abbr title="A technique for producing a surface by rotating a planar curve about a line that lies in the same plane as the curve. As each point rotates about the line, it generates a circle. The surface is the union of the circles generated by all the points on the curve. Lathing imitates shapes that can be produced by a mechanical lathe.">lathing</abbr> a cosine curve. (The image is rotated 90 degrees, so that the y-axis is horizontal.) The curve itself is shown above the surface:</p>
<p><a class="glightbox" href="../../../en/c5/lathe-geometry.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c5/lathe-geometry.png" /></a></p>
<p>The surface is created in <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em> using a <strong><em>THREE.LatheGeometry</em></strong> object. A <strong><em>LatheGeometry</em></strong> is constructed not from a curve but from an array of points that lie on the curve. The points are objects of type <strong><em>Vector2</em></strong>, and the curve lies in the xy-plane. The surface is generated by rotating the curve about the y-axis. The <strong><em>LatheGeometry</em></strong> <abbr title="In object-oriented programming, a subroutine that is used to create objects. A constructor for a class creates and initializes objects belonging to that class.">constructor</abbr> takes the form</p>
<div class="highlight"><pre><span></span><code><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">LatheGeometry</span><span class="p">(</span><span class="w"> </span><span class="nx">points</span><span class="p">,</span><span class="w"> </span><span class="nx">slices</span><span class="w"> </span><span class="p">)</span>
</code></pre></div>
<p>The first parameter is the array of <strong><em>Vector2</em></strong>. The second is the number of subdivisions of the surface along the circle generated when a point is rotated about the axis. (The number of "stacks" for the surface is given by the length of the points array.) In the sample program, I create the array of points from an object, <em>cosine</em>, of type <strong><em>Curve</em></strong> by calling <em>cosine.getPoints(128)</em>. This function creates an array of 128 points on the curve, using values of the parameter that range from 0.0 to 1.0.</p>
<p>Another thing that you can do with a 2D curve is simply to fill in the inside of the curve, giving a 2D filled shape. To do that in <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>, you can use an object of type <strong><em>THREE.Shape</em></strong>, which is a subclass of <strong><em>THREE.Curve</em></strong>. A <strong><em>Shape</em></strong> can be defined in the same way as a path in the 2D Canvas <abbr title="Application Programming Interface. A collection of related classes, functions, constants, etc., for performing some task. An API is an &quot;interface&quot; in the sense that it can be used without understanding how its functionality is actually implemented.">API</abbr> that was covered in <a href="../../c2/s6/">Section 2.6</a>. That is, an object shape of type <strong><em>THREE.Shape</em></strong> has methods <em>shape.moveTo</em>, <em>shape.lineTo</em>, <em>shape.quadraticCurveTo</em> and <em>shape.bezierCurveTo</em> that can be used to define the path. See <a href="../../c2/s6/#262--形状">Subsection 2.6.2</a> for details of how these functions work. As an example, we can create a teardrop shape:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">Shape</span><span class="p">();</span>
<span class="nx">path</span><span class="p">.</span><span class="nx">moveTo</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="mf">10</span><span class="p">);</span>
<span class="nx">path</span><span class="p">.</span><span class="nx">bezierCurveTo</span><span class="p">(</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="mf">5</span><span class="p">,</span><span class="w"> </span><span class="mf">20</span><span class="p">,</span><span class="o">-</span><span class="mf">10</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="o">-</span><span class="mf">10</span><span class="w"> </span><span class="p">);</span>
<span class="nx">path</span><span class="p">.</span><span class="nx">bezierCurveTo</span><span class="p">(</span><span class="w"> </span><span class="o">-</span><span class="mf">20</span><span class="p">,</span><span class="o">-</span><span class="mf">10</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="mf">5</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="mf">10</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>To use the path to create a filled shape in <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>, we need a <strong><em>ShapeGeometry</em></strong> object:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">shapeGeom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">ShapeGeometry</span><span class="p">(</span><span class="w"> </span><span class="nx">path</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>The 2D shape created with this geometry is shown on the left in this picture:</p>
<p><a class="glightbox" href="../../../en/c5/extrusion-geometry.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c5/extrusion-geometry.png" /></a></p>
<p>The other two objects in the picture were created by <strong>extruding</strong> the shape. In <abbr title="A technique for producing a solid from a 2D shape by moving the shape along a curve in 3D. The solid is the set of points through which the shape passes as it moves along the curve. The most common case is moving the shape along a line segment that is perpendicular to the plane that contains the shape. In practice, in computer graphics, the object that is produced by extrusion is just the surface of the extruded solid.">extrusion</abbr>, a filled 2D shape is moved along a path in 3D. The points that the shape passes through make up a 3D solid. In this case, the shape was extruded along a line segment perpendicular to the shape, which is the most common case. The basic extruded shape is shown on the right in the illustration. The middle object is the same shape with "beveled" edges. For more details on <abbr title="A technique for producing a solid from a 2D shape by moving the shape along a curve in 3D. The solid is the set of points through which the shape passes as it moves along the curve. The most common case is moving the shape along a line segment that is perpendicular to the plane that contains the shape. In practice, in computer graphics, the object that is produced by extrusion is just the surface of the extruded solid.">extrusion</abbr>, see the documentation for <strong><em>THREE.ExtrudeGeometry</em></strong> and the source code for the <a href="../../../en/source/threejs/curves-and-surfaces.html">sample program</a>.</p>
</div>
</div>
</div>
<h2 id="523-纹理">5.2.3 <abbr title="物体上某一点到另一点在某些属性上的变化。最常见的类型是图像纹理。当图像纹理应用于表面时，表面颜色会因点而异。">纹理</abbr><a class="headerlink" href="#523-纹理" title="Permanent link">&para;</a></h2>
<p><strong>Textures</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="4:2"><input checked="checked" id="__tabbed_4_1" name="__tabbed_4" type="radio" /><input id="__tabbed_4_2" name="__tabbed_4" type="radio" /><div class="tabbed-labels"><label for="__tabbed_4_1">中文</label><label for="__tabbed_4_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p><em><abbr title="物体上某一点到另一点在某些属性上的变化。最常见的类型是图像纹理。当图像纹理应用于表面时，表面颜色会因点而异。">纹理</abbr></em>可以用来为对象添加视觉兴趣和细节。在<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>中，图像纹理由类型为<strong><em>THREE.Texture</em></strong>的对象表示。由于我们谈论的是网页，<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>的图像通常从网络地址加载。图像纹理通常使用类型为<strong><em>THREE.TextureLoader</em></strong>的对象中的<em>load</em>函数创建。该函数接受一个URL（一个网络地址，通常是相对地址）作为参数，并返回一个<strong><em>Texture</em></strong>对象：</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">loader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">TextureLoader</span><span class="p">();</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">texture</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">loader</span><span class="p">.</span><span class="nx">load</span><span class="p">(</span><span class="w"> </span><span class="nx">imageURL</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>（建议也设置</p>
<div class="highlight"><pre><span></span><code><span class="nx">tex</span><span class="p">.</span><span class="nx">colorSpace</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">SRGBColorSpace</span><span class="p">;</span>
</code></pre></div>
<p>以正确显示颜色。<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>文档表示，“包含颜色信息的PNG或JPEG纹理（如.map或.emissiveMap）使用封闭的sRGB颜色空间，并且必须用texture.colorSpace = SRGBColorSpace进行注释。")</p>
<p>在<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>中，纹理被视为材质的一部分。要将纹理应用于网格，只需将<strong><em>Texture</em></strong>对象分配给用于网格的网格材质上的map属性：</p>
<div class="highlight"><pre><span></span><code><span class="nx">material</span><span class="p">.</span><span class="nx">map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">texture</span><span class="p">;</span>
</code></pre></div>
<p>map属性也可以在材质构造函数中设置。所有三种类型的网格材质（Basic、Lambert和Phong）都可以使用纹理。通常，材质基础颜色将是白色，因为材质颜色将与纹理中的颜色相乘。非白色材质颜色将为纹理颜色添加“色彩”。将图像映射到网格所需的纹理坐标是网格几何体的一部分。标准网格几何体，如<strong><em>THREE.SphereGeometry</em></strong>，已经定义了纹理坐标。</p>
<p>这就是基本思想——从图像URL创建纹理对象并将其分配给材质的map属性。然而，也有复杂性。首先，图像加载是“异步的”。也就是说，调用load函数只启动了图像加载的过程，该过程可能在函数返回后的某个时候完成。在图像加载完成之前在对象上使用纹理不会导致错误，但对象将被渲染为完全黑色。一旦图像加载完成，必须重新渲染场景以显示图像纹理。如果动画正在运行，这将自动发生；图像将在加载完成后的第一帧中出现。但是如果没有动画，你需要一种在图像加载完成后渲染场景的方法。实际上，<strong><em>TextureLoader</em></strong>中的<em>load</em>函数有几个可选参数：</p>
<div class="highlight"><pre><span></span><code><span class="nx">loader</span><span class="p">.</span><span class="nx">load</span><span class="p">(</span><span class="w"> </span><span class="nx">imageURL</span><span class="p">,</span><span class="w"> </span><span class="nx">onLoad</span><span class="p">,</span><span class="w"> </span><span class="kc">undefined</span><span class="p">,</span><span class="w"> </span><span class="nx">onError</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>这里的第三个参数给出为<em>undefined</em>，因为那个参数不再使用。<em>onLoad</em>和<em>onError</em>参数是回调函数。如果定义了<em>onLoad</em>函数，它将在图像成功加载后被调用。如果加载图像的尝试失败，将调用<em>onError</em>函数。例如，如果有一个函数<em>render()</em>渲染场景，那么<em>render</em>本身就可以作为onLoad函数使用：</p>
<div class="highlight"><pre><span></span><code><span class="nx">texture</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">TextureLoader</span><span class="p">().</span><span class="nx">load</span><span class="p">(</span><span class="w"> </span><span class="s2">&quot;brick.png&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">render</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>onLoad的另一个可能用途是在图像加载完成后延迟将纹理分配给材质。如果你稍后添加纹理，请确保设置</p>
<div class="highlight"><pre><span></span><code><span class="nx">material</span><span class="p">.</span><span class="nx">needsUpdate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
</code></pre></div>
<p>以确保更改在对象重新绘制时生效。（needsUpdate需要在各种对象上设置的确切时间并不总是清楚的。请参阅<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>文档中的<a href="https://threejs.org/docs/#manual/en/introduction/How-to-update-things">更新资源</a>部分。）</p>
<p><strong><em>Texture</em></strong>有几个可以设置的属性，包括设置纹理的最小化和放大滤镜属性以及控制mipmap生成的属性，mipmap默认会自动生成。你最有可能想要更改的属性是纹理坐标超出范围0到1的包装模式和纹理转换。（有关这些属性的更多信息，请参阅第4.3节。）</p>
<p>对于<strong><em>Texture</em></strong>对象tex，<abbr title="图形对象的属性，例如颜色。图像可以通过其包含的几何形状以及它们的属性来指定。">属性</abbr><em>tex.wrapS</em>和<em>tex.wrapT</em>控制s和t纹理坐标超出范围0到1时的处理方式。默认值是“clamp to edge”。你最有可能想要通过将属性值设置为<em>THREE.RepeatWrapping</em>来使纹理在两个方向上重复：</p>
<div class="highlight"><pre><span></span><code><span class="nx">tex</span><span class="p">.</span><span class="nx">wrapS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">RepeatWrapping</span><span class="p">;</span>
<span class="nx">tex</span><span class="p">.</span><span class="nx">wrapT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">RepeatWrapping</span><span class="p">;</span>
</code></pre></div>
<p>RepeatWrapping最适合使用“无缝”<abbr title="物体上某一点到另一点在某些属性上的变化。最常见的类型是图像纹理。当图像纹理应用于表面时，表面颜色会因点而异。">纹理</abbr>，其中图像的上边缘与下边缘对齐，左边缘与右边缘对齐。<em>Three.js</em>还提供了一个有趣的变体，称为“镜像重复”，其中重复图像的每个其他副本都被翻转。这消除了图像副本之间的接缝。要进行镜像重复，请使用属性值<em>THREE.MirroredRepeatWrapping</em>：</p>
<div class="highlight"><pre><span></span><code><span class="nx">tex</span><span class="p">.</span><span class="nx">wrapS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">MirroredRepeatWrapping</span><span class="p">;</span>
<span class="nx">tex</span><span class="p">.</span><span class="nx">wrapT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">MirroredRepeatWrapping</span><span class="p">;</span>
</code></pre></div>
<p>纹理属性<em>repeat</em>、<em>offset</em>和<em><abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr></em>控制应用于纹理的缩放、平移和旋转作为纹理转换。repeat和offset的值是类型为<strong><em>THREE.Vector2</em></strong>的，因此每个属性都有一个x和y组件。<em><abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr></em>是一个数字，以弧度为单位，给出纹理关于点(0,0)的旋转。（但实际上，旋转中心由另一个名为center的属性给出。）对于<strong><em>Texture</em></strong>，<em>tex</em>，<em>tex.offset</em>的两个组件分别给出水平和垂直方向上的纹理平移。要在水平方向上将纹理偏移0.5，你可以这样说：</p>
<div class="highlight"><pre><span></span><code><span class="nx">tex</span><span class="p">.</span><span class="nx">offset</span><span class="p">.</span><span class="nx">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="p">;</span>
</code></pre></div>
<p>或者</p>
<div class="highlight"><pre><span></span><code><span class="nx">tex</span><span class="p">.</span><span class="nx">offset</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="w"> </span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>记住，水平偏移的正值会将纹理向对象的<em>左侧</em>移动，因为偏移是应用于纹理坐标本身而不是纹理图像。</p>
<p>属性tex.repeat的组件在水平和垂直方向上给出纹理缩放。例如，</p>
<div class="highlight"><pre><span></span><code><span class="nx">tex</span><span class="p">.</span><span class="nx">repeat</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="mf">2</span><span class="p">,</span><span class="mf">3</span><span class="p">);</span>
</code></pre></div>
<p>将在水平方向上将纹理坐标缩放2倍，在垂直方向上缩放3倍。同样，对图像的影响是相反的，所以图像在水平方向上缩小2倍，在垂直方向上缩小3倍。结果是，你在水平方向上得到两个图像副本，而在垂直方向上得到三个副本。这解释了“repeat”的名称，但请注意，这些值不仅限于整数。</p>
<p>这个演示让你可以查看一些带有纹理的<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>对象。顺便说一下，演示中的“Pill”对象是一个由一个圆柱体和两个半球体组成的复合对象。</p>
<p><iframe src="../../../en/demos/c5/textures.html" width="575" height="370"></iframe></p>
<hr />
<p>假设我们想在本节开头创建的金字塔上使用图像纹理。为了将纹理图像应用于对象，WebGL需要该对象的纹理坐标。当我们从头开始构建网格时，我们必须将纹理坐标作为网格的几何对象的一部分提供。</p>
<p>让我们看看在我们的金字塔示例上如何做到这一点。像示例中的<em>pyramidGeom</em>这样的<strong><em>BufferedGeometry</em></strong>对象有一个名为"uv"的属性，用于保存纹理坐标。（名称"uv"指的是映射到纹理中的s和t坐标的对象上的坐标。表面的纹理坐标通常被称为"uv坐标。"）"uv"属性的<strong><em>BufferAttribute</em></strong>可以从一个包含每个顶点的一对纹理坐标的类型化数组中创建。</p>
<p>我们的金字塔示例有六个三角形面，总共有18个顶点。我们需要一个包含18个顶点的顶点坐标数组。坐标必须被选择以合理的方式将图像映射到面上。我选择的坐标将整个纹理图像映射到金字塔的正方形基座上，并从图像中切出一个三角形应用到每个侧面上。想出正确的坐标需要一些注意。我为金字塔几何体定义纹理坐标如下：</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">pyramidUVs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Float32Array</span><span class="p">([</span>
<span class="w">        </span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w">   </span><span class="c1">// 底部第一个三角形的uv坐标。</span>
<span class="w">        </span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">   </span><span class="c1">// 底部第二个三角形的uv坐标。</span>
<span class="w">        </span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="c1">// 前面的uv坐标。</span>
<span class="w">        </span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="c1">// 右面的uv坐标。</span>
<span class="w">        </span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="c1">// 后面的uv坐标。</span>
<span class="w">        </span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1</span><span class="w">  </span><span class="c1">// 左面的uv坐标。</span>
<span class="p">]);</span>
<span class="nx">pyramidGeom</span><span class="p">.</span><span class="nx">setAttribute</span><span class="p">(</span><span class="s2">&quot;uv&quot;</span><span class="p">,</span>
<span class="w">                        </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">BufferAttribute</span><span class="p">(</span><span class="nx">pyramidUVs</span><span class="p">,</span><span class="mf">2</span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>示例程序<a href="../../../en/source/threejs/textured-pyramid.html">threejs/textured-pyramid.html</a>显示了一个带有砖纹理的金字塔。这是程序中的一张图像：</p>
<p><a class="glightbox" href="../../../en/c5/textured-pyramid.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c5/textured-pyramid.png" /></a></p>
</div>
<div class="tabbed-block">
<p>A <em><abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr></em> can be used to add visual interest and detail to an object. In <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>, an <abbr title="An image that is applied to a surface as a texture, so that it looks at if the image is &quot;painted&quot; onto the surface.">image texture</abbr> is represented by an object of type <strong><em>THREE.Texture</em></strong>. Since we are talking about web pages, the image for a <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em> <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> is generally loaded from a web address. Image textures are usually created using the <em>load</em> function in an object of type <strong><em>THREE.TextureLoader</em></strong>. The function takes a <abbr title="Uniform Resource Locator. An address of some resource on the World Wide Web. For example, &quot;&lt;http://math.hws.edu/grahicsbook&gt;&quot;.">URL</abbr> (a web address, usually a relative address) as parameter and returns a <strong><em>Texture</em></strong> object:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">loader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">TextureLoader</span><span class="p">();</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">texture</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">loader</span><span class="p">.</span><span class="nx">load</span><span class="p">(</span><span class="w"> </span><span class="nx">imageURL</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>(It is also advisable to set</p>
<div class="highlight"><pre><span></span><code><span class="nx">tex</span><span class="p">.</span><span class="nx">colorSpace</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">SRGBColorSpace</span><span class="p">;</span>
</code></pre></div>
<p>to display the colors correctly. The <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em> documentation says, "PNG or JPEG Textures containing color information (like .map or .emissiveMap) use the closed domain sRGB color space, and must be annotated with <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>.colorSpace = SRGBColorSpace.")</p>
<p>A <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> in <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em> is considered to be part of a <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr>. To apply a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> to a mesh, just assign the <strong><em>Texture</em></strong> object to the map property of the mesh <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> that is used on the mesh:</p>
<div class="highlight"><pre><span></span><code><span class="nx">material</span><span class="p">.</span><span class="nx">map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">texture</span><span class="p">;</span>
</code></pre></div>
<p>The <em>map</em> property can also be set in the <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> <abbr title="In object-oriented programming, a subroutine that is used to create objects. A constructor for a class creates and initializes objects belonging to that class.">constructor</abbr>. All three types of mesh <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> (Basic, Lambert, and Phong) can use a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. In general, the <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> base color will be white, since the <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> color will be multiplied by colors from the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. A non-white <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> color will add a "tint" to the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> colors. The <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates that are needed to map the image to a mesh are part of the mesh geometry. The standard mesh geometries such as <strong><em>THREE.SphereGeometry</em></strong> come with <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates already defined.</p>
<p>That's the basic idea—create a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> object from an image <abbr title="Uniform Resource Locator. An address of some resource on the World Wide Web. For example, &quot;&lt;http://math.hws.edu/grahicsbook&gt;&quot;.">URL</abbr> and assign it to the map property of a <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr>. However, there are complications. First of all, image loading is "asynchronous." That is, calling the load function only starts the process of loading the image, and the process can complete sometime after the function returns. Using a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> on an object before the image has finished loading does not cause an error, but the object will be rendered as completely black. Once the image has been loaded, the scene has to be rendered again to show the <abbr title="An image that is applied to a surface as a texture, so that it looks at if the image is &quot;painted&quot; onto the surface.">image texture</abbr>. If an <abbr title="A sequence of images that, when displayed quickly one after the other, will produce the impression of continuous motion or change. The term animation also refers to the process of creating such image sequences.">animation</abbr> is running, this will happen automatically; the image will appear in the first frame after it has finished loading. But if there is no <abbr title="A sequence of images that, when displayed quickly one after the other, will produce the impression of continuous motion or change. The term animation also refers to the process of creating such image sequences.">animation</abbr>, you need a way to render the scene once the image has loaded. In fact, the <em>load</em> function in a <strong><em>TextureLoader</em></strong> has several optional parameters:</p>
<div class="highlight"><pre><span></span><code><span class="nx">loader</span><span class="p">.</span><span class="nx">load</span><span class="p">(</span><span class="w"> </span><span class="nx">imageURL</span><span class="p">,</span><span class="w"> </span><span class="nx">onLoad</span><span class="p">,</span><span class="w"> </span><span class="kc">undefined</span><span class="p">,</span><span class="w"> </span><span class="nx">onError</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>The third parameter here is given as <em>undefined</em> because that parameter is no longer used. The <em>onLoad</em> and <em>onError</em> parameters are callback functions. The <em>onLoad</em> function, if defined, will be called once the image has been successfully loaded. The <em>onError</em> function will be called if the attempt to load the image fails. For example, if there is a function <em>render()</em> that renders the scene, then <em>render</em> itself could be used as the onLoad function:</p>
<div class="highlight"><pre><span></span><code><span class="nx">texture</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">TextureLoader</span><span class="p">().</span><span class="nx">load</span><span class="p">(</span><span class="w"> </span><span class="s2">&quot;brick.png&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">render</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>Another possible use of onLoad would be to delay assigning the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> to a <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr> until the image has finished loading. If you do add the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> later, be sure to set</p>
<div class="highlight"><pre><span></span><code><span class="nx">material</span><span class="p">.</span><span class="nx">needsUpdate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
</code></pre></div>
<p>to make sure that the change will take effect when the object is redrawn. (When exactly needsUpdate needs to be set on various objects is not always clear. See the "<a href="https://threejs.org/docs/#manual/en/introduction/How-to-update-things">Updating Resources</a>" section of the <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em> documentation.)</p>
<p>A <strong><em>Texture</em></strong> has a number of properties that can be set, including properties to set the minification and magnification filters for the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> and a property to control the generation of <abbr title="One of a series of reduced-size copies of a texture image, of decreasing width and height. Starting from the original image, each mipmap is obtained by dividing the width and height of the previous image by two (unless it is already 1). The final mipmap is a single pixel. Mipmaps are used for more efficient mapping of the texture image to a surface, when the image has to be shrunk to fit the surface.">mipmaps</abbr>, which is done automatically by default. The properties that you are most likely to want to change are the wrap mode for <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates outside the range 0 to 1 and the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> transformation. (See Section 4.3 for more information about these properties.)</p>
<p>For a <strong><em>Texture</em></strong> object tex, the properties <em>tex.wrapS</em> and <em>tex.wrapT</em> control how s and t <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates outside the range 0 to 1 are treated. The default is "clamp to edge." You will most likely want to make the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> repeat in both directions by setting the property values to <em>THREE.RepeatWrapping</em>:</p>
<div class="highlight"><pre><span></span><code><span class="nx">tex</span><span class="p">.</span><span class="nx">wrapS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">RepeatWrapping</span><span class="p">;</span>
<span class="nx">tex</span><span class="p">.</span><span class="nx">wrapT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">RepeatWrapping</span><span class="p">;</span>
</code></pre></div>
<p>RepeatWrapping works best with "seamless" textures, where the top edge of the image matches up with the bottom edge and the left edge with the right. <em>Three.js</em> also offers an interesting variation called "mirrored repeat" in which every other copy of the repeated image is flipped. This eliminates the seam between copies of the image. For mirrored repetition, use the property value <em>THREE.MirroredRepeatWrapping</em>:</p>
<div class="highlight"><pre><span></span><code><span class="nx">tex</span><span class="p">.</span><span class="nx">wrapS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">MirroredRepeatWrapping</span><span class="p">;</span>
<span class="nx">tex</span><span class="p">.</span><span class="nx">wrapT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">MirroredRepeatWrapping</span><span class="p">;</span>
</code></pre></div>
<p>The <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> properties <em>repeat</em>, <em>offset</em>, and <em><abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr></em> control the <abbr title="A geometric transform that multiplies each coordinate of a point by a number called the scaling factor. Scaling increases or decreases the size of an object, but also moves its points closer to or farther from the origin. Scaling can be uniform—the same in every direction—or non-uniform—with a different scaling factor in each coordinate direction. A negative scaling factor can be used to apply a reflection.">scaling</abbr>, <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr>, and <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> that are applied to the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> as <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> transformations. The values of repeat and offset are of type <strong><em>THREE.Vector2</em></strong>, so that each property has an x and a y component. The <em><abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr></em> is a number, measured in radians, giving the <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> of the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> about the point (0,0). (But the center of <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> is actually given by another property named center.) For a <strong><em>Texture</em></strong>, <em>tex</em>, the two components of <em>tex.offset</em> give the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr> in the horizontal and vertical directions. To offset the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> by 0.5 horizontally, you can say either</p>
<div class="highlight"><pre><span></span><code><span class="nx">tex</span><span class="p">.</span><span class="nx">offset</span><span class="p">.</span><span class="nx">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="p">;</span>
</code></pre></div>
<p>or</p>
<div class="highlight"><pre><span></span><code><span class="nx">tex</span><span class="p">.</span><span class="nx">offset</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="w"> </span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>Remember that a positive horizontal offset will move the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> to the <em>left</em> on the objects, because the offset is applied to the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates not to the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image itself.</p>
<p>The components of the property tex.repeat give the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> <abbr title="A geometric transform that multiplies each coordinate of a point by a number called the scaling factor. Scaling increases or decreases the size of an object, but also moves its points closer to or farther from the origin. Scaling can be uniform—the same in every direction—or non-uniform—with a different scaling factor in each coordinate direction. A negative scaling factor can be used to apply a reflection.">scaling</abbr> in the horizontal and vertical directions. For example,</p>
<div class="highlight"><pre><span></span><code><span class="nx">tex</span><span class="p">.</span><span class="nx">repeat</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="mf">2</span><span class="p">,</span><span class="mf">3</span><span class="p">);</span>
</code></pre></div>
<p>will scale the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates by a factor of 2 horizontally and 3 vertically. Again, the effect on the image is the inverse, so that the image is shrunk by a factor of 2 horizontally and 3 vertically. The result is that you get two copies of the image in the horizontal direction where you would have had one, and three vertically. This explains the name "repeat," but note that the values are not limited to be integers.</p>
<p>This demo lets you view some textured <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em> objects. The "Pill" object in the demo, by the way, is a compound object consisting of a cylinder and two hemispheres.</p>
<p><iframe src="../../../en/demos/c5/textures.html" width="575" height="370"></iframe></p>
<hr />
<p>Suppose that we want to use an <abbr title="An image that is applied to a surface as a texture, so that it looks at if the image is &quot;painted&quot; onto the surface.">image texture</abbr> on the pyramid that was created at the beginning of this section. In order to apply a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image to an object, <abbr title="A 3D graphics API for use on web pages. WebGL programs are written in the JavaScript programming language and display their images in HTML canvas elements. WebGL is based on OpenGL ES, the version of OpenGL for embedded systems, with a few changes to adapt it to the JavaScript language and the Web environment.">WebGL</abbr> needs <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates for that object. When we build a mesh from scratch, we have to supply the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates as part of the mesh's geometry object.</p>
<p>Let's see how to do this on our pyramid example. A <strong><em>BufferedGeometry</em></strong> object such as <em>pyramidGeom</em> in the example has an <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> named "uv" to hold <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates. (The name "uv" refers to the coordinates on an object that are mapped to the s and t coordinates in a <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. The <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates for a surface are often referred to as "uv coordinates.") The <strong><em>BufferAttribute</em></strong> for a "uv" <abbr title="A property, such as color, of a graphical object. An image can be specified by the geometric shapes that it contains, together with their attributes.">attribute</abbr> can be made from a <abbr title="In JavaScript, an array type that is limited to holding numerical values of a single type. For example, the type Float32Array represents arrays that can hold 32-bit floating point values, and Uint8Array arrays can hold only 8-bit integer values. Such arrays are more efficient than general JavaScript arrays for numerical calculations. The were introduced into JavaScript along with HTML canvas graphics and WebGL.">typed array</abbr> containing a pair of <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates for each <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr>.</p>
<p>Our pyramid example has six triangular faces, with a total of 18 vertices. We need an array containing <abbr title="One of the points that define a geometric primitive, such as the two endpoints of a line segment or the three vertices of a triangle. (The plural is &quot;vertices.&quot;) A vertex can be specified in a coordinate system by giving its x and y coordinates in 2D graphics, or its x, y, and z coordinates in 3D graphics.">vertex</abbr> coordinates for 18 vertices. The coordinates have to be chosen to map the image in a reasonable way onto the faces. My choice of coordinates maps the entire <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> image onto the square base of the pyramid, and it cuts a triangle out of the image to apply to each of the sides. It takes some care to come up with the correct coordinates. I define the <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr> coordinates for the pyramid geometry as follows:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">pyramidUVs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Float32Array</span><span class="p">([</span>
<span class="w">        </span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w">   </span><span class="c1">// uv coords for first triangle in base.</span>
<span class="w">        </span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w">  </span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">   </span><span class="c1">// uv coords for second triangle in base.</span>
<span class="w">        </span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="c1">// uv coords for front face.</span>
<span class="w">        </span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="c1">// uv coords for right face.</span>
<span class="w">        </span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="c1">// uv coords for back face.</span>
<span class="w">        </span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="w">  </span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1</span><span class="w">  </span><span class="c1">// uv coords for left face.</span>
<span class="p">]);</span>
<span class="nx">pyramidGeom</span><span class="p">.</span><span class="nx">setAttribute</span><span class="p">(</span><span class="s2">&quot;uv&quot;</span><span class="p">,</span>
<span class="w">                        </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">BufferAttribute</span><span class="p">(</span><span class="nx">pyramidUVs</span><span class="p">,</span><span class="mf">2</span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>The sample program <a href="../../../en/source/threejs/textured-pyramid.html">threejs/textured-pyramid.html</a> shows the pyramid with a brick <abbr title="Variation in some property from point-to-point on an object. The most common type is image texture. When an image texture is applied to a surface, the surface color varies from point to point.">texture</abbr>. Here is an image from the program:</p>
<p><a class="glightbox" href="../../../en/c5/textured-pyramid.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="123" src="../../../en/c5/textured-pyramid.png" /></a></p>
</div>
</div>
</div>
<h2 id="524-变换">5.2.4 变换<a class="headerlink" href="#524-变换" title="Permanent link">&para;</a></h2>
<p><strong>Transforms</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="5:2"><input checked="checked" id="__tabbed_5_1" name="__tabbed_5" type="radio" /><input id="__tabbed_5_2" name="__tabbed_5" type="radio" /><div class="tabbed-labels"><label for="__tabbed_5_1">中文</label><label for="__tabbed_5_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>为了理解如何在<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>中有效地使用对象，了解它如何实现变换是很有用的。我已经解释了<strong><em>Object3D</em></strong>，obj，具有属性<em>obj.position</em>、<em>obj.scale</em>和<em>obj.<abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr></em>，这些属性指定了它在自己的局部坐标系中的建模变换。但是，这些属性在渲染对象时并没有直接使用。相反，它们被组合起来计算另一个属性，<em>obj.<abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr></em>，它表示变换为一个矩阵。默认情况下，这个矩阵在每次渲染场景时都会自动重新计算。如果变换从不改变，这可能是低效的，所以obj有另一个属性，<em>obj.matrixAutoUpdate</em>，它控制是否自动计算<em>obj.<abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr></em>。如果将<em>obj.matrixAutoUpdate</em>设置为false，则不会进行更新。在这种情况下，如果您确实想更改建模变换，可以调用<em>obj.updateMatrix()</em>从当前值计算矩阵<em>obj.position</em>、<em>obj.scale</em>和<em>obj.<abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr></em>。</p>
<p>我们已经看到了如何通过直接更改属性的值来修改<em>obj</em>的建模变换<em>obj.position</em>、<em>obj.scale</em>和<em>obj.<abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr></em>。然而，您也可以通过调用函数<em>obj.translateX(dx)</em>、<em>obj.translateY(dy)</em>或<em>obj.translateZ(dz)</em>来更改位置，以将对象沿坐标轴的方向移动指定的数量。还有一个函数<em>obj.translateOnAxis(axis,amount)</em>，其中axis是一个<strong><em>Vector3</em></strong>，amount是一个数字，给出平移对象的距离。对象沿着向量的方向移动，axis。该向量必须被规范化；也就是说，它必须长度为1。例如，要将<em>obj</em>沿着向量(1,1,1)的方向平移5个单位，可以说</p>
<div class="highlight"><pre><span></span><code><span class="nx">obj</span><span class="p">.</span><span class="nx">translateOnAxis</span><span class="p">(</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">Vector3</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">).</span><span class="nx">normalize</span><span class="p">(),</span><span class="w"> </span><span class="mf">5</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>没有用于更改缩放变换的函数。但是，您可以使用函数<em>obj.rotateX(angle)</em>、<em>obj.rotateY(angle)</em>和<em>obj.rotateZ(angle)</em>来更改对象的旋转，使对象绕坐标轴旋转。（记住，角度以弧度为单位。）调用<em>obj.rotateX(angle)</em>与将<em>angle</em>加到<em>obj.<abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr>.x</em>的值上不同，因为它在可能已经应用的其他旋转之上应用了关于x轴的旋转。</p>
<p>还有一个函数<em>obj.rotateOnAxis(axis,angle)</em>，其中axis是一个<strong><em>Vector3</em></strong>。这个函数将对象绕向量旋转角度angle（即，绕原点和由<em>axis</em>给出的点之间的线）。该轴必须是一个规范化的向量。</p>
<p>（旋转实际上更加复杂。对象obj的旋转实际上是由属性<em>obj.<abbr title="A vector in the quaternion algebra, which is a four dimensional vector space in which two vectors, in addition to being added, can be multiplied. In computer graphics, quaternions of length one are often used to represent rotations. An advantage is that in the quaternion representation, it is possible to smoothly interpolate between two rotations.">quaternion</abbr></em>表示的，而不是由属性<em>obj.<abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr></em>表示的。<strong><abbr title="四元数代数中的向量，这是一个四维向量空间，其中两个向量除了可以相加外，还可以相乘。在计算机图形学中，长度为一的四元数通常用于表示旋转。一个优点是，在四元数表示中，可以在两个旋转之间平滑插值。">四元数</abbr></strong>是数学对象，通常在计算机图形学中作为欧拉角的替代品，用于表示旋转。然而，当您更改属性<em>obj.<abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr></em>或<em>obj.<abbr title="A vector in the quaternion algebra, which is a four dimensional vector space in which two vectors, in addition to being added, can be multiplied. In computer graphics, quaternions of length one are often used to represent rotations. An advantage is that in the quaternion representation, it is possible to smoothly interpolate between two rotations.">quaternion</abbr></em>之一时，另一个会自动更新，以确保两个属性表示相同的旋转。因此，我们不需要直接使用四元数。）</p>
<p>我需要强调的是，平移和<em><abbr title="一种几何变换，它围绕某个点（在2D中）或轴（在3D中）旋转每个点到指定角度。">旋转</abbr></em>函数修改了对象的位置和<em><abbr title="一种几何变换，它围绕某个点（在2D中）或轴（在3D中）旋转每个点到指定角度。">旋转</abbr></em><abbr title="图形对象的属性，例如颜色。图像可以通过其包含的几何形状以及它们的属性来指定。">属性</abbr>。也就是说，它们以对象坐标应用，而不是世界坐标，并且在渲染对象时作为对象上的第一个建模变换应用。例如，世界坐标中的旋转可以改变对象的位置，如果它没有定位在原点。然而，更改对象的<em><abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr></em>属性的值永远不会改变其位置。</p>
<p>在渲染对象时实际应用到对象的变换是该对象的建模变换与场景图中其所有祖先的建模变换的组合。在<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>中，该变换存储在对象名为<em>obj.matrixWorld</em>的属性中。</p>
<p>还有一个有用的方法来设置旋转：<em>obj.lookAt(vec)</em>，它将对象旋转，使其面向给定的点。参数，<em>vec</em>，是一个<strong><em>Vector3</em></strong>，必须以对象自己的局部坐标系表示。（对于没有父对象或其祖先没有建模变换的对象，这将与世界坐标相同。）对象还被旋转，使其“向上”方向等于属性obj.up的值，默认为(0,1,0)。这个函数可以用于任何对象，但对相机最有用。</p>
</div>
<div class="tabbed-block">
<p>In order to understand how to work with objects effectively in <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>, it can be useful to know more about how it implements transforms. I have explained that an <strong><em>Object3D</em></strong>, obj, has properties <em>obj.position</em>, <em>obj.scale</em>, and <em>obj.<abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr></em> that specify its <abbr title="A transformation that is applied to an object to map that object into the world coordinate system or into the object coordinate system for a more complex, hierarchical object.">modeling transformation</abbr> in its own local <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr>. But these properties are not used directly when the object is rendered. Instead, they are combined to compute another property, <em>obj.<abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr></em>, that represents the transformation as a <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>. By default, this <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> is recomputed automatically every time the scene is rendered. This can be inefficient if the transformation never changes, so obj has another property, <em>obj.matrixAutoUpdate</em>, that controls whether <em>obj.<abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr></em> is computed automatically. If you set <em>obj.matrixAutoUpdate</em> to false, the update is not done. In that case, if you do want to change the <abbr title="A transformation that is applied to an object to map that object into the world coordinate system or into the object coordinate system for a more complex, hierarchical object.">modeling transformation</abbr>, you can call <em>obj.updateMatrix()</em> to compute the <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> from the current values of <em>obj.position</em>, <em>obj.scale</em>, and <em>obj.<abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr></em>.</p>
<p>We have seen how to modify <em>obj</em>'s <abbr title="A transformation that is applied to an object to map that object into the world coordinate system or into the object coordinate system for a more complex, hierarchical object.">modeling transformation</abbr> by directly changing the values of the properties <em>obj.position</em>, <em>obj.scale</em>, and <em>obj.<abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr></em>. However, you can also change the position by calling the function <em>obj.translateX(dx),</em> <em>obj.translateY(dy),</em> or <em>obj.translateZ(dz)</em> to move the object by a specified amount in the direction of a coordinate axis. There is also a function <em>obj.translateOnAxis(axis,amount)</em>, where axis is a <strong><em>Vector3</em></strong> and amount is a number giving the distance to translate the object. The object is moved in the direction of the <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr>, axis. The <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> must be normalized; that is, it must have length 1. For example, to translate <em>obj</em> by 5 units in the direction of the <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> (1,1,1), you could say</p>
<div class="highlight"><pre><span></span><code><span class="nx">obj</span><span class="p">.</span><span class="nx">translateOnAxis</span><span class="p">(</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">THREE</span><span class="p">.</span><span class="nx">Vector3</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">).</span><span class="nx">normalize</span><span class="p">(),</span><span class="w"> </span><span class="mf">5</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>There are no functions for changing the <abbr title="A geometric transform that multiplies each coordinate of a point by a number called the scaling factor. Scaling increases or decreases the size of an object, but also moves its points closer to or farther from the origin. Scaling can be uniform—the same in every direction—or non-uniform—with a different scaling factor in each coordinate direction. A negative scaling factor can be used to apply a reflection.">scaling</abbr> transform. But you can change the object's <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> with the functions <em>obj.rotateX(angle)</em>, <em>obj.rotateY(angle)</em>, and <em>obj.rotateZ(angle)</em> to rotate the object about the coordinate axes. (Remember that angles are measured in radians.) Calling <em>obj.rotateX(angle)</em> is not the same as adding <em>angle</em> onto the value of <em>obj.<abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr>.x</em>, since it applies a <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> about the x-axis on top of other rotations that might already have been applied.</p>
<p>There is also a function <em>obj.rotateOnAxis(axis,angle)</em>, where axis is a <strong><em>Vector3</em></strong>. This function rotates the object through the angle angle about the <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> (that is, about the line between the origin and the point given by <em>axis</em>). The axis must be a <abbr title="The result of dividing a non-zero vector by its length, giving a unit vector, that is, a vector of length one. (Note that &quot;normalized vector&quot; and &quot;normal vector&quot; are, confusingly, unrelated terms!)">normalized vector</abbr>.</p>
<p>(Rotation is actually even more complicated. The <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> of an object, obj, is actually represented by the property <em>obj.<abbr title="A vector in the quaternion algebra, which is a four dimensional vector space in which two vectors, in addition to being added, can be multiplied. In computer graphics, quaternions of length one are often used to represent rotations. An advantage is that in the quaternion representation, it is possible to smoothly interpolate between two rotations.">quaternion</abbr></em>, not by the property <em>obj.<abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr></em>. <strong>Quaternions</strong> are mathematical objects that are often used in computer graphics as an alternative to <abbr title="Express the rotation of an object in its own coordinate system, given as individual rotations about the x, y, and z axes in that coordinate system. The cumulative effect of rotations about the three coordinate axes depends on the order in which the rotations are applied.">Euler angles</abbr>, to represent rotations. However, when you change one of the properties <em>obj.<abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr></em> or <em>obj.<abbr title="A vector in the quaternion algebra, which is a four dimensional vector space in which two vectors, in addition to being added, can be multiplied. In computer graphics, quaternions of length one are often used to represent rotations. An advantage is that in the quaternion representation, it is possible to smoothly interpolate between two rotations.">quaternion</abbr></em>, the other is automatically updated to make sure that both properties represent the same <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr>. So, we don't need to work directly with the quaternions.)</p>
<p>I should emphasize that the <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr> and <em><abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr></em> functions modify the position and <em><abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr></em> properties of the object. That is, they apply in <abbr title="The coordinate system in which the coordinates for points in an object are originally specified, before they are transformed by any modeling or other transform that will be applied to the object.">object coordinates</abbr>, not <abbr title="The coordinate system in which a scene is defined. The image that is produced of the scene will show the contents of the world coordinate system that lie within some view volume (for 3D) or view window (for 2D). Objects are defined in their own object coordinate system. Modeling transformations are then applied to place objects into the scene; that is, they transform object coordinates to world coordinates.">world coordinates</abbr>, and they are applied as the first <abbr title="A transformation that is applied to an object to map that object into the world coordinate system or into the object coordinate system for a more complex, hierarchical object.">modeling transformation</abbr> on the object when the object is rendered. For example, a <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> in <abbr title="The coordinate system in which a scene is defined. The image that is produced of the scene will show the contents of the world coordinate system that lie within some view volume (for 3D) or view window (for 2D). Objects are defined in their own object coordinate system. Modeling transformations are then applied to place objects into the scene; that is, they transform object coordinates to world coordinates.">world coordinates</abbr> can change the position of an object, if it is not positioned at the origin. However, changing the value of the <em><abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr></em> property of an object will never change its position.</p>
<p>The actual transformation that is applied to an object when it is rendered is a combination of the <abbr title="A transformation that is applied to an object to map that object into the world coordinate system or into the object coordinate system for a more complex, hierarchical object.">modeling transformation</abbr> of that object, combined with the <abbr title="A transformation that is applied to an object to map that object into the world coordinate system or into the object coordinate system for a more complex, hierarchical object.">modeling transformation</abbr> on all of its ancestors in the <abbr title="A data structure that represents the objects in a scene, together with attributes of the objects and the modeling transformations that are applied to the objects. An image of the scene is created by traversing the scene graph data structure. A scene graph might exist only conceptually, or it might be an actual data structure in a program.">scene graph</abbr>. In <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>, that transformation is stored in a property of the object named <em>obj.matrixWorld</em>.</p>
<p>There is one more useful method for setting the <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr>: <em>obj.lookAt(vec)</em>, which rotates the object so that it is facing towards a given point. The parameter, <em>vec</em>, is a <strong><em>Vector3</em></strong>, which must be expressed in the object's own local <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr>. (For an object that has no parent, or whose ancestors have no modeling transformations, that will be the same as <abbr title="The coordinate system in which a scene is defined. The image that is produced of the scene will show the contents of the world coordinate system that lie within some view volume (for 3D) or view window (for 2D). Objects are defined in their own object coordinate system. Modeling transformations are then applied to place objects into the scene; that is, they transform object coordinates to world coordinates.">world coordinates</abbr>.) The object is also rotated so that its "up" direction is equal to the value of the property obj.up, which by default is (0,1,0). This function can be used with any object, but it is most useful for a <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>.</p>
</div>
</div>
</div>
<h2 id="525-加载模型">5.2.5 加载模型<a class="headerlink" href="#525-加载模型" title="Permanent link">&para;</a></h2>
<p><strong>Loading Models</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="6:2"><input checked="checked" id="__tabbed_6_1" name="__tabbed_6" type="radio" /><input id="__tabbed_6_2" name="__tabbed_6" type="radio" /><div class="tabbed-labels"><label for="__tabbed_6_1">中文</label><label for="__tabbed_6_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>尽管通过列出网格对象的顶点和面来创建它们是可能的，但除了非常简单的对象外，手工制作是非常困难的。例如，在Blender这样的交互式建模程序中设计对象要容易得多（见<a href="../a2/index.md">附录B</a>）。像Blender这样的建模程序可以使用许多不同的文件格式导出对象。<em>Three.js</em>拥有用于从各种文件格式加载模型的实用函数。这些实用程序不是<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>核心的一部分，但定义它们的JavaScript文件可以在<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>下载包的<em>examples</em>文件夹中找到。</p>
<p>模型文件的首选格式是<strong><abbr title="GL传输格式。3D模型的文件格式。GLTF文件可以包含完整的3D场景，包括对象、材质、灯光甚至动画。GLTF规范来自Khronos Group，该组织也负责OpenGL、WebGL和Vulkan。">GLTF</abbr></strong>。GLTF模型可以存储在扩展名为.gltf的文本文件中，也可以存储在扩展名为.glb的二进制文件中。二进制文件更小、更高效，但不是人类可读的。<em>Three.js</em>用于加载GLTF文件的加载器由<strong><em>GLTFLoader</em></strong>类定义，可以从<em>GLTFLoader.js</em>模块中导入，该模块可在<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>下载包中找到。该脚本的副本以及其他模型加载器的脚本可以在教科书的源文件夹的<a href="https://math.hws.edu/graphicsbook/source/threejs/script/loaders">threejs/script/loaders</a>文件夹中找到，或者在<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em>下载包的examples/jsm/loaders文件夹中找到。（注意，<strong><em>GLTFLoader</em></strong>不是对象THREE的一部分。）</p>
<p>如果<em>loader</em>是类型为<strong><em>GLTFLoader</em></strong>的对象，您可以使用它的<em>load()</em>方法开始加载模型的过程：</p>
<div class="highlight"><pre><span></span><code><span class="nx">loader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">GLTFLoader</span><span class="p">()</span>
<span class="nx">loader</span><span class="p">.</span><span class="nx">load</span><span class="p">(</span><span class="w"> </span><span class="nx">url</span><span class="p">,</span><span class="w"> </span><span class="nx">onLoad</span><span class="p">,</span><span class="w"> </span><span class="nx">onProgress</span><span class="p">,</span><span class="w"> </span><span class="nx">onError</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>只有一个参数是必需的；它是一个包含模型的文件的URL。其他三个参数是回调函数：<em>onLoad</em>将在加载完成时被调用，参数表示来自文件的数据；<em>onProgress</em>在加载过程中定期被调用，参数包含有关模型大小以及已加载多少的信息；如果发生任何错误，将调用<em>onError</em>。（我自己实际上没有使用过<em>onProgress</em>。）请注意，与纹理一样，加载是异步完成的。</p>
<p>GLTF文件可能相当复杂，可以包含整个3D场景，包含多个对象、灯光和其他东西。<strong><em>GLTFLoader</em></strong>返回的数据包含一个<em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em> <strong><em>Scene</em></strong>。文件中定义的任何对象都将是该场景的场景图的一部分。教科书中使用的所有模型文件都定义了一个<strong><em>Mesh</em></strong>对象，是<strong><em>Scene</em></strong>对象的第一个子对象。此对象带有完整的几何体和材质。onLoad回调函数可以将该对象添加到场景中，可能看起来像这样：</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span><span class="w"> </span><span class="nx">onLoad</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 参数是加载的模型数据</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">object</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">data</span><span class="p">.</span><span class="nx">scene</span><span class="p">.</span><span class="nx">children</span><span class="p">[</span><span class="mf">0</span><span class="p">];</span>
<span class="w">    </span><span class="c1">// 也许修改建模变换或材质...</span>
<span class="w">    </span><span class="nx">scene</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">object</span><span class="p">);</span><span class="w">  </span><span class="c1">// 将加载的对象添加到我们的场景中</span>
<span class="w">    </span><span class="nx">render</span><span class="p">();</span><span class="w">  </span><span class="c1">// 调用render以显示带有新对象的场景</span>
<span class="p">}</span>
</code></pre></div>
<p>示例程序<a href="../../../en/source/threejs/model-viewer.html">threejs/model-viewer.html</a>使用<strong><em>GLTFLoader</em></strong>加载了几个模型。它还使用Collada和OBJ两种其他格式的模型的加载器，工作方式非常相似。实际上，加载模型的技术比我在这里描述的更通用。有关详细信息，请参见示例程序的源代码。</p>
<p>我还要提到，GLTF模型可以包括动画。<em>Three.js</em>有几个支持动画的类，包括<strong><em>THREE.AnimationMixer</em></strong>、<strong><em>THREE.AnimationAction</em></strong>和<strong><em>THREE.AnimationClip</em></strong>。我不会在这里讨论动画，但是这三个类用于在这个演示中动画化马和鹳的模型：</p>
<p><iframe src="../../../en/demos/c5/mesh-animation.html" width="550" height="520"></iframe></p>
</div>
<div class="tabbed-block">
<p>Although it is possible to create mesh objects by listing their vertices and faces, it would be difficult to do it by hand for all but very simple objects. It's much easier, for example, to design an object in an interactive modeling program such as <abbr title="A free and open source 3D modeling and animation program.">Blender</abbr> (<a href="../a2/index.md">Appendix B</a>). Modeling programs like <abbr title="A free and open source 3D modeling and animation program.">Blender</abbr> can export objects using many different file formats. <em>Three.js</em> has utility functions for loading models from files in a variety of file formats. These utilities are not part of the <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em> core, but <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> files that define them can be found in the <em>examples</em> folder in the <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em> download.</p>
<p>The preferred format for model files is <strong><abbr title="GL传输格式。3D模型的文件格式。GLTF文件可以包含完整的3D场景，包括对象、材质、灯光甚至动画。GLTF规范来自Khronos Group，该组织也负责OpenGL、WebGL和Vulkan。">GLTF</abbr></strong>. A <abbr title="GL传输格式。3D模型的文件格式。GLTF文件可以包含完整的3D场景，包括对象、材质、灯光甚至动画。GLTF规范来自Khronos Group，该组织也负责OpenGL、WebGL和Vulkan。">GLTF</abbr> model can be stored in a text file with extension .gltf or in a binary file with extension .glb. Binary files are smaller and more efficient, but not human-readable. A <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em> loader for <abbr title="GL传输格式。3D模型的文件格式。GLTF文件可以包含完整的3D场景，包括对象、材质、灯光甚至动画。GLTF规范来自Khronos Group，该组织也负责OpenGL、WebGL和Vulkan。">GLTF</abbr> files is defined by the class <strong><em>GLTFLoader</em></strong>, which can be imported from the module <em>GLTFLoader.js</em>. from the <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em> download. Copies of that script, as well as scripts for other model loaders, can be found in the <a href="https://math.hws.edu/graphicsbook/source/threejs/script/loaders">threejs/script/loaders</a> folder in the source folder for this textbook, or in the examples/jsm/loaders folder in the <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em> download. (Note that <strong><em>GLTFLoader</em></strong> is not part of the object THREE.)</p>
<p>If <em>loader</em> is an object of type <strong><em>GLTFLoader</em></strong>, you can use its <em>load()</em> method to start the process of loading a model:</p>
<div class="highlight"><pre><span></span><code><span class="nx">loader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">GLTFLoader</span><span class="p">()</span>
<span class="nx">loader</span><span class="p">.</span><span class="nx">load</span><span class="p">(</span><span class="w"> </span><span class="nx">url</span><span class="p">,</span><span class="w"> </span><span class="nx">onLoad</span><span class="p">,</span><span class="w"> </span><span class="nx">onProgress</span><span class="p">,</span><span class="w"> </span><span class="nx">onError</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<p>Only the first parameter is required; it is a <abbr title="Uniform Resource Locator. An address of some resource on the World Wide Web. For example, &quot;&lt;http://math.hws.edu/grahicsbook&gt;&quot;.">URL</abbr> for the file that contains the model. The other three parameters are callback functions: <em>onLoad</em> will be called when the loading is complete, with a parameter that represents the data from the file; <em>onProgress</em> is called periodically during the loading with a parameter that contains information about the size of the model and how much of it has be loaded; and <em>onError</em> is called if any error occurs. (I have not actually used <em>onProgress</em> myself.) Note that, as for textures, the loading is done asynchronously.</p>
<p>A <abbr title="GL传输格式。3D模型的文件格式。GLTF文件可以包含完整的3D场景，包括对象、材质、灯光甚至动画。GLTF规范来自Khronos Group，该组织也负责OpenGL、WebGL和Vulkan。">GLTF</abbr> file can be quite complicated and can contain an entire 3D scene, containing multiple objects, lights, and other things. The data returned by a <strong><em>GLTFLoader</em></strong> contains a <em><abbr title="一个用于3D图形的JavaScript库。该库实现了面向对象的场景图API。虽然它主要用于WebGL，但three.js也可以使用2D画布图形API渲染3D场景。">three.js</abbr></em> <strong><em>Scene</em></strong>. Any objects defined by the file will be part of the <abbr title="A data structure that represents the objects in a scene, together with attributes of the objects and the modeling transformations that are applied to the objects. An image of the scene is created by traversing the scene graph data structure. A scene graph might exist only conceptually, or it might be an actual data structure in a program.">scene graph</abbr> for that scene. All of the model files used in this textbook define a <strong><em>Mesh</em></strong> object that is the first child of the <strong><em>Scene</em></strong> object. This object comes complete with both geometry and <abbr title="The properties of an object that determine how that object interacts with light in the environment. Material properties in OpenGL include, for example, diffuse color, specular color, and shininess.">material</abbr>. The onLoad callback function can add that object to the scene and might look something like this:</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span><span class="w"> </span><span class="nx">onLoad</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// the parameter is the loaded model data</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">object</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">data</span><span class="p">.</span><span class="nx">scene</span><span class="p">.</span><span class="nx">children</span><span class="p">[</span><span class="mf">0</span><span class="p">];</span>
<span class="w">    </span><span class="c1">// maybe modify the modeling transformation or material...</span>
<span class="w">    </span><span class="nx">scene</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">object</span><span class="p">);</span><span class="w">  </span><span class="c1">// add the loaded object to our scene</span>
<span class="w">    </span><span class="nx">render</span><span class="p">();</span><span class="w">  </span><span class="c1">// call render to show the scene with the new object</span>
<span class="p">}</span>
</code></pre></div>
<p>The sample program <a href="../../../en/source/threejs/model-viewer.html">threejs/model-viewer.html</a> uses <strong><em>GLTFLoader</em></strong> to load several models. It also uses loaders for models in two other formats, Collada and OBJ, that work much the same way. The technique for loading the models is actually a little more general that what I've described here. See the source code for the example program for details.</p>
<p>I'll also mention that <abbr title="GL传输格式。3D模型的文件格式。GLTF文件可以包含完整的3D场景，包括对象、材质、灯光甚至动画。GLTF规范来自Khronos Group，该组织也负责OpenGL、WebGL和Vulkan。">GLTF</abbr> models can include animations. <em>Three.js</em> has several classes that support <abbr title="A sequence of images that, when displayed quickly one after the other, will produce the impression of continuous motion or change. The term animation also refers to the process of creating such image sequences.">animation</abbr>, including <strong><em>THREE.AnimationMixer</em></strong>, <strong><em>THREE.AnimationAction</em></strong>, and <strong><em>THREE.AnimationClip</em></strong>. I won't discuss <abbr title="A sequence of images that, when displayed quickly one after the other, will produce the impression of continuous motion or change. The term animation also refers to the process of creating such image sequences.">animation</abbr> here, but these three classes are used to animate the horse and stork models in this demo:</p>
<p><iframe src="../../../en/demos/c5/mesh-animation.html" width="550" height="520"></iframe></p>
</div>
</div>
</div>







  
    
  
  
    
  


  <aside class="md-source-file">
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="最后更新">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1-2.1-2M12.5 7v5.2l4 2.4-1 1L11 13V7h1.5M11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2v1.8Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">2024年6月10日</span>
  </span>

    
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="创建日期">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.47 15.08 11 13V7h1.5v5.25l3.08 1.83c-.41.28-.79.62-1.11 1m-1.39 4.84c-.36.05-.71.08-1.08.08-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8c0 .37-.03.72-.08 1.08.69.1 1.33.32 1.92.64.1-.56.16-1.13.16-1.72 0-5.5-4.5-10-10-10S2 6.5 2 12s4.47 10 10 10c.59 0 1.16-.06 1.72-.16-.32-.59-.54-1.23-.64-1.92M18 15v3h-3v2h3v3h2v-3h3v-2h-3v-3h-2Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">2024年5月26日</span>
  </span>

    
    
    
  </aside>





                
              </article>
            </div>
          
          
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var tab,labels=set.querySelector(".tabbed-labels");for(tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script>

<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../../..", "features": ["content.code.copy", "content.tabs.link", "navigation.tabs", "navigation.tabs.sticky", "navigation.indexes", "navigation.top", "toc.follow", "content.tooltips"], "search": "../../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.3220b9d7.min.js"></script>
      
        <script src="../../../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="https://unpkg.com/mermaid@9.4.0/dist/mermaid.min.js"></script>
      
    
  <script>document$.subscribe(() => {const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});})</script></body>
</html>