
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="计算机图形学概论(graphicsbook)">
      
      
      
        <link rel="canonical" href="https://hellowac.github.io/graphicsbook-zh-cn/cn/c2/s3/">
      
      
        <link rel="prev" href="../s2/">
      
      
        <link rel="next" href="../s4/">
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.5.18">
    
    
      
        <title>第3节: 变换 - 计算机图形学概论</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.66ac8b77.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.06af60db.min.css">
      
      

  
  
  
  
  <style>:root{--md-annotation-icon:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M22 12a10 10 0 0 1-10 10A10 10 0 0 1 2 12 10 10 0 0 1 12 2a10 10 0 0 1 10 10M6 13h8l-3.5 3.5 1.42 1.42L17.84 12l-5.92-5.92L10.5 7.5 14 11H6v2Z"/></svg>');}</style>


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
   <link href="../../../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
        html.glightbox-open { overflow: initial; height: 100%; }
        .gslide-title { margin-top: 0px; user-select: text; }
        .gslide-desc { color: #666; user-select: text; }
        .gslide-image img { background: white; }
        
            .gscrollbar-fixer { padding-right: 15px; }
            .gdesc-inner { font-size: 0.75rem; }
            body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
            body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
            body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}
            </style> <script src="../../../assets/javascripts/glightbox.min.js"></script></head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="default" data-md-color-accent="red">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#第3节-变换" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="计算机图形学概论" class="md-header__button md-logo" aria-label="计算机图形学概论" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            计算机图形学概论
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              第3节: 变换
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
      <div class="md-header__option">
  <div class="md-select">
    
    <button class="md-header__button md-icon" aria-label="选择当前语言">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m12.87 15.07-2.54-2.51.03-.03A17.52 17.52 0 0 0 14.07 6H17V4h-7V2H8v2H1v2h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04M18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12m-2.62 7 1.62-4.33L19.12 17h-3.24Z"/></svg>
    </button>
    <div class="md-select__inner">
      <ul class="md-select__list">
        
          <li class="md-select__item">
            <a href="/graphicsbook-zh-cn/en/" hreflang="en" class="md-select__link">
              English
            </a>
          </li>
        
          <li class="md-select__item">
            <a href="/graphicsbook-zh-cn/cn/" hreflang="cn" class="md-select__link">
              中文
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</div>
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/hellowac/graphicsbook-zh-cn" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    graphicsbook
  </div>
</a>
      </div>
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../" class="md-tabs__link">
        
  
    
  
  首页

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../preface/" class="md-tabs__link">
        
  
    
  
  前言

      </a>
    </li>
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c1/" class="md-tabs__link">
          
  
    
  
  1.简介

        </a>
      </li>
    
  

      
        
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../" class="md-tabs__link">
          
  
    
  
  2.二维图形

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c3/" class="md-tabs__link">
          
  
    
  
  3.几何

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c4/" class="md-tabs__link">
          
  
    
  
  4.灯光和材质

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c5/" class="md-tabs__link">
          
  
    
  
  5.three.js

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c6/" class="md-tabs__link">
          
  
    
  
  6.WebGL

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c7/" class="md-tabs__link">
          
  
    
  
  7.WebGL 3D

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c8/" class="md-tabs__link">
          
  
    
  
  8.高阶3D

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../c9/" class="md-tabs__link">
          
  
    
  
  9.WEBGPU

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../a1/" class="md-tabs__link">
          
  
    
  
  附录

        </a>
      </li>
    
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../.." class="md-tabs__link">
        
  
    
  
  关于

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="计算机图形学概论" class="md-nav__button md-logo" aria-label="计算机图形学概论" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    计算机图形学概论
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/hellowac/graphicsbook-zh-cn" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    graphicsbook
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    首页
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../preface/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    前言
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c1/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    1.简介
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_3" id="__nav_3_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            1.简介
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 1 节 绘画与绘图
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 2 节：三维(3D)图形的要素
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c1/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第 3 节：硬件与软件
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" checked>
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    2.二维图形
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_4" id="__nav_4_label" tabindex="">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            2.二维图形
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第1节: 像素、坐标和颜色
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第2节: 形状
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    第3节: 变换
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    第3节: 变换
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#231--视口和建模" class="md-nav__link">
    <span class="md-ellipsis">
      2.3.1  视口和建模
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#232--平移" class="md-nav__link">
    <span class="md-ellipsis">
      2.3.2  平移
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#233--旋转" class="md-nav__link">
    <span class="md-ellipsis">
      2.3.3  旋转
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#234--组合变换" class="md-nav__link">
    <span class="md-ellipsis">
      2.3.4  组合变换
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#235--缩放" class="md-nav__link">
    <span class="md-ellipsis">
      2.3.5  缩放
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#236--剪切" class="md-nav__link">
    <span class="md-ellipsis">
      2.3.6  剪切
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#237--视窗到视口" class="md-nav__link">
    <span class="md-ellipsis">
      2.3.7  视窗到视口
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#238--矩阵和向量" class="md-nav__link">
    <span class="md-ellipsis">
      2.3.8  矩阵和向量
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第4节: 分层建模
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第5节: Java 绘制2D
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第6节: HTML Canvas图形
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../s7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第7节: SVG：一种场景描述语言
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c3/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    3.几何
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_5" id="__nav_5_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            3.几何
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.1 OpenGL 1.1 中的形状和颜色
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.2 3D 坐标和变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.3 投影与观看
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.4 多边形网格和 glDrawArrays
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.5 部分线性代数基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c3/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.6 使用 GLUT 和 JOGL
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c4/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    4.灯光和材质
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_6" id="__nav_6_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6">
            <span class="md-nav__icon md-icon"></span>
            4.灯光和材质
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.1 照明简介
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.2 OpenGL 1.1 中的光和材质
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.3 图像纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c4/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.4 灯光、相机、动作
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c5/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    5.three.js
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_7" id="__nav_7_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7">
            <span class="md-nav__icon md-icon"></span>
            5.three.js
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.1 Three.js 基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.2 构建对象
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c5/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.3 其他功能
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c6/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    6.WebGL
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_8" id="__nav_8_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8">
            <span class="md-nav__icon md-icon"></span>
            6.WebGL
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.1 可编程流水线
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.2 第一个例子
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.3 GLSL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.4 图像纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c6/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.5 实现 2D 变换
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c7/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    7.WebGL 3D
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_9" id="__nav_9_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9">
            <span class="md-nav__icon md-icon"></span>
            7.WebGL 3D
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.1 3D变换
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.2 照明和材质
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.3 纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.4 帧缓冲区
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c7/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.5 WebGL 扩展
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c8/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    8.高阶3D
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_10" id="__nav_10_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_10_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10">
            <span class="md-nav__icon md-icon"></span>
            8.高阶3D
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c8/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8.1 光线追踪
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c8/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8.2 路径追踪
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_11" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../c9/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    9.WEBGPU
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_11" id="__nav_11_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_11_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_11">
            <span class="md-nav__icon md-icon"></span>
            9.WEBGPU
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.1 WebGPU 基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.2 实例和索引
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.3 WGSL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.4 WebGPU 中的 3D 图形
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.5 纹理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.6 计算着色器
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../c9/s7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.7 细节
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_12" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../a1/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    附录
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_12" id="__nav_12_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_12_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_12">
            <span class="md-nav__icon md-icon"></span>
            附录
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a2/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Blender 3D建模
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../a3/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Gimp和Inkscape
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../source/index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    示例程序源代码
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../glossary/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    术语表
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    关于
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#231--视口和建模" class="md-nav__link">
    <span class="md-ellipsis">
      2.3.1  视口和建模
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#232--平移" class="md-nav__link">
    <span class="md-ellipsis">
      2.3.2  平移
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#233--旋转" class="md-nav__link">
    <span class="md-ellipsis">
      2.3.3  旋转
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#234--组合变换" class="md-nav__link">
    <span class="md-ellipsis">
      2.3.4  组合变换
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#235--缩放" class="md-nav__link">
    <span class="md-ellipsis">
      2.3.5  缩放
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#236--剪切" class="md-nav__link">
    <span class="md-ellipsis">
      2.3.6  剪切
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#237--视窗到视口" class="md-nav__link">
    <span class="md-ellipsis">
      2.3.7  视窗到视口
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#238--矩阵和向量" class="md-nav__link">
    <span class="md-ellipsis">
      2.3.8  矩阵和向量
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="第3节-变换">第3节: 变换<a class="headerlink" href="#第3节-变换" title="Permanent link">&para;</a></h1>
<p><strong>Transforms</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="1:2"><input checked="checked" id="__tabbed_1_1" name="__tabbed_1" type="radio" /><input id="__tabbed_1_2" name="__tabbed_1" type="radio" /><div class="tabbed-labels"><label for="__tabbed_1_1">中文</label><label for="__tabbed_1_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>在<a href="../s1/">第2.1节</a>中，我们讨论了坐标系统以及如何将坐标从一个坐标系统转换为另一个的可能性。在本节中，我们将更仔细地探讨这个想法，并且还将看看几何变换如何用于将图形对象放置到一个坐标系统中。</p>
</div>
<div class="tabbed-block">
<p>In <a href="../s1/">Section 2.1</a>, we discussed <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate systems</abbr> and how it is possible to transform coordinates from one <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr> to another. In this section, we'll look at that idea a little more closely, and also look at how geometric transformations can be used to place graphics objects into a <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr>.</p>
</div>
</div>
</div>
<h2 id="231--视口和建模">2.3.1  视口和建模<a class="headerlink" href="#231--视口和建模" title="Permanent link">&para;</a></h2>
<p><strong>Viewing and Modeling</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="2:2"><input checked="checked" id="__tabbed_2_1" name="__tabbed_2" type="radio" /><input id="__tabbed_2_2" name="__tabbed_2" type="radio" /><div class="tabbed-labels"><label for="__tabbed_2_1">中文</label><label for="__tabbed_2_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>在典型的应用中，我们有一个由像素构成的矩形，其自然像素坐标用于显示图像。这个矩形称为<strong><abbr title="2D或3D图形显示图像的矩形区域。视口上的坐标是像素坐标，更确切地称为设备坐标，因为它们是图像显示的实际物理坐标。">视口</abbr>(<abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr>)</strong>。我们还有一组几何对象，这些对象在可能不同的坐标系中定义，通常是使用实数坐标而不是整数。这些对象组成了我们想要查看的“场景”或“世界”，用于定义场景的坐标称为<strong><abbr title="定义场景的坐标系统。生成的场景图像将显示位于某个视图体积（对于3D）或视图窗口（对于2D）内的世界坐标系统中的内容。对象在其自己的对象坐标系统中定义。然后应用建模变换将对象放置到场景中，即将对象坐标转换为世界坐标。">世界坐标</abbr>(<abbr title="The coordinate system in which a scene is defined. The image that is produced of the scene will show the contents of the world coordinate system that lie within some view volume (for 3D) or view window (for 2D). Objects are defined in their own object coordinate system. Modeling transformations are then applied to place objects into the scene; that is, they transform object coordinates to world coordinates.">world coordinates</abbr>)</strong>。</p>
<p>对于二维图形，世界位于一个平面上。不可能显示整个无限平面的图像。我们需要在平面上选择一些矩形区域来显示在图像中。让我们称这个矩形区域为窗口，或称为<strong><abbr title="在本书中,2D图形的窗口或视图窗口是包含将在图像中显示的平面部分的xy平面中的矩形。(在3D图形中,对应的术语是&quot;视图体积&quot;。)">视窗</abbr>(window)</strong>。坐标变换用于将窗口映射到视口中。</p>
<p><figure markdown="span">
    <a class="glightbox" href="../../../en/c2/coordinate-transformation-2d.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="pixel-coordinates" src="../../../en/c2/coordinate-transformation-2d.png" /></a>
</figure></p>
<p>在这个图示中，<strong>T</strong>代表坐标变换。<strong>T</strong>是一个函数，它接受窗口中的世界坐标(x,y)并将它们映射到视口中的像素坐标<strong>T</strong>(x,y)。在这个例子中，你可以检查到：</p>
<div class="highlight"><pre><span></span><code>T(x,y) = ( 800*(x+4)/8, 600*(3-y)/6 )
</code></pre></div>
<p>看一下窗口中角落坐标为(-1,2)和(3,-1)的矩形。当这个矩形在视口中显示时，它将显示为具有角落<strong>T</strong>(-1,2)和<strong>T</strong>(3,-1)的矩形。在这个例子中，<strong>T</strong>(-1,2) = (300,100) 以及 <strong>T</strong>(3,-1) = (700,400)。</p>
<p>我们以这种方式使用坐标变换是因为它允许我们选择一个对于描述我们想要显示的场景而言是自然的世界坐标系，而这比直接使用视口坐标更容易。沿着同样的思路，假设我们想要定义一些复杂的对象，并假设在我们的场景中会有几个该对象的副本。或者也许我们正在制作一个动画，并且希望该对象在不同帧中有不同的位置。我们希望选择一些方便的坐标系，并将其用于一劳永逸地定义对象。我们用于定义对象的坐标称为该对象的<strong><abbr title="对象中的点的坐标最初在其中指定的坐标系统，然后通过应用于对象的任何建模或其他变换来转换这些坐标。">对象坐标</abbr>(<abbr title="The coordinate system in which the coordinates for points in an object are originally specified, before they are transformed by any modeling or other transform that will be applied to the object.">object coordinates</abbr>)</strong>。当我们想要将对象放置到场景中时，我们需要将用于定义对象的对象坐标转换为我们用于场景的世界坐标系。我们需要的转换称为<strong><abbr title="应用于对象以将该对象映射到世界坐标系统或更复杂的分层对象的对象坐标系统的变换。">建模变换</abbr>(<abbr title="A transformation that is applied to an object to map that object into the world coordinate system or into the object coordinate system for a more complex, hierarchical object.">modeling transformation</abbr>)</strong>。这张图片说明了一个在其自己的对象坐标系中定义的对象，然后通过三种不同的建模变换映射到世界坐标系中：</p>
<p><figure markdown="span">
    <a class="glightbox" href="../../../en/c2/modeling2d-1.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="pixel-coordinates" src="../../../en/c2/modeling2d-1.png" /></a>
</figure></p>
<p>记住，为了查看场景，还会有另一个转换，将对象从世界坐标中的视窗映射到视口中。</p>
<p>现在，请记住，视窗的选择决定了图像中显示场景的哪一部分。移动、调整大小，甚至旋转窗口都会给场景带来不同的视图。假设我们制作了几张同一辆汽车的图片：</p>
<p><figure markdown="span">
    <a class="glightbox" href="../../../en/c2/modeling-or-viewing-2d.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="pixel-coordinates" src="../../../en/c2/modeling-or-viewing-2d.png" /></a>
</figure></p>
<p>这张图片上部的图像和左下角的图像之间发生了什么？实际上，有两种可能性：要么汽车向右移动，要么定义场景的视窗向左移动。这一点很重要，请确保你理解了它。（试试用你的手机相机。把它对准一些物体，向左走一步，注意一下相机取景器中的物体会发生什么变化：它们在照片中向右移动！）同样，在顶部图片和底部中间的图片之间会发生什么？要么汽车逆时针旋转，要么窗口顺时针旋转。（再次尝试使用相机——你可能想拍两张实际照片以便比较。）最后，从顶部图片到右下角的图片的变化可能是因为汽车变小了，也可能是因为窗口变大了。（在你的相机上，更大的窗口意味着你看到了更大的视野，你可以通过给相机加上变焦或者从你正在观看的物体后退来实现这一点。）</p>
<p>这里有一个重要的总体概念。当我们修改视窗时，我们改变了应用于视口的坐标系统。但实际上，这等同于保持该坐标系统不变，而是移动场景中的对象。不过，为了在最终图像中获得相同的效果，您必须对对象应用相反的变换（例如，向左移动窗口等同于将对象向右移动）。因此，在转换窗口和转换对象之间并没有本质区别。在数学上，您通过在某个自然坐标系统中给出坐标来指定几何基元，计算机会对这些坐标应用一系列变换，最终产生用于在图像中实际绘制基元的坐标。您会认为其中一些变换是建模变换，一些是坐标变换，但对于计算机来说，这都是一样的。</p>
<p>这里有一个实时演示，可以帮助您理解建模变换和视口变换之间的等价性。滑块控制应用于图片中对象的变换。在演示的底部部分，您可以看到一个较大的视图，其中上部图像的视口被表示为半透明的黑色矩形。阅读演示中的帮助文本以获取更多信息。</p>
<p><iframe src="../../../en/demos/c2/transform-equivalence-2d.html" width="700" height="750"></iframe></p>
<p>我们稍后会在书中多次回到这个概念，但无论如何，您可以看到几何变换是计算机图形学中的一个核心概念。让我们更详细地看看一些基本类型的变换。我们在二维图形中将使用的变换可以写成如下形式：</p>
<div class="highlight"><pre><span></span><code>x1 = a*x + b*y + e
y1 = c*x + d*y + f
</code></pre></div>
<p>其中 (x,y) 表示变换应用前的某一点的坐标，(x1,y1) 是变换后的坐标。这个变换由六个常数 a、b、c、d、e 和 f 定义。注意，这可以写成一个函数 <strong>T</strong>，其中</p>
<div class="highlight"><pre><span></span><code>T(x,y) = ( a*x + b*y + e, c*x + d*y + f )
</code></pre></div>
<p>这种形式的变换称为<strong><abbr title="保持平行线的变换。也就是说，当变换应用于一对平行线时，结果变换后的线也是平行的。仿射变换T具有以下特性：点(x1,y1)和点(x2,y2)之间的线段的变换是点T(x1,y1)和点T(x2,y2)之间的线段。实际上，可以通过仅变换线段的两个端点来计算线段的变换。这使得仿射变换在计算机图形中非常高效。任何仿射变换都可以表示为旋转、平移和缩放的组合。">仿射变换</abbr></strong>。仿射变换具有以下性质：当它应用于两条平行线时，变换后的线也将是平行的。此外，如果将一个仿射变换跟随另一个仿射变换，结果仍然是一个仿射变换。</p>
</div>
<div class="tabbed-block">
<p>In a typical application, we have a rectangle made of <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr>, with its natural <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> coordinates, where an image will be displayed. This rectangle will be called the <strong><abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr></strong>. We also have a set of geometric objects that are defined in a possibly different <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr>, generally one that uses real-number coordinates rather than integers. These objects make up the "scene" or "world" that we want to view, and the coordinates that we use to define the scene are called <strong><abbr title="The coordinate system in which a scene is defined. The image that is produced of the scene will show the contents of the world coordinate system that lie within some view volume (for 3D) or view window (for 2D). Objects are defined in their own object coordinate system. Modeling transformations are then applied to place objects into the scene; that is, they transform object coordinates to world coordinates.">world coordinates</abbr></strong>.</p>
<p>For 2D graphics, the world lies in a plane. It's not possible to show a picture of the entire infinite plane. We need to pick some rectangular area in the plane to display in the image. Let's call that rectangular area the window, or view <strong>window</strong>. A coordinate transform is used to map the window to the <abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr>.</p>
<p><figure markdown="span">
    <a class="glightbox" href="../../../en/c2/coordinate-transformation-2d.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="pixel-coordinates" src="../../../en/c2/coordinate-transformation-2d.png" /></a>
</figure></p>
<p>In this illustration, <strong>T</strong> represents the coordinate transformation. <strong>T</strong> is a function that takes <abbr title="The coordinate system in which a scene is defined. The image that is produced of the scene will show the contents of the world coordinate system that lie within some view volume (for 3D) or view window (for 2D). Objects are defined in their own object coordinate system. Modeling transformations are then applied to place objects into the scene; that is, they transform object coordinates to world coordinates.">world coordinates</abbr> (x,y) in some window and maps them to <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> coordinates <strong>T</strong>(x,y) in the <abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr>. (I've drawn the <abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr> and window with different sizes to emphasize that they are not the same thing, even though they show the same objects, but in fact they don't even exist in the same space, so it doesn't really make sense to compare their sizes.) In this example, as you can check,</p>
<div class="highlight"><pre><span></span><code>T(x,y) = ( 800*(x+4)/8, 600*(3-y)/6 )
</code></pre></div>
<p>Look at the rectangle with corners at (-1,2) and (3,-1) in the window. When this rectangle is displayed in the <abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr>, it is displayed as the rectangle with corners <strong>T</strong>(-1,2) and <strong>T</strong>(3,-1). In this example, <strong>T</strong>(-1,2) = (300,100) and <strong>T</strong>(3,-1) = (700,400).</p>
<p>We use coordinate transformations in this way because it allows us to choose a world <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr> that is natural for describing the scene that we want to display, and it is easier to do that than to work directly with <abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr> coordinates. Along the same lines, suppose that we want to define some complex object, and suppose that there will be several copies of that object in our scene. Or maybe we are making an <abbr title="A sequence of images that, when displayed quickly one after the other, will produce the impression of continuous motion or change. The term animation also refers to the process of creating such image sequences.">animation</abbr>, and we would like the object to have different positions in different frames. We would like to choose some convenient <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr> and use it to define the object once and for all. The coordinates that we use to define an object are called <abbr title="The coordinate system in which the coordinates for points in an object are originally specified, before they are transformed by any modeling or other transform that will be applied to the object.">object coordinates</abbr> for the object. When we want to place the object into a scene, we need to transform the <abbr title="The coordinate system in which the coordinates for points in an object are originally specified, before they are transformed by any modeling or other transform that will be applied to the object.">object coordinates</abbr> that we used to define the object into the world <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr> that we are using for the scene. The transformation that we need is called a <abbr title="A transformation that is applied to an object to map that object into the world coordinate system or into the object coordinate system for a more complex, hierarchical object.">modeling transformation</abbr>. This picture illustrates an object defined in its own object <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr> and then mapped by three different modeling transformations into the world <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr>:</p>
<p><figure markdown="span">
    <a class="glightbox" href="../../../en/c2/modeling2d-1.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="pixel-coordinates" src="../../../en/c2/modeling2d-1.png" /></a>
</figure></p>
<p>Remember that in order to view the scene, there will be another transformation that maps the object from a <abbr title="As used in this book, the window, or view window, for 2D graphics is the rectangle in the xy-plane that contains the portion of the plane that will be displayed in the image. (The corresponding term in 3D graphics is &quot;view volume.&quot;)">view window</abbr> in <abbr title="The coordinate system in which a scene is defined. The image that is produced of the scene will show the contents of the world coordinate system that lie within some view volume (for 3D) or view window (for 2D). Objects are defined in their own object coordinate system. Modeling transformations are then applied to place objects into the scene; that is, they transform object coordinates to world coordinates.">world coordinates</abbr> into the <abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr>.</p>
<p>Now, keep in mind that the choice of a <abbr title="As used in this book, the window, or view window, for 2D graphics is the rectangle in the xy-plane that contains the portion of the plane that will be displayed in the image. (The corresponding term in 3D graphics is &quot;view volume.&quot;)">view window</abbr> tells which part of the scene is shown in the image. Moving, resizing, or even rotating the window will give a different view of the scene. Suppose we make several images of the same car:</p>
<p><figure markdown="span">
    <a class="glightbox" href="../../../en/c2/modeling-or-viewing-2d.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="pixel-coordinates" src="../../../en/c2/modeling-or-viewing-2d.png" /></a>
</figure></p>
<p>What happened between making the top image in this illustration and making the image on the bottom left? In fact, there are two possibilities: Either the car was moved to the right, or the <abbr title="As used in this book, the window, or view window, for 2D graphics is the rectangle in the xy-plane that contains the portion of the plane that will be displayed in the image. (The corresponding term in 3D graphics is &quot;view volume.&quot;)">view window</abbr> that defines the scene was moved to the left. This is important, so be sure you understand it. (Try it with your cell phone <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>. Aim it at some objects, take a step to the left, and notice what happens to the objects in the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>'s viewfinder: They move to the right in the picture!) Similarly, what happens between the top picture and the middle picture on the bottom? Either the car rotated counterclockwise, or the window was rotated clockwise. (Again, try it with a <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>—you might want to take two actual photos so that you can compare them.) Finally, the change from the top picture to the one on the bottom right could happen because the car got smaller or because the window got larger. (On your <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr>, a bigger window means that you are seeing a larger field of view, and you can get that by applying a zoom to the <abbr title="In 3D computer graphics, an object that combines the projection and viewing transforms into an abstraction that imitates a physical camera or eye.">camera</abbr> or by backing up away from the objects that you are <abbr title="Setting the position and orientation of the viewer in a 3D world, which determine what will be visible when the 2D image of a 3D world is rendered.">viewing</abbr>.)</p>
<p>There is an important general idea here. When we modify the <abbr title="As used in this book, the window, or view window, for 2D graphics is the rectangle in the xy-plane that contains the portion of the plane that will be displayed in the image. (The corresponding term in 3D graphics is &quot;view volume.&quot;)">view window</abbr>, we change the <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr> that is applied to the <abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr>. But in fact, this is the same as leaving that <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr> in place and moving the objects in the scene instead. Except that to get the same effect in the final image, you have to apply the opposite transformation to the objects (for example, moving the window to the left is equivalent to moving the objects to the right). So, there is no essential distinction between transforming the window and transforming the object. Mathematically, you specify a <abbr title="Geometric objects in a graphics system, such as OpenGL, that are not made up of simpler objects. Examples in OpenGL include points, lines, and triangles, but the set of available primitives depends on the graphics system. (Note that as the term is used in OpenGL, a single primitive can be made up of many points, line segments, or triangles.)">geometric primitive</abbr> by giving coordinates in some natural <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr>, and the computer applies a sequence of transformations to those coordinates to produce, in the end, the coordinates that are used to actually draw the primitive in the image. You will think of some of those transformations as modeling transforms and some as coordinate transforms, but to the computer, it's all the same.</p>
<p>Here is a live demo that can help you to understand the equivalence between modeling transformations and <abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr> transformations. The sliders control transformations that are applied to the objects in the picture. In the lower section of the demo, you see a larger view in which the <abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr> for the upper image is represented as a translucent black rectangle. Read the help text in the demo for more information.</p>
<p><iframe src="../../../en/demos/c2/transform-equivalence-2d.html" width="700" height="750"></iframe></p>
<p>We will return to this idea several times later in the book, but in any case, you can see that geometric transforms are a central concept in computer graphics. Let's look at some basic types of transformation in more detail. The transforms we will use in 2D graphics can be written in the form</p>
<div class="highlight"><pre><span></span><code>x1 = a*x + b*y + e
y1 = c*x + d*y + f
</code></pre></div>
<p>where (x,y) represents the coordinates of some point before the transformation is applied, and (x1,y1) are the transformed coordinates. The transform is defined by the six constants a, b, c, d, e, and f. Note that this can be written as a function <strong>T</strong>, where</p>
<div class="highlight"><pre><span></span><code>T(x,y) = ( a*x + b*y + e, c*x + d*y + f )
</code></pre></div>
<p>A transformation of this form is called an <strong><abbr title="A transform that preserves parallel lines. That is, when the transform is applied to a pair of lines that are parallel, then the resulting transformed lines are also parallel. An affine transform, T, has the property that the transform of the line segment between a point (x1,y1) and a point (x2,y2) is the line between the points T(x1,y1) and T(x2,y2). Effectively, the transform of a line segment can be computed just by transforming its two endpoints. This makes affine transforms very efficient for computer graphics. Any affine transform can be represented as a composition of rotations, translations, and scalings.">affine transform</abbr></strong>. An <abbr title="A transform that preserves parallel lines. That is, when the transform is applied to a pair of lines that are parallel, then the resulting transformed lines are also parallel. An affine transform, T, has the property that the transform of the line segment between a point (x1,y1) and a point (x2,y2) is the line between the points T(x1,y1) and T(x2,y2). Effectively, the transform of a line segment can be computed just by transforming its two endpoints. This makes affine transforms very efficient for computer graphics. Any affine transform can be represented as a composition of rotations, translations, and scalings.">affine transform</abbr> has the property that, when it is applied to two parallel lines, the transformed lines will also be parallel. Also, if you follow one <abbr title="A transform that preserves parallel lines. That is, when the transform is applied to a pair of lines that are parallel, then the resulting transformed lines are also parallel. An affine transform, T, has the property that the transform of the line segment between a point (x1,y1) and a point (x2,y2) is the line between the points T(x1,y1) and T(x2,y2). Effectively, the transform of a line segment can be computed just by transforming its two endpoints. This makes affine transforms very efficient for computer graphics. Any affine transform can be represented as a composition of rotations, translations, and scalings.">affine transform</abbr> by another <abbr title="A transform that preserves parallel lines. That is, when the transform is applied to a pair of lines that are parallel, then the resulting transformed lines are also parallel. An affine transform, T, has the property that the transform of the line segment between a point (x1,y1) and a point (x2,y2) is the line between the points T(x1,y1) and T(x2,y2). Effectively, the transform of a line segment can be computed just by transforming its two endpoints. This makes affine transforms very efficient for computer graphics. Any affine transform can be represented as a composition of rotations, translations, and scalings.">affine transform</abbr>, the result is again an <abbr title="A transform that preserves parallel lines. That is, when the transform is applied to a pair of lines that are parallel, then the resulting transformed lines are also parallel. An affine transform, T, has the property that the transform of the line segment between a point (x1,y1) and a point (x2,y2) is the line between the points T(x1,y1) and T(x2,y2). Effectively, the transform of a line segment can be computed just by transforming its two endpoints. This makes affine transforms very efficient for computer graphics. Any affine transform can be represented as a composition of rotations, translations, and scalings.">affine transform</abbr>.</p>
</div>
</div>
</div>
<h2 id="232--平移">2.3.2  <abbr title="一种几何变换，它将点的每个坐标添加给定的平移量。平移用于移动对象而不改变其大小或方向。">平移</abbr><a class="headerlink" href="#232--平移" title="Permanent link">&para;</a></h2>
<p><strong>Translation</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="3:2"><input checked="checked" id="__tabbed_3_1" name="__tabbed_3" type="radio" /><input id="__tabbed_3_2" name="__tabbed_3" type="radio" /><div class="tabbed-labels"><label for="__tabbed_3_1">中文</label><label for="__tabbed_3_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>平移变换简单地将每个点水平移动一定量，垂直移动一定量。如果 (x,y) 是原始点，(x1,y1) 是变换后的点，那么平移的公式为</p>
<div class="highlight"><pre><span></span><code>x1 = x + e
y1 = y + f
</code></pre></div>
<p>其中 e 是点水平移动的单位数，f 是垂直移动的单位数。（因此，对于平移，仿射变换的一般公式中 a = d = 1，b = c = 0。）一个二维图形系统通常会有一个类似于</p>
<div class="highlight"><pre><span></span><code>translate( e, f )
</code></pre></div>
<p>的函数来应用平移变换。平移将应用于在给出命令后绘制的所有内容。也就是说，对于所有后续的绘图操作，e 将被添加到 x <abbr title="一种将数值坐标分配给几何点的方法。在二维中，每个点对应一对数字。在三维中，每个点对应一组三个数字。">坐标</abbr>，f 将被添加到 y <abbr title="一种将数值坐标分配给几何点的方法。在二维中，每个点对应一对数字。在三维中，每个点对应一组三个数字。">坐标</abbr>。让我们看一个例子。假设你使用以 (0,0) 为中心的坐标绘制一个“F”。如果在绘制“F”之前说 translate(4,2)，那么在实际使用坐标之前，“F”的每个点都将水平移动 4 个单位，垂直移动 2 个单位，因此在平移之后，“F”将位于 (4,2)：</p>
<p><figure markdown="span">
    <a class="glightbox" href="../../../en/c2/translate-2d.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="pixel-coordinates" src="../../../en/c2/translate-2d.png" /></a>
</figure></p>
<p>这张图片中浅灰色的“F”显示了在没有平移的情况下会绘制什么；深红色的“F”显示了应用了平移 (4,2) 后绘制的相同的“F”。顶部的箭头显示了“F”的左上角已向右移动 4 个单位，向上移动 2 个单位。在“F”中的每个点都受到相同的位移影响。请注意，在我的例子中，我假设 y 坐标从下到上递增。也就是说，y 轴朝上。</p>
<p>记住，当你给出 translate(e,f) 命令时，这个平移将应用于之后所有的绘图，而不仅仅是下一个你绘制的形状。如果你在平移后应用另一个变换，第二个变换不会取代平移，而是与平移结合起来，从而后续的绘图将受到组合变换的影响。例如，如果你将 translate(4,2) 与 translate(-1,5) 组合，结果与单个平移 translate(3,7) 相同。这是一个重要的观点，稍后将会有更多内容介绍。</p>
<p>还要记住，你不需要自己计算坐标变换。你只需要为对象指定原始坐标（即对象坐标），并指定要应用的变换或变换。计算机会负责将变换应用于坐标。你甚至不需要知道用于变换的方程式；你只需要理解它在几何上做了什么。</p>
</div>
<div class="tabbed-block">
<p>A <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr> transform simply moves every point by a certain amount horizontally and a certain amount vertically. If (x,y) is the original point and (x1,y1) is the transformed point, then the formula for a <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr> is</p>
<div class="highlight"><pre><span></span><code>x1 = x + e
y1 = y + f
‵‵‵

where e is the number of units by which the point is moved horizontally and f is the amount by which it is moved vertically. (Thus for a translation, a = d = 1, and b = c = 0 in the general formula for an affine transform.) A 2D graphics system will typically have a function such as

```text
translate( e, f )
</code></pre></div>
<p>to apply a translate transformation. The <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr> would apply to everything that is drawn after the command is given. That is, for all subsequent drawing operations, e would be added to the x-coordinate and f would be added to the y-coordinate. Let's look at an example. Suppose that you draw an "F" using coordinates in which the "F" is centered at (0,0). If you say translate(4,2) before drawing the "F", then every point of the "F" will be moved horizontally by 4 units and vertically by 2 units before the coordinates are actually used, so that after the <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr>, the "F" will be centered at (4,2):</p>
<p><figure markdown="span">
    <a class="glightbox" href="../../../en/c2/translate-2d.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="pixel-coordinates" src="../../../en/c2/translate-2d.png" /></a>
</figure></p>
<p>The light gray "F" in this picture shows what would be drawn without the <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr>; the dark red "F" shows the same "F" drawn after applying a <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr> by (4,2). The top arrow shows that the upper left corner of the "F" has been moved over 4 units and up 2 units. Every point in the "F" is subjected to the same displacement. Note that in my examples, I am assuming that the y-coordinate increases from bottom to top. That is, the y-axis points up.</p>
<p>Remember that when you give the command translate(e,f), the <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr> applies to all the drawing that you do after that, not just to the next shape that you draw. If you apply another transformation after the <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr>, the second transform will not replace the <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr>. It will be combined with the <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr>, so that subsequent drawing will be affected by the combined transformation. For example, if you combine translate(4,2) with translate(-1,5), the result is the same as a single <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr>, translate(3,7). This is an important point, and there will be a lot more to say about it later.</p>
<p>Also remember that you don't compute coordinate transformations yourself. You just specify the original coordinates for the object (that is, the <abbr title="The coordinate system in which the coordinates for points in an object are originally specified, before they are transformed by any modeling or other transform that will be applied to the object.">object coordinates</abbr>), and you specify the transform or transforms that are to be applied. The computer takes care of applying the transformation to the coordinates. You don't even need to know the equations that are used for the transformation; you just need to understand what it does geometrically.</p>
</div>
</div>
</div>
<h2 id="233--旋转">2.3.3  <abbr title="一种几何变换，它围绕某个点（在2D中）或轴（在3D中）旋转每个点到指定角度。">旋转</abbr><a class="headerlink" href="#233--旋转" title="Permanent link">&para;</a></h2>
<p><strong>Rotation</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="4:2"><input checked="checked" id="__tabbed_4_1" name="__tabbed_4" type="radio" /><input id="__tabbed_4_2" name="__tabbed_4" type="radio" /><div class="tabbed-labels"><label for="__tabbed_4_1">中文</label><label for="__tabbed_4_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>在我们这里的情况下，旋转变换会围绕原点 (0,0) 旋转每个点。每个点都被旋转相同的角度，称为旋转角度。为此，角度可以用度或弧度来度量。（我们稍后将在本章中查看的 Java 和 <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> 的 2D 图形 <abbr title="Application Programming Interface. A collection of related classes, functions, constants, etc., for performing some task. An API is an &quot;interface&quot; in the sense that it can be used without understanding how its functionality is actually implemented.">API</abbr> 使用弧度，但 <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> 和 <abbr title="可缩放矢量图形。一种用于指定2D矢量图形的XML语言。SVG是一种场景描述语言。它旨在集成到网页中。">SVG</abbr> 使用度。）具有正角度的旋转会将对象顺时针旋转从正 x 轴指向正 y 轴的方向。在这里的示例中，坐标系中 y 轴向上，这是逆时针旋转，但在通常的像素坐标中，y 轴向下而不是向上，所以这是顺时针旋转。虽然不明显，但是当对点 (x,y) 应用以 r 弧度为角度的绕原点旋转时，结果点 (x1,y1) 由以下公式给出：</p>
<div class="highlight"><pre><span></span><code>x1 = cos(r) * x - sin(r) * y
y1 = sin(r) * x + cos(r) * y
</code></pre></div>
<p>也就是说，在仿射变换的一般公式中，e = f = 0，a = d = cos(r)，b = -sin(r)，c = sin(r)。这里有一个图示，说明了绕原点旋转负 135 度的角度：</p>
<p><figure markdown="span">
    <a class="glightbox" href="../../../en/c2/translate-2d.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="pixel-coordinates" src="../../../en/c2/translate-2d.png" /></a>
</figure></p>
<p>再次，浅灰色的“F”是原始形状，深红色的“F”是应用旋转后的形状。箭头显示了原始“F”的左上角是如何移动的。</p>
<p>一个 2D 图形 <abbr title="Application Programming Interface. A collection of related classes, functions, constants, etc., for performing some task. An API is an &quot;interface&quot; in the sense that it can be used without understanding how its functionality is actually implemented.">API</abbr> 通常会有一个 rotate(r) 命令来应用旋转。这个命令在绘制应用旋转的对象之前使用。</p>
</div>
<div class="tabbed-block">
<p>A <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> transform, for our purposes here, rotates each point about the origin, (0,0). Every point is rotated through the same angle, called the angle of <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr>. For this purpose, angles can be measured either in degrees or in radians. (The 2D graphics APIs for Java and <abbr title="A programming language for web pages. JavaScript code on a web page is executed by a web browser that displays the page, and it can interact with the contents of the web page and with the user. There are JavaScript APIs for 2D and for 3D graphics">JavaScript</abbr> that we will look at later in this chapter use radians, but <abbr title="A family of computer graphics APIs that is implemented in many graphics hardware devices. There are several versions of the API, and there are implementations, or &quot;bindings&quot; for several different programming languages. Versions of OpenGL for embedded systems such as mobile phones are known as OpenGL ES. WebGL is a version for use on Web pages. OpenGL can be used for 2D as well as for 3D graphics, but it is most commonly associated with 3D.">OpenGL</abbr> and <abbr title="可缩放矢量图形。一种用于指定2D矢量图形的XML语言。SVG是一种场景描述语言。它旨在集成到网页中。">SVG</abbr> use degrees.) A <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> with a positive angle rotates objects in the direction from the positive x-axis towards the positive y-axis. This is counterclockwise in a <abbr title="A way of assigning numerical coordinates to geometric points. In two dimensions, each point corresponds to a pair of numbers. In three dimensions, each point corresponds to a triple of numbers.">coordinate system</abbr> where the y-axis points up, as it does in my examples here, but it is clockwise in the usual <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> coordinates, where the y-axis points down rather than up. Although it is not obvious, when <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> through an angle of r radians about the origin is applied to the point (x,y), then the resulting point (x1,y1) is given by</p>
<p>```text
x1 = cos(r) * x - sin(r) * y
y1 = sin(r) * x + cos(r) * y
‵‵‵</p>
<p>That is, in the general formula for an <abbr title="A transform that preserves parallel lines. That is, when the transform is applied to a pair of lines that are parallel, then the resulting transformed lines are also parallel. An affine transform, T, has the property that the transform of the line segment between a point (x1,y1) and a point (x2,y2) is the line between the points T(x1,y1) and T(x2,y2). Effectively, the transform of a line segment can be computed just by transforming its two endpoints. This makes affine transforms very efficient for computer graphics. Any affine transform can be represented as a composition of rotations, translations, and scalings.">affine transform</abbr>, e = f = 0, a = d = cos(r), b = -sin(r), and c = sin(r). Here is a picture that illustrates a <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> about the origin by the angle negative 135 degrees:</p>
<p><figure markdown="span">
    <a class="glightbox" href="../../../en/c2/translate-2d.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="pixel-coordinates" src="../../../en/c2/translate-2d.png" /></a>
</figure></p>
<p>Again, the light gray "F" is the original shape, and the dark red "F" is the shape that results if you apply the <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr>. The arrow shows how the upper left corner of the original "F" has been moved.</p>
<p>A 2D graphics <abbr title="Application Programming Interface. A collection of related classes, functions, constants, etc., for performing some task. An API is an &quot;interface&quot; in the sense that it can be used without understanding how its functionality is actually implemented.">API</abbr> would typically have a command rotate(r) to apply a <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr>. The command is used before drawing the objects to which the <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> applies.</p>
</div>
</div>
</div>
<h2 id="234--组合变换">2.3.4  组合变换<a class="headerlink" href="#234--组合变换" title="Permanent link">&para;</a></h2>
<p><strong>Combining Transformations</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="5:2"><input checked="checked" id="__tabbed_5_1" name="__tabbed_5" type="radio" /><input id="__tabbed_5_2" name="__tabbed_5" type="radio" /><div class="tabbed-labels"><label for="__tabbed_5_1">中文</label><label for="__tabbed_5_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>现在我们可以看到当你组合两个变换时会发生什么。假设在绘制某个对象之前，你说：</p>
<div class="highlight"><pre><span></span><code>translate(4,0)
rotate(90)
</code></pre></div>
<p>假设角度是以度为单位测量的。然后平移将应用于所有后续的绘制。但是，由于旋转命令，你在平移之后绘制的东西是旋转的对象。也就是说，平移应用于已经旋转过的对象。下图的左侧是一个例子，在这个例子中，浅灰色的“F”是原始形状，红色的“F”显示了将这两个变换应用于原始形状的结果。原始“F”首先被旋转了90度角度，然后向右移动了4个单位。</p>
<p><figure markdown="span">
    <a class="glightbox" href="../../../en/c2/rotate-and-translate-2d.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="pixel-coordinates" src="../../../en/c2/rotate-and-translate-2d.png" /></a>
</figure></p>
<p>请注意，变换是以与代码中给出的顺序相反的顺序应用于对象的（因为代码中的第一个变换是应用于已经受到第二个变换影响的对象）。还请注意，应用变换的顺序很重要。如果我们在这个例子中颠倒两个变换的应用顺序，通过以下方式：</p>
<div class="highlight"><pre><span></span><code>rotate(90)
translate(4,0)
</code></pre></div>
<p>那么结果就如上图右侧所示。在那张图片中，原始“F”首先向右移动4个单位，然后通过原点旋转90度角度，以得到实际显示在屏幕上的形状。</p>
<p>对于另一个应用多个变换的例子，假设我们想要围绕点 (p,q) 而不是围绕点 (0,0) 将一个形状旋转 r 角度。我们可以通过首先将点 (p,q) 移动到原点，使用 translate(-p,-q) 来实现这一点。然后我们可以调用 rotate(r) 进行围绕原点的标准旋转。最后，我们可以通过应用 translate(p,q) 将原点移回点 (p,q)。记住我们必须以相反的顺序编写变换的代码，我们需要在绘制形状之前说：</p>
<div class="highlight"><pre><span></span><code>translate(p,q)
rotate(r)
translate(-p,-q)
</code></pre></div>
<p>（事实上，一些图形 <abbr title="Application Programming Interface. A collection of related classes, functions, constants, etc., for performing some task. An API is an &quot;interface&quot; in the sense that it can be used without understanding how its functionality is actually implemented.">API</abbr> 允许我们使用单个命令来实现这个变换，例如 rotate(r,p,q)。这将在点 (p,q) 处围绕角度 r 进行旋转。）</p>
</div>
<div class="tabbed-block">
<p>We are now in a position to see what can happen when you combine two transformations. Suppose that before drawing some object, you say</p>
<div class="highlight"><pre><span></span><code>translate(4,0)
rotate(90)
‵‵‵

Assume that angles are measured in degrees. The translation will then apply to all subsequent drawing. But, because of the rotation command, the things that you draw after the translation are rotated objects. That is, the translation applies to objects that have already been rotated. An example is shown on the left in the illustration below, where the light gray &quot;F&quot; is the original shape, and red &quot;F&quot; shows the result of applying the two transforms to the original. The original &quot;F&quot; was first rotated through a 90 degree angle, and then moved 4 units to the right.

&lt;figure markdown=&quot;span&quot;&gt;
    ![pixel-coordinates](../../en/c2/rotate-and-translate-2d.png)
&lt;/figure&gt;

Note that transforms are applied to objects in the reverse of the order in which they are given in the code (because the first transform in the code is applied to an object that has already been affected by the second transform). And note that the order in which the transforms are applied is important. If we reverse the order in which the two transforms are applied in this example, by saying

```text
rotate(90)
translate(4,0)
‵‵‵

then the result is as shown on the right in the above illustration. In that picture, the original &quot;F&quot; is first moved 4 units to the right and the resulting shape is then rotated through an angle of 90 degrees about the origin to give the shape that actually appears on the screen.

For another example of applying several transformations, suppose that we want to rotate a shape through an angle r about a point (p,q) instead of about the point (0,0). We can do this by first moving the point (p,q) to the origin, using translate(-p,-q). Then we can do a standard rotation about the origin by calling rotate(r). Finally, we can move the origin back to the point (p,q) by applying translate(p,q). Keeping in mind that we have to write the code for the transformations in the reverse order, we need to say

```text
translate(p,q)
rotate(r)
translate(-p,-q)
</code></pre></div>
<p>before drawing the shape. (In fact, some graphics APIs let us accomplish this transform with a single command such as rotate(r,p,q). This would apply a <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> through the angle r about the point (p,q).)</p>
</div>
</div>
</div>
<h2 id="235--缩放">2.3.5  <abbr title="一种几何变换，它将点的每个坐标乘以一个称为缩放因子的数。缩放增加或减少对象的大小，但也将其点移动到原点更近或更远的位置。缩放可以是均匀的——在每个方向上都相同——或非均匀的——在每个坐标方向上具有不同的缩放因子。可以使用负的缩放因子来应用反射。">缩放</abbr><a class="headerlink" href="#235--缩放" title="Permanent link">&para;</a></h2>
<p><strong>Scaling</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="6:2"><input checked="checked" id="__tabbed_6_1" name="__tabbed_6" type="radio" /><input id="__tabbed_6_2" name="__tabbed_6" type="radio" /><div class="tabbed-labels"><label for="__tabbed_6_1">中文</label><label for="__tabbed_6_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>缩放变换可用于使对象变大或变小。在数学上，缩放变换简单地将每个 x 坐标乘以一个给定的量，每个 y 坐标乘以一个给定的量。也就是说，如果一个点 (x,y) 在 x 方向上按比例因子 a <abbr title="一种几何变换，它将点的每个坐标乘以一个称为缩放因子的数。缩放增加或减少对象的大小，但也将其点移动到原点更近或更远的位置。缩放可以是均匀的——在每个方向上都相同——或非均匀的——在每个坐标方向上具有不同的缩放因子。可以使用负的缩放因子来应用反射。">缩放</abbr>，在 y 方向上按比例因子 d <abbr title="一种几何变换，它将点的每个坐标乘以一个称为缩放因子的数。缩放增加或减少对象的大小，但也将其点移动到原点更近或更远的位置。缩放可以是均匀的——在每个方向上都相同——或非均匀的——在每个坐标方向上具有不同的缩放因子。可以使用负的缩放因子来应用反射。">缩放</abbr>，那么结果点 (x1,y1) 由以下公式给出：</p>
<div class="highlight"><pre><span></span><code>x1 = a * x
y1 = d * y
</code></pre></div>
<p>如果将此变换应用于以原点为中心的形状，则会将形状在水平方向上拉伸 a 倍，垂直方向上拉伸 d 倍。以下是一个示例，原始的浅灰色“F”在水平方向上按 3 倍，垂直方向上按 2 倍进行缩放，得到最终的深红色“F”：</p>
<p><figure markdown="span">
    <a class="glightbox" href="../../../en/c2/scale-2d.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="pixel-coordinates" src="../../../en/c2/scale-2d.png" /></a>
</figure></p>
<p>常见情况是水平和垂直缩放因子相同，称为<strong><abbr title="缩放变换，所有方向上的缩放因子相同。均匀缩放改变对象的大小而不改变其形状。">均匀缩放</abbr>(uniform <abbr title="A geometric transform that multiplies each coordinate of a point by a number called the scaling factor. Scaling increases or decreases the size of an object, but also moves its points closer to or farther from the origin. Scaling can be uniform—the same in every direction—or non-uniform—with a different scaling factor in each coordinate direction. A negative scaling factor can be used to apply a reflection.">scaling</abbr>)</strong>。均匀缩放拉伸或收缩一个形状而不会扭曲它。</p>
<p>当缩放应用于不以 (0,0) 为中心的形状时，除了被拉伸或收缩之外，形状还将远离或接近 0。事实上，缩放操作的真实描述是将每个点远离 (0,0) 或将每个点拉向 (0,0)。如果想要围绕不同于 (0,0) 的点进行缩放，可以使用与旋转情况类似的三个变换的序列。</p>
<p>一个 2D 图形 <abbr title="Application Programming Interface. A collection of related classes, functions, constants, etc., for performing some task. An API is an &quot;interface&quot; in the sense that it can be used without understanding how its functionality is actually implemented.">API</abbr> 可以提供一个名为 scale(a,d) 的函数来应用缩放变换。与往常一样，该变换应用于所有后续绘图操作中的所有 x 和 y <abbr title="一种将数值坐标分配给几何点的方法。在二维中，每个点对应一对数字。在三维中，每个点对应一组三个数字。">坐标</abbr>。请注意，允许使用负缩放因子，并且会导致反射形状以及可能的拉伸或收缩。例如，scale(1,-1) 将使对象在垂直方向上反射，通过 x 轴。</p>
<p>事实上，每个仿射变换都可以通过组合平移、绕原点旋转和原点缩放来创建。我不会试图证明这一点，但下面是一个交互式演示，让您可以尝试平移、旋转和缩放，并尝试组合它们所产生的变换。</p>
<p><iframe src="../../../en/demos/c2/transforms-2d.html" width="725" height="550"></iframe></p>
<p>我还注意到，由平移和绕原点旋转构成的变换，没有缩放，将保持被应用对象的长度和角度。它也会保持矩形的纵横比。具有这种属性的变换被称为“<strong>欧几里得</strong>”。如果还允许<strong>均匀</strong><abbr title="一种几何变换，它将点的每个坐标乘以一个称为缩放因子的数。缩放增加或减少对象的大小，但也将其点移动到原点更近或更远的位置。缩放可以是均匀的——在每个方向上都相同——或非均匀的——在每个坐标方向上具有不同的缩放因子。可以使用负的缩放因子来应用反射。">缩放</abbr>，则结果变换将保持角度和纵横比，但不会保持长度。</p>
</div>
<div class="tabbed-block">
<p>A <abbr title="A geometric transform that multiplies each coordinate of a point by a number called the scaling factor. Scaling increases or decreases the size of an object, but also moves its points closer to or farther from the origin. Scaling can be uniform—the same in every direction—or non-uniform—with a different scaling factor in each coordinate direction. A negative scaling factor can be used to apply a reflection.">scaling</abbr> transform can be used to make objects bigger or smaller. Mathematically, a <abbr title="A geometric transform that multiplies each coordinate of a point by a number called the scaling factor. Scaling increases or decreases the size of an object, but also moves its points closer to or farther from the origin. Scaling can be uniform—the same in every direction—or non-uniform—with a different scaling factor in each coordinate direction. A negative scaling factor can be used to apply a reflection.">scaling</abbr> transform simply multiplies each x-coordinate by a given amount and each y-coordinate by a given amount. That is, if a point (x,y) is scaled by a factor of a in the x direction and by a factor of d in the y direction, then the resulting point (x1,y1) is given by</p>
<div class="highlight"><pre><span></span><code>x1 = a * x
y1 = d * y
</code></pre></div>
<p>If you apply this transform to a shape that is centered at the origin, it will stretch the shape by a factor of a horizontally and d vertically. Here is an example, in which the original light gray "F" is scaled by a factor of 3 horizontally and 2 vertically to give the final dark red "F":</p>
<p><figure markdown="span">
    <a class="glightbox" href="../../../en/c2/scale-2d.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="pixel-coordinates" src="../../../en/c2/scale-2d.png" /></a>
</figure></p>
<p>The common case where the horizontal and vertical <abbr title="A geometric transform that multiplies each coordinate of a point by a number called the scaling factor. Scaling increases or decreases the size of an object, but also moves its points closer to or farther from the origin. Scaling can be uniform—the same in every direction—or non-uniform—with a different scaling factor in each coordinate direction. A negative scaling factor can be used to apply a reflection.">scaling</abbr> factors are the same is called <strong>uniform <abbr title="A geometric transform that multiplies each coordinate of a point by a number called the scaling factor. Scaling increases or decreases the size of an object, but also moves its points closer to or farther from the origin. Scaling can be uniform—the same in every direction—or non-uniform—with a different scaling factor in each coordinate direction. A negative scaling factor can be used to apply a reflection.">scaling</abbr></strong>. Uniform <abbr title="A geometric transform that multiplies each coordinate of a point by a number called the scaling factor. Scaling increases or decreases the size of an object, but also moves its points closer to or farther from the origin. Scaling can be uniform—the same in every direction—or non-uniform—with a different scaling factor in each coordinate direction. A negative scaling factor can be used to apply a reflection.">scaling</abbr> stretches or shrinks a shape without distorting it.</p>
<p>When <abbr title="A geometric transform that multiplies each coordinate of a point by a number called the scaling factor. Scaling increases or decreases the size of an object, but also moves its points closer to or farther from the origin. Scaling can be uniform—the same in every direction—or non-uniform—with a different scaling factor in each coordinate direction. A negative scaling factor can be used to apply a reflection.">scaling</abbr> is applied to a shape that is not centered at (0,0), then in addition to being stretched or shrunk, the shape will be moved away from 0 or towards 0. In fact, the true description of a <abbr title="A geometric transform that multiplies each coordinate of a point by a number called the scaling factor. Scaling increases or decreases the size of an object, but also moves its points closer to or farther from the origin. Scaling can be uniform—the same in every direction—or non-uniform—with a different scaling factor in each coordinate direction. A negative scaling factor can be used to apply a reflection.">scaling</abbr> operation is that it pushes every point away from (0,0) or pulls every point towards (0,0). If you want to scale about a point other than (0,0), you can use a sequence of three transforms, similar to what was done in the case of <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr>.</p>
<p>A 2D graphics <abbr title="Application Programming Interface. A collection of related classes, functions, constants, etc., for performing some task. An API is an &quot;interface&quot; in the sense that it can be used without understanding how its functionality is actually implemented.">API</abbr> can provide a function scale(a,d) for applying <abbr title="A geometric transform that multiplies each coordinate of a point by a number called the scaling factor. Scaling increases or decreases the size of an object, but also moves its points closer to or farther from the origin. Scaling can be uniform—the same in every direction—or non-uniform—with a different scaling factor in each coordinate direction. A negative scaling factor can be used to apply a reflection.">scaling</abbr> transformations. As usual, the transform applies to all x and y coordinates in subsequent drawing operations. Note that negative <abbr title="A geometric transform that multiplies each coordinate of a point by a number called the scaling factor. Scaling increases or decreases the size of an object, but also moves its points closer to or farther from the origin. Scaling can be uniform—the same in every direction—or non-uniform—with a different scaling factor in each coordinate direction. A negative scaling factor can be used to apply a reflection.">scaling</abbr> factors are allowed and will result in reflecting the shape as well as possibly stretching or shrinking it. For example, scale(1,-1) will reflect objects vertically, through the x-axis.</p>
<p>It is a fact that every <abbr title="A transform that preserves parallel lines. That is, when the transform is applied to a pair of lines that are parallel, then the resulting transformed lines are also parallel. An affine transform, T, has the property that the transform of the line segment between a point (x1,y1) and a point (x2,y2) is the line between the points T(x1,y1) and T(x2,y2). Effectively, the transform of a line segment can be computed just by transforming its two endpoints. This makes affine transforms very efficient for computer graphics. Any affine transform can be represented as a composition of rotations, translations, and scalings.">affine transform</abbr> can be created by combining translations, rotations about the origin, and scalings about the origin. I won't try to prove that, but here is an interactive demo that will let you experiment with translations, rotations, and scalings, and with the transformations that can be made by combining them.</p>
<p><iframe src="../../../en/demos/c2/transforms-2d.html" width="725" height="550"></iframe></p>
<p>I also note that a transform that is made from translations and rotations, with no <abbr title="A geometric transform that multiplies each coordinate of a point by a number called the scaling factor. Scaling increases or decreases the size of an object, but also moves its points closer to or farther from the origin. Scaling can be uniform—the same in every direction—or non-uniform—with a different scaling factor in each coordinate direction. A negative scaling factor can be used to apply a reflection.">scaling</abbr>, will preserve length and angles in the objects to which it is applied. It will also preserve aspect ratios of rectangles. Transforms with this property are called "<strong>Euclidean</strong>." If you also allow <strong>uniform</strong> <abbr title="A geometric transform that multiplies each coordinate of a point by a number called the scaling factor. Scaling increases or decreases the size of an object, but also moves its points closer to or farther from the origin. Scaling can be uniform—the same in every direction—or non-uniform—with a different scaling factor in each coordinate direction. A negative scaling factor can be used to apply a reflection.">scaling</abbr>, the resulting transformation will preserve angles and <abbr title="The ratio of the width, w, of a rectangle to the height, h, of the rectangle, expressed either as a ratio **w:h** or as a fraction** w/h**.">aspect ratio</abbr>, but not lengths.</p>
</div>
</div>
</div>
<h2 id="236--剪切">2.3.6  剪切<a class="headerlink" href="#236--剪切" title="Permanent link">&para;</a></h2>
<p><strong>Shear</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="7:2"><input checked="checked" id="__tabbed_7_1" name="__tabbed_7" type="radio" /><input id="__tabbed_7_2" name="__tabbed_7" type="radio" /><div class="tabbed-labels"><label for="__tabbed_7_1">中文</label><label for="__tabbed_7_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>我们将再看一个基本变换类型，<strong><abbr title="在2D中，保持某条线L不变，与L垂直的线相对于L“倾斜”相同的角度。另一种描述是，平行于L的线被映射到其自身，但是移动的距离与其与L的距离成比例。在3D中，剪切变换保持某个平面P不变，并将平行于P的平面映射到其自身，但是移动的距离与其与P的距离成比例。">剪切变换</abbr></strong>。尽管必要时可以通过旋转和缩放来构建剪切，但如何做到这一点并不是很明显。剪切会“倾斜”对象。水平剪切会将事物向左（负剪切）或向右（正剪切）倾斜。垂直剪切会使它们向上或向下倾斜。以下是水平剪切的示例：</p>
<p><figure markdown="span">
    <a class="glightbox" href="../../../en/c2/shear-2d.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="pixel-coordinates" src="../../../en/c2/shear-2d.png" /></a>
</figure></p>
<p>水平剪切不会移动 x 轴。每条水平线都会根据该线上的 y 值移动到左侧或右侧。当将水平剪切应用于点 (x,y) 时，得到的结果点 (x1,y1) 由以下公式给出：</p>
<div class="highlight"><pre><span></span><code>x1 = x + b * y
y1 = y
</code></pre></div>
<p>其中 b 是某个常数剪切因子。类似地，具有剪切因子 c 的垂直剪切由以下方程给出：</p>
<div class="highlight"><pre><span></span><code>x1 = x
y1 = c * x + y
</code></pre></div>
<p>剪切有时被称为“倾斜”，但倾斜通常是指一个角度，而不是一个剪切因子。</p>
</div>
<div class="tabbed-block">
<p>We will look at one more type of basic transform, a <strong>shearing transform</strong>. Although shears can in fact be built up out of rotations and scalings if necessary, it is not really obvious how to do so. A shear will "tilt" objects. A horizontal shear will tilt things towards the left (for negative shear) or right (for positive shear). A vertical shear tilts them up or down. Here is an example of horizontal shear:</p>
<p><figure markdown="span">
    <a class="glightbox" href="../../../en/c2/shear-2d.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="pixel-coordinates" src="../../../en/c2/shear-2d.png" /></a>
</figure></p>
<p>A horizontal shear does not move the x-axis. Every other horizontal line is moved to the left or to the right by an amount that is proportional to the y-value along that line. When a horizontal shear is applied to a point (x,y), the resulting point (x1,y1) is given by</p>
<div class="highlight"><pre><span></span><code>x1 = x + b * y
y1 = y
</code></pre></div>
<p>for some constant shearing factor b. Similarly, a vertical shear with shearing factor c is given by the equations</p>
<div class="highlight"><pre><span></span><code>x1 = x
y1 = c * x + y
</code></pre></div>
<p>Shear is occasionally called "skew," but skew is usually specified as an angle rather than as a shear factor.</p>
</div>
</div>
</div>
<h2 id="237--视窗到视口">2.3.7  视窗到视口<a class="headerlink" href="#237--视窗到视口" title="Permanent link">&para;</a></h2>
<p><strong>Window-to-Viewport</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="8:2"><input checked="checked" id="__tabbed_8_1" name="__tabbed_8" type="radio" /><input id="__tabbed_8_2" name="__tabbed_8" type="radio" /><div class="tabbed-labels"><label for="__tabbed_8_1">中文</label><label for="__tabbed_8_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>在图像显示之前应用于对象的最后一个变换是窗口到视口变换，它将包含场景的 xy 平面中的矩形视窗映射到图像将显示的像素矩形网格中。我在这里假设视窗没有旋转；也就是说，它的边是平行于 x 和 y 轴的。在这种情况下，窗口到视口变换可以用平移和缩放变换来表示。让我们看看典型情况，其中视口具有从左边的 0 到右边的宽度、从顶部的 0 到底部的高度的像素坐标。并假设视窗的限制是 left、right、bottom 和 top。在这种情况下，窗口到视口变换可以编程为：</p>
<div class="highlight"><pre><span></span><code>scale( width / (right-left), height / (bottom-top) );
translate( -left, -top )
</code></pre></div>
<p>这些应该是应用于点的最后变换。由于变换是按与程序中指定的顺序相反的顺序应用于点的，它们应该是程序中指定的第一个变换。为了看到这是如何工作的，请考虑视窗中的一个点 (x,y)。（这个点来自场景中的某个对象。可能已经应用了几次建模变换来生成点 (x,y)，而该点现在已准备好进行最终的转换为视口坐标。）<abbr title="一种将数值坐标分配给几何点的方法。在二维中，每个点对应一对数字。在三维中，每个点对应一组三个数字。">坐标</abbr> (x,y) 首先被平移了 (-left,-top) 以得到 (x-left,y-top)。然后将这些坐标乘以上面显示的缩放因子，得到最终的坐标：</p>
<div class="highlight"><pre><span></span><code>x1 = width / (right-left) * (x-left)
y1 = height / (bottom-top) * (y-top)
</code></pre></div>
<p>请注意，点 (left,top) 被映射到 (0,0)，而点 (right,bottom) 被映射到 (width,height)，这正是我们想要的。</p>
<p>还有一个纵横比的问题。如 <a href="../s1/#213-纵横比">2.1.3 小节</a> 所述，如果我们希望强制窗口的纵横比与视口的纵横比匹配，可能需要调整窗口的限制。下面是一个子程序的伪代码，假设视口的左上角具有像素坐标 (0,0)：</p>
<div class="highlight"><pre><span></span><code>subroutine applyWindowToViewportTransformation (
        left, right,   // horizontal limits on view window
        bottom, top,   // vertical limits on view window
        width, height, // width and height of viewport
        preserveAspect // should window be forced to match viewport aspect?
    )

if preserveAspect :
    // Adjust the limits to match the aspect ratio of the drawing area.
    displayAspect = abs(height / width);
    windowAspect = abs(( top-bottom ) / ( right-left ));
    if displayAspect &gt; windowAspect :
        // Expand the viewport vertically.
        excess = (top-bottom) * (displayAspect/windowAspect - 1)
        top = top + excess/2
        bottom = bottom - excess/2
    else if displayAspect &lt; windowAspect :
        // Expand the viewport horizontally.
        excess = (right-left) * (windowAspect/displayAspect - 1)
        right = right + excess/2
        left = left - excess/2 

    scale( width / (right-left), height / (bottom-top) )
    translate( -left, -top )
</code></pre></div>
</div>
<div class="tabbed-block">
<p>The last transformation that is applied to an object before it is displayed in an image is the window-to-<abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr> transformation, which maps the rectangular <abbr title="As used in this book, the window, or view window, for 2D graphics is the rectangle in the xy-plane that contains the portion of the plane that will be displayed in the image. (The corresponding term in 3D graphics is &quot;view volume.&quot;)">view window</abbr> in the xy-plane that contains the scene to the rectangular grid of <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixels</abbr> where the image will be displayed. I'll assume here that the <abbr title="As used in this book, the window, or view window, for 2D graphics is the rectangle in the xy-plane that contains the portion of the plane that will be displayed in the image. (The corresponding term in 3D graphics is &quot;view volume.&quot;)">view window</abbr> is not rotated; that it, its sides are parallel to the x- and y-axes. In that case, the window-to-<abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr> transformation can be expressed in terms of <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr> and <abbr title="A geometric transform that multiplies each coordinate of a point by a number called the scaling factor. Scaling increases or decreases the size of an object, but also moves its points closer to or farther from the origin. Scaling can be uniform—the same in every direction—or non-uniform—with a different scaling factor in each coordinate direction. A negative scaling factor can be used to apply a reflection.">scaling</abbr> transforms. Let's look at the typical case where the <abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr> has <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> coordinates ranging from 0 on the left to width on the right and from 0 at the top to height at the bottom. And assume that the limits on the <abbr title="As used in this book, the window, or view window, for 2D graphics is the rectangle in the xy-plane that contains the portion of the plane that will be displayed in the image. (The corresponding term in 3D graphics is &quot;view volume.&quot;)">view window</abbr> are left, right, bottom, and top. In that case, the window-to-<abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr> transformation can be programmed as:</p>
<div class="highlight"><pre><span></span><code>scale( width / (right-left), height / (bottom-top) );
translate( -left, -top )
</code></pre></div>
<p>These should be the last transforms that are applied to a point. Since transforms are applied to points in the reverse of the order in which they are specified in the program, they should be the first transforms that are specified in the program. To see how this works, consider a point (x,y) in the <abbr title="As used in this book, the window, or view window, for 2D graphics is the rectangle in the xy-plane that contains the portion of the plane that will be displayed in the image. (The corresponding term in 3D graphics is &quot;view volume.&quot;)">view window</abbr>. (This point comes from some object in the scene. Several modeling transforms might have already been applied to the object to produce the point (x,y), and that point is now ready for its final transformation into <abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr> coordinates.) The coordinates (x,y) are first translated by (-left,-top) to give (x-left,y-top). These coordinates are then multiplied by the <abbr title="A geometric transform that multiplies each coordinate of a point by a number called the scaling factor. Scaling increases or decreases the size of an object, but also moves its points closer to or farther from the origin. Scaling can be uniform—the same in every direction—or non-uniform—with a different scaling factor in each coordinate direction. A negative scaling factor can be used to apply a reflection.">scaling</abbr> factors shown above, giving the final coordinates</p>
<div class="highlight"><pre><span></span><code>x1 = width / (right-left) * (x-left)
y1 = height / (bottom-top) * (y-top)
</code></pre></div>
<p>Note that the point (left,top) is mapped to (0,0), while the point (right,bottom) is mapped to (width,height), which is just what we want.</p>
<p>There is still the question of <abbr title="The ratio of the width, w, of a rectangle to the height, h, of the rectangle, expressed either as a ratio **w:h** or as a fraction** w/h**.">aspect ratio</abbr>. As noted in <a href="../s1/#213-纵横比">Subsection 2.1.3</a>, if we want to force the <abbr title="The ratio of the width, w, of a rectangle to the height, h, of the rectangle, expressed either as a ratio **w:h** or as a fraction** w/h**.">aspect ratio</abbr> of the window to match the <abbr title="The ratio of the width, w, of a rectangle to the height, h, of the rectangle, expressed either as a ratio **w:h** or as a fraction** w/h**.">aspect ratio</abbr> of the <abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr>, it might be necessary to adjust the limits on the window. Here is pseudocode for a subroutine that will do that, again assuming that the top-left corner of the <abbr title="The rectangular area in which the image for 2D or 3D graphics is displayed. The coordinates on the viewport are pixel coordinates, more properly called device coordinates since they are actual physical coordinates on the device where the image is being displayed.">viewport</abbr> has <abbr title="A digital image is made up of rows and columns of small rectangles called pixels. To specify a digital image, a color is assigned to each pixel in the image.">pixel</abbr> coordinates (0,0):</p>
<div class="highlight"><pre><span></span><code>subroutine applyWindowToViewportTransformation (
        left, right,   // horizontal limits on view window
        bottom, top,   // vertical limits on view window
        width, height, // width and height of viewport
        preserveAspect // should window be forced to match viewport aspect?
    )

if preserveAspect :
    // Adjust the limits to match the aspect ratio of the drawing area.
    displayAspect = abs(height / width);
    windowAspect = abs(( top-bottom ) / ( right-left ));
    if displayAspect &gt; windowAspect :
        // Expand the viewport vertically.
        excess = (top-bottom) * (displayAspect/windowAspect - 1)
        top = top + excess/2
        bottom = bottom - excess/2
    else if displayAspect &lt; windowAspect :
        // Expand the viewport horizontally.
        excess = (right-left) * (windowAspect/displayAspect - 1)
        right = right + excess/2
        left = left - excess/2 

    scale( width / (right-left), height / (bottom-top) )
    translate( -left, -top )
</code></pre></div>
</div>
</div>
</div>
<h2 id="238--矩阵和向量">2.3.8  矩阵和向量<a class="headerlink" href="#238--矩阵和向量" title="Permanent link">&para;</a></h2>
<p><strong>Matrices and Vectors</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="9:2"><input checked="checked" id="__tabbed_9_1" name="__tabbed_9" type="radio" /><input id="__tabbed_9_2" name="__tabbed_9" type="radio" /><div class="tabbed-labels"><label for="__tabbed_9_1">中文</label><label for="__tabbed_9_2">英文</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>在计算机图形中使用的变换可以表示为矩阵，而它们作用的点则表示为向量。回想一下，从计算机科学家的角度来看，<strong><abbr title="数字的矩形数组。矩阵可以表示为二维数组，数字按行和列排列。一个N×N矩阵表示从N维空间到自身的线性变换。">矩阵</abbr>(<abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>)</strong>是一个二维数组，而<strong><abbr title="向量空间中的元素。向量空间的元素可以相加，并且可以乘以常数。对于计算机图形，向量只是包含两个、三个或四个数字的列表或数组。在这个意义上，向量通常用于表示2D、3D或4D空间中的点。然而，准确地说，向量表示具有长度和方向的数量；以这种方式使用的向量可以被可视化为箭头。">向量</abbr>(<abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr>)</strong>是一个一维数组。矩阵和向量是<strong><abbr title="研究向量空间及其之间的线性变换的数学领域。线性代数是计算机图形学的基本数学基础之一。">线性代数</abbr>(<abbr title="The field of mathematics that studies vector spaces and linear transformations between them. Linear algebra is part of the essential mathematical foundation of computer graphics.">linear algebra</abbr>)</strong>领域的研究对象。线性代数对计算机图形至关重要。事实上，矩阵和向量数学已经内置在了 <abbr title="Graphics Processing Unit, a computer hardware component that performs graphical computations that create and manipulate images. Operations such as drawing a line on the screen or rendering a 3D image are done in the GPU, which is optimized to perform such operations very quickly.">GPU</abbr> 中。你不需要对线性代数有很多了解来阅读本教材，但一些基本概念是必不可少的。</p>
<p>我们需要的向量是由两个、三个或四个数字组成的列表。它们通常被写作 (x,y)、(x,y,z) 和 (x,y,z,w)。一个具有 N 行和 M 列的矩阵称为“N行M列矩阵”。在大多数情况下，我们需要的矩阵是 N 行 N 列的矩阵，其中 N 为 2、3 或 4。也就是说，它们有 2、3 或 4 行和列，行数等于列数。</p>
<p>如果 A 和 B 是两个 N 行 N 列的矩阵，那么它们可以相乘得到一个乘积矩阵 C = AB。如果 A 是一个 N 行 N 列的矩阵，v 是长度为 N 的向量，那么 v 可以乘以 A 得到另一个向量 w = Av。将 v 映射到 Av 的函数是一个变换；它将任意给定的大小为 N 的向量转换为另一个大小为 N 的向量。这种形式的变换称为<strong><abbr title="从一个向量空间到另一个向量空间的函数，保持向量加法和常数乘法。线性变换可以用矩阵表示。在计算机图形中，它们用于实现旋转和平移等几何操作。">线性变换</abbr>(<abbr title="A function from one vector space to another that preserves vector addition and multiplication by constants. Linear transformations can be represented by matrices. In computer graphics, they are used to implement geometric operations such as rotation and translation.">linear transformation</abbr>)</strong>。</p>
<p>现在，假设 A 和 B 是 N 行 N 列的矩阵，v 是长度为 N 的向量。那么，我们可以形成两个不同的乘积：A(Bv) 和 (AB)v。一个核心事实是，这两个操作具有相同的效果。也就是说，我们可以先将 v 乘以 B，然后将结果乘以 A，或者我们可以将矩阵 A 和 B 相乘得到矩阵乘积 AB，然后将 v 乘以 AB。结果是相同的。</p>
<p>事实证明，旋转和缩放都是线性变换。也就是说，绕原点旋转 (x,y) 角度为 d 的操作可以通过将 (x,y) 乘以一个 2×2 的矩阵来实现。让我们称该矩阵为 Rd。类似地，水平方向缩放因子为 a，垂直方向缩放因子为 b，可以表示为一个矩阵 Sa,b。如果我们想对点 v = (x,y) 应用缩放后再旋转，我们可以计算<strong>要么</strong> Rd(Sa,b^v) <strong>要么</strong> (RdSa,b)v。</p>
<p>那么呢？嗯，假设我们想要对数千个点应用相同的两个操作，先缩放再旋转，就像我们在为计算机图形中的对象进行变换时通常所做的那样。关键在于，我们可以一劳永逸地计算乘积矩阵 RdSa,b，然后通过单次乘法将组合变换应用于每个点。这意味着如果一个程序说</p>
<div class="highlight"><pre><span></span><code>rotate(d)
scale(a,b)
.
.  // draw a complex object
.
</code></pre></div>
<p>计算机无需跟踪两个独立的操作。它将这些操作合并成一个单独的矩阵，然后只需跟踪这个矩阵。即使对对象应用了50个变换，计算机也可以将它们全部合并成一个矩阵。通过使用矩阵代数，多个变换可以像单个变换一样高效地处理！</p>
<p>这确实很好，但存在一个严重的问题：<strong>平移不是线性变换</strong>。为了将平移纳入这个框架，我们首先做一些看起来有点奇怪的事情：我们不再将二维点表示为一对数字 (x,y)，而是表示为三个数字的三元组 (x,y,1)。也就是说，我们在第三个坐标位置添加了一个 1。然后，结果是我们可以将旋转、缩放和平移——因此任何仿射变换——在二维空间中表示为一个 3×3 矩阵的乘法。我们需要的矩阵具有包含 (0,0,1) 的底部一行。将 (x,y,1) 乘以这样的矩阵会得到一个新向量 (x1,y1,1)。我们忽略额外的坐标，并将其视为将 (x,y) 转换为 (x1,y1)。有关记录，2D <abbr title="一种几何变换，它将点的每个坐标添加给定的平移量。平移用于移动对象而不改变其大小或方向。">平移</abbr> (Ta,b)、<abbr title="一种几何变换，它将点的每个坐标乘以一个称为缩放因子的数。缩放增加或减少对象的大小，但也将其点移动到原点更近或更远的位置。缩放可以是均匀的——在每个方向上都相同——或非均匀的——在每个坐标方向上具有不同的缩放因子。可以使用负的缩放因子来应用反射。">缩放</abbr> (Sa,b) 和旋转 (Rd) 的 3×3 矩阵如下所示：</p>
<p><figure markdown="span">
    <a class="glightbox" href="../../../en/c2/transform-matrices-2d.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="pixel-coordinates" src="../../../en/c2/transform-matrices-2d.png" /></a>
</figure></p>
<p>你可以将这些矩阵的乘法与上面给出的平移、缩放和旋转公式进行比较。但在进行图形编程时，你不需要自己执行这些乘法。目前，你应该从这次讨论中带走的重要观点是，一系列变换可以合并成单个变换。计算机只需要跟踪一个矩阵，我们可以称之为“当前矩阵”或“当前变换”。为了实现诸如 translate(a,b) 或 rotate(d) 等变换命令，计算机只需将当前矩阵乘以代表变换的矩阵。</p>
</div>
<div class="tabbed-block">
<p>The transforms that are used in computer graphics can be represented as matrices, and the points on which they operate are represented as vectors. Recall that a <strong><abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr></strong>, from the point of view of a computer scientist, is a two-dimensional array of numbers, while a <strong><abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr></strong> is a one-dimensional array. Matrices and vectors are studied in the field of mathematics called <strong><abbr title="The field of mathematics that studies vector spaces and linear transformations between them. Linear algebra is part of the essential mathematical foundation of computer graphics.">linear algebra</abbr></strong>. Linear algebra is fundamental to computer graphics. In fact, <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> and <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> math is built into GPUs. You won't need to know a great deal about <abbr title="The field of mathematics that studies vector spaces and linear transformations between them. Linear algebra is part of the essential mathematical foundation of computer graphics.">linear algebra</abbr> for this textbook, but a few basic ideas are essential.</p>
<p>The vectors that we need are lists of two, three, or four numbers. They are often written as (x,y), (x,y,z), and (x,y,z,w). A <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> with N rows and M columns is called an "N-by-M <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>." For the most part, the matrices that we need are N-by-N matrices, where N is 2, 3, or 4. That is, they have 2, 3, or 4 rows and columns, and the number of rows is equal to the number of columns.</p>
<p>If A and B are two N-by-N matrices, then they can be multiplied to give a product <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> C = AB. If A is an N-by-N <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>, and v is a <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> of length N, then v can be multiplied by A to give another <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> w = Av. The function that takes v to Av is a transformation; it transforms any given <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> of size N into another <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> of size N. A transformation of this form is called a <strong><abbr title="A function from one vector space to another that preserves vector addition and multiplication by constants. Linear transformations can be represented by matrices. In computer graphics, they are used to implement geometric operations such as rotation and translation.">linear transformation</abbr></strong>.</p>
<p>Now, suppose that A and B are N-by-N matrices and v is a <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> of length N. Then, we can form two different products: A(Bv) and (AB)v. It is a central fact that these two operations have the same effect. That is, we can multiply v by B and then multiply the result by A, or we can multiply the matrices A and B to get the <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> product AB and then multiply v by AB. The result is the same.</p>
<p>Rotation and <abbr title="A geometric transform that multiplies each coordinate of a point by a number called the scaling factor. Scaling increases or decreases the size of an object, but also moves its points closer to or farther from the origin. Scaling can be uniform—the same in every direction—or non-uniform—with a different scaling factor in each coordinate direction. A negative scaling factor can be used to apply a reflection.">scaling</abbr>, as it turns out, are linear transformations. That is, the operation of rotating (x,y) through an angle d about the origin can be done by multiplying (x,y) by a 2-by-2 <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>. Let's call that <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> Rd. Similarly, <abbr title="A geometric transform that multiplies each coordinate of a point by a number called the scaling factor. Scaling increases or decreases the size of an object, but also moves its points closer to or farther from the origin. Scaling can be uniform—the same in every direction—or non-uniform—with a different scaling factor in each coordinate direction. A negative scaling factor can be used to apply a reflection.">scaling</abbr> by a factor a in the horizontal direction and b in the vertical direction can be given as a <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> Sa,b. If we want to apply a <abbr title="A geometric transform that multiplies each coordinate of a point by a number called the scaling factor. Scaling increases or decreases the size of an object, but also moves its points closer to or farther from the origin. Scaling can be uniform—the same in every direction—or non-uniform—with a different scaling factor in each coordinate direction. A negative scaling factor can be used to apply a reflection.">scaling</abbr> followed by a <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> to the point v = (x,y), we can compute <strong>either</strong> Rd(Sa,b^v) or (RdSa,b)v.</p>
<p>So what? Well, suppose that we want to apply the same two operations, scale then rotate, to thousands of points, as we typically do when transforming objects for computer graphics. The point is that we could compute the product <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> RdSa,b once and for all, and then apply the combined transform to each point with a single multiplication. This means that if a program says</p>
<div class="highlight"><pre><span></span><code>rotate(d)
scale(a,b)
.
.  // draw a complex object
.
</code></pre></div>
<p>the computer doesn't have to keep track of two separate operations. It combines the operations into a single <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> and just keeps track of that. Even if you apply, say, 50 transformations to the object, the computer can just combine them all into one <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>. By using <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> algebra, multiple transformations can be handled as efficiently as a single transformation!</p>
<p>This is really nice, but there is a gaping problem: <strong>Translation is not a <abbr title="A function from one vector space to another that preserves vector addition and multiplication by constants. Linear transformations can be represented by matrices. In computer graphics, they are used to implement geometric operations such as rotation and translation.">linear transformation</abbr></strong>. To bring <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr> into this framework, we do something that looks a little strange at first: Instead of representing a point in 2D as a pair of numbers (x,y), we represent it as the triple of numbers (x,y,1). That is, we add a one as the third coordinate. It then turns out that we can then represent <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr>, <abbr title="A geometric transform that multiplies each coordinate of a point by a number called the scaling factor. Scaling increases or decreases the size of an object, but also moves its points closer to or farther from the origin. Scaling can be uniform—the same in every direction—or non-uniform—with a different scaling factor in each coordinate direction. A negative scaling factor can be used to apply a reflection.">scaling</abbr>, and <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr>—and hence any affine transformation—on 2D space as multiplication by a 3-by-3 <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>. The matrices that we need have a bottom row containing (0,0,1). Multiplying (x,y,1) by such a <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> gives a new <abbr title="An element of a vector space. Elements of a vector space can be added and can be multiplied by constants. For computer graphics, a vector is just a list or array containing two, three, or four numbers. Vectors in that sense are often used to represent points in 2D, 3D, or 4D space. Properly, however, a vector represents a quantity that has a length and a direction; a vector used in this way can be visualized as an arrow.">vector</abbr> (x1,y1,1). We ignore the extra coordinate and consider this to be a transformation of (x,y) into (x1,y1). For the record, the 3-by-3 matrices for <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr> (Ta,b), <abbr title="A geometric transform that multiplies each coordinate of a point by a number called the scaling factor. Scaling increases or decreases the size of an object, but also moves its points closer to or farther from the origin. Scaling can be uniform—the same in every direction—or non-uniform—with a different scaling factor in each coordinate direction. A negative scaling factor can be used to apply a reflection.">scaling</abbr> (Sa,b), and <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr> (Rd) in 2D are</p>
<p><figure markdown="span">
    <a class="glightbox" href="../../../en/c2/transform-matrices-2d.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="pixel-coordinates" src="../../../en/c2/transform-matrices-2d.png" /></a>
</figure></p>
<p>You can compare multiplication by these matrices to the formulas given above for <abbr title="A geometric transform that adds a given translation amount to each coordinate of a point. Translation is used to move objects without changing their size or orientation.">translation</abbr>, <abbr title="A geometric transform that multiplies each coordinate of a point by a number called the scaling factor. Scaling increases or decreases the size of an object, but also moves its points closer to or farther from the origin. Scaling can be uniform—the same in every direction—or non-uniform—with a different scaling factor in each coordinate direction. A negative scaling factor can be used to apply a reflection.">scaling</abbr>, and <abbr title="A geometric transform that rotates each point by a specified angle about some point (in 2D) or axis (in 3D).">rotation</abbr>. But when doing graphics programming, you won't need to do the multiplication yourself. For now, the important idea that you should take away from this discussion is that a sequence of transformations can be combined into a single transformation. The computer only needs to keep track of a single <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>, which we can call the "current <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr>" or "current transformation." To implement transform commands such as translate(a,b) or rotate(d), the computer simply multiplies the current <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> by the <abbr title="A rectangular array of numbers. A matrix can be represented as a two-dimensional array, with numbers arranged in rows and columns. An N-by-N matrix represents a linear transformation from N-dimensional space to itself.">matrix</abbr> that represents the transform.</p>
</div>
</div>
</div>







  
    
  
  
    
  


  <aside class="md-source-file">
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="最后更新">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1-2.1-2M12.5 7v5.2l4 2.4-1 1L11 13V7h1.5M11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2v1.8Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">2024年5月6日</span>
  </span>

    
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="创建日期">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.47 15.08 11 13V7h1.5v5.25l3.08 1.83c-.41.28-.79.62-1.11 1m-1.39 4.84c-.36.05-.71.08-1.08.08-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8c0 .37-.03.72-.08 1.08.69.1 1.33.32 1.92.64.1-.56.16-1.13.16-1.72 0-5.5-4.5-10-10-10S2 6.5 2 12s4.47 10 10 10c.59 0 1.16-.06 1.72-.16-.32-.59-.54-1.23-.64-1.92M18 15v3h-3v2h3v3h2v-3h3v-2h-3v-3h-2Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">2024年4月25日</span>
  </span>

    
    
    
  </aside>





                
              </article>
            </div>
          
          
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var tab,labels=set.querySelector(".tabbed-labels");for(tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script>

<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../../..", "features": ["content.code.copy", "content.tabs.link", "navigation.tabs", "navigation.tabs.sticky", "navigation.indexes", "navigation.top", "toc.follow", "content.tooltips"], "search": "../../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.3220b9d7.min.js"></script>
      
        <script src="../../../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="https://unpkg.com/mermaid@9.4.0/dist/mermaid.min.js"></script>
      
    
  <script>document$.subscribe(() => {const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});})</script></body>
</html>